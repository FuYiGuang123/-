.版本 2


.程序集 集_程序
.子程序 程序_运行Ex, 逻辑型, 公开
.参数 命令行, 文本型
.参数 等待运行完毕, 逻辑型, 可空
.参数 窗口显示方式, 整数型, 可空, 参数值可以为以下常量之一：1、#隐藏窗口； 2、#普通激活； 3、#最小化激活； 4、#最大化激活； 5、#普通不激活； 6、#最小化不激活。如果省略本参数，默认为“普通激活”方式。
.参数 标准输入数据, 字节集, 可空
.参数 运行返回值, 整数型, 参考 可空, 该参数值为返回值，且[等待运行完毕]必须为真。
.参数 标准输出数据, 字节集, 参考 可空, 该参数值为返回值，且[等待运行完毕]必须为真。
.参数 标准错误数据, 字节集, 参考 可空, 该参数值为返回值，且[等待运行完毕]必须为真。
.局部变量 startupInfo, STARTUPINFO_x
.局部变量 pipeAttr, SECURITY_ATTRIBUTES
.局部变量 processInfo, 精易_进程结构
.局部变量 hRead, 整数型
.局部变量 hWrite, 整数型
.局部变量 hErrorRead, 整数型
.局部变量 hErrorWrite, 整数型
.局部变量 size, 整数型
.局部变量 result, 逻辑型
startupInfo.cb ＝ #sizeof_STARTUPINFO
startupInfo.dwFlags ＝ #STARTF_USESHOWWINDOW
.判断开始 (窗口显示方式 ＝ #隐藏窗口)
    startupInfo.wShowWindow ＝ #SW_HIDE
.判断 (窗口显示方式 ＝ #最小化激活)
    startupInfo.wShowWindow ＝ #SW_SHOWMINIMIZED
.判断 (窗口显示方式 ＝ #最大化激活)
    startupInfo.wShowWindow ＝ #SW_SHOWMAXIMIZED
.判断 (窗口显示方式 ＝ #普通不激活)
    startupInfo.wShowWindow ＝ #SW_SHOWNOACTIVATE
.判断 (窗口显示方式 ＝ #最小化不激活)
    startupInfo.wShowWindow ＝ #SW_SHOWMINNOACTIVE
.默认
    ' #普通激活
    startupInfo.wShowWindow ＝ #SW_SHOWNORMAL
.判断结束
.如果真 (是否为空 (标准输入数据) ＝ 假 或 是否为空 (标准输出数据) ＝ 假 或 是否为空 (标准错误数据) ＝ 假)
    startupInfo.dwFlags ＝ 位或 (startupInfo.dwFlags, #STARTF_USESTDHANDLES)
    pipeAttr.nLength ＝ #sizeof_SECURITY_ATTRIBUTES
    pipeAttr.bInheritHandle ＝ 真
    CreatePipe (hRead, hWrite, pipeAttr, 0)
    CreatePipe (hErrorRead, hErrorWrite, pipeAttr, 0)
    .如果真 (是否为空 (标准输入数据) ＝ 假)
        WriteFile (hWrite, 标准输入数据, 取字节集长度 (标准输入数据), 0, 0)
        startupInfo.hStdInput ＝ hRead
    .如果真结束
    .如果真 (是否为空 (标准输出数据) ＝ 假)
        startupInfo.hStdOutput ＝ hWrite
    .如果真结束
    .如果真 (是否为空 (标准错误数据) ＝ 假)
        startupInfo.hStdError ＝ hErrorWrite
    .如果真结束
.如果真结束
.如果真 (CreateProcess_运行 (0, 命令行, 0, 0, 真, 0, 0, 0, startupInfo, processInfo))
    result ＝ 真
    .如果真 (等待运行完毕)
        WaitForSingleObject (processInfo.进程句柄, #INFINITE)
        .如果真 (是否为空 (运行返回值) ＝ 假)
            GetExitCodeProcess (processInfo.进程句柄, 运行返回值)
        .如果真结束
        .如果真 (是否为空 (标准输出数据) ＝ 假)
            .如果真 (PeekNamedPipe_字节集 (hRead, 标准输出数据, 0, 0, size, 0))
                标准输出数据 ＝ 取空白字节集 (size)
                .如果真 (size ＞ 0)
                    ReadFile (hRead, 标准输出数据, size, 0, 0)
                .如果真结束
            .如果真结束
        .如果真结束
        .如果真 (是否为空 (标准错误数据) ＝ 假)
            .如果真 (PeekNamedPipe_字节集 (hErrorRead, 标准错误数据, 0, 0, size, 0))
                标准错误数据 ＝ 取空白字节集 (size)
                .如果真 (size ＞ 0)
                    ReadFile (hErrorRead, 标准错误数据, size, 0, 0)
                .如果真结束
            .如果真结束
        .如果真结束
    .如果真结束
    CloseHandle (processInfo.进程句柄)
    CloseHandle (processInfo.线程句柄)
.如果真结束
.如果真 (是否为空 (标准输入数据) ＝ 假 或 是否为空 (标准输出数据) ＝ 假 或 是否为空 (标准错误数据) ＝ 假)
    CloseHandle (hRead)
    CloseHandle (hWrite)
    CloseHandle (hErrorRead)
    CloseHandle (hErrorWrite)
.如果真结束
返回 (result)
.子程序 程序_标准输入, 逻辑型, 公开
.参数 数据, 字节集, 参考 可空, 该参数值为返回值
.局部变量 handle, 整数型
.局部变量 max, 整数型
.局部变量 size, 整数型
handle ＝ GetStdHandle (#STD_INPUT_HANDLE)
.如果真 (handle ≠ 0)
    .如果真 (PeekNamedPipe_字节集 (handle, 数据, 0, 0, size, 0))
        数据 ＝ 取空白字节集 (size)
        .如果真 (size ＞ 0)
            ReadFile_字节集 (handle, 数据, size, 0, 0)
        .如果真结束
        返回 (真)
    .如果真结束
.如果真结束
返回 (假)
.子程序 程序_标准输出, 逻辑型, 公开
.参数 数据, 字节集
.局部变量 handle, 整数型
handle ＝ GetStdHandle (#STD_OUTPUT_HANDLE)
.如果真 (handle ≠ 0)
    返回 (WriteFile (handle, 数据, 取字节集长度 (数据), 0, 0))
.如果真结束
返回 (假)
.子程序 程序_锁定到任务栏, , 公开, 将指定的文件锁定到任务栏,(暂不支持win10)
.参数 文件路径, 文本型
.局部变量 vShell, 对象
.局部变量 vFolder, 对象
.局部变量 vFolderItem, 对象
.局部变量 vItemVerbs, 对象
.局部变量 hInst, 整数型
.局部变量 szPinName, 文本型
.局部变量 str, 文本型
.局部变量 nCount, 整数型
.局部变量 i, 整数型
CoInitialize (0)
vShell.创建 (“Shell.Application”, )
vFolder ＝ vShell.对象型方法 (“NameSpace”, 文件_取目录 (文件路径))
vFolderItem ＝ vFolder.对象型方法 (“ParseName”, 文件_取文件名 (文件路径, 真))
vItemVerbs ＝ vFolderItem.对象型方法 (“Verbs”, )
hInst ＝ LoadLibraryA (“Shell32.dll”)
szPinName ＝ 取空白文本 (256)
LoadString (hInst, 5386, szPinName, 256)
FreeLibrary (hInst)
nCount ＝ vItemVerbs.读数值属性 (“Count”, )
.计次循环首 (nCount, i)
    str ＝ vItemVerbs.对象型方法 (“Item”, i).读文本属性 (“Name”, )
    .如果真 (str ＝ szPinName)
        vItemVerbs.对象型方法 (“Item”, i).对象型方法 (“DoIt”, )
    .如果真结束
.计次循环尾 ()
CoUninitialize ()
.子程序 程序_内存中运行EXE, 逻辑型, 公开, 可以直接运行资源中的程序，不必释放。成功返回真，失败返回假。
.参数 欲执行的程序, 字节集, , 欲执行的程序，不支持某些加了壳的程序，请自行测试。
.参数 命令行, 文本型, 可空, 为程序提供的命令行参数，不需要请留空。
.参数 外壳程序路径, 文本型, 可空, 外壳程序的路径(如果用系统程序做外壳，如cmd.exe、svchost.exe，可以实现穿防火墙，呵呵)，不支持某些程序，请自行测试；不在当前目录下要提供绝对路径；留空默认为cmd.exe，如果无法运行，请换用不同的程序尝试。
.参数 等待程序运行完毕, 逻辑型, 可空, 默认为假，即不等待。
.参数 窗口显示方式, 整数型, 可空, 1#隐藏窗口； 2#普通激活； 3#最小化激活； 4#最大化激活； 5#普通不激活； 6#最小化不激活。如果省略本参数，默认为“普通激活”方式。
.参数 运行信息, 精易_运行信息, 参考 可空, 用来接收在内存中执行的exe的运行信息(进程、主线程的句柄和ID)。不需要可留空。
.局部变量 idh, IMAGE_DOS_HEADER
.局部变量 inh, IMAGE_NT_HEADERS
.局部变量 ish, IMAGE_SECTION_HEADER
.局部变量 si, STARTUPINFO_x
.局部变量 context, CONTEXT86
.局部变量 ImageBase, 整数型
.局部变量 i, 整数型
.局部变量 addr, 整数型
.局部变量 lOffset, 整数型
连续赋值 (0, 运行信息.进程ID, 运行信息.进程句柄, 运行信息.主线程ID, 运行信息.主线程句柄)
.如果真 (欲执行的程序 ＝ {  })
    返回 (假)
.如果真结束
RtlMoveMemory_IMAGE_DOS_HEADER (idh, 欲执行的程序 [1], Len_idh (idh))
.如果真 (idh.e_magic ≠ 23117)
    返回 (假)
.如果真结束
RtlMoveMemory_IMAGE_NT_HEADERS (inh, 欲执行的程序 [idh.e_lfanew ＋ 1], Len_inh (inh))
.如果真 (inh.Signature ≠ 17744)
    返回 (假)
.如果真结束
si.cb ＝ Len_si (si)
.如果真 (是否为空 (窗口显示方式) ＝ 假 且 窗口显示方式 ≠ 2 且 窗口显示方式 ＞ 0 且 窗口显示方式 ≤ 6)
    si.dwFlags ＝ 1
    si.wShowWindow ＝ 多项选择 (窗口显示方式, 0, 5, 2, 3, 8, 7)
.如果真结束
.如果真 (CreateProcess_x (0, 选择 (是否为空 (外壳程序路径), 取cmd路径 (), 外壳程序路径) ＋ 选择 (是否为空 (命令行) 或 命令行 ＝ “”, “”, “ ” ＋ 命令行), 0, 0, 0, 4, 0, 0, si, 运行信息) ＝ 0)
    返回 (假)
.如果真结束
context.ContextFlags ＝ 65538
.如果真 (GetThreadContext (运行信息.主线程句柄, context) ＝ 0)
    ClearProcess (运行信息)
    返回 (假)
.如果真结束
ReadProcessMemory (运行信息.进程句柄, context.Ebx ＋ 8, addr, 4, 0)
.如果真 (addr ＝ 0)
    ClearProcess (运行信息)
    返回 (假)
.如果真结束
.如果真 (ZwUnmapViewOfSection (运行信息.进程句柄, addr) ＝ 0)
    ClearProcess (运行信息)
    返回 (假)
.如果真结束
ImageBase ＝ VirtualAllocEx (运行信息.进程句柄, inh.OptionalHeader.ImageBase, inh.OptionalHeader.SizeOfImage, 12288, 4)
.如果真 (ImageBase ＝ 0)
    ClearProcess (运行信息)
    返回 (假)
.如果真结束
WriteProcessMemory (运行信息.进程句柄, ImageBase, 欲执行的程序 [1], inh.OptionalHeader.SizeOfHeaders, 0)
lOffset ＝ idh.e_lfanew ＋ Len_inh (inh)
.计次循环首 (inh.FileHeader.NumberOfSections, i)
    RtlMoveMemory_IMAGE_SECTION_HEADER (ish, 欲执行的程序 [lOffset ＋ (i － 1) × 40 ＋ 1], Len_ish (ish))
    .如果真 (ish.PointerToRawData ＋ 1 ＞ 字节集_取长度 (欲执行的程序))
        ClearProcess (运行信息)
        返回 (假)
    .如果真结束
    WriteProcessMemory (运行信息.进程句柄, ImageBase ＋ ish.VirtualAddress, 欲执行的程序 [ish.PointerToRawData ＋ 1], ish.SizeOfRawData, 0)
    VirtualProtectEx (运行信息.进程句柄, ImageBase ＋ ish.VirtualAddress, ish.VirtualSize, Protect (ish.characteristics), addr)
.计次循环尾 ()
WriteProcessMemory_整数35 (运行信息.进程句柄, context.Ebx ＋ 8, ImageBase, 4, 0)
context.Eax ＝ ImageBase ＋ inh.OptionalHeader.AddressOfEntryPoint
SetThreadContext (运行信息.主线程句柄, context)
ResumeThread (运行信息.主线程句柄)
.如果真 (等待程序运行完毕)
    WaitForSingleObject (运行信息.进程句柄, -1)
.如果真结束
.如果真 (是否为空 (运行信息))
    CloseHandle (运行信息.主线程句柄)
    CloseHandle (运行信息.进程句柄)
.如果真结束
返回 (真)
.子程序 取cmd路径, 文本型
.局部变量 size, 整数型
.局部变量 name, 文本型
size ＝ GetEnvironmentVariable (“ComSpec”, “”, 0)
.计次循环首 (size, )
    name ＝ name ＋ “ ”
.计次循环尾 ()
GetEnvironmentVariable (“ComSpec”, name, size)
返回 (name)
.子程序 ClearProcess
.参数 运行信息, 精易_运行信息, 参考
TerminateProcess (运行信息.进程句柄, 0)
CloseHandle (运行信息.主线程句柄)
CloseHandle (运行信息.进程句柄)
连续赋值 (0, 运行信息.进程ID, 运行信息.进程句柄, 运行信息.主线程ID, 运行信息.主线程句柄)
.子程序 Protect, 整数型
.参数 characteristics, 整数型
返回 (多项选择 (RShift (characteristics, 29) ＋ 1, 1, 16, 2, 32, 4, 64, 4, 64))
.子程序 RShift, 整数型
.参数 lValue, 整数型
.参数 lNumberOfBitsToShift, 整数型
返回 (vbLongToULong (lValue) ÷ 数值_求次方 (2, lNumberOfBitsToShift))
.子程序 vbLongToULong, 双精度小数型
.参数 Value, 双精度小数型
.如果真 (Value ＜ 0)
    返回 (Value ＋ 4294967296)
.如果真结束
返回 (Value)
.子程序 数值_求次方, 双精度小数型
.参数 欲求次方数值, 双精度小数型
.参数 次方数, 双精度小数型
置入代码 ({ 221, 69, 16, 221, 69, 8, 217, 241, 217, 192, 217, 252, 220, 225, 217, 201, 217, 224, 217, 240, 217, 232, 222, 193, 217, 253, 221, 217, 221, 93, 248, 139, 85, 252, 139, 69, 248, 201, 194, 16, 0 })
返回 (0)
.子程序 程序_生成GUID, 文本型, 公开, 生成标准的GUID格式：635897F8-2A48-4882-B3E1-823B8E5B6DF8
.局部变量 guid, 字节集
.局部变量 a, 长整数型
.局部变量 b, 整数型
.局部变量 c, 整数型
.局部变量 s, 文本型
.局部变量 i, 整数型
guid ＝ 取空白字节集 (16)
CoCreateGuid (guid)
a ＝ 取字节集数据 (取字节集左边 (guid, 4), #长整数型)
b ＝ 取字节集数据 (取字节集中间 (guid, 5, 2), #整数型)
c ＝ 取字节集数据 (取字节集中间 (guid, 7, 2), #整数型)
s ＝ “”
s ＝ s ＋ 取文本右边 (“00000000” ＋ 取十六进制文本 (a), 8) ＋ “-”
s ＝ s ＋ 取文本右边 (“0000” ＋ 取十六进制文本 (b), 4) ＋ “-”
s ＝ s ＋ 到小写 (取文本右边 (“0000” ＋ 取十六进制文本 (c), 4)) ＋ “-”  ' 第三部分中的字母为小写字母
.计次循环首 (8, i)
    s ＝ s ＋ 取文本右边 (“00” ＋ 取十六进制文本 (guid [i ＋ 8]), 2)
    .如果真 (i ＝ 2)
        s ＝ s ＋ “-”
    .如果真结束
.计次循环尾 ()
返回 (s)
.子程序 程序_COM生成GUID, 文本型, 公开, 生成返回一个新的全球唯一的随机GUID文本值
.参数 GUID, GUID, 参考 可空, 保存生成的GUID到此参数变量中
.局部变量 TEMP, 字节集
TEMP ＝ 取空白字节集 (128)
COM_创建GUID_ (GUID)
StringFromGUID (GUID, TEMP, 128)
返回 (到窄文本 (TEMP))
.子程序 程序_取文件版本号, 文本型, 公开, 取某程序的版本号信息，若为易语言程序，该版本号可以在配置里修改，如果在调试中，则返回空文本。一个易语言程序会获取到版本号和创建号，比如1.1.0.0，如果只需要1.1的部分，第三个参数设置为真即可。如果第一个参数不为空，则获取其他文件的版本号信息。源码由雪山凌狐提供
.参数 程序路径, 文本型, 可空, 取出指定程序的版本号信息，如果留空，则取当前执行文件的版本号
.参数 错误信息, 文本型, 参考 可空, 用于返回错误信息的
.参数 忽略创建号, 逻辑型, 可空, 默认为真，忽略创建号，比如获取到的版本号为1.1.0.0，会返回1.1
.局部变量 版本号, 文本型
.局部变量 临时文件名, 文本型
.局部变量 内容分割, 文本型, , "0"
临时文件名 ＝ 程序路径
.如果真 (是否为空 (忽略创建号))
    忽略创建号 ＝ 真
.如果真结束
.如果真 (目录_是否符合规范 (临时文件名) ＝ 假 且 临时文件名 ≠ “”)
    错误信息 ＝ “当前文件名不符合规范”
    返回 (“”)
.如果真结束
.如果真 (临时文件名 ＝ “”)
    临时文件名 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
.如果真结束
版本号 ＝ 文件_取文件版本号 (临时文件名, 错误信息)
.如果真 (忽略创建号)
    内容分割 ＝ 分割文本 (版本号, “.”, )
    .如果真 (取数组成员数 (内容分割) ＝ 4)
        版本号 ＝ 内容分割 [1] ＋ “.” ＋ 内容分割 [2]
    .如果真结束
.如果真结束
返回 (版本号)
.子程序 程序_是否关闭, 逻辑型, 公开, 弹出一个信息框，返回操作信息框的结果
.如果真 (信息框 (“确定要关闭本窗口吗？”, 32 ＋ 1, “友情提醒”) ＝ 0)
    返回 (真)
.如果真结束
返回 (假)
.子程序 程序_调用DLL命令, 整数型, 公开, 调用失败返回-1，调用成功返回命令自身的值。 注意：被调用的命令必须有4个参数（前2个整数型,后2个文本型），否则会调用失败。
.参数 DLL路径, 文本型, , DLL完整路径
.参数 函数名称, 文本型, , 要调用的子程序命令名称
.参数 参数1, 整数型, 可空, 参数如果非整数可用指针传递
.参数 参数2, 整数型, 可空
.参数 参数3, 整数型, 可空
.参数 参数4, 整数型, 可空
.参数 参数5, 整数型, 可空
.参数 参数6, 整数型, 可空
.参数 参数7, 整数型, 可空
.参数 参数8, 整数型, 可空
.参数 参数9, 整数型, 可空
.参数 参数10, 整数型, 可空
.参数 参数11, 整数型, 可空
.参数 参数12, 整数型, 可空
.参数 参数13, 整数型, 可空
.参数 参数14, 整数型, 可空
.参数 参数15, 整数型, 可空
.局部变量 模块句柄, 整数型
.局部变量 函数地址, 整数型
.局部变量 ret, 整数型
模块句柄 ＝ LoadLibraryA (DLL路径)  ' 载入指定的动态链接库，并将它映射到当前进程使用的地址空间
.如果真 (模块句柄 ＝ 0)
    返回 (-1)
.如果真结束
函数地址 ＝ GetProcAddress (模块句柄, 函数名称)
.如果 (函数地址 ≠ 0)
    ret ＝ 调用子程序_ (函数地址, 参数1, 参数2, 参数3, 参数4, 参数5, 参数6, 参数7, 参数8, 参数9, 参数10, 参数11, 参数12, 参数13, 参数14, 参数15)
.否则
    ret ＝ -1
.如果结束
FreeLibrary (模块句柄)  ' 释放动态链接库
返回 (ret)
.子程序 程序_延时, 逻辑型, 公开, 不占用cpu，窗口不卡死，不影响其它代码执行
.参数 延时间隔, 整数型, 可空, 1000毫秒 = 1秒  留空为无限等待
.参数 延时单位, 长整数型, 可空, 默认为毫秒  0=毫秒  1=秒  2=分钟  3=小时
.局部变量 局_时间句柄, 整数型
.局部变量 局_时间, 程序延时
.判断开始 (延时单位 ＝ 0 且 是否为空 (延时间隔))
    延时间隔 ＝ 5000 × 60 × 60
    延时单位 ＝ 5000 × 60 × 60
.判断 (延时单位 ＝ 0)
    延时单位 ＝ 1
.判断 (延时单位 ＝ 1)
    延时单位 ＝ 1000
.判断 (延时单位 ＝ 2)
    延时单位 ＝ 1000 × 60
.判断 (延时单位 ＝ 3)
    延时单位 ＝ 1000 × 60 × 60
.默认
.判断结束
局_时间.成员_时间 ＝ -10 × 延时间隔 × 1000 × 延时单位
局_时间句柄 ＝ CreateWaitableTimerA (0, 假, 0)
SetWaitableTimer (局_时间句柄, 局_时间, 0, 0, 0, 假)
.判断循环首 (MsgWaitForMultipleObjects (1, 局_时间句柄, 假, -1, 255) ≠ 0)
    处理事件 ()
.判断循环尾 ()
CloseHandle (局_时间句柄)
返回 (真)
.子程序 程序_条件判断, 逻辑型, 公开
.参数 条件文本, 文本型
.参数 条件内存地址, 整数型, 可空
.局部变量 局_时间句柄, 整数型
.局部变量 局_时间, 程序延时
.局部变量 延时间隔, 整数型
.局部变量 内存共享, 内存共享
局_时间.成员_时间 ＝ -10 × 5000 × 1000 × 1000
局_时间句柄 ＝ CreateWaitableTimerA (0, 假, 0)
SetWaitableTimer (局_时间句柄, 局_时间, 0, 0, 0, 假)
.判断循环首 (MsgWaitForMultipleObjects (1, 局_时间句柄, 假, -1, 255) ≠ 0)
    .如果真 (条件文本 ＝ 到文本 (内存共享.读取 (条件内存地址)))
        内存共享.释放 (条件内存地址)
        CloseHandle (局_时间句柄)
        返回 (真)
    .如果真结束
    处理事件 ()
.判断循环尾 ()
.如果真 (局_时间句柄 ≠ 0)
    CloseHandle (局_时间句柄)
.如果真结束
返回 (假)
.子程序 程序_等待窗口出现, 整数型, 公开, 如果目标窗口出现则返回窗口句柄，否则将一直等待，超时返回 -1 。
.参数 父句柄, 整数型, 可空, 父窗口句柄
.参数 窗口标题, 文本型, 可空, 指定窗口标题。二选一
.参数 窗口类名, 文本型, 可空, 指定窗口类名。二选一
.参数 超时返回, 整数型, 可空, 单位为毫秒，超过此时间等待还没结果则返回假，留空则一直等待
.参数 是否顶端, 逻辑型, 可空, 默认为假。如果为真，顶端窗口的标题或类名和指定的相同才返回窗口句柄。
.局部变量 局_延时, 整数型
.局部变量 局_启动时间, 整数型
.局部变量 局_窗口句柄, 整数型
.如果真 (是否为空 (窗口标题) 且 是否为空 (窗口类名))
    输出调试文本 (“需指定一个窗口标题或窗口类名！”)
    返回 (-1)
.如果真结束
.如果 (超时返回 ＞ 0)
    局_延时 ＝ 超时返回
.否则
    局_延时 ＝ 1000 × 10000
.如果结束
局_启动时间 ＝ 取启动时间 ()
.判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
    .如果 (是否顶端)
        局_窗口句柄 ＝ 窗口_取顶端窗口句柄 ()
        .如果真 (是否为空 (窗口标题) ＝ 假 且 窗口_取标题 (局_窗口句柄) ＝ 窗口标题)
            返回 (局_窗口句柄)
        .如果真结束
        .如果真 (是否为空 (窗口类名) ＝ 假 且 窗口_取类名 (局_窗口句柄) ＝ 窗口类名)
            返回 (局_窗口句柄)
        .如果真结束
    .否则
        局_窗口句柄 ＝ 窗口_取句柄 (父句柄, , 窗口类名, 窗口标题)
        .如果真 (窗口_句柄是否有效 (局_窗口句柄))
            返回 (局_窗口句柄)
        .如果真结束
    .如果结束
    程序_延时 (50, )
.判断循环尾 ()
返回 (-1)
.子程序 程序_等待窗口消失, 逻辑型, 公开, 如果目标窗口不存在返回真 否则将一直等待，可以在第三个参数中设置超时返回
.参数 窗口标题, 文本型, 可空, 窗口标题
.参数 窗口类名, 文本型, 可空, 窗口类名
.参数 超时返回, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回假,留空则一直等待
.局部变量 局_启动时间, 整数型
.局部变量 局_窗口句柄, 整数型
.局部变量 局_延时, 整数型
.如果 (超时返回 ＞ 0)
    局_延时 ＝ 超时返回
.否则
    局_延时 ＝ 1000 × 10000
.如果结束
局_启动时间 ＝ 取启动时间 ()
.判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
    局_窗口句柄 ＝ 窗口_取句柄 (, , 窗口类名, 窗口标题)
    .如果真 (窗口_句柄是否有效 (局_窗口句柄) ＝ 假)
        返回 (真)
    .如果真结束
    程序_延时 (50)
.判断循环尾 ()
返回 (假)
.子程序 程序_等待句柄消失, 逻辑型, 公开, 如果目标句柄存在返回真 否则将一直等待，可以在第二个参数中设置超时返回
.参数 窗口句柄, 整数型, , 目标窗口句柄
.参数 超时返回, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回假,留空则一直等待
.局部变量 局_启动时间, 整数型
.局部变量 局_延时, 整数型
.如果 (超时返回 ＞ 0)
    局_延时 ＝ 超时返回
.否则
    局_延时 ＝ 1000 × 10000
.如果结束
局_启动时间 ＝ 取启动时间 ()
.判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
    .如果真 (窗口_句柄是否有效 (窗口句柄) ＝ 假)
        返回 (真)
    .如果真结束
    程序_延时 (50)
.判断循环尾 ()
返回 (假)
.子程序 程序_等待控件内容改变, 逻辑型, 公开, 等待一个控件的内容被改变，如果该控件的内容和第2个参数的文本一样，则返回真
.参数 控件句柄, 整数型, , 目标窗口句柄
.参数 控件内容, 文本型, , 控件的内容
.参数 超时返回, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回假,留空则一直等待
.局部变量 局_启动时间, 整数型
.局部变量 局_延时, 整数型
.如果 (超时返回 ＞ 0)
    局_延时 ＝ 超时返回
.否则
    局_延时 ＝ 1000 × 10000
.如果结束
局_启动时间 ＝ 取启动时间 ()
.判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
    .如果真 (窗口_取控件内容 (控件句柄) ＝ 控件内容)
        返回 (真)
    .如果真结束
    程序_延时 (50)
.判断循环尾 ()
返回 (假)
.子程序 程序_重启, , 公开, 重启当前程序
.参数 窗口显示方式, 整数型, 可空, 可空：默认为正常。说明：重启后，窗口的显示方式。1、#隐藏窗口； 2、#普通激活； 3、#最小化激活； 4、#最大化激活； 5、#普通不激活； 6、#最小化不激活
.参数 重启延时, 整数型, 可空, 可空。默认为1秒，最快。
.局部变量 局_文本, 文本型
.局部变量 局_临时文件名, 文本型
.如果真 (是否为调试版 ())
    提示框 (“你好，在调试状态下不能重启程序”)
    返回 ()
.如果真结束
.如果真 (是否为空 (重启延时) 或 重启延时 ＜ 1)
    重启延时 ＝ 2
.如果真结束
局_临时文件名 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
.如果真 (文件是否存在 (局_临时文件名) ＝ 假)
    返回 ()
.如果真结束
局_文本 ＝ 子文本替换 (#常量_重启, “<文件名>”, 文件_到短文件名 (局_临时文件名), , 1, 真)
局_文本 ＝ 子文本替换 (局_文本, “秒数”, 到文本 (重启延时), , 1, 真)
写到文件 (取运行目录 () ＋ “\Restart.bat”, 到字节集 (局_文本))
运行 (取运行目录 () ＋ “\Restart.bat”, 假, 1)
进程_结束 ()
.子程序 程序_更新, 文本型, 公开, 返回要运行命令行 万能更新程序 下载和例程使用说明地址: http://bbs.125.la/thread-20780-1-1.html
.参数 万能更新程序地址, 文本型, , 万能更新程序地址
.参数 启动窗口标题, 文本型, , 更新程序的启动窗口标题
.参数 超级链接标题, 文本型, , 更新进度条下方的超级链接标题
.参数 超级链接地址, 文本型, , 更新进度条下方的超级链接地址
.参数 本地程序地址, 文本型, , 要更新的文件路径地址
.参数 网络程序地址, 文本型, , 只支持zip和exe格式的下载文件
.参数 信息框提示文本, 文本型, , 程序更新完成后的信息框提示文本,如果填入 不提示 三个汉字,将不会弹出信息框提示
.参数 是否运行程序, 逻辑型, , 更新完成是否运行程序,一般为软件的主程序才设置为真
.局部变量 局_临时文本, 文本型
.局部变量 局_分割符, 文本型
局_分割符 ＝ “<#>”
局_临时文本 ＝ 启动窗口标题 ＋ 局_分割符 ＋ 超级链接标题 ＋ 局_分割符 ＋ 超级链接地址 ＋ 局_分割符 ＋ 本地程序地址 ＋ 局_分割符 ＋ 网络程序地址 ＋ 局_分割符 ＋ 信息框提示文本 ＋ 局_分割符 ＋ 到文本 (是否运行程序)
局_临时文本 ＝ “ ” ＋ 子文本替换 (局_临时文本, “ ”, “<?>”, , , 真)
ShellExecuteA (GetActiveWindow (), “”, 万能更新程序地址, 局_临时文本, “”, 5)
返回 (局_临时文本)
.子程序 程序_删除自身, , 公开, 删除程序自身EXE文件
.局部变量 路径, 文本型
.局部变量 后缀, 文本型
路径 ＝ 取运行目录 () ＋ “\”
后缀 ＝ #引号 ＋ “)”
写到文件 (路径 ＋ “tem.vbs”, 到字节集 (#自我删除1 ＋ 路径 ＋ 取执行文件名 () ＋ 后缀 ＋ #换行符 ＋ #自我删除0 ＋ 路径 ＋ “tem.vbs” ＋ 后缀))
置文件属性 (路径 ＋ “tem.vbs”, 2)
文件_执行 (路径 ＋ “tem.vbs”)
结束 ()
.子程序 程序_删除自身1, , 公开, 删除程序自身EXE文件
.局部变量 nSize, 整数型
.局部变量 szFileName, 字节集
.局部变量 szComspec, 字节集
.局部变量 szBat, 字节集
.局部变量 stShellDel, SHELLEXECUTEINFOW
.局部变量 len, 整数型
nSize ＝ #MAX_PATH × 2
szFileName ＝ 取空白字节集 (nSize)
szComspec ＝ 取空白字节集 (nSize)
GetModuleFileNameW (0, szFileName, #MAX_PATH)
len ＝ GetShortPathNameW (szFileName, szFileName, #MAX_PATH)
.如果真 (len ≠ 0 且 GetEnvironmentVariableW (编码_Ansi到Unicode (“COMSPEC”, ), szComspec, #MAX_PATH) ≠ 0)
    ' /c del xxx > nul
    szBat ＝ { 47, 0, 99, 0, 32, 0, 100, 0, 101, 0, 108, 0, 32, 0 } ＋ 取字节集左边 (szFileName, len × 2) ＋ { 32, 0, 62, 0, 32, 0, 110, 0, 117, 0, 108, 0, 0, 0 }
    stShellDel.cbSize ＝ 60  ' sizeof(SHELLEXECUTEINFO)
    ' 命令窗口进程句柄，ShellExecuteEx函数执行时设置
    stShellDel.hwnd ＝ 0
    stShellDel.lpVerb ＝ 编码_Ansi到Unicode (“Open”, )
    stShellDel.lpFile ＝ szComspec
    stShellDel.lpParameters ＝ szBat
    stShellDel.lpDirectory ＝ {  }
    stShellDel.nShow ＝ #SW_HIDE
    ' 设置为SellExecuteEx函数结束后进程退出
    stShellDel.fMask ＝ #SEE_MASK_NOCLOSEPROCESS
    ' 创建执行命令窗口进程
    .如果真 (ShellExecuteExW (stShellDel))
        ' 设置命令行进程的执行级别为空闲执行，这使本程序有足够的时间从内存中退出
        SetPriorityClass (stShellDel.hProcess, #IDLE_PRIORITY_CLASS)
        ' 设置本程序进程的执行级别为实时执行，这保证本程序能立即获取CPU执行权，快速退出
        SetPriorityClass (GetCurrentProcess (), #REALTIME_PRIORITY_CLASS)
        SetThreadPriority (GetCurrentThread (), #THREAD_PRIORITY_TIME_CRITICAL)
        ' 通知Windows资源管理器，本程序文件已经被删除
        SHChangeNotify (#SHCNE_DELETE, #SHCNF_PATH, 取指针字节集_ (szFileName), 0)
        ExitProcess (0)
    .如果真结束
.如果真结束
.子程序 程序_出错退出, , 公开, 让程序内部崩溃方式结束运行。感谢goomoo提供提示
.局部变量 字集, 字节集
.判断循环首 (字集 ＝ {  })
    字集 ＝ 字集 ＋ 取空白字节集 (1024 × 1024 × 1024)
.判断循环尾 ()
.子程序 程序_是否被调试, 逻辑型, 公开, 判断自己的软件是否被调试；返回真，正在被调试，返回假，没有被调试；
返回 (IsDebuggerPresent ())
.子程序 程序_禁止重复运行, , 公开, 禁止当前程序多开运行
.参数 标识文本, 文本型, 可空, 尽量输复杂一点的文本
.参数 是否弹出信息框提示, 逻辑型, 可空, 默认为假,不弹出提示;
.参数 消息框提示文本, 文本型, 可空, 第二个参数设置为假,该参数则无效
.参数 消息框提示图标, 整数型, 可空, 默认为信息图标，如：#信息图标
.参数 是否前端显示程序, 逻辑型, 可空, 如果已重复运行,是否将程序在前端显示
.局部变量 局_句柄, 整数型
.如果真 (标识文本 ＝ “”)
    标识文本 ＝ 校验_取md5 (到字节集 (“你懒得输入，我就写死，略略”))  ' 标识文本，如果有重复的，就不能打开事件，实现禁止
.如果真结束
.如果真 (OpenEventA (2031619, 假, 标识文本) ≠ 0)
    .如果真 (是否弹出信息框提示)
        .如果真 (是否为空 (消息框提示文本))
            消息框提示文本 ＝ “对不起,该进程已打开!”
        .如果真结束
        信息框 (消息框提示文本, 消息框提示图标, “友情提醒:”)
    .如果真结束
    .如果真 (是否前端显示程序)
        局_句柄 ＝ 进程_名取句柄 (取执行文件名 ())
        .如果真 (IsWindowVisible (局_句柄) ＝ 假)
            窗口_强制显示 (局_句柄, 假)
        .如果真结束
        .如果真 (窗口_是否最小化 (局_句柄))
            窗口_还原 (局_句柄)
        .如果真结束
        窗口_置顶 (局_句柄, 真)
    .如果真结束
    结束 ()
.如果真结束
CreateEvent (0, 假, 假, 标识文本)
.子程序 程序_添加到IE工具栏, , 公开, 在IE的工具栏上添加自己的软件快捷方式
.参数 主程序路径, 文本型, , 主程序路径
.参数 提示内容, 文本型, , 如:精易编程助手
.参数 程序图标路径, 文本型, , 在工具栏上显示的图标,格式为 ico
.参数 程序图标点燃图标路径, 文本型, , 在工具栏上显示的图标,格式为 ico
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”, 提示内容)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”, “{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}”)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”, “Yes”)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”, 主程序路径)  ' 程序路径
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”, 程序图标点燃图标路径)  ' 点燃图标
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”, 程序图标路径)  ' 程序图标
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”, 提示内容)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”, 提示内容)
.子程序 程序_加入右键菜单, 逻辑型, 公开, 把目标程序加入到右键菜单中,成功=真
.参数 菜单显示名, 文本型, , 不能有符号，如“\”等
.参数 目标程序名称, 文本型, 可空, 填空为程序本身
.参数 是否删除, 逻辑型, 可空, 真=删除，假=不删除，默认为假，添加右键菜单
.参数 命令行, 文本型, 可空
.局部变量 局_命令行, 文本型
.如果真 (是否删除 ＝ 真)
    .如果真 (删除注册项 (#根类, “*\shell\” ＋ 菜单显示名 ＋ “\command”) ＝ 真)
        删除注册项 (#根类, “*\shell\” ＋ 菜单显示名)
        返回 (真)
    .如果真结束
    返回 (假)
.如果真结束
.如果真 (取文本长度 (命令行) ＞ 0)
    局_命令行 ＝ “ ” ＋ 命令行
.如果真结束
.如果真 (寻找文本 (菜单显示名, “\”, , 假) ＝ -1)
    .如果真 (是否为空 (目标程序名称) ＝ 真)
        目标程序名称 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
    .如果真结束
    .如果真 (写注册项 (#根类, “*\shell\” ＋ 菜单显示名 ＋ “\command\”, 目标程序名称 ＋ 局_命令行 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号) ＝ 真)
        返回 (真)
    .如果真结束
.如果真结束
返回 (假)
.子程序 系统_关联右键菜单带图标, , 公开, 在win7系统中的右键菜单最上方添加一个带图标的菜单
.参数 右键名称, 文本型
.参数 程序路径, 文本型, 可空, 可空，留空为程序自身
.参数 图标路径, 文本型, 可空, 留空为程序的图标
.参数 是否删除, 逻辑型, 可空, 真为删除指定右键名称
.局部变量 注册表, 注册表操作
.如果真 (是否删除 ＝ 真)
    注册表.删除项 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称)
    返回 ()
.如果真结束
注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\”, 右键名称, “”)
注册表.写多字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称, “”, 右键名称)
.如果真 (是否为空 (程序路径) ＝ 真)
    程序路径 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
.如果真结束
.如果 (是否为空 (图标路径) ＝ 真)
    注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称, “Icon”, 程序路径 ＋ “,0”)  ' 取程序的图标为右击图标
.否则
    注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称, “Icon”, 图标路径 ＋ “,0”)
.如果结束
注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称 ＋ “\command”, “”, 程序路径 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号)
.子程序 程序_写日志, , 公开, 在程序根目录建立一个txt文件用于记录相关日志内容
.参数 日志内容, 文本型
.参数 日志文件路径, 文本型, 可空, 写日记文件的路径，可空，默认在运行目录下写出
.局部变量 文件号, 整数型
.如果真 (是否为空 (日志文件路径))
    日志文件路径 ＝ 取运行目录 () ＋ “\运行日志.txt”
.如果真结束
.如果真 (文件是否存在 (日志文件路径) ＝ 假)
    写到文件 (日志文件路径, {  })
.如果真结束
文件号 ＝ 打开文件 (日志文件路径, , )
插入文本行 (文件号, 到文本 (取现行时间 ()) ＋ “   ” ＋ 日志内容)
关闭文件 (文件号)
.子程序 程序_加入IE工具栏, , 公开, 把程序加入到IE工具栏,重启IE生效
.参数 程序名称, 文本型
.参数 程序路径, 文本型, 可空, 留空为自身程序路径
.参数 显示图标, 文本型, 可空, 留空为系统默认程序图标
.参数 是否删除, 逻辑型, 可空, 真=删除
.如果真 (是否删除 ＝ 真)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”)  ' 程序位置(路径)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”)  ' 点燃图标
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”)  ' 程序图标
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}”)
    返回 ()
.如果真结束
.如果真 (是否为空 (程序路径))
    程序路径 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
.如果真结束
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”, 程序名称)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”, “{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}”)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”, “Yes”)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”, 程序路径)  ' 程序位置(路径)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”, 显示图标)  ' 点燃图标
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”, 显示图标)  ' 程序图标
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”, 程序名称)
写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”, 程序名称)
.子程序 内部_Call, 整数型, , 内部调用
.参数 子程序指针, 整数型
.参数 参数1, 整数型
.参数 参数2, 整数型
.参数 参数3, 整数型
.参数 参数4, 整数型
.参数 参数5, 整数型
置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
返回 (0)
.子程序 程序_Call, 整数型, 公开, 少在计次循环里使用
.参数 子程序指针, 整数型
.参数 参数1, 整数型, 可空
.参数 参数2, 整数型, 可空
.参数 参数3, 整数型, 可空
.参数 参数4, 整数型, 可空
.参数 参数5, 整数型, 可空
返回 (内部_Call (子程序指针, 参数1, 参数2, 参数3, 参数4, 参数5))
.子程序 程序_执行文本子程序, 文本型, 公开, 执行子程序参数为文本的；并返回文本；
.参数 欲执行的子程序, 子程序指针
.参数 参数一, 文本型, 可空
.参数 参数二, 文本型, 可空
.参数 参数三, 整数型, 可空
.局部变量 bin, 字节集
.局部变量 lpText, 整数型
bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
lpText ＝ CallWindowProcA (取指针_字节集型 (bin), 到整数 (欲执行的子程序), 取指针_文本型 (参数一), 取指针_文本型 (参数二), 参数三)
返回 (指针到文本 (lpText))
.子程序 程序_执行整数子程序, 整数型, 公开, 执行子程序参数为整数的；并返回整数；
.参数 子程序, 子程序指针
.参数 参数一, 整数型, 可空
.参数 参数二, 整数型, 可空
.参数 参数三, 整数型, 可空
.局部变量 bin, 字节集
bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
返回 (CallWindowProcA (取指针_字节集型 (bin), 到整数 (子程序), 参数一, 参数二, 参数三))
.子程序 程序_执行整数子程序1, 整数型, 公开, 执行子程序参数为整数的；并返回整数；
.参数 子程序, 整数型
.参数 参数一, 整数型, 可空
.参数 参数二, 整数型, 可空
.参数 参数三, 整数型, 可空
.局部变量 bin, 字节集
bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
返回 (CallWindowProcA (取指针_字节集型 (bin), 子程序, 参数一, 参数二, 参数三))
.子程序 程序_取命令行, 整数型, 公开, 本命令可以取出在启动易程序时附加在其可执行文件名后面的所有以空格分隔的命令行文本段
.参数 命令行数组, 文本型, 数组, 存放被取回命令行文本的数组变量,本变量数组内被顺序填入在启动易程序时附加在其可执行文件名后面的以空格分隔的命令行文本段
.局部变量 szArglist
.局部变量 nArgs
.局部变量 Command, , , "0"
.局部变量 Length
.局部变量 i, 整数型
清除数组 (命令行数组)
szArglist ＝ CommandLineToArgvW (GetCommandLineW (), nArgs)
.如果真 (nArgs ＝ 1)
    返回 (0)
.如果真结束
重定义数组 (Command, 假, nArgs)
Length ＝ lstrlen (szArglist) × 2
RtlMoveMemory (取数据_通用型_数组 (Command), szArglist, Length)
.变量循环首 (2, nArgs, 1, i)
    加入成员 (命令行数组, 编码_Unicode到Ansi (指针到字节集 (Command [i], lstrlen (Command [i]) × 2)))
.变量循环尾 ()
LocalFree (szArglist)
返回 (取数组成员数 (命令行数组))
.子程序 程序_隐藏托盘图标, , 公开, 隐藏托盘上指定按钮,和 程序_显示托盘图标 配合使用
.参数 任务栏按钮标题, 文本型
.局部变量 局_按钮序号, 整数型
.局部变量 局_任务栏句柄, 整数型
局_任务栏句柄 ＝ 功能_取托盘区句柄 ()
局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 1)
.子程序 程序_显示托盘图标, , 公开, 显示托盘上指定按钮,和 程序_隐藏托盘图标 配合使用
.参数 任务栏按钮标题, 文本型
.局部变量 局_按钮序号, 整数型
.局部变量 局_任务栏句柄, 整数型
局_任务栏句柄 ＝ 功能_取托盘区句柄 ()
局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 0)
.子程序 程序_隐藏任务栏图标, , 公开, 隐藏任务栏上指定按钮,和 程序_显示任务栏图标 配合使用（本命令不兼容Win7或以上系统）
.参数 任务栏按钮标题, 文本型
.局部变量 局_按钮序号, 整数型
.局部变量 局_任务栏句柄, 整数型
局_任务栏句柄 ＝ 功能_取任务栏句柄 ()
局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 1)
.子程序 程序_显示任务栏图标, , 公开, 显示任务栏上指定按钮,和 程序_隐藏任务栏图标 配合使用（本命令不兼容Win7或以上系统）
.参数 任务栏按钮标题, 文本型
.局部变量 局_按钮序号, 整数型
.局部变量 局_任务栏句柄, 整数型
局_任务栏句柄 ＝ 功能_取任务栏句柄 ()
局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 0)
.子程序 程序_取安装目录, 文本型, 公开, 成功返回目录，以“\”结尾。失败返回空文本。
.参数 程序名称, 文本型, , 如：e.exe
.局部变量 局_路径, 文本型
局_路径 ＝ 取文本注册项 (#本地机器, “SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\App Paths\” ＋ 程序名称 ＋ “\Path”, )
.如果 (局_路径 ≠ “”)
    局_路径 ＝ 局_路径 ＋ “\”
.否则
    局_路径 ＝ 取文本注册项 (#根类, “Applications\” ＋ 程序名称 ＋ “\shell\open\command\”, )
    .如果真 (局_路径 ≠ “”)
        .如果 (局_路径 ≈ #引号)
            局_路径 ＝ 文本_取出中间文本 (局_路径, #引号, #引号, , )
            局_路径 ＝ 文件_取目录 (局_路径)
        .否则
            ' 部分系统记录安装路径不规范导致
            局_路径 ＝ 文本_取左边 (局_路径, 取空白文本 (1), -1, )
        .如果结束
    .如果真结束
.如果结束
返回 (局_路径)
.子程序 功能_取托盘区句柄, 整数型, , 取出当前桌面托盘区域的句柄
.局部变量 局_系统句柄, 整数型, , , SysPager
.局部变量 局_句柄, 整数型
.局部变量 局_托盘句柄, 整数型
局_句柄 ＝ FindWindowA (“Shell_TrayWnd”, 字符 (0))
局_句柄 ＝ 窗口_取句柄 (局_句柄, 0, “TrayNotifyWnd”)
局_系统句柄 ＝ 窗口_取句柄 (局_句柄, 0, “SysPager”)
.如果真 (局_系统句柄 ≠ 0)  ' 2003,XP,2000； Windows ME没有 "SysPager" 容器,“TrayNotifyWnd”容器中直接就是“ToolbarWindow32”
    局_句柄 ＝ 局_系统句柄
.如果真结束
局_托盘句柄 ＝ 窗口_取句柄 (局_句柄, 0, “ToolbarWindow32”)
.如果真 (局_托盘句柄 ＝ 0)  ' Windows 98没有“ToolbarWindow32”
    局_托盘句柄 ＝ 局_句柄
.如果真结束
返回 (局_托盘句柄)
.子程序 功能_取任务栏句柄, 整数型, , 本子程序采用【精易编程助手】生成,成功返回窗口句柄,失败返回0
.局部变量 局_1级句柄, 整数型
.局部变量 局_2级句柄, 整数型
.局部变量 局_3级句柄, 整数型
.局部变量 局_4级句柄, 整数型
局_1级句柄 ＝ 窗口_取句柄 (, , “Shell_TrayWnd”, “”)
.如果真 (局_1级句柄 ＝ -1)
    返回 (0)
.如果真结束
局_2级句柄 ＝ 窗口_取句柄 (局_1级句柄, , “ReBarWindow32”, “”)
.如果真 (局_2级句柄 ＝ -1)
    返回 (0)
.如果真结束
局_3级句柄 ＝ 窗口_取句柄 (局_2级句柄, , “MSTaskSwWClass”, “运行应用程序”)
.如果真 (局_3级句柄 ＝ -1)
    返回 (0)
.如果真结束
局_4级句柄 ＝ 窗口_取句柄 (局_3级句柄, , “ToolbarWindow32”, “运行应用程序”)
.如果真 (局_4级句柄 ＝ -1)
    返回 (0)
.如果真结束
返回 (局_4级句柄)
.子程序 托盘_取按钮位置, 整数型, , 取任务栏或托盘的按钮位置
.参数 按钮标题, 文本型
.参数 托盘或任务栏句柄, 整数型, 可空
.局部变量 局_进程ID, 整数型
.局部变量 局_进程句柄, 整数型
.局部变量 局_hTargetHandle, 整数型
.局部变量 局_pStart, 整数型
.局部变量 局_Result, 整数型
.局部变量 局_pBufStart, 整数型
.局部变量 局_dwWrite, 整数型, , , 0
.局部变量 局_dwRead, 整数型, , , 0
.局部变量 局_txtLen, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_TextBufSize, 整数型
.局部变量 局_dwAllocSize, 整数型
.局部变量 局_TempBuf, 字节型, , "254"
.局部变量 局_图标数, 整数型
.局部变量 局_当前进程句柄, 整数型
.局部变量 TBi, 按钮信息
局_TextBufSize ＝ 255
局_dwAllocSize ＝ 32
GetWindowThreadProcessId (托盘或任务栏句柄, 局_进程ID)  ' 获取进程句柄
局_进程句柄 ＝ OpenProcess (2035711, 0, 局_进程ID)  ' 打开进程
.如果真 (局_进程句柄 ＝ 0)  ' 打开进程失败
    返回 (-1)  ' 0)
.如果真结束
局_当前进程句柄 ＝ GetCurrentProcess ()  ' 取自身程序的进程句柄
局_Result ＝ DuplicateHandle (局_当前进程句柄, 局_进程句柄, 局_当前进程句柄, 局_hTargetHandle, 2035711, 0, 0)  ' 复制对象句柄
.如果真 (局_Result ＝ 0)  ' 复制句柄失败
    CloseHandle (局_进程句柄)
    返回 (-1)  ' 0)
.如果真结束
局_pStart ＝ VirtualAllocEx (局_hTargetHandle, 0, 局_dwAllocSize, 4096, 4)  ' 分配外部指针
局_pBufStart ＝ VirtualAllocEx (局_hTargetHandle, 0, 局_TextBufSize, 4096, 4)  ' 工具提示信息 存放空间
.如果真 (局_pStart ＝ 0 或 局_pBufStart ＝ 0)  ' 分配内存失败
    CloseHandle (局_hTargetHandle)  ' 关闭一个内核对象
    返回 (-1)  ' 0)
.如果真结束
局_图标数 ＝ SendMessageA (托盘或任务栏句柄, 1048, 0, 0)
.变量循环首 (1, 局_图标数, 1, 局_计次)
    TBi.cbSize ＝ 局_dwAllocSize
    TBi.dwMask ＝ 位或 (2147483648, 32, 4, 8, 1, 16, 64)  ' 'Or TBIF_TEXT
    WriteProcessMemory_整数3 (局_hTargetHandle, 局_pStart, SetHandleCount_字节型 (TBi.cbSize), 局_dwAllocSize, 局_dwWrite)  ' 写整数内存
    SendMessageA (托盘或任务栏句柄, 1089, 局_计次 － 1, 局_pStart)
    ReadProcessMemory_整数型 (局_hTargetHandle, 局_pStart, SetHandleCount_字节型 (TBi.cbSize), 局_dwAllocSize, 局_dwRead)  ' 读整数内存
    重定义数组 (局_TempBuf, 假, 局_TextBufSize)
    WriteProcessMemory_整数3 (局_hTargetHandle, 局_pBufStart, SetHandleCount_字节型 (局_TempBuf [1]), 局_TextBufSize, 局_dwWrite)  ' 写整数内存
    局_txtLen ＝ SendMessageA (托盘或任务栏句柄, 1069, TBi.idCommand, 局_pBufStart)
    ReadProcessMemory_整数型 (局_hTargetHandle, 局_pBufStart, SetHandleCount_字节型 (局_TempBuf [1]), 局_TextBufSize, 局_dwRead)  ' 读整数内存
    .如果真 (局_txtLen ＞ 0)
        重定义数组 (局_TempBuf, 真, 局_txtLen)
        .如果真 (寻找文本 (到文本 (局_TempBuf), 按钮标题, , 假) ≠ -1)
            跳出循环 ()
        .如果真结束
    .如果真结束
.变量循环尾 ()
VirtualFreeEx (局_hTargetHandle, 局_pStart, 局_dwAllocSize, 16384)
VirtualFreeEx (局_hTargetHandle, 局_pBufStart, 局_TextBufSize, 16384)
返回 (TBi.idCommand)
.子程序 程序_任务栏窗口图标状态, 逻辑型, 公开, 设置或获取指定窗口的任务栏图标状态
.参数 窗口句柄, 整数型
.参数 参数, 整数型, , 1、隐藏图标；2、显示图标；3、取得当前显示状态
.局部变量 局_父窗口句柄, 整数型
.局部变量 局_是否可见, 逻辑型
.局部变量 局_是否最小化, 逻辑型
' https://bbs.125.la/thread-14498152-1-1.html
.如果真 (IsWindow (窗口句柄) ＝ 0)
    返回 (假)
.如果真结束
.如果真 (参数 ＝ 3)
    局_父窗口句柄 ＝ GetWindowLongA (窗口句柄, #GWL_HWNDPARENT)
    .如果真 (局_父窗口句柄 ＝ 0)
        .如果真 (GetWindowLongA (局_父窗口句柄, #GWL_EXSTYLE) ≠ 384 或 GetWindowLongA (局_父窗口句柄, #GWL_STYLE) ≠ 79691776)
            返回 (真)
        .如果真结束
    .如果真结束
    返回 (假)
.如果真结束
.如果真 (参数 ＝ 2)
    .如果真 (程序_任务栏窗口图标状态 (窗口句柄, 3))
        返回 (真)
    .如果真结束
    局_是否最小化 ＝ IsIconic (窗口句柄)
    局_是否可见 ＝ IsWindowVisible (窗口句柄)
    局_父窗口句柄 ＝ GetWindowLongA (窗口句柄, #GWL_HWNDPARENT)
    SetWindowLongA (窗口句柄, #GWL_HWNDPARENT, 0)
    PostThreadMessageA (GetWindowThreadProcessId (局_父窗口句柄, 0), #WM_QUIT, 0, 0)
    SendMessageA (局_父窗口句柄, #WM_CLOSE, 0, 0)
    SendMessageA (窗口句柄, #WM_SETREDRAW, 0, 0)
    ShowWindow (窗口句柄, #SW_SHOWMINNOACTIVE)
    .如果真 (局_是否最小化 ＝ 假)
        ShowWindow (窗口句柄, #SW_SHOWNOACTIVATE)
    .如果真结束
    SendMessageA (窗口句柄, #WM_SETREDRAW, 1, 0)
    .如果真 (局_是否可见 ＝ 假)
        ShowWindow (窗口句柄, #SW_HIDE)
    .如果真结束
    返回 (真)
.如果真结束
.如果真 (程序_任务栏窗口图标状态 (窗口句柄, 3) ＝ 假)
    返回 (真)
.如果真结束
SetWindowLongA (窗口句柄, #GWL_HWNDPARENT, GetDesktopWindow ())
返回 (真)
.子程序 程序_是否在虚拟机中运行, 逻辑型, 公开, 通过BIOS信息检测程序是否在虚拟机中运行（不支持XP）
.局部变量 iSignature, 整数型
.局部变量 dwSize, 整数型
.局部变量 dwWriteSize, 整数型
.局部变量 pBuffer, 字节集
.局部变量 i, 整数型
iSignature ＝ 取代码 (“R”, )
iSignature ＝ 位或 (左移 (iSignature, 8), 取代码 (“S”, ))
iSignature ＝ 位或 (左移 (iSignature, 8), 取代码 (“M”, ))
iSignature ＝ 位或 (左移 (iSignature, 8), 取代码 (“B”, ))
dwSize ＝ GetSystemFirmwareTable (iSignature, 0, 0, 0)
pBuffer ＝ 取空白字节集 (dwSize)
dwWriteSize ＝ GetSystemFirmwareTable (iSignature, 0, 取指针_字节集型 (pBuffer), dwSize)
.如果真 (dwWriteSize ≤ dwSize)
    .变量循环首 (9, dwSize － 8, 1, i)
        .如果真 (pBuffer [i] ＝ 取代码 (“V”, ))
            .如果真 (取字节集数据 (pBuffer, #文本型, i) ≈ “VMware”)
                返回 (真)
            .如果真结束
        .如果真结束
    .变量循环尾 ()
.如果真结束
返回 (假)
.程序集 集_自绘解析, , , 感谢会员【酷宝贝】提供Accessible接口
.子程序 自绘窗口_鼠标点击, , 公开, 对指定窗口指定坐标进行鼠标操作
.参数 主窗口句柄, 整数型, 可空, 可空:为桌面超级列表框句柄 接收鼠标消息窗口句柄
.参数 横坐标, 整数型, 可空, 可空:为原水平坐标不变 移动目标鼠标水平坐标 (注:坐标为参数一窗口句柄中的坐标)
.参数 纵坐标, 整数型, 可空, 可空:为原垂直坐标不变 移动目标鼠标垂直坐标
.参数 鼠标键, 整数型, 可空, 可空:为左键 1 #左键 2 #右键 3 #中键 4 #中键上滚动 5 #中键下滚动(滚动前后请按下放开中键)
.参数 键状态, 整数型, 可空, 可空:为单击 1 #单击 2 #双击 3 #按下 4 #放开
鼠标_消息 (主窗口句柄, 横坐标, 纵坐标, 鼠标键, 键状态)
.子程序 自绘窗口_投递文本, , 公开, 往指定的自绘投递文本
.参数 主窗口句柄, 整数型
.参数 投递内容, 文本型
文本_投递 (主窗口句柄, 投递内容)
.子程序 自绘窗口_取信息, 文本型, 公开, 通过名称，状态，类型来获取相关的元素信息，如果需要更多信息请使用【自绘窗口_解析】 线程中调用请在线程头部加上  线程_初始化com库
.参数 窗口句柄, 整数型, , 自绘窗口句柄
.参数 控件名称, 文本型, , 自绘控件的名称
.参数 控件状态, 文本型, , 自绘控件的状态
.参数 控件类型, 文本型, , 自绘控件的类型
.参数 获取类型, 整数型, 可空, 默认：0  0=控件描述，1=控件值，2控件大小，3控件相对主窗口位置，4=状态标识，5=类型标识
.参数 返回索引, 整数型, 可空, 如果返回多个相同信息的，按传入索引返回信息，默认为1
.局部变量 局_详细, 精易_详细信息
.局部变量 局_对象, 类_Accessible, , "0"
.局部变量 局_主对象, 类_Accessible
.局部变量 局_索引对象, 类_Accessible
.局部变量 局_位置, 精易_位置和大小
.局部变量 句柄, 整数型
.局部变量 局_左, 整数型
.局部变量 局_顶, 整数型
.局部变量 局_宽, 整数型
.局部变量 局_高, 整数型
.局部变量 局_左边, 整数型
.局部变量 局_顶边, 整数型
.局部变量 局_总数, 整数型
.如果真 (是否为空 (返回索引))
    返回索引 ＝ 1
.如果真结束
.如果真 (返回索引 ＝ 0)
    返回索引 ＝ 1
.如果真结束
.如果真 (是否为空 (获取类型))
    获取类型 ＝ 0
.如果真结束
局_主对象.创建自窗口句柄 (窗口句柄)
内部_查找指定元素 (局_主对象, 控件名称, 控件类型, 控件状态, 局_对象)
局_总数 ＝ 取数组成员数 (局_对象)
输出调试文本 (“共计取到” ＋ 到文本 (局_总数) ＋ “个信息”)
.如果真 (局_总数 ＝ 0)
    返回 (“”)
.如果真结束
.如果真 (返回索引 ＞ 局_总数)
    返回索引 ＝ 1
.如果真结束
.如果 (局_总数 ＝ 1)
    局_索引对象 ＝ 局_对象 [1]
.否则
    局_索引对象 ＝ 局_对象 [返回索引]
.如果结束
局_详细 ＝ 自绘窗口_格式化信息 (局_索引对象)
.如果真 (获取类型 ＝ 0)
    返回 (局_详细.控件描述)
.如果真结束
.如果真 (获取类型 ＝ 1)
    返回 (局_详细.控件值)
.如果真结束
.如果真 (获取类型 ＝ 2)
    返回 (局_详细.窗口大小)
.如果真结束
.如果真 (获取类型 ＝ 3)
    局_索引对象.取位置 (局_左, 局_顶, 局_宽, 局_高)
    局_位置 ＝ 窗口_取位置和大小 (窗口句柄)
    局_左边 ＝ 局_左 － 局_位置.左边
    局_顶边 ＝ 局_顶 － 局_位置.顶边
    返回 (“左：” ＋ 到文本 (局_左边) ＋ “ 顶：” ＋ 到文本 (局_顶边))
.如果真结束
.如果真 (获取类型 ＝ 4)
    返回 (局_详细.状态标识)
.如果真结束
.如果真 (获取类型 ＝ 5)
    返回 (局_详细.类型标识)
.如果真结束
返回 (“”)
.子程序 内部_查找指定元素, 逻辑型, , 根据指定名称与角色文本在指定父元素中查找子元素对象  线程中调用请在线程头部加上  线程_初始化com库
.参数 参数_根元素, 类_Accessible
.参数 参数_名称, 文本型
.参数 参数_角色文本, 文本型
.参数 参数_状态文本, 文本型
.参数 参数_返回的元素, 类_Accessible, 参考 数组
.局部变量 count, 整数型
.局部变量 child, 类_Accessible, , "0"
.局部变量 局_对象, 类_Accessible
.局部变量 i, 整数型
.局部变量 左, 整数型
.局部变量 顶, 整数型
.局部变量 宽, 整数型
.局部变量 高, 整数型
.局部变量 局_状态, 文本型
count ＝ 参数_根元素.枚举子元素 (child)
.计次循环首 (count, i)
    局_对象 ＝ child [i]
    .如果真 (局_对象.取名称 () ＝ “昵称”)
        局_对象.取位置 (左, 顶, 宽, 高)
    .如果真结束
    .如果真 (局_对象.取名称 () ＝ 参数_名称)
        .如果真 (局_对象.取角色文本 () ＝ 参数_角色文本)
            局_状态 ＝ 文本_取左边 (局_对象.取状态文本 (), “,”)
            .如果真 (局_状态 ＝ 参数_状态文本)
                加入成员 (参数_返回的元素, 局_对象)
                返回 (真)
            .如果真结束
        .如果真结束
    .如果真结束
    .如果真 (局_对象.取子元素总数 () ≠ 0)
        内部_查找指定元素 (局_对象, 参数_名称, 参数_角色文本, 参数_状态文本, 参数_返回的元素)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 自绘窗口_格式化信息, 精易_详细信息, 公开, 获取指定对象下的相关元素信息  线程中调用请在线程头部加上  线程_初始化com库
.参数 参_对象, 类_Accessible, , 指定自绘窗口的元素对象
.局部变量 左, 整数型
.局部变量 顶, 整数型
.局部变量 宽, 整数型
.局部变量 高, 整数型
.局部变量 局_矩形, 矩形信息
.局部变量 局_详细, 精易_详细信息
.局部变量 数量, 整数型
.局部变量 局_标题, 文本型
数量 ＝ 参_对象.取子元素总数 ()
参_对象.取位置 (左, 顶, 宽, 高)
局_矩形.左边 ＝ 左
局_矩形.顶边 ＝ 顶
局_矩形.宽度 ＝ 宽
局_矩形.高度 ＝ 高
局_详细.控件ID ＝ 到文本 (参_对象.取ID ())
局_详细.控件值 ＝ 参_对象.取值 ()
局_详细.子窗口数 ＝ 到文本 (数量)
局_详细.控件描述 ＝ 参_对象.取描述 ()
.如果 (参_对象.取名称 () ＝ “”)
    局_标题 ＝ “NAMELESS”
.否则
    局_标题 ＝ 参_对象.取名称 ()
.如果结束
局_详细.控件名称 ＝ 局_标题
局_详细.控件状态 ＝ 参_对象.取状态文本 ()
局_详细.控件类型 ＝ 参_对象.取角色文本 ()
局_详细.窗口位置 ＝ “左：” ＋ 到文本 (左) ＋ “ 顶：” ＋ 到文本 (顶)
局_详细.窗口大小 ＝ “宽：” ＋ 到文本 (宽) ＋ “ 高：” ＋ 到文本 (高)
局_详细.矩形信息 ＝ 局_矩形
局_详细.默认动作 ＝ 参_对象.取默认动作 ()
局_详细.状态标识 ＝ 到文本 (参_对象.取状态 ())
局_详细.类型标识 ＝ 到文本 (参_对象.取角色 ())
返回 (局_详细)
.子程序 自绘窗口_解析, 逻辑型, 公开, 枚举指定自绘窗口元素信息  线程中调用请在线程头部加上  线程_初始化com库
.参数 窗口句柄, 整数型
.参数 类型标识, 文本型, 可空, 指定自绘窗口的类型标识  支持多类型 | 间隔与结尾 如：“42|16|”   单个标识“42|”
.参数 状态标识, 文本型, 可空, 指定自绘窗口的状态标识  支持多类型 | 间隔与结尾 如：“0|32768|” 单个标识“32768|”
.参数 是否可见, 逻辑型, 可空, 如果传入的状态标识包含 32768 与 32769 此参数请留空
.参数 元素信息, 精易_详细信息, 参考 数组, 返回解析的元素控件所有信息数组
.局部变量 局_对象, 类_Accessible, , , 当前窗口元素
.局部变量 局_对象数组, 类_Accessible, , "0", 枚举子元素
.局部变量 局_详细, 精易_详细信息
清除数组 (元素信息)
.如果真 (局_对象.创建自窗口句柄 (窗口句柄) ＝ 假)
    返回 (假)
.如果真结束
.如果 (是否为空 (类型标识))
    类型标识 ＝ “-1”
.否则
    类型标识 ＝ “|” ＋ 类型标识
.如果结束
.如果 (是否为空 (状态标识))
    状态标识 ＝ “-1”
.否则
    状态标识 ＝ “|” ＋ 状态标识
.如果结束
局_对象.枚举子元素 (局_对象数组)
内部_递归解析元素 (类型标识, 状态标识, 是否可见, 元素信息, 局_对象数组)
返回 (真)
.子程序 内部_递归解析元素, , , 递归条件解析窗口
.参数 参_类型标识, 文本型, 可空
.参数 参_状态标识, 文本型, 可空
.参数 是否可见, 逻辑型, 可空
.参数 参_详细数组, 精易_详细信息, 参考 数组
.参数 参_对象, 类_Accessible, 数组
.局部变量 局_数组, 类_Accessible, , "0"
.局部变量 局_计次, 整数型
.局部变量 局_对象, 类_Accessible
.局部变量 局_总数, 整数型
.局部变量 局_数量, 整数型
.局部变量 局_详细, 精易_详细信息
.局部变量 局_状态, 整数型
.局部变量 局_类型, 整数型
.局部变量 局_是否符合类型, 整数型
.局部变量 局_是否符合状态, 整数型
.局部变量 局_可见, 逻辑型
局_总数 ＝ 取数组成员数 (参_对象)
.计次循环首 (局_总数, 局_计次)
    局_对象 ＝ 参_对象 [局_计次]
    ' ————————————————————————————————————————’
    局_状态 ＝ 局_对象.取状态 ()
    局_类型 ＝ 局_对象.取角色 ()
    .如果真 (是否可见)
        .如果真 (局_状态 ＝ 32768 或 局_状态 ＝ 32769)  ' 不可见 与  不可见不可用
            到循环尾 ()
        .如果真结束
    .如果真结束
    .如果真 (参_类型标识 ≠ “-1”)  ' 传了类型
        局_是否符合类型 ＝ 寻找文本 (参_类型标识, “|” ＋ 到文本 (局_类型) ＋ “|”, , 假)
    .如果真结束
    .如果真 (参_状态标识 ≠ “-1”)  ' 传了状态
        局_是否符合状态 ＝ 寻找文本 (参_状态标识, “|” ＋ 到文本 (局_状态) ＋ “|”, , 假)
    .如果真结束
    .判断开始 (参_类型标识 ≠ “-1” 且 参_状态标识 ≠ “-1” 且 局_是否符合类型 ≠ -1 且 局_是否符合状态 ≠ -1)  ' 都传了值且都找到了
        局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
        加入成员 (参_详细数组, 局_详细)
    .判断 (参_类型标识 ≠ “-1” 且 参_状态标识 ＝ “-1” 且 局_是否符合类型 ≠ -1)  ' 只传了类型 没状态 且找到了对应的类型
        局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
        加入成员 (参_详细数组, 局_详细)
    .判断 (参_状态标识 ≠ “-1” 且 参_类型标识 ＝ “-1” 且 局_是否符合状态 ≠ -1)  ' 只传了状态 没类型 且找到了对应的状态
        局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
        加入成员 (参_详细数组, 局_详细)
    .判断 (参_类型标识 ＝ “-1” 且 参_状态标识 ＝ “-1”)  ' 都没传 直接加入
        局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
        加入成员 (参_详细数组, 局_详细)
    .默认
        ' 都没找到
    .判断结束
    局_数量 ＝ 局_对象.取子元素总数 ()
    .如果真 (局_数量 ≠ 0)
        局_对象.枚举子元素 (局_数组)
        内部_递归解析元素 (参_类型标识, 参_状态标识, 是否可见, 参_详细数组, 局_数组)
    .如果真结束
.计次循环尾 ()
.子程序 _取对象指针, 整数型
.参数 参数_对象, 对象, 参考
置入代码 ({ 139, 69, 8, 139, 0, 139, 0, 201, 194, 4, 0 })
' mov eax,[ebp+08]
' mov eax,[eax]
' mov eax,[eax]
' leave
' retn 04
返回 (0)
.子程序 _取对象指针的地址, 整数型
.参数 参数_对象, 对象, 参考
置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
' mov eax,[ebp+08]
' mov eax,[eax]
' leave
' retn 04
返回 (0)
.程序集 类_Accessible, , 公开, 感谢会员【酷宝贝】提供Accessible接口
.程序集变量 m_parent, 对象
.程序集变量 m_self, 对象
.程序集变量 m_id, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 创建自窗口句柄, 逻辑型, 公开, 从指定窗口句柄处获取自绘对象
.参数 参数_窗口句柄, 整数型, , 目标自绘窗口句柄
.局部变量 hr, 整数型
.局部变量 ppObj, 整数型
m_self.清除 ()
m_parent.清除 ()
m_id ＝ 0
ppObj ＝ _取对象指针的地址 (m_self)
hr ＝ AccessibleObjectFromWindow (参数_窗口句柄, #OBJID_WINDOW, { 224, 54, 135, 97, 61, 60, 207, 17, 129, 12, 0, 170, 0, 56, 155, 113 }, ppObj)
返回 (hr ＝ 0)
.子程序 创建自屏幕坐标, 逻辑型, 公开, 从桌面坐标处获取自绘窗口对象
.参数 参数_X, 整数型, , 桌面X坐标
.参数 参数_Y, 整数型, , 桌面Y坐标
.局部变量 hr, 整数型
.局部变量 ppObj, 整数型
.局部变量 item, 变体型
m_self.清除 ()
m_parent.清除 ()
m_id ＝ 0
ppObj ＝ _取对象指针的地址 (m_self)
hr ＝ AccessibleObjectFromPoint (参数_X, 参数_Y, ppObj, item)
.如果真 (hr ≠ 0)
    返回 (假)
.如果真结束
m_id ＝ item.取数值 ()
.如果真 (m_id ≠ 0)
    m_parent ＝ m_self
    m_self.清除 ()
.如果真结束
返回 (真)
.子程序 创建自对象, , 公开, 内部使用，从指定对象获取自绘窗口对象
.参数 参数_对象, 对象
m_self.清除 ()
m_parent.清除 ()
m_id ＝ 0
m_self ＝ 参数_对象
.子程序 创建自ID, , 公开, 内部使用，用从指定ID获取自绘窗口对象
.参数 参数_ID, 整数型
.参数 参数_父对象, 对象
m_self.清除 ()
m_parent.清除 ()
m_id ＝ 参数_ID
m_parent ＝ 参数_父对象
.子程序 到变体型, 变体型, 公开
.局部变量 var, 变体型
.如果 (m_id ＝ 0)
    var.赋值 (m_self, )
.否则
    var.赋值 (m_id, )
.如果结束
返回 (var)
.子程序 是否空, 逻辑型, 公开
.如果 (m_id ≠ 0)
    返回 (m_parent.是否为空 ())
.否则
    返回 (m_self.是否为空 ())
.如果结束
.子程序 取ID, 整数型, 公开
返回 (m_id)
.子程序 取父元素, 逻辑型, 公开, accParent
.参数 参数_父元素, 类_Accessible, 参考
.如果 (m_id ≠ 0)
    参数_父元素.创建自对象 (m_parent)
.否则
    参数_父元素.创建自对象 (m_self.读对象型属性 (“accParent”, ))
.如果结束
返回 (取反 (参数_父元素.是否空 ()))
.子程序 取子元素总数, 整数型, 公开, accChildCount
返回 (m_self.读数值属性 (“accChildCount”, ))
.子程序 取子元素, 逻辑型, 公开, accChild
.参数 参数_索引, 整数型, , 索引从1开始
.参数 参数_子元素, 类_Accessible, 参考
.局部变量 obj, 对象
.局部变量 var, 变体型, , "1"
.局部变量 cObtained, 整数型
.局部变量 hr, 整数型
hr ＝ AccessibleChildren (_取对象指针 (m_self), 参数_索引 － 1, 1, var, cObtained)
.如果真 (hr ＝ 0 且 cObtained ＝ 1)
    .如果 (var [1].取类型 () ＝ #变体类型.数值型)
        obj ＝ m_self.读对象型属性 (“accChild”, var [1])
    .否则
        obj ＝ var [1].取对象 ()
    .如果结束
    .如果 (obj.是否为空 ())  ' 如果为空说明子元素是一个简单元素
        参数_子元素.创建自ID (var [1].取数值 (), m_self)
    .否则
        参数_子元素.创建自对象 (obj)
    .如果结束
.如果真结束
返回 (取反 (参数_子元素.是否空 ()))
.子程序 枚举子元素, 整数型, 公开, 从指定节点对象枚举下级全部子元素
.参数 参数_子元素组, 类_Accessible, 参考 数组
.局部变量 obj, 对象
.局部变量 var, 变体型, , "0"
.局部变量 cObtained, 整数型
.局部变量 hr, 整数型
.局部变量 i, 整数型
.局部变量 count, 整数型
count ＝ 取子元素总数 ()
.如果真 (count ＝ 0)
    返回 (0)
.如果真结束
重定义数组 (var, 假, count)
hr ＝ AccessibleChildren (_取对象指针 (m_self), 0, count, var, cObtained)
.如果真 (hr ≠ 0)
    返回 (0)
.如果真结束
重定义数组 (参数_子元素组, 假, count)
.计次循环首 (count, i)
    .如果 (var [i].取类型 () ＝ #变体类型.数值型)
        obj ＝ m_self.读对象型属性 (“accChild”, var [i])
    .否则
        obj ＝ var [i].取对象 ()
    .如果结束
    .如果 (obj.是否为空 ())  ' 如果为空说明子元素是一个简单元素
        参数_子元素组 [i].创建自ID (var [i].取数值 (), m_self)
    .否则
        参数_子元素组 [i].创建自对象 (obj)
    .如果结束
.计次循环尾 ()
返回 (count)
.子程序 取名称, 文本型, 公开, accName
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读文本属性 (“accName”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读文本属性 (“accName”, var))
.如果结束
.子程序 置名称, 逻辑型, 公开, accName
.参数 参数_名称, 文本型
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.写属性 (“accName”, var, 参数_名称))
.否则
    var.赋值 (0, )
    返回 (m_self.写属性 (“accName”, var, 参数_名称))
.如果结束
.子程序 取值, 文本型, 公开, accValue
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读文本属性 (“accValue”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读文本属性 (“accValue”, var))
.如果结束
.子程序 赋值, 逻辑型, 公开, accValue
.参数 参数_值, 文本型
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.写属性 (“accValue”, var, 参数_值))
.否则
    var.赋值 (0, )
    返回 (m_self.写属性 (“accValue”, var, 参数_值))
.如果结束
.子程序 取描述, 文本型, 公开, accDescription
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读文本属性 (“accDescription”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读文本属性 (“accDescription”, var))
.如果结束
.子程序 取角色, 整数型, 公开, accRole 返回 #ROLE_SYSTEM_ 常量之一
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读数值属性 (“accRole”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读数值属性 (“accRole”, var))
.如果结束
.子程序 取角色文本, 文本型, 公开, accRole 
.局部变量 var, 变体型
.局部变量 role, 整数型
.局部变量 lpstr, 文本型
.局部变量 len, 整数型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    role ＝ m_parent.读数值属性 (“accRole”, var)
.否则
    var.赋值 (0, )
    role ＝ m_self.读数值属性 (“accRole”, var)
.如果结束
len ＝ GetRoleText_int (role, 0, 0) ＋ 1
lpstr ＝ 取空白文本 (len)
GetRoleText (role, lpstr, len)
返回 (lpstr)
.子程序 取状态, 整数型, 公开, accState 返回 #STATE_SYSTEM_ 常量组合
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读数值属性 (“accState”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读数值属性 (“accState”, var))
.如果结束
.子程序 取状态文本, 文本型, 公开, GetStateText 
.局部变量 var, 变体型
.局部变量 state, 整数型
.局部变量 i, 整数型
.局部变量 str, 文本型
.局部变量 lpstr, 文本型
.局部变量 len, 整数型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    state ＝ m_parent.读数值属性 (“accState”, var)
.否则
    var.赋值 (0, )
    state ＝ m_self.读数值属性 (“accState”, var)
.如果结束
.如果真 (state ＝ #STATE_SYSTEM_NORMAL)
    len ＝ GetStateText_int (state, 0, 0) ＋ 1
    lpstr ＝ 取空白文本 (len)
    GetStateText (state, lpstr, len)
    返回 (lpstr)
.如果真结束
i ＝ #STATE_SYSTEM_UNAVAILABLE
.循环判断首 ()
    .如果真 (位与 (state, i) ≠ 0)
        len ＝ GetStateText_int (i, 0, 0) ＋ 1
        lpstr ＝ 取空白文本 (len)
        GetStateText (i, lpstr, len)
        str ＝ str ＋ lpstr ＋ “,”
    .如果真结束
    i ＝ 左移 (i, 1)
.循环判断尾 (i ≤ #STATE_SYSTEM_ALERT_HIGH)
返回 (str)
.子程序 取帮助, 文本型, 公开, accHelp
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读文本属性 (“accHelp”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读文本属性 (“accHelp”, var))
.如果结束
.子程序 取帮助主题, 整数型, 公开, accHelpTopic
.局部变量 var, 变体型
.局部变量 HelpFile, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读数值属性 (“accHelpTopic”, HelpFile, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读数值属性 (“accHelpTopic”, HelpFile, var))
.如果结束
.子程序 取快捷键, 文本型, 公开, accKeyboardShortcut
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读文本属性 (“accKeyboardShortcut”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读文本属性 (“accKeyboardShortcut”, var))
.如果结束
.子程序 取默认动作, 文本型, 公开, accDefaultAction
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    返回 (m_parent.读文本属性 (“accDefaultAction”, var))
.否则
    var.赋值 (0, )
    返回 (m_self.读文本属性 (“accDefaultAction”, var))
.如果结束
.子程序 取焦点元素, 逻辑型, 公开, accFocus
.参数 参数_焦点元素, 类_Accessible, 参考
.局部变量 var, 变体型
.如果 (m_id ＝ 0)
    var ＝ m_self.读属性 (“accFocus”, )
    .如果真 (var.取类型 () ＝ #变体类型.空)
        返回 (假)
    .如果真结束
    .如果 (var.取类型 () ＝ #变体类型.数值型)
        参数_焦点元素.创建自ID (var.取数值 (), m_self)
    .否则
        参数_焦点元素.创建自对象 (var.取对象 ())
    .如果结束
.否则
    var ＝ m_parent.读属性 (“accFocus”, )
    .如果真 (var.取类型 () ＝ #变体类型.空)
        返回 (假)
    .如果真结束
    .如果 (var.取类型 () ＝ #变体类型.数值型)
        参数_焦点元素.创建自ID (var.取数值 (), m_parent)
    .否则
        参数_焦点元素.创建自对象 (var.取对象 ())
    .如果结束
.如果结束
返回 (取反 (参数_焦点元素.是否空 ()))
.子程序 取选择元素, 逻辑型, 公开, accSelection
.参数 参数_选择元素, 类_Accessible, 参考
.局部变量 var, 变体型
.如果 (m_id ＝ 0)
    var ＝ m_self.读属性 (“accSelection”, )
    .如果真 (var.取类型 () ＝ #变体类型.空)
        返回 (假)
    .如果真结束
    .如果 (var.取类型 () ＝ #变体类型.数值型)
        参数_选择元素.创建自ID (var.取数值 (), m_self)
    .否则
        参数_选择元素.创建自对象 (var.取对象 ())
    .如果结束
.否则
    var ＝ m_parent.读属性 (“accSelection”, )
    .如果真 (var.取类型 () ＝ #变体类型.空)
        返回 (假)
    .如果真结束
    .如果 (var.取类型 () ＝ #变体类型.数值型)
        参数_选择元素.创建自ID (var.取数值 (), m_parent)
    .否则
        参数_选择元素.创建自对象 (var.取对象 ())
    .如果结束
.如果结束
返回 (取反 (参数_选择元素.是否空 ()))
.子程序 选择元素, , 公开, accSelect
.参数 参数_标志, 整数型, , #SELFLAG_ 常量组合
.参数 参数_被选择元素, 类_Accessible, 可空, 如果为空则表示自身被选择
.局部变量 var, 变体型
.如果 (是否为空 (参数_被选择元素))
    var.赋值 (0, )
.否则
    var ＝ 参数_被选择元素.到变体型 ()
.如果结束
.如果 (m_id ＝ 0)
    m_self.方法 (“accSelect”, 参数_标志, var)
.否则
    m_parent.方法 (“accSelect”, 参数_标志, var)
.如果结束
.子程序 取位置, , 公开, accLocation
.参数 参数_左边, 整数型, 参考
.参数 参数_顶边, 整数型, 参考
.参数 参数_宽度, 整数型, 参考
.参数 参数_高度, 整数型, 参考
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    m_parent.方法 (“accLocation”, 参数_左边, 参数_顶边, 参数_宽度, 参数_高度, var)
.否则
    var.赋值 (0, )
    m_self.方法 (“accLocation”, 参数_左边, 参数_顶边, 参数_宽度, 参数_高度, var)
.如果结束
.子程序 导航, 逻辑型, 公开, accNavigate
.参数 参数_标志, 整数型, , #NAVDIR_ 常量之一
.参数 参数_开始元素, 类_Accessible, 可空
.参数 参数_返回元素, 类_Accessible, 参考
.局部变量 varStart, 变体型
.局部变量 varEnd, 变体型
varStart ＝ 参数_开始元素.到变体型 ()
.如果 (m_id ≠ 0)
    varEnd ＝ m_parent.通用方法 (“accNavigate”, 参数_标志, varStart)
    .如果 (varEnd.取类型 () ＝ #变体类型.数值型)
        参数_返回元素.创建自ID (varEnd.取数值 (), m_parent)
    .否则
        参数_返回元素.创建自对象 (varEnd.取对象 ())
    .如果结束
.否则
    varEnd ＝ m_self.通用方法 (“accNavigate”, 参数_标志, varStart)
    .如果 (varEnd.取类型 () ＝ #变体类型.数值型)
        参数_返回元素.创建自ID (varEnd.取数值 (), m_self)
    .否则
        参数_返回元素.创建自对象 (varEnd.取对象 ())
    .如果结束
.如果结束
返回 (取反 (参数_返回元素.是否空 ()))
.子程序 命中测试, 逻辑型, 公开, accHitTest
.参数 参数_左边, 整数型
.参数 参数_顶边, 整数型
.参数 参数_元素, 类_Accessible, 参考
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var ＝ m_parent.通用方法 (“accHitTest”, 参数_左边, 参数_顶边)
.否则
    var ＝ m_self.通用方法 (“accHitTest”, 参数_左边, 参数_顶边)
.如果结束
.如果真 (var.取类型 () ＝ #变体类型.空)
    返回 (假)
.如果真结束
.如果真 (var.取类型 () ＝ #变体类型.数值型)
    .如果 (var.取数值 () ＝ 0)
        参数_元素.创建自对象 (m_self)
    .否则
        参数_元素.创建自ID (var.取数值 (), m_self)
    .如果结束
    返回 (真)
.如果真结束
.如果真 (var.取类型 () ＝ #变体类型.对象型)
    参数_元素.创建自对象 (var.取对象 ())
    返回 (真)
.如果真结束
返回 (假)
.子程序 执行默认动作, , 公开, accDoDefaultAction
.局部变量 var, 变体型
.如果 (m_id ≠ 0)
    var.赋值 (m_id, )
    m_parent.方法 (“accDoDefaultAction”, var)
.否则
    var.赋值 (0, )
    m_self.方法 (“accDoDefaultAction”, var)
.如果结束
.子程序 取窗口句柄, 整数型, 公开
.局部变量 pobj, 整数型
.局部变量 hwnd, 整数型
.如果 (m_id ≠ 0)
    pobj ＝ _取对象指针 (m_parent)
.否则
    pobj ＝ _取对象指针 (m_self)
.如果结束
WindowFromAccessibleObject (pobj, hwnd)
返回 (hwnd)
.子程序 获取对象, , 公开
.参数 参_对象m_parent, 对象, 参考
.参数 参_对象m_self, 对象, 参考
参_对象m_parent ＝ m_parent
参_对象m_self ＝ m_self
.程序集 集_键盘鼠标
.程序集变量 键盘锁定钩子句柄, 整数型
.程序集变量 鼠标锁定钩子句柄, 整数型
.程序集变量 鼠标锁定状态, 逻辑型
.程序集变量 记忆坐标变量, 精易_坐标
.程序集变量 移入移出事件, 精易_鼠标移入移出事件, , "0"
.程序集变量 是否移入, 逻辑型
.程序集变量 zTmp, 精易_鼠标移入移出事件
.程序集变量 临时句柄, , , , 当前控件的句柄
.程序集变量 nTmp, , , , 当前控件在数组中的存放位置
.程序集变量 集_键盘状态, 逻辑型, , , 真:锁全键盘(可空为假)假:锁定功能键与Win键Esc键F4键Tab键Print键Soroll键Pause键
.程序集变量 集_HOOK, 整数型
.程序集变量 集_监视事件, 子程序指针
.子程序 鼠标_监视_安装, , 公开
.参数 响应监视事件, 子程序指针, , 响应监视事件,3个参数,都为整数型,第1个为键代码（1为左键，2为右键，3为中键，4为滚轮，5为侧键上，6为侧键下）,第2个为按键状态(1为按下，2为放开，4往上滚，5往下滚)，第3个参数为窗口句柄与坐标的指针集合（指针到文本即可取出信息  窗口句柄|X,Y）
.如果真 (集_HOOK ≠ 0)
    返回 ()
.如果真结束
集_监视事件 ＝ 响应监视事件
集_HOOK ＝ SetWindowsHookExA (14, &MousePro, GetModuleHandleA1 (0), 0)  ' 14 WH_MOUSE_LL
.子程序 MousePro, 整数型
.参数 nCode, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 Mouse, MOUSEHOOKSTRUCT
.局部变量 hwnd, 整数型
.局部变量 pid, 整数型
.局部变量 局_键代码, 整数型
.局部变量 局_键状态, 整数型
.局部变量 局_信息, 文本型
.局部变量 局_偏移, 整数型
.如果真 (nCode ≥ 0)  ' #HC_ACTION = 0
    CopyMemory_Mouse (Mouse, lParam, 20)
    .判断开始 (wParam ＝ #WM_MOUSEWHEEL)  ' 鼠标滚动
        .判断开始 (右移 (Mouse.hwnd, 16) ＞ 0)
            局_键代码 ＝ 4
            局_键状态 ＝ 4
            ' 输出调试文本 (“滚轮向上”)
        .判断 (右移 (Mouse.hwnd, 16) ＜ 0)
            局_键代码 ＝ 4
            局_键状态 ＝ 5
            ' 输出调试文本 (“滚轮向下”)
        .默认
        .判断结束
    .判断 (wParam ＝ #WM_LBUTTONDOWN)
        局_键代码 ＝ 1
        局_键状态 ＝ 1
        ' 输出调试文本 (“鼠标左键按下”)
    .判断 (wParam ＝ #WM_LBUTTONUP)
        局_键代码 ＝ 1
        局_键状态 ＝ 2
        ' 输出调试文本 (“鼠标左键放开”)
    .判断 (wParam ＝ #WM_LBUTTONDBLCLK)
        局_键代码 ＝ 1
        局_键状态 ＝ 3
        ' 输出调试文本 (“鼠标左键双击”)
    .判断 (wParam ＝ #WM_RBUTTONDOWN)
        局_键代码 ＝ 2
        局_键状态 ＝ 1
        ' 输出调试文本 (“鼠标右键按下”)
    .判断 (wParam ＝ #WM_RBUTTONUP)
        局_键代码 ＝ 2
        局_键状态 ＝ 2
        ' 输出调试文本 (“鼠标右键放开”)
    .判断 (wParam ＝ #WM_RBUTTONDBLCLK)
        局_键代码 ＝ 2
        局_键状态 ＝ 3
        ' 输出调试文本 (“鼠标右键双击”)
    .判断 (wParam ＝ #WM_MBUTTONDOWN)
        局_键代码 ＝ 3
        局_键状态 ＝ 1
        ' 输出调试文本 (“鼠标中键按下”)
    .判断 (wParam ＝ #WM_MBUTTONUP)
        局_键代码 ＝ 3
        局_键状态 ＝ 2
        ' 输出调试文本 (“鼠标中键放开”)
    .判断 (wParam ＝ #WM_MBUTTONDBLCLK)
        局_键代码 ＝ 3
        局_键状态 ＝ 3
        ' 输出调试文本 (“鼠标中键双击”)
    .判断 (wParam ＝ 523)  ' 鼠标侧键
        局_偏移 ＝ 右移 (Mouse.hwnd, 16)
        .判断开始 (局_偏移 ＝ 2)
            局_键代码 ＝ 5
            局_键状态 ＝ 1
            ' 输出调试文本 (“侧键上被按下”)
        .判断 (局_偏移 ＝ 1)
            局_键代码 ＝ 6
            局_键状态 ＝ 1
            ' 输出调试文本 (“侧键下被按下”)
        .默认
        .判断结束
    .判断 (wParam ＝ 524)  ' 鼠标侧键
        局_偏移 ＝ 右移 (Mouse.hwnd, 16)
        .判断开始 (局_偏移 ＝ 2)
            局_键代码 ＝ 5
            局_键状态 ＝ 2
            ' 输出调试文本 (“侧键上被放开”)
        .判断 (局_偏移 ＝ 1)
            局_键代码 ＝ 6
            局_键状态 ＝ 2
            ' 输出调试文本 (“侧键下被放开”)
        .默认
        .判断结束
    .默认
    .判断结束
    hwnd ＝ WindowFromPoint (Mouse.pt.X, Mouse.pt.Y)
    局_信息 ＝ 到文本 (hwnd) ＋ “|” ＋ 到文本 (Mouse.pt.X) ＋ “,” ＋ 到文本 (Mouse.pt.Y)
    程序_执行整数子程序 (集_监视事件, 局_键代码, 局_键状态, 取指针文本_ (局_信息))
.如果真结束
返回 (CallNextHookEx (集_HOOK, nCode, wParam, lParam))
.子程序 鼠标_监视_卸载, 逻辑型, 公开
.局部变量 局_结果, 逻辑型
局_结果 ＝ UnhookWindowsHookEx (集_HOOK)
.如果真 (局_结果)
    集_HOOK ＝ 0
.如果真结束
返回 (局_结果)
.子程序 鼠标_删除鼠标移入移出事件, 整数型, 公开, 本命令由【不想说话的树】提供
.参数 组件句柄, 整数型
.局部变量 i, 整数型
.局部变量 局返回值
.计次循环首 (取数组成员数 (移入移出事件), i)
    .如果真 (移入移出事件 [i].句柄 ＝ 组件句柄)
        局返回值 ＝ SetWindowLongA (移入移出事件 [i].句柄, -4, 移入移出事件 [i].消息钩子句柄)
        删除成员 (移入移出事件, i, )
        nTmp ＝ 0
        临时句柄 ＝ 0
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (局返回值)
.子程序 鼠标_删除所有鼠标移入移出事件, , 公开
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (移入移出事件), i)
    SetWindowLongA (移入移出事件 [i].句柄, -4, 移入移出事件 [i].消息钩子句柄)
.计次循环尾 ()
清除数组 (移入移出事件)
nTmp ＝ 0
临时句柄 ＝ 0
.子程序 鼠标_添加鼠标移入移出事件, , 公开, 添加鼠标移入移出事件
.参数 句柄, , , 指定控件句柄可以是任何组件
.参数 移入事件, 子程序指针
.参数 移出事件, 子程序指针
zTmp.句柄 ＝ 句柄
zTmp.移入事件 ＝ 移入事件
zTmp.移出事件 ＝ 移出事件
zTmp.消息钩子句柄 ＝ SetWindowLongA (句柄, -4, 到整数 (&消息钩子回调))
加入成员 (移入移出事件, zTmp)
.子程序 消息钩子回调, 整数型
.参数 hWnd
.参数 uMsg
.参数 wParam
.参数 lParam
.局部变量 PrevProchWnd, 整数型
.局部变量 i, 整数型, , , 计次变量
.局部变量 个数
个数 ＝ 取数组成员数 (移入移出事件)
.' 如果真 (个数 ＝ 0)
    ' 返回 (1)
.如果真结束
.如果真 (临时句柄 ≠ hWnd)  ' 确定只程序执行一次,这样可以防止程序多次运行,大大的提高了运行效率。
    临时句柄 ＝ hWnd
    .计次循环首 (个数, i)
        .如果真 (移入移出事件 [i].句柄 ＝ hWnd)
            ' 鼠标移入移出事件 (hWnd, 移入移出事件 [i].移入事件, 移入移出事件 [i].移出事件)
            nTmp ＝ i
            跳出循环 ()
        .如果真结束
    .计次循环尾 ()
.如果真结束
.如果真 (uMsg ＝ 512)
    鼠标移入移出事件 (hWnd, 移入移出事件 [nTmp].移入事件, 移入移出事件 [nTmp].移出事件)
    返回 (1)
.如果真结束
返回 (CallWindowProcA (移入移出事件 [nTmp].消息钩子句柄, hWnd, uMsg, wParam, lParam))
.子程序 鼠标移入移出事件, 整数型, , 移入返回1,移出返回2,移动中返回3
.参数 控件句柄, 整数型
.参数 移入事件, 子程序指针
.参数 移出事件, 子程序指针
处理事件 ()
.如果 (窗口_取鼠标处窗口句柄 () ＝ 控件句柄)
    .如果真 (是否移入 ＝ 假)
        SetCapture (控件句柄)
        执行子程序_ (移入事件)
        是否移入 ＝ 真
        返回 (1)
    .如果真结束
.否则
    执行子程序_ (移出事件)
    ReleaseCapture ()
    是否移入 ＝ 假
    返回 (2)
.如果结束
SetCapture (控件句柄)
返回 (3)
.子程序 执行子程序_, 整数型, , 例子，执行子程序 (&子程序1, 100) 或 执行子程序1 (&子程序1, 1, 2, 3)
.参数 子程序, 子程序指针
.参数 参数一, 整数型, 可空
.参数 参数二, 整数型, 可空
.参数 参数三, 整数型, 可空
.局部变量 bin, 字节集
bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
返回 (CallWindowProcA (取指针_字节集型 (bin), 到整数 (子程序), 参数一, 参数二, 参数三))
.子程序 键鼠_锁定, 整数型, 公开, 阻塞键盘及鼠标事件到达应用程序【beineimao】
.参数 状态, 逻辑型, , 真=锁定
.如果 (状态)  ' 如果想得到更多错误信息，可以 调用GetLastError()函数
    返回 (BlockInput (1))
.否则
    返回 (BlockInput (0))
.如果结束
.子程序 鼠标钩子处理, 整数型, , 锁鼠标
.参数 code, 整数型
.参数 鼠标标识, 整数型
.参数 lp, 整数型
.如果真 (鼠标锁定状态)
    返回 (1)
.如果真结束
.如果真 (鼠标标识 ＝ 513 或 鼠标标识 ＝ 514 或 鼠标标识 ＝ 515)  ' 鼠标左键按下,鼠标左键放开,鼠标左键双击
    返回 (1)
.如果真结束
.如果真 (鼠标标识 ＝ 516 或 鼠标标识 ＝ 517 或 鼠标标识 ＝ 518)  ' 鼠标右键按下,鼠标右键放开,鼠标右键双击
    返回 (1)
.如果真结束
返回 (CallNextHookEx (鼠标锁定钩子句柄, code, 鼠标标识, lp))
.子程序 子程序0, , , ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
.子程序 鼠标_带轨迹移动, , 公开
.参数 参_起始x, 整数型, 可空, 空为鼠标当前坐标
.参数 参_起始y, 整数型, 可空
.参数 参_终点x, 整数型
.参数 参_终点y, 整数型
.参数 参_移动速度, 整数型, 可空
.局部变量 局_判断值, 逻辑型
.局部变量 局_X
.局部变量 局_Y
.如果真 (是否为空 (参_起始x))
    参_起始x ＝ 取鼠标水平位置 ()
.如果真结束
.如果真 (是否为空 (参_起始y))
    参_起始y ＝ 取鼠标垂直位置 ()
.如果真结束
.如果真 (是否为空 (参_移动速度))
    参_移动速度 ＝ 1
.如果真结束
SetCursorPos (参_起始x, 参_起始y)
.判断循环首 (局_判断值 ＝ 假)
    参_起始x ＝ 取鼠标水平位置 ()
    参_起始y ＝ 取鼠标垂直位置 ()
    .判断开始 (参_终点x ＞ 参_起始x)
        局_X ＝ 1
    .判断 (参_终点x ＜ 参_起始x)
        局_X ＝ -1
    .判断 (参_终点x ＝ 参_起始x)
        局_X ＝ 0
    .默认
    .判断结束
    .判断开始 (参_终点y ＞ 参_起始y)
        局_Y ＝ 1
    .判断 (参_终点y ＜ 参_起始y)
        局_Y ＝ -1
    .判断 (参_终点y ＝ 参_起始y)
        局_Y ＝ 0
    .默认
    .判断结束
    鼠标_相对移动 (局_X, 局_Y)
    .如果真 (参_起始x ＝ 参_终点x 且 参_起始y ＝ 参_终点y)
        局_判断值 ＝ 真
        ' 跳出循环 ()
    .如果真结束
    程序_延时 (参_移动速度)
    处理事件 ()
.判断循环尾 ()
.子程序 鼠标_相对移动
.参数 参数_x
.参数 参数_y
.局部变量 x
.局部变量 y
x ＝ 取鼠标水平位置 ()
y ＝ 取鼠标垂直位置 ()
SetCursorPos (x ＋ 参数_x, y ＋ 参数_y)
.子程序 鼠标_捕获, , 公开, 捕获指定窗口的鼠标
.参数 窗口句柄, 整数型
SetCapture (窗口句柄)
.子程序 鼠标_释放, , 公开, 释放被捕获的鼠标
ReleaseCapture ()
.子程序 鼠标_锁定, , 公开, 锁定鼠标键(锁定后,鼠标键无效)
.参数 状态, 逻辑型, 可空, 真:完全锁定鼠标 (可空为假) 假:锁定鼠标左右键
.如果真 (鼠标锁定钩子句柄 ≠ 0)
    UnhookWindowsHookEx (鼠标锁定钩子句柄)
.如果真结束
鼠标锁定状态 ＝ 状态
鼠标锁定钩子句柄 ＝ SetWindowsHookExA (#WH_MOUSE_LL, &鼠标钩子处理, GetModuleHandleA1 (0), 0)  ' 载入鼠标钩子
.子程序 鼠标_解锁, , 公开, 鼠标键解锁(锁定鼠标键锁定后,用来恢复鼠标的使用)
.如果真 (鼠标锁定钩子句柄 ≠ 0)
    UnhookWindowsHookEx (鼠标锁定钩子句柄)
.如果真结束
.子程序 鼠标_限制, , 公开, 限制鼠标的活动范围(无返回值)
.参数 临时左边, 整数型, 可空, 可空，为0
.参数 临时顶边, 整数型, 可空, 可空，为0
.参数 临时宽度, 整数型, 可空, 可空，为屏幕宽度-临时左边
.参数 临时高度, 整数型, 可空, 可空，为屏幕高度-临时顶边
.局部变量 临时范围, 精易_矩形
临时范围.左边 ＝ 临时左边
临时范围.顶边 ＝ 临时顶边
.判断开始 (临时宽度 ＝ 0)
    临时范围.右边 ＝ 取屏幕宽度 () － 临时左边
.默认
    临时范围.右边 ＝ 临时宽度 ＋ 临时左边
.判断结束
.判断开始 (临时高度 ＝ 0)
    临时范围.底边 ＝ 取屏幕高度 () － 临时高度
.默认
    临时范围.底边 ＝ 临时高度 ＋ 临时顶边
.判断结束
ClipCursor (临时范围)
' 输出调试文本 (GetLastError ())
.子程序 鼠标_按键, , 公开, 模拟鼠标按键(无返回值)
.参数 键, 整数型, 可空, 可空:为左键  1 #左键   2 #右键   3 #中键
.参数 控制, 整数型, 可空, 可空:为单击  1 #单击   2 #双击   3 #按下  4 #放开
.如果真 (键 ＝ 1 或 键 ＝ 0)
    .如果真 (控制 ＝ 3)
        mouse_event (2, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 4)
        mouse_event (4, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 1 或 控制 ＝ 0)
        mouse_event (2, 0, 0, 0, 0)
        mouse_event (4, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 2)
        mouse_event (2, 0, 0, 0, 0)
        mouse_event (4, 0, 0, 0, 0)
        程序_延时 (GetDoubleClickTime ())
        mouse_event (2, 0, 0, 0, 0)
        mouse_event (4, 0, 0, 0, 0)
    .如果真结束
.如果真结束
.如果真 (键 ＝ 3)
    .如果真 (控制 ＝ 3)
        mouse_event (32, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 4)
        mouse_event (64, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 1 或 控制 ＝ 0)
        mouse_event (32, 0, 0, 0, 0)
        mouse_event (64, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 2)
        mouse_event (32, 0, 0, 0, 0)
        mouse_event (64, 0, 0, 0, 0)
        程序_延时 (GetDoubleClickTime ())
        mouse_event (32, 0, 0, 0, 0)
        mouse_event (64, 0, 0, 0, 0)
    .如果真结束
.如果真结束
.如果真 (键 ＝ 2)
    .如果真 (控制 ＝ 3)
        mouse_event (8, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 4)
        mouse_event (16, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 1 或 控制 ＝ 0)
        mouse_event (8, 0, 0, 0, 0)
        mouse_event (16, 0, 0, 0, 0)
    .如果真结束
    .如果真 (控制 ＝ 2)
        mouse_event (8, 0, 0, 0, 0)
        mouse_event (16, 0, 0, 0, 0)
        程序_延时 (GetDoubleClickTime ())
        mouse_event (8, 0, 0, 0, 0)
        mouse_event (16, 0, 0, 0, 0)
    .如果真结束
.如果真结束
.子程序 鼠标_消息, , 公开, 向指定窗口发送鼠标动作消息(无返回值)
.参数 窗口句柄, 整数型, 可空, 可空:为桌面超级列表框句柄  接收鼠标消息窗口句柄
.参数 水平坐标, 整数型, 可空, 可空:为原水平坐标不变  移动目标鼠标水平坐标 (注:坐标为参数一窗口句柄中的坐标)
.参数 垂直坐标, 整数型, 可空, 可空:为原垂直坐标不变  移动目标鼠标垂直坐标
.参数 键, 整数型, 可空, 可空:为左键  1 #左键   2 #右键   3 #中键  4 #中键上滚动 5 #中键下滚动(滚动前后请按下放开中键)
.参数 控制, 整数型, 可空, 可空:为单击  1 #单击   2 #双击   3 #按下  4 #放开
.局部变量 坐标值, 整数型
.局部变量 坐标, 精易_坐标
.如果真 (窗口句柄 ＝ 0)
    窗口句柄 ＝ GetDesktopWindow ()
.如果真结束
' 坐标 ＝ 鼠标_取窗口坐标 (窗口句柄)
.如果真 (是否为空 (水平坐标))
    水平坐标 ＝ 2
.如果真结束
.如果真 (是否为空 (垂直坐标))
    垂直坐标 ＝ 2
.如果真结束
坐标值 ＝ 水平坐标 ＋ 垂直坐标 × 65536
.如果真 (键 ＝ 4)  ' 中键上滚动
    投递消息整数 (窗口句柄, 522, 7864336, 坐标值 ＋ 25100873)
    返回 ()
.如果真结束
.如果真 (键 ＝ 5)  ' 中键下滚动
    投递消息整数 (窗口句柄, 522, -7864304, 坐标值 ＋ 25100873)
    返回 ()
.如果真结束
投递消息整数 (窗口句柄, 512, 2, 坐标值)
.如果真 (键 ＝ 0 或 键 ＝ 1)
    .如果真 (控制 ＝ 0 或 控制 ＝ 1)
        投递消息整数 (窗口句柄, 513, 1, 坐标值)  ' 左键按下
        投递消息整数 (窗口句柄, 514, 0, 坐标值)  ' 左键放开
    .如果真结束
    .如果真 (控制 ＝ 2)
        投递消息整数 (窗口句柄, 513, 1, 坐标值)
        投递消息整数 (窗口句柄, 514, 0, 坐标值)
        投递消息整数 (窗口句柄, 515, 0, 坐标值)  ' 双击左键
    .如果真结束
    .如果真 (控制 ＝ 3)
        投递消息整数 (窗口句柄, 513, 1, 坐标值)
    .如果真结束
    .如果真 (控制 ＝ 4)
        投递消息整数 (窗口句柄, 514, 0, 坐标值)
    .如果真结束
    返回 ()
.如果真结束
.如果真 (键 ＝ 2)
    .如果真 (控制 ＝ 0 或 控制 ＝ 1)
        投递消息整数 (窗口句柄, 516, 2, 坐标值)  ' 右键按下
        投递消息整数 (窗口句柄, 517, 2, 坐标值)  ' 右键放开
    .如果真结束
    .如果真 (控制 ＝ 2)
        投递消息整数 (窗口句柄, 516, 2, 坐标值)
        投递消息整数 (窗口句柄, 517, 2, 坐标值)
        投递消息整数 (窗口句柄, 518, 0, 坐标值)  ' 双击右键
    .如果真结束
    .如果真 (控制 ＝ 3)
        投递消息整数 (窗口句柄, 516, 2, 坐标值)
    .如果真结束
    .如果真 (控制 ＝ 4)
        投递消息整数 (窗口句柄, 517, 2, 坐标值)
    .如果真结束
    投递消息整数 (窗口句柄, 123, 132782, 坐标值 ＋ 25100873)  ' 右键放开
    返回 ()
.如果真结束
.如果真 (键 ＝ 3)
    .如果真 (控制 ＝ 0 或 控制 ＝ 1)
        投递消息整数 (窗口句柄, 519, 16, 坐标值)  ' 中键按下
        投递消息整数 (窗口句柄, 520, 0, 坐标值)  ' 中键放开
    .如果真结束
    .如果真 (控制 ＝ 2)
        投递消息整数 (窗口句柄, 519, 16, 坐标值)
        投递消息整数 (窗口句柄, 520, 0, 坐标值)
        投递消息整数 (窗口句柄, 521, 0, 坐标值)  ' 双击中键
    .如果真结束
    .如果真 (控制 ＝ 3)
        投递消息整数 (窗口句柄, 519, 16, 坐标值)
    .如果真结束
    .如果真 (控制 ＝ 4)
        投递消息整数 (窗口句柄, 520, 0, 坐标值)
    .如果真结束
    返回 ()
.如果真结束
' WM_MOUSEFIRST = 512
' WM_MOUSEMOVE = 512
' // 移动鼠标
' WM_LBUTTONDOWN = 513
' //按下鼠标左键
' WM_LBUTTONUP = 514
' //释放鼠标左键
' WM_LBUTTONDBLCLK = 515
' //双击鼠标左键
' WM_RBUTTONDOWN = 516
' //按下鼠标右键
' WM_RBUTTONUP = 517
' //释放鼠标右键
' WM_RBUTTONDBLCLK = 518
' //双击鼠标右键
' WM_MBUTTONDOWN = 519
' //按下鼠标中键
' WM_MBUTTONUP = 520
' //释放鼠标中键
' WM_MBUTTONDBLCLK = 521
' //双击鼠标中键
' WM_MOUSEWHEEL = 522
' 当鼠标轮子转动时发送此消息个当前有焦点的控件
.子程序 鼠标_记位, 精易_坐标, 公开, 记录当前鼠标坐标
.局部变量 坐标, 精易_坐标
记忆坐标变量.横 ＝ 0
记忆坐标变量.纵 ＝ 0
坐标 ＝ 鼠标_取位置 ()
记忆坐标变量.横 ＝ 坐标.横
记忆坐标变量.纵 ＝ 坐标.纵
返回 (记忆坐标变量)
.子程序 鼠标_归位, , 公开, 恢复当前鼠标坐标到"鼠标_记位"的坐标点或移动鼠标到指定点(无返回值)
.参数 坐标, 精易_坐标, 可空, 可空:恢复到上次记录的坐标点
.如果 (是否为空 (坐标))
    鼠标_移动 (, 记忆坐标变量.横, 记忆坐标变量.纵)
.否则
    鼠标_移动 (, 坐标.横, 坐标.纵)
.如果结束
.子程序 鼠标_单击, , 公开, 鼠标操作，具体请看参数的备注
.参数 窗口句柄
.参数 横坐标, 整数型, 可空, 留空则取鼠标所在位置
.参数 纵坐标, 整数型, 可空, 留空则取鼠标所在位置
.参数 类型, 整数型, 可空, 1 = 鼠标左键单击；2 = 鼠标右键单击；3 = 鼠标左键按住不放；
.局部变量 局_坐标, 精易_坐标
.局部变量 局_标志
局_坐标 ＝ 鼠标_取位置 ()
类型 ＝ 选择 (类型 ＝ 0, 1, 类型)
横坐标 ＝ 选择 (是否为空 (横坐标), 局_坐标.横, 横坐标)
纵坐标 ＝ 选择 (是否为空 (纵坐标), 局_坐标.纵, 纵坐标)
.如果真 (类型 ＞ 0 且 类型 ＜ 4)
    局_标志 ＝ 多项选择 (类型, 6, 24, 3)
    鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
    mouse_event (局_标志, 横坐标, 纵坐标, 0, 0)
    鼠标_移动 (, 局_坐标.横, 局_坐标.纵)
.如果真结束
.判断开始断 (类型 ＝ 1)
    ' 鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
    ' mouse_event (6, 横坐标, 纵坐标, 0, 0)
    ' 鼠标_移动 (窗口句柄, 局_坐标.横, 局_坐标.纵)
.' 判断 (类型 ＝ 2)
    ' 鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
    ' mouse_event (24, 横坐标, 纵坐标, 0, 0)
    ' 鼠标_移动 (窗口句柄, 局_坐标.横, 局_坐标.纵)
.' 判断 (类型 ＝ 3)
    ' 鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
    ' mouse_event (2, 横坐标, 纵坐标, 0, 0)
    ' 鼠标_移动 (窗口句柄, 局_坐标.横, 局_坐标.纵)
.默认
.判断结束
' MOUSEEVENTF_MOVE 1 鼠标移动
' MOUSEEVENTF_LEFTDOWN 2 左键按下
' MOUSEEVENTF_LEFTUP 4 左键放开
' MOUSEEVENTF_RIGHTDOWN 8 右键按下
' MOUSEEVENTF_RIGHTUP 16 右键放开
' MOUSEEVENTF_MIDDLEDOWN 32 中键按下
' MOUSEEVENTF_MIDDLEUP 64 中键放开
.子程序 鼠标_移动, , 公开, 设置鼠标坐标
.参数 窗口句柄, 整数型, 可空, 可空:相对桌面移动鼠标  句柄有效则相对窗口中坐标移动
.参数 水平坐标, 整数型, , 水平坐标
.参数 垂直坐标, 整数型, , 垂直坐标
.局部变量 临时坐标, 精易_坐标
.如果真 (窗口句柄 ≠ 0)
    ClientToScreen (窗口句柄, 临时坐标)
.如果真结束
SetCursorPos (临时坐标.横 ＋ 水平坐标, 临时坐标.纵 ＋ 垂直坐标)
.子程序 鼠标_取位置, 精易_坐标, 公开, 取鼠标在屏幕中的坐标位置；
.局部变量 坐标, 精易_坐标
GetCursorPos (坐标)
返回 (坐标)
.子程序 鼠标_显示隐藏, , 公开, 设置鼠标指针的可视性,只能在自身窗口隐藏鼠标
.参数 类型, 逻辑型, , 真 = 隐藏；假 = 显示；
ShowCursor (取反 (类型))
.子程序 鼠标_改指针, , 公开, 只能改自身程序的鼠标指针；
.参数 参_窗口句柄, 整数型, , 要改鼠标的窗口句柄
.参数 参_光标路径, 文本型, 可空, 鼠标文件名路径；支持动态鼠标；
.参数 参_光标指针, 整数型, 可空, #鼠标指针_
.局部变量 L, 整数型
.如果 (是否为空 (参_光标路径) ＝ 假 且 参_光标路径 ≠ “”)
    L ＝ LoadCursorFromFileA (参_光标路径)
.否则
    L ＝ LoadCursorW (0, 参_光标指针)
.如果结束
SetClassLongA (参_窗口句柄, -12, L)
.子程序 鼠标_取窗口坐标, 精易_坐标, 公开, 取回鼠标当前在某个窗口上的坐标
.参数 窗口句柄, 整数型, 可空, 如果提供窗口句柄，将返回鼠标在该窗口上的坐标；否则将取出屏幕中的坐标；
.局部变量 光标位置, 精易_坐标
.局部变量 坐标1, 精易_坐标
.如果真 (窗口句柄 ≠ 0)
    坐标1 ＝ 窗口_取控件坐标 (窗口句柄)
.如果真结束
GetCursorPos (光标位置)
光标位置.横 ＝ 光标位置.横 － 坐标1.横
光标位置.纵 ＝ 光标位置.纵 － 坐标1.纵
返回 (光标位置)
.子程序 鼠标_左右键交换, , 公开, 鼠标左右键交换
.参数 是否交换, 逻辑型, , 真=左右键交换；假=恢复
SwapMouseButton (是否交换)
.子程序 鼠标_取双击间隔时间, 整数型, 公开, 取鼠标双击间隔时间
返回 (GetDoubleClickTime ())
.子程序 子程序2, , , ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
.子程序 键盘_取功能键状态, 整数型, 公开, 取键名的功能键状态，1.Ctrl键，2.Shift键，4.Alt键，其他为组合
.参数 键名, 文本型, , 键名,如填:Ctrl键,将返回1，字母不区分大小写
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 c, 整数型
a ＝ 选择 (寻找文本 (键名, “Ctrl键”, , 真) ＝ -1, 0, 1)
b ＝ 选择 (寻找文本 (键名, “Shift键”, , 真) ＝ -1, 0, 2)
c ＝ 选择 (寻找文本 (键名, “Alt键”, , 真) ＝ -1, 0, 4)
返回 (a ＋ b ＋ c)
.子程序 键盘_取功能键名, 文本型, 公开, 取功能键状态对应的键名，1.Ctrl键，2.Shift键，4.Alt键，其他为组合
.参数 功能键状态, 整数型, , 功能键状态,如填1，将返回Ctrl键
.局部变量 键名, 文本型
.判断开始 (功能键状态 ＝ 1)
    键名 ＝ “Ctrl键”
.判断 (功能键状态 ＝ 2)
    键名 ＝ “Shift键”
.判断 (功能键状态 ＝ 3)
    键名 ＝ “Ctrl键” ＋ “Shift键”
.判断 (功能键状态 ＝ 4)
    键名 ＝ “Alt键”
.判断 (功能键状态 ＝ 5)
    键名 ＝ “Ctrl键” ＋ “Alt键”
.判断 (功能键状态 ＝ 6)
    键名 ＝ “Shift键” ＋ “Alt键”
.判断 (功能键状态 ＝ 7)
    键名 ＝ “Ctrl键” ＋ “Shift键” ＋ “Alt键”
.默认
    键名 ＝ “”
.判断结束
返回 (键名)
.子程序 键盘_模拟输入, , 公开, 利用vbs脚本模拟键盘输入，感谢小磊提供
.参数 字符, 文本型, , 待输入的字符
.局部变量 vbs, 对象
.局部变量 局_字符, 文本型
局_字符 ＝ 字符
局_字符 ＝ 子文本替换 (局_字符, “+”, “{+}”, , , 真)
局_字符 ＝ 子文本替换 (局_字符, “^”, “{^}”, , , 真)
局_字符 ＝ 子文本替换 (局_字符, “%”, “{%}”, , , 真)
局_字符 ＝ 子文本替换 (局_字符, “~”, “{~}”, , , 真)
CoInitialize (0)
vbs.创建 (“wscript.shell”, )
vbs.写属性 (“SendKeys”, 局_字符)
CoUninitialize ()
.子程序 键盘_锁定, , 公开, 锁定所有键盘按键(锁定后,键盘无法操作) 
.参数 状态, 逻辑型, 可空, 可空。真=锁全键盘(可空为假)，假=锁定功能键与Win键Esc键F4键Tab键Print键Soroll键Pause键
.如果真 (键盘锁定钩子句柄 ≠ 0)
    UnhookWindowsHookEx (键盘锁定钩子句柄)
.如果真结束
集_键盘状态 ＝ 状态
键盘锁定钩子句柄 ＝ SetWindowsHookExA (#WH_KEYBOARD_LL, &键盘钩子处理, GetModuleHandleA1 (0), 0)
.子程序 键盘钩子处理, 整数型, , 锁键盘
.参数 icode, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 按键信息, MSG
.如果真 (icode ＝ 0)
    RtlMoveMemory_MSG1 (按键信息, lParam, 28)
    .判断开始 (集_键盘状态 ＝ 假)
        .如果真 (按键信息.hwnd ＝ #Esc键 或 按键信息.hwnd ＝ #Tab键 或 按键信息.hwnd ＝ #F4键)
            返回 (1)
        .如果真结束
        .如果真 (按键信息.hwnd ＝ 44 或 按键信息.hwnd ＝ 145 或 按键信息.hwnd ＝ 19)  ' Print键 Scroll键 Pause键
            返回 (1)
        .如果真结束
        .如果真 (按键信息.hwnd ＝ 91 或 按键信息.hwnd ＝ 92 或 按键信息.hwnd ＝ 93)  ' 左右Win键与菜单键
            返回 (1)
        .如果真结束
        .如果真 (按键信息.hwnd ＝ 160 或 按键信息.hwnd ＝ 161)  ' 左右Shift键
            返回 (1)
        .如果真结束
        .如果真 (按键信息.hwnd ＝ 162 或 按键信息.hwnd ＝ 163)  ' 左右Ctrl键
            返回 (1)
        .如果真结束
        .如果真 (按键信息.hwnd ＝ 164 或 按键信息.hwnd ＝ 165)  ' 左右Alt键
            返回 (1)
        .如果真结束
        返回 (0)
    .默认
        返回 (1)
    .判断结束
.如果真结束
返回 (CallNextHookEx (键盘锁定钩子句柄, icode, wParam, lParam))
.子程序 键盘_解锁, , 公开, 键盘解锁(键盘锁定后,用来恢复键盘的使用)
.如果真 (键盘锁定钩子句柄 ≠ 0)
    UnhookWindowsHookEx (键盘锁定钩子句柄)
.如果真结束
.子程序 键盘_单击, , 公开, 前台模拟键盘操作
.参数 键代码, 整数型, , 键代码；如A是65，就直接输65
.参数 状态, 整数型, 可空, 留空为单击；1按下   2放开
.判断开始 (状态 ＝ 1)
    keybd_event (键代码, 0, 0, 0)
.判断 (状态 ＝ 2)
    keybd_event (键代码, 0, 2, 0)
.默认
    keybd_event (键代码, 0, 0, 0)
    处理事件 ()
    keybd_event (键代码, 0, 2, 0)
.判断结束
.子程序 键盘_消息, , 公开, 向指定窗口句柄的窗口中发送按键消息(无返回值)
.参数 窗口句柄, 整数型, , 接收消息的窗口句柄
.参数 键代码, 整数型, , 按键的键代码
.参数 状态, 整数型, 可空, 可空。默认为1  1=输入字符(大写) 2=输入字符(小写)  3=按下，4=放开，5=单击
.参数 是否功能键, 逻辑型, 可空, 可空。默认为假：普通键   真:功能键 (为功能键可用于热键技能不输入字符)
.局部变量 按下, 整数型
.局部变量 放开, 整数型
.如果 (是否功能键)
    按下 ＝ 260
    放开 ＝ 261
.否则
    按下 ＝ 256
    放开 ＝ 257
.如果结束
.判断开始 (状态 ＝ 1 或 是否为空 (状态))
    PostMessageA (窗口句柄, 258, 键代码, 0)
.判断 (状态 ＝ 2)
    PostMessageA (窗口句柄, 按下, 键代码, 0)
.判断 (状态 ＝ 3)
    PostMessageA (窗口句柄, 按下, 键代码, 0)
.判断 (状态 ＝ 4)
    PostMessageA (窗口句柄, 放开, 键代码, 0)
.判断 (状态 ＝ 5)
    PostMessageA (窗口句柄, 按下, 键代码, 0)
    PostMessageA (窗口句柄, 放开, 键代码, 0)
.默认
.判断结束
.子程序 键盘_组合按键, , 公开, 模拟一个组合按键；如:Ctrl+A
.参数 键代码, 整数型, , 键代码；如：A(65)
.参数 功能键码1, 整数型, , 功能键代码；如：ctrl(1) 或 #ctrl
.参数 功能键码2, 整数型, 可空, 功能键代码(可以留空)
.参数 功能键码3, 整数型, 可空, 功能键代码(可以留空)
.如果真 (功能键码3 ≠ 0)
    keybd_event (功能键码3, 0, 0, 0)
.如果真结束
.如果真 (功能键码2 ≠ 0)
    keybd_event (功能键码2, 0, 0, 0)
.如果真结束
keybd_event (功能键码1, 0, 0, 0)
keybd_event (键代码, 0, 0, 0)
.如果真 (功能键码3 ≠ 0)
    keybd_event (功能键码3, 0, 2, 0)
.如果真结束
.如果真 (功能键码2 ≠ 0)
    keybd_event (功能键码2, 0, 2, 0)
.如果真结束
keybd_event (功能键码1, 0, 2, 0)
keybd_event (键代码, 0, 2, 0)
.子程序 键盘_键名取键代码, 整数型, 公开, 取键名的键代码(返回键代码)
.参数 键名, 文本型, , 键名,如填:A键,将返回65的键代码
.局部变量 按键码, 整数型
.判断开始 (到小写 (键名) ＝ “win键”)
    按键码 ＝ 91
.判断 (到小写 (键名) ＝ “ctrl键”)
    按键码 ＝ #Ctrl键
.判断 (到小写 (键名) ＝ “shift键”)
    按键码 ＝ #Shift键
.判断 (到小写 (键名) ＝ “alt键”)
    按键码 ＝ #Alt键
.判断 (键名 ＝ “0键”)
    按键码 ＝ #键0
.判断 (键名 ＝ “1键”)
    按键码 ＝ #键1
.判断 (键名 ＝ “2键”)
    按键码 ＝ #键2
.判断 (键名 ＝ “3键”)
    按键码 ＝ #键3
.判断 (键名 ＝ “4键”)
    按键码 ＝ #键4
.判断 (键名 ＝ “5键”)
    按键码 ＝ #键5
.判断 (键名 ＝ “6键”)
    按键码 ＝ #键6
.判断 (键名 ＝ “7键”)
    按键码 ＝ #键7
.判断 (键名 ＝ “8键”)
    按键码 ＝ #键8
.判断 (键名 ＝ “9键”)
    按键码 ＝ #键9
.判断 (到大写 (键名) ＝ “A键”)
    按键码 ＝ #A键
.判断 (到大写 (键名) ＝ “B键”)
    按键码 ＝ #B键
.判断 (到大写 (键名) ＝ “C键”)
    按键码 ＝ #C键
.判断 (到大写 (键名) ＝ “D键”)
    按键码 ＝ #D键
.判断 (到大写 (键名) ＝ “E键”)
    按键码 ＝ #E键
.判断 (到大写 (键名) ＝ “F键”)
    按键码 ＝ #F键
.判断 (到大写 (键名) ＝ “G键”)
    按键码 ＝ #G键
.判断 (到大写 (键名) ＝ “H键”)
    按键码 ＝ #H键
.判断 (到大写 (键名) ＝ “I键”)
    按键码 ＝ #I键
.判断 (到大写 (键名) ＝ “J键”)
    按键码 ＝ #J键
.判断 (到大写 (键名) ＝ “K键”)
    按键码 ＝ #K键
.判断 (到大写 (键名) ＝ “L键”)
    按键码 ＝ #L键
.判断 (到大写 (键名) ＝ “M键”)
    按键码 ＝ #M键
.判断 (到大写 (键名) ＝ “N键”)
    按键码 ＝ #N键
.判断 (到大写 (键名) ＝ “O键”)
    按键码 ＝ #O键
.判断 (到大写 (键名) ＝ “P键”)
    按键码 ＝ #P键
.判断 (到大写 (键名) ＝ “Q键”)
    按键码 ＝ #Q键
.判断 (到大写 (键名) ＝ “R键”)
    按键码 ＝ #R键
.判断 (到大写 (键名) ＝ “S键”)
    按键码 ＝ #S键
.判断 (到大写 (键名) ＝ “T键”)
    按键码 ＝ #T键
.判断 (到大写 (键名) ＝ “U键”)
    按键码 ＝ #U键
.判断 (到大写 (键名) ＝ “V键”)
    按键码 ＝ #V键
.判断 (到大写 (键名) ＝ “W键”)
    按键码 ＝ #W键
.判断 (到大写 (键名) ＝ “X键”)
    按键码 ＝ #X键
.判断 (到大写 (键名) ＝ “Y键”)
    按键码 ＝ #Y键
.判断 (到大写 (键名) ＝ “Z键”)
    按键码 ＝ #Z键
.判断 (到大写 (键名) ＝ “F1键”)
    按键码 ＝ #F1键
.判断 (到大写 (键名) ＝ “F2键”)
    按键码 ＝ #F2键
.判断 (到大写 (键名) ＝ “F3键”)
    按键码 ＝ #F3键
.判断 (到大写 (键名) ＝ “F4键”)
    按键码 ＝ #F4键
.判断 (到大写 (键名) ＝ “F5键”)
    按键码 ＝ #F5键
.判断 (到大写 (键名) ＝ “F6键”)
    按键码 ＝ #F6键
.判断 (到大写 (键名) ＝ “F7键”)
    按键码 ＝ #F7键
.判断 (到大写 (键名) ＝ “F8键”)
    按键码 ＝ #F8键
.判断 (到大写 (键名) ＝ “F9键”)
    按键码 ＝ #F9键
.判断 (到大写 (键名) ＝ “F10键”)
    按键码 ＝ #F10键
.判断 (到大写 (键名) ＝ “F11键”)
    按键码 ＝ #F11键
.判断 (到大写 (键名) ＝ “F12键”)
    按键码 ＝ #F12键
.判断 (到大写 (键名) ＝ “F13键”)
    按键码 ＝ #F13键
.判断 (到大写 (键名) ＝ “F14键”)
    按键码 ＝ #F14键
.判断 (到大写 (键名) ＝ “F15键”)
    按键码 ＝ #F15键
.判断 (到大写 (键名) ＝ “F16键”)
    按键码 ＝ #F16键
.判断 (键名 ＝ “break键”)
    按键码 ＝ #Break键
.判断 (键名 ＝ “Tab键”)
    按键码 ＝ #Tab键
.判断 (键名 ＝ “回车键”)
    按键码 ＝ #回车键
.判断 (到小写 (键名) ＝ “pause键”)
    按键码 ＝ #Pause键
.判断 (到小写 (键名) ＝ “capsLock键”)
    按键码 ＝ #CapsLock键
.判断 (到小写 (键名) ＝ “numLock键”)
    按键码 ＝ #NumLock键
.判断 (到小写 (键名) ＝ “scrollLock键”)
    按键码 ＝ #ScrollLock键
.判断 (到小写 (键名) ＝ “esc键”)
    按键码 ＝ #Esc键
.判断 (键名 ＝ “空格键”)
    按键码 ＝ #空格键
.判断 (到小写 (键名) ＝ “pageup键”)
    按键码 ＝ #PageUp键
.判断 (到小写 (键名) ＝ “pagedown键”)
    按键码 ＝ #PageDown键
.判断 (到小写 (键名) ＝ “home键”)
    按键码 ＝ #Home键
.判断 (到小写 (键名) ＝ “end键”)
    按键码 ＝ #End键
.判断 (键名 ＝ “左光标键”)
    按键码 ＝ #左光标键
.判断 (键名 ＝ “上光标键”)
    按键码 ＝ #上光标键
.判断 (键名 ＝ “右光标键”)
    按键码 ＝ #右光标键
.判断 (键名 ＝ “下光标键”)
    按键码 ＝ #下光标键
.判断 (到小写 (键名) ＝ “ins键”)
    按键码 ＝ #Ins键
.判断 (到小写 (键名) ＝ “del键”)
    按键码 ＝ #Del键
.判断 (键名 ＝ “分号键”)
    按键码 ＝ #分号键
.判断 (键名 ＝ “等号键”)
    按键码 ＝ #等号键
.判断 (键名 ＝ “逗号键”)
    按键码 ＝ #逗号键
.判断 (键名 ＝ “减号键”)
    按键码 ＝ #减号键
.判断 (键名 ＝ “圆点键”)
    按键码 ＝ #圆点键
.判断 (键名 ＝ “除号键”)
    按键码 ＝ #除号键
.判断 (键名 ＝ “反撇号键”)
    按键码 ＝ #反撇号键
.判断 (键名 ＝ “左中括号键”)
    按键码 ＝ #左中括号键
.判断 (键名 ＝ “右中括号键”)
    按键码 ＝ #右中括号键
.判断 (键名 ＝ “斜杠键”)
    按键码 ＝ #斜杠键
.判断 (键名 ＝ “单引号键”)
    按键码 ＝ #单引号键
.判断 (键名 ＝ “乘号键”)
    按键码 ＝ 106
.判断 (键名 ＝ “加号键”)
    按键码 ＝ 107
.判断 (键名 ＝ “退格键”)
    按键码 ＝ #退格键
.判断 (键名 ＝ “~”)
    按键码 ＝ 192
.判断 (到小写 (键名) ＝ “左shift键”)
    按键码 ＝ 160
.判断 (到小写 (键名) ＝ “右shift键”)
    按键码 ＝ 161
.判断 (到大写 (键名) ＝ “左CTRL键”)
    按键码 ＝ 162
.判断 (到大写 (键名) ＝ “右CTRL键”)
    按键码 ＝ 163
.默认
.判断结束
返回 (按键码)
.子程序 键盘_键代码取键名, 文本型, 公开, 取键代码的键名(返回键名)
.参数 键代码, 整数型, , 键代码,如填:65,将返回 A键
.局部变量 文本, 文本型
.判断开始 (键代码 ＝ #Ctrl键)
    文本 ＝ “Ctrl键”
.判断 (键代码 ＝ #Shift键)
    文本 ＝ “Shift键”
.判断 (键代码 ＝ #Alt键)
    文本 ＝ “Alt键”
.判断 (键代码 ＝ #键0)
    文本 ＝ “0键”
.判断 (键代码 ＝ #键1)
    文本 ＝ “1键”
.判断 (键代码 ＝ #键2)
    文本 ＝ “2键”
.判断 (键代码 ＝ #键3)
    文本 ＝ “3键”
.判断 (键代码 ＝ #键4)
    文本 ＝ “4键”
.判断 (键代码 ＝ #键5)
    文本 ＝ “5键”
.判断 (键代码 ＝ #键6)
    文本 ＝ “6键”
.判断 (键代码 ＝ #键7)
    文本 ＝ “7键”
.判断 (键代码 ＝ #键8)
    文本 ＝ “8键”
.判断 (键代码 ＝ #键9)
    文本 ＝ “9键”
.判断 (键代码 ＝ #A键)
    文本 ＝ “A键”
.判断 (键代码 ＝ #B键)
    文本 ＝ “B键”
.判断 (键代码 ＝ #C键)
    文本 ＝ “C键”
.判断 (键代码 ＝ #D键)
    文本 ＝ “D键”
.判断 (键代码 ＝ #E键)
    文本 ＝ “E键”
.判断 (键代码 ＝ #F键)
    文本 ＝ “F键”
.判断 (键代码 ＝ #G键)
    文本 ＝ “G键”
.判断 (键代码 ＝ #H键)
    文本 ＝ “H键”
.判断 (键代码 ＝ #I键)
    文本 ＝ “I键”
.判断 (键代码 ＝ #J键)
    文本 ＝ “J键”
.判断 (键代码 ＝ #K键)
    文本 ＝ “K键”
.判断 (键代码 ＝ #L键)
    文本 ＝ “L键”
.判断 (键代码 ＝ #M键)
    文本 ＝ “M键”
.判断 (键代码 ＝ #N键)
    文本 ＝ “N键”
.判断 (键代码 ＝ #O键)
    文本 ＝ “O键”
.判断 (键代码 ＝ #P键)
    文本 ＝ “P键”
.判断 (键代码 ＝ #Q键)
    文本 ＝ “Q键”
.判断 (键代码 ＝ #R键)
    文本 ＝ “R键”
.判断 (键代码 ＝ #S键)
    文本 ＝ “S键”
.判断 (键代码 ＝ #T键)
    文本 ＝ “T键”
.判断 (键代码 ＝ #U键)
    文本 ＝ “U键”
.判断 (键代码 ＝ #V键)
    文本 ＝ “V键”
.判断 (键代码 ＝ #W键)
    文本 ＝ “W键”
.判断 (键代码 ＝ #X键)
    文本 ＝ “X键”
.判断 (键代码 ＝ #Y键)
    文本 ＝ “Y键”
.判断 (键代码 ＝ #Z键)
    文本 ＝ “Z键”
.判断 (键代码 ＝ #F1键)
    文本 ＝ “F1键”
.判断 (键代码 ＝ #F2键)
    文本 ＝ “F2键”
.判断 (键代码 ＝ #F3键)
    文本 ＝ “F3键”
.判断 (键代码 ＝ #F4键)
    文本 ＝ “F4键”
.判断 (键代码 ＝ #F5键)
    文本 ＝ “F5键”
.判断 (键代码 ＝ #F6键)
    文本 ＝ “F6键”
.判断 (键代码 ＝ #F7键)
    文本 ＝ “F7键”
.判断 (键代码 ＝ #F8键)
    文本 ＝ “F8键”
.判断 (键代码 ＝ #F9键)
    文本 ＝ “F9键”
.判断 (键代码 ＝ #F10键)
    文本 ＝ “F10键”
.判断 (键代码 ＝ #F11键)
    文本 ＝ “F11键”
.判断 (键代码 ＝ #F12键)
    文本 ＝ “F12键”
.判断 (键代码 ＝ #F13键)
    文本 ＝ “F13键”
.判断 (键代码 ＝ #F14键)
    文本 ＝ “F14键”
.判断 (键代码 ＝ #F15键)
    文本 ＝ “F15键”
.判断 (键代码 ＝ #F16键)
    文本 ＝ “F16键”
.判断 (键代码 ＝ #Break键)
    文本 ＝ “Break”
.判断 (键代码 ＝ #回车键)
    文本 ＝ “回车键”
.判断 (键代码 ＝ #Pause键)
    文本 ＝ “Pause键”
.判断 (键代码 ＝ #CapsLock键)
    文本 ＝ “Caps Lock键”
.判断 (键代码 ＝ #NumLock键)
    文本 ＝ “NumLock键”
.判断 (键代码 ＝ #ScrollLock键)
    文本 ＝ “ScrollLock键”
.判断 (键代码 ＝ #Esc键)
    文本 ＝ “Esc键”
.判断 (键代码 ＝ #空格键)
    文本 ＝ “空格键”
.判断 (键代码 ＝ #PageUp键)
    文本 ＝ “PageUp键”
.判断 (键代码 ＝ #PageDown键)
    文本 ＝ “PageDown键”
.判断 (键代码 ＝ #Home键)
    文本 ＝ “Home键”
.判断 (键代码 ＝ #End键)
    文本 ＝ “End键”
.判断 (键代码 ＝ #左光标键)
    文本 ＝ “左光标键”
.判断 (键代码 ＝ #上光标键)
    文本 ＝ “上光标键”
.判断 (键代码 ＝ #右光标键)
    文本 ＝ “右光标键”
.判断 (键代码 ＝ #下光标键)
    文本 ＝ “下光标键”
.判断 (键代码 ＝ #Ins键)
    文本 ＝ “Ins键”
.判断 (键代码 ＝ #Del键)
    文本 ＝ “Del键”
.判断 (键代码 ＝ #分号键)
    文本 ＝ “分号键”
.判断 (键代码 ＝ #等号键)
    文本 ＝ “等号键”
.判断 (键代码 ＝ #逗号键)
    文本 ＝ “逗号键”
.判断 (键代码 ＝ #减号键)
    文本 ＝ “减号键”
.判断 (键代码 ＝ #圆点键)
    文本 ＝ “圆点键”
.判断 (键代码 ＝ #除号键)
    文本 ＝ “除号键”
.判断 (键代码 ＝ #反撇号键)
    文本 ＝ “反撇号键”
.判断 (键代码 ＝ #左中括号键)
    文本 ＝ “左中括号键”
.判断 (键代码 ＝ #右中括号键)
    文本 ＝ “右中括号键”
.判断 (键代码 ＝ #斜杠键)
    文本 ＝ “斜杠键”
.判断 (键代码 ＝ #单引号键)
    文本 ＝ “单引号键”
.判断 (键代码 ＝ 106)
    文本 ＝ “乘号键”
.判断 (键代码 ＝ 107)
    文本 ＝ “加号键”
.判断 (键代码 ＝ #退格键)
    文本 ＝ “退格键”
.判断 (键代码 ＝ 91)
    文本 ＝ “Win键”
.判断 (键代码 ＝ #Tab键)
    文本 ＝ “Tab键”
.判断 (键代码 ＝ 192)
    文本 ＝ “~”
.判断 (键代码 ＝ 160)
    文本 ＝ “左shift键”
.判断 (键代码 ＝ 161)
    文本 ＝ “右shift键”
.判断 (键代码 ＝ 162)
    文本 ＝ “左CTRL键”
.判断 (键代码 ＝ 163)
    文本 ＝ “右CTRL键”
.默认
.判断结束
返回 (文本)
.子程序 键盘_键代码取键名1, 文本型, 公开, 成功返回键代码的键名
.参数 键代码, 整数型
.局部变量 lParam, 整数型
.局部变量 String, 文本型
lParam ＝ 左移 (MapVirtualKeyA (键代码, 0), 16)
String ＝ 取空白文本 (256)
GetKeyNameTextA (lParam, String, 256)
返回 (String)
.子程序 键盘_取大小写状态, 逻辑型, 公开, 取当前的输入状态,返回真为大写,返回假则为小写
返回 (GetKeyState (20))
.子程序 键盘_取小键盘状态, 逻辑型, 公开, 取当前的输入状态,返回真为开,返回假则为关
返回 (GetKeyState (144))
.程序集 集_进程通信
.程序集变量 集_oldlong, 整数型
.程序集变量 集_标志文本数组, 文本型, , "0"
.程序集变量 集_消息编号数组, 整数型, , "0"
.程序集变量 集_数据数组, 字节集, , "0"
.程序集变量 集_指针数组, 整数型, , "0"
.程序集变量 集_窗口句柄, 整数型
.子程序 进程通信_接收端_初始化, , 公开, 监听前必需调用此子程序，只需使用一次，停止监听前不能再使用此子程序，否则会出错。
.参数 参数_窗口句柄, 整数型, , 当前窗口句柄，可用 取窗口句柄() 得到。
集_窗口句柄 ＝ 参数_窗口句柄
集_oldlong ＝ SetWindowLongA (参数_窗口句柄, -4, 到整数 (&接收端_读数据))
.子程序 进程通信_接收端_开始监听, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 参数_标志文本, 文本型, , 可以为任意文本(不能为空文本)，但是不要和系统中已有的冲突。设置不同的标志文本，可绑定不同的子程序。
.参数 参数_回调函数, 子程序指针, 可空, 接收到信息后要触发的子程序，不可多个标志文本绑定同个子程序，不需要可不填。
.局部变量 局_计次, 整数型
.如果真 (参数_标志文本 ＝ “”)
    返回 (假)
.如果真结束
.计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)  ' 判断是否有相同的标识文件存在
    .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标志文本)
        返回 (假)
    .如果真结束
.计次循环尾 ()  ' 判断是否有相同的标识文件存在
加入成员 (集_消息编号数组, RegisterWindowMessageA (参数_标志文本))
加入成员 (集_标志文本数组, 参数_标志文本)
.如果真 (集_消息编号数组 [取数组成员数 (集_消息编号数组)] ＝ 0)  ' 如果获取的消息编号为0,将其删除;
    删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
    删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
    返回 (假)
.如果真结束
.计次循环首 (取数组成员数 (集_消息编号数组) － 1, 局_计次)  ' 判断 集_消息编号数组 是否有重复
    .如果真 (集_消息编号数组 [局_计次] ＝ 集_消息编号数组 [取数组成员数 (集_消息编号数组)])
        删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
        删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
        返回 (假)
    .如果真结束
.计次循环尾 ()
.计次循环首 (取数组成员数 (集_指针数组), 局_计次)
    .如果真 (集_指针数组 [局_计次] ＝ 到整数 (参数_回调函数))
        删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
        删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
        返回 (假)
    .如果真结束
.计次循环尾 ()
加入成员 (集_指针数组, 到整数 (参数_回调函数))
加入成员 (集_数据数组, 到字节集 (“”))
返回 (真)
.子程序 进程通信_接收端_关闭监听, , 公开, 关闭某监听，要恢复请直接开始(不用重新初始化)。
.参数 参数_标志文本, 文本型
.局部变量 计次, 整数型
.计次循环首 (取数组成员数 (集_标志文本数组), 计次)
    .如果真 (集_标志文本数组 [计次] ＝ 参数_标志文本)
        删除成员 (集_消息编号数组, 计次, )
        删除成员 (集_标志文本数组, 计次, )
        删除成员 (集_数据数组, 计次, )
        删除成员 (集_指针数组, 计次, )
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
.子程序 进程通信_接收端_停止监听, , 公开, 关闭所有监听，要恢复请重新初始化。
SetWindowLongA (集_窗口句柄, -4, 集_oldlong)
清除数组 (集_标志文本数组)
清除数组 (集_消息编号数组)
清除数组 (集_数据数组)
清除数组 (集_指针数组)
.子程序 进程通信_接收端_取出数据, 字节集, 公开, 回调函数或其它子程序可用此子程序取出接收到的数据。
.参数 参数_标识文本, 文本型, , 接收端监听时设置的文本。
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)
    .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标识文本)
        返回 (集_数据数组 [局_计次])
    .如果真结束
.计次循环尾 ()
返回 ({  })
.子程序 进程通信_接收端_清除数据, , 公开, 清除某监听得到的数据(其它数据不变)，释放该数据所占的内存。
.参数 参数_标志文本, 文本型
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)
    .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标志文本)
        集_数据数组 [局_计次] ＝ {  }
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
.子程序 进程通信_接收端_清空数据, , 公开, 清空所有监听得到的所有数据，释放内存。
重定义数组 (集_数据数组, 假, 取数组成员数 (集_数据数组))
.子程序 进程通信_发送端_发送数据, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 参数_窗口句柄, 整数型, , 接收端的窗口句柄。
.参数 参数_标志文本, 文本型, , 接收端监听时设置的文本。
.参数 参数_欲发送的数据, 字节集, , 要发送的数据。
.局部变量 局_消息文本, 字节集
.局部变量 局_标识文本, 字节集
.局部变量 局_进程ID, 文本型, 静态
.局部变量 局_消息号, 整数型
.局部变量 局_PIDlen, 文本型
局_消息号 ＝ RegisterWindowMessageA (参数_标志文本)
.如果真 (局_进程ID ＝ “” 或 局_进程ID ＝ “0”)
    局_进程ID ＝ 到文本 (GetCurrentProcessId ())
.如果真结束
.如果真 (IsWindow (参数_窗口句柄) ≠ 0)
    局_标识文本 ＝ { 1 }
    局_消息文本 ＝ 到字节集 (到文本 (lstrcpynA_字节集 (局_标识文本, 局_标识文本, 0)) ＋ “$” ＋ 到文本 (取字节集长度 (参数_欲发送的数据)) ＋ “&” ＋ 到文本 (lstrcpynA_字节集 (参数_欲发送的数据, 参数_欲发送的数据, 0)))
    局_PIDlen ＝ 到文本 (取文本长度 (局_进程ID))
    SendMessageA (参数_窗口句柄, 局_消息号, 到整数 (局_PIDlen ＋ 局_进程ID ＋ 到文本 (取字节集长度 (局_消息文本))), lstrcpynA_字节集 (局_消息文本, 局_消息文本, 0))
    .如果真 (局_标识文本 ＝ { 2 })
        返回 (真)
    .如果真结束
    返回 (假)
.如果真结束
返回 (假)
.子程序 接收端_读数据, 整数型
.参数 参数_窗口句柄, 整数型
.参数 参数_消息号, 整数型
.参数 参数_参数1, 整数型
.参数 参数_参数2, 整数型
.局部变量 局_消息文本, 文本型
.局部变量 局_标识地址, 整数型
.局部变量 局_len, 整数型
.局部变量 局_drlen, 整数型
.局部变量 局_hProcess, 整数型
.局部变量 局_lpBuffer, 字节集
.局部变量 局_计次, 整数型
.局部变量 bin, 字节集
.计次循环首 (取数组成员数 (集_消息编号数组), 局_计次)
    .如果真 (集_消息编号数组 [局_计次] ＝ 参数_消息号)
        局_消息文本 ＝ 到文本 (参数_参数1)
        局_len ＝ 到整数 (取文本左边 (局_消息文本, 1))
        局_消息文本 ＝ 取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 1)
        局_hProcess ＝ OpenProcess (2035711, 0, 到整数 (取文本左边 (局_消息文本, 局_len)))
        局_drlen ＝ 到整数 (取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 局_len))
        局_lpBuffer ＝ 取空白字节集 (局_drlen)
        ReadProcessMemory_字节集 (局_hProcess, 参数_参数2, 局_lpBuffer, 局_drlen, 0)
        局_消息文本 ＝ 到文本 (局_lpBuffer)
        局_标识地址 ＝ 到整数 (取文本左边 (局_消息文本, 寻找文本 (局_消息文本, “$”, , 假) － 1))
        WriteProcessMemory_字节集 (局_hProcess, 局_标识地址, { 2 }, 1, 0)
        局_消息文本 ＝ 取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 寻找文本 (局_消息文本, “$”, , 假))
        局_drlen ＝ 到整数 (取文本左边 (局_消息文本, 寻找文本 (局_消息文本, “&”, , 假) － 1))
        局_len ＝ 到整数 (取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 寻找文本 (局_消息文本, “&”, , 假)))
        局_lpBuffer ＝ 取空白字节集 (局_drlen)
        ReadProcessMemory_字节集 (局_hProcess, 局_len, 局_lpBuffer, 局_drlen, 0)
        集_数据数组 [局_计次] ＝ 局_lpBuffer
        CloseHandle (局_hProcess)
        .如果真 (到整数 (集_指针数组 [局_计次]) ≠ 0)
            ' bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
            ' CallWindowProcA (取指针_字节集型 (bin), 集_指针数组 [局_计次], 0, 0, 0)
            CallWindowProcA (取指针_字节集型 ({ 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }), 集_指针数组 [局_计次], 0, 0, 0)
        .如果真结束
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (CallWindowProcA (集_oldlong, 参数_窗口句柄, 参数_消息号, 参数_参数1, 参数_参数2))
.子程序 子程序1, , , '''分割线
.子程序 内存_远程创建内存_文本, 整数型, 公开, 创建成功后返回远程文本内存地址。可用来远程调用
.参数 进程句柄, 整数型
.参数 文本内容, 文本型
返回 (内存_远程创建内存_字节集 (进程句柄, 到字节集 (文本内容) ＋ { 0 }))  ' 0是文本终止符
.子程序 内存_远程创建内存_字节集, 整数型, 公开, 创建成功后返回远程字节集内存地址。可用来远程调用
.参数 进程句柄, 整数型
.参数 字节集内容, 字节集
.局部变量 内存地址, 整数型
内存地址 ＝ VirtualAllocEx (进程句柄, 0, 取字节集长度 (字节集内容), #MEM_COMMIT, #PAGE_EXECUTE_READWRITE)
.如果真 (内存地址 ＝ 0)
    输出调试文本 (“内存申请失败”)
    返回 (0)
.如果真结束
' 写远程内存。
.如果真 (WriteProcessMemory_字节集 (进程句柄, 内存地址, 字节集内容, 取字节集长度 (字节集内容), 0) ＝ 假)
    输出调试文本 (“写内存失败”)
    返回 (0)
.如果真结束
' 释放进程句柄并返回内存地址
返回 (内存地址)
.子程序 内存_远程调用子程序, 逻辑型, 公开, 在远程进程创建一条线程，成功返回真，失败返回假。会导致少数进程崩溃，暂未找到原因   调用实例：https://bbs.125.la/thread-14193109-1-1.html  
.参数 进程句柄, 整数型
.参数 远程子程序地址, 整数型
.参数 参数, 整数型, 可空 数组, 只接受整数型数据，如需传递文本请自行创建远程文本内存，传入内存地址
.参数 是否C调用, 逻辑型, 可空, 默认为APICALL(即_stdcall)，如果本函数为真则使用C调用(_cdcel)
.参数 是否等待远程线程, 逻辑型, 可空, 如果为真，则等待远程线程执行完毕后才会返回。否则创建后立即返回(异步)
.局部变量 远程函数字节集, 字节集
.局部变量 数组成员数, 整数型
.局部变量 j, 整数型
.局部变量 内存地址, 整数型
.局部变量 远程线程句柄, 整数型
.如果真 (远程子程序地址 ＝ 0)
    返回 (假)
.如果真结束
' 首先整理出远程内存call的字节集
' 思路如下, 倒序push参数, 将需要call的地址放入eax, 然后call eax。最后根据调用约定, 决定是否平衡堆栈
' 倒序遍历数组
远程函数字节集 ＝ {  }
数组成员数 ＝ 取数组成员数 (参数)
.如果真 (数组成员数 ＞ 63)
    ' 参数过多。后面有解释原因。虽然我觉得没必要解释什么← ←
    返回 (假)
.如果真结束
.计次循环首 (数组成员数, j)
    .如果 (参数 [数组成员数 － j ＋ 1] ＜ 255)
        ' 小于255(一个字节)的时候可以使用{106,内容}的方法push, 节约内存
        远程函数字节集 ＝ 远程函数字节集 ＋ { 106 } ＋ 到字节集 (到字节 (参数 [数组成员数 － j ＋ 1]))
    .否则
        ' 大于255(一个字节)的时候可以用{104,0,0,0,0}的方法push四字节内容
        远程函数字节集 ＝ 远程函数字节集 ＋ { 104 } ＋ 到字节集 (参数 [数组成员数 － j ＋ 1])
    .如果结束
.计次循环尾 ()
' 然后应当将函数地址传入eax，方法为 {184,0,0,0,0,255,208}(0,0,0,0是远程子程序地址，255，208是call eax的意思)
远程函数字节集 ＝ 远程函数字节集 ＋ { 184 } ＋ 到字节集 (远程子程序地址) ＋ { 255, 208 }
' 判断是否为C调用。如果是C调用, 根据_cdcel调用约定, 应当在call调用完毕后手动平衡堆栈
.如果真 (是否C调用 ＝ 真)
    ' 平衡堆栈说明。使用 add esp,数量 来平衡堆栈。字节集为131,196,0，0是数量，不能超过255(PS:255相当于63个参数....一般人真不会超过255吧QwQ 所以上面加了个判断)
    远程函数字节集 ＝ 远程函数字节集 ＋ { 131, 196 } ＋ 到字节集 (到字节 (数组成员数 × 4))
.如果真结束
' 最后添加返回的字节集机器码 ,ret{195}返回
远程函数字节集 ＝ 远程函数字节集 ＋ { 195 }
' 接下来将字节集写到远程内存
内存地址 ＝ 内存_远程创建内存_字节集 (进程句柄, 远程函数字节集)
.如果真 (内存地址 ＝ 0)
    返回 (假)
.如果真结束
' 创建远程线程
远程线程句柄 ＝ CreateRemoteThread (进程句柄, 0, 0, 内存地址, 0, 0, 0)
.如果真 (远程线程句柄 ＝ 0)
    输出调试文本 (“远程线程创建失败”)
    返回 (假)
.如果真结束
.如果 (是否等待远程线程 ＝ 真)
    WaitForSingleObject (远程线程句柄, -1)
    CloseHandle (远程线程句柄)
    内存_释放远程内存 (进程句柄, 内存地址)
    输出调试文本 (“远程资源已自动释放”)
    返回 (真)
.否则
    ' 创建线程, 在线程等待。最后销毁相关数据
    ' 关于线程参数的一点说明
    ' 为了等待，需要传递三个参数：远程线程句柄，释放内存地址，进程PID
    ' 将通过一个长度为12的字节集来传递数据
    j ＝ VirtualAlloc (0, 12, #MEM_COMMIT, #PAGE_READWRITE)
    ' j是之前循环变量, 已经不需要了, 这里就直接拿来用
    写到内存 (到字节集 (远程线程句柄) ＋ 到字节集 (内存地址) ＋ 到字节集 (进程句柄), j, 12)
    CloseHandle (CreateThread (0, 0, 到整数 (&内部等待线程), j, 0, 0))
    ' 因为并不需要对线程做后续操作，所以直接关闭线程句柄，让线程自行运行完毕自动销毁即可。
.如果结束
返回 (真)
.子程序 内存_释放远程内存, 逻辑型, 公开, 释放在远程创建的内存，可以释放本模块创建的远程文本/字节集内存。
.参数 进程句柄, 整数型
.参数 远程内存地址, 整数型
' 释放内存
.如果真 (VirtualFreeEx (进程句柄, 远程内存地址, 0, #MEM_RELEASE) ＝ 0)
    输出调试文本 (“释放内存失败”)
    返回 (假)
.如果真结束
返回 (真)
.子程序 内部等待线程
.参数 参数地址, 整数型
.局部变量 字节集, 字节集
.局部变量 远程线程句柄, 整数型
.局部变量 内存地址, 整数型
.局部变量 进程PID, 整数型
字节集 ＝ 指针到字节集 (参数地址, 12)
' 释放参数地址内存, 避免内存泄漏
VirtualFree (参数地址, 0, #MEM_RELEASE)
远程线程句柄 ＝ 取字节集数据 (字节集, #整数型, )
内存地址 ＝ 取字节集数据 (字节集, #整数型, 5)
进程PID ＝ 取字节集数据 (字节集, #整数型, 9)
WaitForSingleObject (远程线程句柄, -1)
CloseHandle (远程线程句柄)
内存_释放远程内存 (进程PID, 内存地址)
输出调试文本 (“远程资源已自动释放”)
.程序集 集_信号量
.子程序 信号量_创建, 整数型, 公开, 创建一个信号量。成功返回信号量句柄，失败返回0 。
.参数 初始数值, 整数型, 可空
.参数 最大数值, 整数型, 可空, 如果留空 默认为1
.参数 标识, 文本型, 可空
返回 (CreateSemaphore (0, 初始数值, 选择 (是否为空 (最大数值) ＝ 真, 1, 最大数值), 标识))
.子程序 信号量_打开, 整数型, 公开, 打开一个信号量。成功返回信号量句柄，失败返回0 。
.参数 标识, 文本型, 可空
返回 (OpenSemaphore (2031619, 真, 标识))
.子程序 信号量_销毁, 逻辑型, 公开, 销毁指定信号量。
.参数 句柄, 整数型
.如果真 (句柄 ＝ 0)
    返回 (假)
.如果真结束
返回 (CloseHandle (句柄))
.子程序 信号量_增加, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 句柄, 整数型
.参数 递增数值, 整数型, 可空, 留空为1 要增加的值，这个值必须大于0。
.参数 返回递增前的值, 整数型, 参考 可空, 返回信号量上次的值（被增加前的值）。
.如果真 (句柄 ＝ 0)
    返回 (假)
.如果真结束
.如果真 (是否为空 (递增数值) ＝ 真)
    递增数值 ＝ 1
.如果真结束
返回 (ReleaseSemaphore (句柄, 递增数值, 返回递增前的值))
.子程序 信号量_递减, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 句柄, 整数型
.参数 超时值, 整数型, 可空
.局部变量 ret, 整数型
.如果真 (句柄 ＝ 0)
    返回 (假)
.如果真结束
ret ＝ WaitForSingleObject (句柄, 选择 (是否为空 (超时值) ＝ 真, -1, 超时值))
返回 (ret ＝ 0)
.程序集 类_队列, , 公开, 【先进先出】
.程序集变量 临界资源, 临界许可, , , 临界许可 用来做线程兼容的
.程序集变量 Heap, 整数型, , , 堆句柄
.程序集变量 Ptr, 整数型, , , 内存快句柄
.程序集变量 Ptrlen, 整数型, , , 内存快当前长度
.程序集变量 Tmplen, 整数型, , , 缓冲区大小
.程序集变量 Pushi, 整数型, , , 压入位置
.程序集变量 Popi, 整数型, , , 弹出位置
.程序集变量 Count, 整数型, , , 队列数量
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
InitializeCriticalSection_临界许可 (临界资源)  ' 初始化临界许可 （许可证）
Tmplen ＝ 1048576  ' 1mb‘默认缓冲区大小1MB
Heap ＝ HeapCreate (1, Tmplen, 0)  ' 申请一个堆
Ptr ＝ HeapAlloc (Heap, 8, Tmplen)  ' 申请一个内存快 大小为1M
Ptrlen ＝ Tmplen
Pushi ＝ 0
Popi ＝ 0
Count ＝ 0
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
HeapDestroy (Heap)  ' 销毁堆
Count ＝ 0
Ptr ＝ 0
Heap ＝ 0
DeleteCriticalSection_临界许可 (临界资源)  ' 删除临界资源
.子程序 增量缓冲区, 逻辑型, , 增量缓冲区
.参数 len, 整数型
.局部变量 tmp_len, 整数型
.局部变量 tmp_ptr, 整数型
tmp_len ＝ Ptrlen － Popi  ' 算出有效数据长度
Ptrlen ＝ tmp_len ＋ Tmplen ＋ len  ' 算出移动后的大小 （其实应该先判断下减去演出位置后是否够本次压入 够的话可以直接返回的）
tmp_ptr ＝ HeapAlloc (Heap, 8, Ptrlen)  ' 新申请一块内存 （其实可以 HeapReAlloc ）
.如果真 (tmp_ptr ＝ 0)  ' 申请不到 那只能返回啦
    Ptrlen ＝ tmp_len ＋ Popi  ' 还原内存快长度
    返回 (假)
.如果真结束
RtlMoveMemory (tmp_ptr, Ptr ＋ Popi, tmp_len)  ' 把有效数据移动到新内存快
HeapFree (Heap, 1, Ptr)  ' 销毁旧内存快
Ptr ＝ tmp_ptr  ' 赋值新内存快地址
Pushi ＝ Pushi － Popi  ' 算出移动后的压入位置
Popi ＝ 0
返回 (真)
.子程序 收缩缓冲区, , , 收缩缓冲区
.局部变量 tmp_len, 整数型
.局部变量 tmp_ptr, 整数型
' //收缩和增量原理一样  （其实这里可以优化的很多 下面的写法内存收回并不及时）
tmp_len ＝ Ptrlen － Popi
tmp_ptr ＝ HeapAlloc (Heap, 8, tmp_len)
.如果真 (tmp_ptr ＝ 0)
    返回 ()
.如果真结束
RtlMoveMemory (tmp_ptr, Ptr ＋ Popi, tmp_len)
HeapFree (Heap, 1, Ptr)
Ptr ＝ tmp_ptr
Ptrlen ＝ tmp_len
Pushi ＝ Pushi － Popi
Popi ＝ 0
返回 ()
.子程序 置缓冲区大小, , 公开, 置缓冲区大小 缓冲区大小建议是压入数据长度的倍数。（缓冲区大小不影响队列的容量）
.参数 缓冲区大小, 整数型, 可空, 单位：KB，缓冲区大小 默认1M
.局部变量 temp, 整数型
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果 (缓冲区大小 ＝ 0)
    Tmplen ＝ 1024 × 1024  ' 默认1MB
.否则
    Tmplen ＝ 缓冲区大小 × 1024
.如果结束
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
.子程序 压入字节集, 逻辑型, 公开, 压入字节集 。成功返回真，失败返回假。
.参数 bin, 字节集, , 要压入的数据
.局部变量 len, 整数型
len ＝ 取字节集长度 (bin)
.如果真 (len ＜ 1)
    返回 (假)
.如果真结束
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果真 (Pushi ＋ 4 ＋ len ＞ Ptrlen)  ' 如果 压入位置+本次长度+占位符4 超过了内存快长度
    .如果真 (增量缓冲区 (len ＋ 4) ＝ 假)  ' 执行增量操作
        LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
        返回 (假)
    .如果真结束
.如果真结束
RtlMoveMemory_Eint_int (Ptr ＋ Pushi, len, 4)  ' 写入bin的长度
Pushi ＝ Pushi ＋ 4  ' 压入位置 + 4
RtlMoveMemory_Ebin_int (Ptr ＋ Pushi, bin, len)  ' 写入bin
Pushi ＝ Pushi ＋ len  ' 压入位置 + bin的长度
Count ＝ Count ＋ 1  ' 队列数 + 1
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
返回 (真)
.子程序 弹出字节集, 逻辑型, 公开, 弹出字节集 。成功返回真，失败返回假。
.参数 bin, 字节集, 参考, 用来接收弹出数据的变量
.局部变量 len, 整数型
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果真 (Count ＜ 1)  ' 队列数量少于 1
    LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
    返回 (假)
.如果真结束
.如果真 (Popi ＞ Tmplen)  ' 弹出位置超过缓冲区长度 表示内存快前端有很多空闲内存可以收回
    收缩缓冲区 ()
.如果真结束
len ＝ 0
RtlMoveMemory_整数传址1 (len, Ptr ＋ Popi, 4)  ' 取出本次bin数据的长度信息
Popi ＝ Popi ＋ 4
bin ＝ 取空白字节集 (len)  ' 初始化E的变量用来接收bin
RtlMoveMemory_字节集传址1 (bin, Ptr ＋ Popi, len)  ' 复制bin
Popi ＝ Popi ＋ len  ' 弹出位置后移
Count ＝ Count － 1  ' 队列数量减去 1
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
返回 (真)
.子程序 压入文本, 逻辑型, 公开, 压入文本 。成功返回真，失败返回假。
.参数 str, 文本型, , 要压入的数据
.局部变量 len, 整数型
len ＝ 取文本长度 (str)
.如果真 (len ＜ 1)
    返回 (假)
.如果真结束
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果真 (Pushi ＋ 4 ＋ len ＞ Ptrlen)
    .如果真 (增量缓冲区 (len ＋ 4) ＝ 假)
        LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
        返回 (假)
    .如果真结束
.如果真结束
RtlMoveMemory_Eint_int (Ptr ＋ Pushi, len, 4)
Pushi ＝ Pushi ＋ 4
RtlMoveMemory_Estr_int (Ptr ＋ Pushi, str, len)
Pushi ＝ Pushi ＋ len
Count ＝ Count ＋ 1
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
返回 (真)
.子程序 弹出文本, 逻辑型, 公开, 弹出文本 。成功返回真，失败返回假。
.参数 str, 文本型, 参考, 用来接收弹出数据的变量
.局部变量 len, 整数型
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果真 (Count ＜ 1)
    LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
    返回 (假)
.如果真结束
.如果真 (Popi ＞ Tmplen)
    收缩缓冲区 ()
.如果真结束
len ＝ 0
RtlMoveMemory_整数传址1 (len, Ptr ＋ Popi, 4)
Popi ＝ Popi ＋ 4
str ＝ 取空白文本 (len)
RtlMoveMemory (取指针_文本型 (str), Ptr ＋ Popi, len)
Popi ＝ Popi ＋ len
Count ＝ Count － 1
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
返回 (真)
.子程序 压入整数, 逻辑型, 公开, 压入整数 。成功返回真，失败返回假。
.参数 int, 整数型, , 要压入的数据
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果真 (Pushi ＋ 8 ＞ Ptrlen)
    .如果真 (增量缓冲区 (8) ＝ 假)
        LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
        返回 (假)
    .如果真结束
.如果真结束
RtlMoveMemory_Eint_int (Ptr ＋ Pushi, 4, 4)
Pushi ＝ Pushi ＋ 4
RtlMoveMemory_Eint_int (Ptr ＋ Pushi, int, 4)
Pushi ＝ Pushi ＋ 4
Count ＝ Count ＋ 1
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
返回 (真)
.子程序 弹出整数, 逻辑型, 公开, 弹出整数 。成功返回真，失败返回假。
.参数 int, 整数型, 参考, 用来接收弹出数据的变量
EnterCriticalSection_临界许可 (临界资源)  ' 进入临界
.如果真 (Count ＜ 1)
    LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
    返回 (假)
.如果真结束
.如果真 (Popi ＞ Tmplen)
    收缩缓冲区 ()
.如果真结束
Popi ＝ Popi ＋ 4
RtlMoveMemory_整数传址1 (int, Ptr ＋ Popi, 4)
Popi ＝ Popi ＋ 4
Count ＝ Count － 1
LeaveCriticalSection_临界许可 (临界资源)  ' 退出临界
返回 (真)
.子程序 取数量, 整数型, 公开
返回 (Count)
.程序集 类_线程池, , 公开, 更加灵活的线程池
.程序集变量 成员_线程池IOCP, 整数型
.程序集变量 线程池_状态, 逻辑型
.程序集变量 线程池_处理函数, 整数型
.程序集变量 成员_线程数, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
关闭 (1)
.子程序 启动, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 线程数, 整数型, , 处理客户请求的最大线程池的数目，最小为1。
.参数 处理函数, 子程序指针, , 处理函数，该函数必须有一个整数形的参数。
.参数 超时返回, 整数型, 可空, 单位为：毫秒。默认为0一直等待。
.局部变量 临时_线程内存状态地址, 整数型
.如果真 (线程池_状态)
    返回 (假)
.如果真结束
.如果真 (线程数 ＜ 1)
    线程数 ＝ 1
.如果真结束
临时_线程内存状态地址 ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 16)
' 地址结构依次为：
' 完成端口IOCP句柄
' 线程池状态。 1运行，0停止
' 处理函数。到整数(子程序指针)
' 超时时间
成员_线程池IOCP ＝ CreateIoCompletionPort (-1, 0, 0, 线程数)
线程池_状态 ＝ 真
线程池_处理函数 ＝ 到整数 (处理函数)
RtlMoveMemory_Eint_int (临时_线程内存状态地址, 成员_线程池IOCP, 4)
RtlMoveMemory_Eint_int (临时_线程内存状态地址 ＋ 4, 到整数 (1), 4)
RtlMoveMemory_Eint_int (临时_线程内存状态地址 ＋ 8, 线程池_处理函数, 4)
RtlMoveMemory_Eint_int (临时_线程内存状态地址 ＋ 12, 超时返回, 4)
成员_线程数 ＝ 线程数
.计次循环首 (成员_线程数, )
    CloseHandle (线程_启动 (&内部_线程, 临时_线程内存状态地址))  ' 这几个句柄不再需要了，关闭
.计次循环尾 ()
返回 (真)
.子程序 加入工作, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 任务参数, 整数型
.如果真 (取反 (线程池_状态))
    返回 (假)
.如果真结束
返回 (PostQueuedCompletionStatus (成员_线程池IOCP, 任务参数, 0, 0) ＝ 1)
.子程序 关闭, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 等待时间, 整数型, 可空, 可空。默认为“5000”毫秒。等待线程池销毁的时间，单位毫秒。如果为-1则无限等待。
.参数 执行函数, 整数型, 可空, 可空。成功关闭后，执行此函数。
.参数 传入参数, 整数型, 可空, 可空。第2个参数为空时，此参数无效。
.局部变量 关闭, 逻辑型
.如果真 (取反 (线程池_状态))
    返回 (假)
.如果真结束
线程池_状态 ＝ 假
.计次循环首 (成员_线程数, )
    PostQueuedCompletionStatus (成员_线程池IOCP, 0, -999, 0)  ' 通知所有线程退出
.计次循环尾 ()
.判断开始 (是否为空 (等待时间))
    等待时间 ＝ 5000
.判断 (等待时间 ＝ -1)
    等待时间 ＝ 5000 × 5000
.默认
.判断结束
' 处理事件 ()
' 延时 (等待时间)
程序_延时 (等待时间)
' 处理事件 ()
关闭 ＝ CloseHandle (成员_线程池IOCP)
返回 (关闭)
.子程序 取状态, 逻辑型, 公开, 取一个线程池的状态
返回 (线程池_状态)
.程序集 类_内存配置项, , 公开
.程序集变量 集_配置节, 配置节数据, , "0"
.程序集变量 集_保存文件名, 文本型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
写到文件 ()
清除数组 (集_配置节)
.子程序 写配置项, 逻辑型, 公开, 将配置项写入内存
.参数 节名称, 文本型
.参数 配置项名称, 文本型
.参数 欲写入值, 文本型
.局部变量 项目是否存在, 逻辑型
.局部变量 节名序号, 整数型
.局部变量 临时_配置节, 配置节数据
.局部变量 临时_配置项, 配置项数据
.局部变量 i, 整数型
.局部变量 o, 整数型
.如果真 (节名称 ＝ “” 或 配置项名称 ＝ “”)
    返回 (假)
.如果真结束
欲写入值 ＝ 内部方法_换行符转换行符标识符 (欲写入值)
.计次循环首 (取数组成员数 (集_配置节), i)
    .如果真 (集_配置节 [i].节名称 ＝ 节名称)
        节名序号 ＝ i
        .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
            .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)  ' 如果存在'节名称'且'配置项名称'也存在  ,则直接写入值
                集_配置节 [i].项 [o].值 ＝ 欲写入值
                项目是否存在 ＝ 真
                跳出循环 ()
            .如果真结束
        .计次循环尾 ()
    .如果真结束
.计次循环尾 ()
.如果真 (节名序号 ＝ 0)  ' 无此配置节 添加配置节 赋值配置节的序号
    临时_配置节.节名称 ＝ 节名称
    清除数组 (临时_配置节.项)
    加入成员 (集_配置节, 临时_配置节)
    节名序号 ＝ 取数组成员数 (集_配置节)
.如果真结束
.如果真 (取反 (项目是否存在))  ' 如果不存在就添加 节名称,配置项名称,值
    ' 临时_配置项.节名称 ＝ 节名称
    临时_配置项.配置项名称 ＝ 配置项名称
    临时_配置项.值 ＝ 欲写入值
    加入成员 (集_配置节 [节名序号].项, 临时_配置项)
.如果真结束
返回 (真)
.子程序 读配置项, 文本型, 公开, 返回 节名称->配置项名称->值
.参数 节名称, 文本型
.参数 配置项名称, 文本型
.参数 默认文本, 文本型, 可空, 注明：如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
.局部变量 i, 整数型
.局部变量 o, 整数型
.如果真 (配置项名称 ＝ “” 或 节名称 ＝ “”)
    返回 (默认文本)
.如果真结束
.计次循环首 (取数组成员数 (集_配置节), i)
    .如果真 (集_配置节 [i].节名称 ＝ 节名称)  ' 存在此配置节
        .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
            .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)
                返回 (内部方法_换行符标识符转换行符 (集_配置节 [i].项 [o].值))
            .如果真结束
        .计次循环尾 ()
        返回 (默认文本)  ' 无对应配置项
    .如果真结束
.计次循环尾 ()
返回 (默认文本)  ' 无对应配置节
.子程序 读配置项_整数, 整数型, 公开, 返回 节名称->配置项名称->值
.参数 节名称, 文本型
.参数 配置项名称, 文本型
.参数 默认数值, , 可空, 注明：如果指定配置项不存在，将返回此默认数值。如果指定配置项不存在且本参数被省略，将返回0。
.局部变量 i, 整数型
.局部变量 o, 整数型
.如果真 (配置项名称 ＝ “” 或 节名称 ＝ “”)
    返回 (默认数值)
.如果真结束
.计次循环首 (取数组成员数 (集_配置节), i)
    .如果真 (集_配置节 [i].节名称 ＝ 节名称)  ' 存在此配置节
        .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
            .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)
                返回 (到数值 (内部方法_换行符标识符转换行符 (集_配置节 [i].项 [o].值)))
            .如果真结束
        .计次循环尾 ()
        返回 (默认数值)  ' 无对应配置项
    .如果真结束
.计次循环尾 ()
返回 (默认数值)  ' 无对应配置节
.子程序 删除配置项, 逻辑型, 公开, 返回删除是否i成功
.参数 节名称, 文本型
.参数 配置项名称, 文本型, 可空, 留空则删除'节名称'的所有'配置项'
.局部变量 配置项_长度, 整数型
.局部变量 i, 整数型
.局部变量 o, 整数型
.如果真 (节名称 ＝ “”)
    返回 (假)
.如果真结束
配置项_长度 ＝ 取数组成员数 (集_配置节)
.如果 (是否为空 (配置项名称))
    .变量循环首 (配置项_长度, 1, -1, i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称)  ' 删除节列表名称
            删除成员 (集_配置节, i, 1)
            跳出循环 ()
        .如果真结束
    .变量循环尾 ()
.否则
    .变量循环首 (配置项_长度, 1, -1, i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称)
            .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
                .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)
                    删除成员 (集_配置节 [i].项, o, 1)
                    返回 (真)
                .如果真结束
            .计次循环尾 ()
        .如果真结束
    .变量循环尾 ()
.如果结束
返回 (真)
.子程序 清空, , 公开, 所有数据将丢失
重定义数组 (集_配置节, 假, 0)
.子程序 取所有配置项, 整数型, 公开, 返回'配置项名'的数量
.参数 节名称, 文本型, 可空, 留空取所有的配置项数目
.参数 配置项_参考_数组, 配置项数据, 参考 可空 数组, 留空为不取
.局部变量 配置项_长度, 整数型
.局部变量 k, 整数型
.局部变量 i, 整数型
配置项_长度 ＝ 取数组成员数 (集_配置节)
.如果真 (是否为空 (节名称))
    返回 (配置项_长度)
.如果真结束
.如果 (取反 (是否为空 (配置项_参考_数组)))
    重定义数组 (配置项_参考_数组, 假, 0)
    .计次循环首 (配置项_长度, i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称)
            配置项_参考_数组 ＝ 集_配置节 [i].项
            跳出循环 ()
        .如果真结束
    .计次循环尾 ()
    返回 (取数组成员数 (配置项_参考_数组))
.否则
    .计次循环首 (配置项_长度, i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称)
            k ＝ k ＋ 1
        .如果真结束
    .计次循环尾 ()
    返回 (k)
.如果结束
.子程序 取配置项名, 整数型, 公开, 返回'配置项名'的数量
.参数 节名称, 文本型, , 留空取所有的配置项数目
.参数 配置项名称_参考_数组, 文本型, 参考 数组
.局部变量 k, 整数型
.局部变量 i, 整数型
.如果真 (节名称 ＝ “”)
    返回 (0)
.如果真结束
重定义数组 (配置项名称_参考_数组, 假, 0)
.计次循环首 (取数组成员数 (集_配置节), i)
    .如果真 (集_配置节 [i].节名称 ＝ 节名称)
        .计次循环首 (取数组成员数 (集_配置节 [i].项), k)
            加入成员 (配置项名称_参考_数组, 集_配置节 [i].项 [k].配置项名称)
        .计次循环尾 ()
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (取数组成员数 (配置项名称_参考_数组))
.子程序 取配置节名, 整数型, 公开, 返回'节名称'的数量
.参数 节名称_参考_数组, 文本型, 参考 可空 数组, 接收节名称数组
.局部变量 i, 整数型
.局部变量 局_配置节数, 整数型
局_配置节数 ＝ 取数组成员数 (集_配置节)
.如果真 (取反 (是否为空 (节名称_参考_数组)))
    清除数组 (节名称_参考_数组)
    .计次循环首 (局_配置节数, i)
        加入成员 (节名称_参考_数组, 集_配置节 [i].节名称)
    .计次循环尾 ()
.如果真结束
返回 (局_配置节数)
.子程序 加载配置项_从文件, 逻辑型, 公开, 将一配置文件内容加载到内存配置中，但不管内存配置项如何变动不会对该配置文件进行任何修改。
.参数 配置文件名路径, 文本型, , 例 c:\config.ini
.参数 自动保存, 逻辑型, 可空, 类销毁时,是否自动保存配置到文件(配置文件名)
.局部变量 执行结果, 逻辑型
.局部变量 局_配置数据, 字节集
集_保存文件名 ＝ 选择 (自动保存, 配置文件名路径, “”)
.如果真 (文件是否存在 (配置文件名路径))
    局_配置数据 ＝ 读入文件 (配置文件名路径)
    执行结果 ＝ 内部方法_加载配置项 (局_配置数据)
.如果真结束
返回 (执行结果)
.子程序 内部方法_加载配置项, 逻辑型
.参数 文本数据, 字节集
.局部变量 局部_文本, 文本型
.局部变量 当前节名, 文本型
.局部变量 位置, 整数型
.局部变量 数组_长度
.局部变量 局_字集数组, 字节集, , "0"
.局部变量 i, 整数型
局_字集数组 ＝ 分割字节集 (文本数据, { 13, 10 }, )
数组_长度 ＝ 取数组成员数 (局_字集数组)
.如果真 (数组_长度 ＞ 0)
    重定义数组 (集_配置节, 假, 0)
    .计次循环首 (数组_长度, i)
        局部_文本 ＝ 删首尾空 (到文本 (局_字集数组 [i]))
        .如果真 (局部_文本 ≠ “”)
            .如果 (局部_文本 ≈ “[”)
                当前节名 ＝ 取文本中间 (局部_文本, 2, 取文本长度 (局部_文本) － 2)
            .否则
                位置 ＝ 寻找文本 (局部_文本, “=”, 0, 假)
                .如果真 (位置 ≠ -1)
                    写配置项 (当前节名, 删首尾空 (取文本左边 (局部_文本, 位置 － 1)), 取文本右边 (局部_文本, 取文本长度 (局部_文本) － 位置))
                .如果真结束
            .如果结束
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    返回 (真)
.如果真结束
返回 (假)
.子程序 内部方法_换行符转换行符标识符, 文本型
.参数 待转文本, 文本型
返回 (子文本替换 (待转文本, #换行符, “{\r\n}”, , , 真))  ' 处理换行符
.子程序 内部方法_换行符标识符转换行符, 文本型
.参数 待转文本, 文本型
返回 (子文本替换 (待转文本, “{\r\n}”, #换行符, , , 真))  ' 处理换行符
.子程序 加载配置项_从内存, 逻辑型, 公开, 将一符合配置文件格式的内存数据加载到内存配置中。
.参数 文本数据, 字节集
返回 (内部方法_加载配置项 (文本数据))
.子程序 取配置数据, 字节集, 公开, 配置项的文件信息,用于下次加载
.局部变量 配置项名数组, 文本型, , "0"
.局部变量 节名称数组, 文本型, , "0"
.局部变量 i, 整数型
.局部变量 j, 整数型
.局部变量 文件号, 整数型
.局部变量 文件数据, 字节集
文件号 ＝ 打开内存文件 ()
.计次循环首 (取数组成员数 (集_配置节), i)
    写出文本 (文件号, “[”, 集_配置节 [i].节名称, “]”, #换行符)
    .计次循环首 (取数组成员数 (集_配置节 [i].项), j)
        写出文本 (文件号, 集_配置节 [i].项 [j].配置项名称, “=”, 内部方法_换行符转换行符标识符 (集_配置节 [i].项 [j].值), #换行符)
    .计次循环尾 ()
.计次循环尾 ()
移到文件首 (文件号)
文件数据 ＝ 读入字节集 (文件号, 取文件长度 (文件号))
关闭文件 (文件号)
返回 (文件数据)
.子程序 写到文件, 逻辑型, 公开, 将当前内存配置内容写出到文件
.参数 配置文件名, 文本型, 可空, 例： c:\config.ini,留空,则使用加载配置项_从文件()时提供的 '配置文件名路径'
.如果真 (是否为空 (配置文件名))
    配置文件名 ＝ 集_保存文件名
.如果真结束
.如果真 (配置文件名 ＝ “”)
    返回 (假)
.如果真结束
返回 (写到文件 (配置文件名, 取配置数据 ()))
.程序集 类_配置项, , 公开, 本类由萧阳天编写；MSDN资料:http://msdn.microsoft.com/en-us/library/windows/desktop/ms724875(v=vs.85).aspx
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 写入节, 逻辑型, 公开
.参数 配置文件, 文本型
.参数 节名称, 文本型
.参数 写入内容, 字节集
返回 (WritePrivateProfileSection (节名称, 写入内容, 配置文件))
.子程序 读取节, 字节集, 公开
.参数 配置文件, 文本型
.参数 节名称, 文本型
.局部变量 sbuffer, 字节集
.局部变量 Length
sbuffer ＝ 取空白字节集 (32767)  ' The maximum profile section size is 32,767 characters.
Length ＝ GetPrivateProfileSection (节名称, sbuffer, 32767, 配置文件)
返回 (取字节集左边 (sbuffer, Length))
.子程序 枚举节, 整数型, 公开, 返回配置文件中所有已有节名的数量。
.参数 配置文件, 文本型
.参数 节数组, 文本型, 数组, 变量储存返回值。
.局部变量 Length
.局部变量 sbuffer, 字节集
.局部变量 Array, 字节集, , "0"
.局部变量 cnt, 整数型
清除数组 (节数组)
sbuffer ＝ 取空白字节集 (32767)  ' The maximum profile section size is 32,767 characters.
Length ＝ GetPrivateProfileSectionNames (sbuffer, 32767, 配置文件)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
Array ＝ 分割字节集 (sbuffer, { 0 }, )
.计次循环首 (取数组成员数 (Array), cnt)
    加入成员 (节数组, 到文本 (Array [cnt]))
.计次循环尾 ()
返回 (取数组成员数 (Array))
.子程序 取节数, 整数型, 公开
.参数 配置文件, 文本型
.局部变量 Length
.局部变量 sbuffer, 字节集
.局部变量 Array, 字节集, , "0"
sbuffer ＝ 取空白字节集 (32767)  ' The maximum profile section size is 32,767 characters.
Length ＝ GetPrivateProfileSectionNames (sbuffer, 32767, 配置文件)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
Array ＝ 分割字节集 (sbuffer, { 0 }, )
返回 (取数组成员数 (Array))
.子程序 删除节, 逻辑型, 公开, 注意，此命令将会删除指定节上所有项目，一但删除将无法挽回。成功返回真，失败返回假。
.参数 配置文件, 文本型
.参数 节名称, 文本型
返回 (WritePrivateProfileString (节名称, 字符 (0), 字符 (0), 配置文件))
.子程序 读项文本, 文本型, 公开, 读取指定配置文件中指定项目的文本内容。本命令为初级命令。
.参数 配置文件名, 文本型, , 指定配置文件的名称，通常以.ini作为文件名后缀。
.参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
.参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
.参数 默认文本, 文本型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
.局部变量 sbuffer, 文本型
.局部变量 Length
sbuffer ＝ 取空白文本 (32767)
Length ＝ GetPrivateProfileString (节名称, 配置项名称, 默认文本, sbuffer, 32767, 配置文件名)
返回 (取文本左边 (sbuffer, Length))
.子程序 写项文本, 逻辑型, 公开, 将指定文本内容写入指定配置项中或者删除指定的配置项或节，如果指定配置文件不存在，将会自动创建。成功返回真，失败返回假。本命令为初级命令。
.参数 配置文件名, 文本型, , 指定配置文件的名称，通常以.ini作为文件名后缀。
.参数 节名称, 文本型, , 包含欲写入配置项所处节的名称。
.参数 配置项名称, 文本型, 可空, 可以被省略。参数值指定欲写入配置项在其节中的名称。如果参数值被省略，则删除指定节及其下的所有配置项。
.参数 欲写入值, 文本型, 可空, 可以被省略。参数值指定欲写入到指定配置项中的文本。如果参数值被省略，则删除所指定配置项。
返回 (WritePrivateProfileString (节名称, 配置项名称, 欲写入值, 配置文件名))
.子程序 删除项, 逻辑型, 公开, 注意，此命令将会删除指定节上指定配置项，一但删除将无法挽回。成功返回真，失败返回假。
.参数 配置文件, 文本型
.参数 节名称, 文本型
.参数 配置项名称, 文本型
返回 (WritePrivateProfileString (节名称, 配置项名称, 字符 (0), 配置文件))
.子程序 枚举项, 整数型, 公开
.参数 配置文件, 文本型
.参数 节名称, 文本型
.参数 名称, 文本型, 数组, 变量储存返回值。
.参数 值, 文本型, 数组
.局部变量 sbuffer, 字节集
.局部变量 Length
.局部变量 Array, 字节集, , "0"
.局部变量 i, 整数型
.局部变量 Text, 文本型
.局部变量 Number
清除数组 (名称)
清除数组 (值)
sbuffer ＝ 取空白字节集 (32767)  ' The maximum profile section size is 32,767 characters.
Length ＝ GetPrivateProfileSection (节名称, sbuffer, 32767, 配置文件)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
Array ＝ 分割字节集 (sbuffer, { 0 }, )
.计次循环首 (取数组成员数 (Array), i)
    Text ＝ 到文本 (Array [i])
    Number ＝ 寻找文本 (Text, “=”, , 假)
    加入成员 (名称, 取文本左边 (Text, Number － 1))
    加入成员 (值, 取文本右边 (Text, 取文本长度 (Text) － Number))
.计次循环尾 ()
返回 (取数组成员数 (Array))
.子程序 取项数, 整数型, 公开
.参数 配置文件, 文本型
.参数 节名称, 文本型
.局部变量 sbuffer, 字节集
.局部变量 Length
.局部变量 Array, 字节集, , "0"
.局部变量 i, 整数型
.局部变量 Text, 文本型
.局部变量 Number
sbuffer ＝ 取空白字节集 (32767)  ' The maximum profile section size is 32,767 characters.
Length ＝ GetPrivateProfileSection (节名称, sbuffer, 32767, 配置文件)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
Array ＝ 分割字节集 (sbuffer, { 0 }, )
返回 (取数组成员数 (Array))
.子程序 读项数值, 整数型, 公开, 读取指定配置文件中指定项目的文本内容。本命令为初级命令。
.参数 配置文件名, 文本型, , 指定配置文件的名称，通常以.ini作为文件名后缀。
.参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
.参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
.参数 默认数值, 整数型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
返回 (GetPrivateProfileInt (到字节集 (节名称), 配置项名称, 默认数值, 配置文件名))
.子程序 写项结构, 逻辑型, 公开, 把指定数据结构以字节集方式存入配置项，成功返回真，失败返回假。
.参数 配置文件名, 文本型
.参数 节名称, 文本型
.参数 配置项名称, 文本型
.参数 数据结构, 字节集
返回 (WritePrivateProfileStruct (配置项名称, 节名称, 数据结构, 取字节集长度 (数据结构), 配置文件名))
.子程序 读项结构, 字节集, 公开, 取回｛写项结构()｝写入的结构数据，失败返回Null。
.参数 配置文件名, 文本型
.参数 节名称, 文本型
.参数 配置项名称, 文本型
.参数 数据结构大小
.局部变量 sbuffer, 字节集
sbuffer ＝ 取空白字节集 (数据结构大小)
GetPrivateProfileStruct (配置项名称, 节名称, sbuffer, 数据结构大小, 配置文件名)
返回 (sbuffer)
.子程序 系统配置项注册表目录, , , HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\IniFileMapping\win.ini
.子程序 写系统节, 逻辑型, 公开, 注意：设置系统配置项可能造成系统不稳定，请谨慎。向系统Win.ini中写入配置项，成功返回真，失败返回假。
.参数 节名称, 文本型
.参数 内容, 字节集
返回 (WriteProfileSection (节名称, 内容))
.子程序 读系统节, 字节集, 公开
.参数 节名称, 文本型
.局部变量 sbuffer, 字节集
.局部变量 Length
sbuffer ＝ 取空白字节集 (32768)
Length ＝ GetProfileSection (节名称, sbuffer, 32767)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
返回 (sbuffer)
.子程序 枚举系统项, 整数型, 公开, 枚举系统win.ini中的配置项及值，失败返回Null。
.参数 节名称, 文本型
.参数 项名称, 文本型, 数组, 变量储存返回值。
.参数 值, 文本型, 可空 数组, 变量储存返回值。
.局部变量 sbuffer, 字节集
.局部变量 Length
.局部变量 Array, 字节集, , "0"
.局部变量 cnt, 整数型
.局部变量 Text, 文本型
.局部变量 Number, 整数型
清除数组 (项名称)
清除数组 (值)
sbuffer ＝ 取空白字节集 (32768)
Length ＝ GetProfileSection (节名称, sbuffer, 32767)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
Array ＝ 分割字节集 (sbuffer, { 0 }, )
.计次循环首 (取数组成员数 (Array), cnt)
    Text ＝ 到文本 (Array [cnt])
    Number ＝ 寻找文本 (Text, “=”, , 假)
    加入成员 (项名称, 取文本左边 (Text, Number － 1))
    加入成员 (值, 取文本右边 (Text, 取文本长度 (Text) － Number))
.计次循环尾 ()
返回 (取数组成员数 (Array))
.子程序 取系统项数, 整数型, 公开
.参数 节名称, 文本型
.局部变量 sbuffer, 字节集
.局部变量 Length
.局部变量 Array, 字节集, , "0"
.局部变量 cnt, 整数型
.局部变量 Text, 文本型
.局部变量 Number, 整数型
sbuffer ＝ 取空白字节集 (32768)
Length ＝ GetProfileSection (节名称, sbuffer, 32767)
sbuffer ＝ 取字节集左边 (sbuffer, Length)
Array ＝ 分割字节集 (sbuffer, { 0 }, )
返回 (取数组成员数 (Array))
.子程序 读系统项文本, 文本型, 公开, 从系统Win.ini中读取指定配置项文本，失败失败Null。本命令为初级命令。
.参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
.参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
.参数 默认文本, 文本型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
.局部变量 sbuffer, 文本型
.局部变量 Length
sbuffer ＝ 取空白文本 (256)
Length ＝ GetProfileString (节名称, 配置项名称, 默认文本, sbuffer, 256)
返回 (取文本左边 (sbuffer, Length))
.子程序 写系统项文本, 逻辑型, 公开, 注意：设置系统配置项可能造成系统不稳定，请谨慎。向系统Win.ini配置项中写入文本值，成功返回真，失败返回假。
.参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
.参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
.参数 欲写入值, 文本型
返回 (WriteProfileString (节名称, 配置项名称, 欲写入值))
.子程序 读系统项数值, 整数型, 公开, 从系统Win.ini中读取指定配置项数值，失败失败Null。本命令为初级命令。
.参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
.参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
.参数 默认数值, 整数型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
返回 (GetProfileInt (节名称, 配置项名称, 默认数值))  ' 对应注册表；HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\IniFileMapping\win.ini
.程序集 类_配置项ex, , 公开, 本类由【果子】编写，简约读写配置项
.程序集变量 集_配置文件路径, 文本型
.程序集变量 集_加密密码, 文本型
.程序集变量 集_默认节名称, 文本型
.程序集变量 集_节名前缀, 文本型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
集_默认节名称 ＝ “System”
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 初始化, , 公开, 可重复初始化，重复初始化将直接覆盖前面的参数值
.参数 配置文件路径, 文本型, 可空, 可空，默认为“程序根目录\Data\Config.ini”
.参数 加密密码, 文本型, 可空, 可空，为空=不加密
.参数 节名前缀, 文本型, 可空, 可空
.局部变量 dir, 文本型
.判断开始 (是否为空 (配置文件路径) 或 删首尾空 (配置文件路径) ＝ “”)
    目录_创建 (取运行目录 () ＋ “\Data”)
    集_配置文件路径 ＝ 取运行目录 () ＋ “\Data\Config.ini”
.默认
    集_配置文件路径 ＝ 配置文件路径
    dir ＝ 目录_取父路径 (配置文件路径)
    .如果真 (目录_是否存在 (dir) ＝ 假)
        目录_创建 (dir)
    .如果真结束
.判断结束
集_加密密码 ＝ 删首尾空 (加密密码)
集_节名前缀 ＝ 节名前缀
.子程序 写, 逻辑型, 公开
.参数 节名称, 文本型, 可空, 可空，默认为System，包含欲写入配置项所处节的名称。
.参数 配置项名称, 文本型, 可空, 可以被省略。参数值指定欲写入配置项在其节中的名称。如果参数值被省略，则删除指定节及其下的所有配置项。
.参数 欲写入值, 文本型, 可空, 可以被省略。参数值指定欲写入到指定配置项中的文本。如果参数值被省略，则删除所指定配置项。
.参数 加密, 逻辑型, 可空, 用系统自动的密码进行加密。
.局部变量 局_文本, 文本型
.如果真 (是否为空 (节名称) 或 删首尾空 (节名称) ＝ “”)
    节名称 ＝ 集_默认节名称
.如果真结束
.判断开始 (是否为空 (配置项名称) 或 删首尾空 (配置项名称) ＝ “”)
    返回 (写配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, , ))
.判断 (是否为空 (欲写入值))
    返回 (写配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, 配置项名称, ))
.默认
.判断结束
.如果真 (删首尾空 (配置项名称) ＝ “”)
    输出调试文本 (“配置项类：写失败，原因：【配置项名称】为空”)
    返回 (假)
.如果真结束
局_文本 ＝ 删首尾空 (子文本替换 (欲写入值, #换行符, “{#换行符}”, , , 真))
.判断开始 (集_加密密码 ≠ “” 且 加密)
    局_文本 ＝ 文本_加密 (局_文本, 集_加密密码)
.判断 (加密)
    局_文本 ＝ 文本_解密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
.判断 (配置项名称 ＝ “User” 或 配置项名称 ＝ “Pass”)  ' 如果是用户名，自动加密
    局_文本 ＝ 文本_加密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
.默认
.判断结束
返回 (写配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, 配置项名称, 局_文本))
.子程序 读, 文本型, 公开
.参数 节名称, 文本型, 可空, 可空，默认为System，包含欲写入配置项所处节的名称。
.参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
.参数 默认文本, 文本型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
.参数 解密, 逻辑型, 可空, 如果你在写的时候加密了，这里同样也要解决，用系统自动的密码进行解密。
.局部变量 局_文本, 文本型
.局部变量 局_默认文本, 文本型
.局部变量 局_对比结果, 逻辑型
.如果真 (是否为空 (节名称) 或 删首尾空 (节名称) ＝ “”)
    节名称 ＝ 集_默认节名称
.如果真结束
.如果真 (删首尾空 (配置项名称) ＝ “”)
    输出调试文本 (“配置项类：读失败，原因：【配置项名称】为空”)
    返回 (“”)
.如果真结束
局_默认文本 ＝ 取重复文本 (10, 字符 (1))
局_文本 ＝ 读配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, 配置项名称, 局_默认文本)
局_对比结果 ＝ 局_文本 ＝ 局_默认文本
.如果真 (局_对比结果)
    局_文本 ＝ 默认文本
.如果真结束
局_文本 ＝ 子文本替换 (局_文本, “{#换行符}”, #换行符, , , 真)
局_文本 ＝ 子文本替换 (局_文本, “><br><”, #换行符, , , 真)
.判断开始 (集_加密密码 ≠ “” 且 局_对比结果 ＝ 假)
    局_文本 ＝ 文本_解密 (局_文本, 集_加密密码)
.判断 (解密)
    局_文本 ＝ 文本_解密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
.判断 (配置项名称 ＝ “User” 或 配置项名称 ＝ “Pass”)  ' 如果是用户名，自动加密
    局_文本 ＝ 文本_解密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
.默认
.判断结束
返回 (局_文本)
.子程序 置_默认节名称, , 公开, 默认节名称，当节名称留空时，以此节名称为主
.参数 默认节名称, 文本型, , 当节名称留空时，以此节名称为主
集_默认节名称 ＝ 删全部空 (默认节名称)
.子程序 置_节名前缀, , 公开
.参数 节名前缀, 文本型
集_节名前缀 ＝ 节名前缀
.子程序 批量保存, 逻辑型, 公开, 【编辑框，选择框，单选框，组合框】保存指定窗口上指定组件的内容，与"批量读取()"命令一起用的。【特别注意：组件的[标识]将作为保存配置的项名称，标识为空将不保存】
.参数 父窗口, 窗口, , 直接填写顶级窗口就行了，如:_启动窗口。
.参数 组件类型, 文本型, , 如：“编辑框、组合框、单选框”等等，多个组件请使用半角逗号分隔开。
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_编辑框, 编辑框
.局部变量 局_单选框, 单选框
.局部变量 局_选择框, 选择框
.局部变量 局_组合框, 组合框
.局部变量 局_选择夹, 选择夹
.局部变量 局_文本, 文本型
.局部变量 局_组件数量, 整数型
.局部变量 局_配置项名称, 文本型
.局部变量 Arr, 文本型, , "0"
.如果真 (是否已创建 (父窗口) ＝ 假)
    输出调试文本 (“配置项，批量保存失败，原因：参数【父窗口】为载入！”)
    返回 (假)
.如果真结束
.如果真 (删首尾空 (组件类型) ＝ “”)
    输出调试文本 (“配置项，批量保存失败，原因：参数【组件类型】为空！”)
    返回 (假)
.如果真结束
.判断开始 (寻找文本 (组件类型, “,”, , 假) ≠ -1)
    Arr ＝ 分割文本 (组件类型, “,”, )
    .计次循环首 (取数组成员数 (Arr), 局_计次)
        批量保存 (父窗口, Arr [局_计次])
    .计次循环尾 ()
.默认
    局_寻找句柄 ＝ 寻找组件 (父窗口, , 组件类型, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        .判断开始 (组件类型 ＝ “选择框”)
            局_选择框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_选择框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_选择框.选中))
        .判断 (组件类型 ＝ “单选框”)
            局_单选框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_单选框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_单选框.选中))
        .判断 (组件类型 ＝ “组合框”)
            局_组合框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_组合框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_组合框.现行选中项))
            .如果真 (局_组合框.现行选中项 ＝ -1 且 局_组合框.内容 ≠ “”)
                写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称 ＋ “-内容”, 局_组合框.内容, )
            .如果真结束
        .判断 (组件类型 ＝ “编辑框”)
            局_编辑框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_编辑框.标记)
            局_文本 ＝ 子文本替换 (局_编辑框.内容, #换行符, “><br><”, , , 真)
            局_文本 ＝ 子文本替换 (局_文本, #引号, “%22”, , , 真)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 局_文本, )
        .判断 (组件类型 ＝ “选择夹”)
            局_选择夹 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_选择夹.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_选择夹.现行子夹), )
        .默认
        .判断结束
    .计次循环尾 ()
.判断结束
返回 (真)
.子程序 批量读取, 逻辑型, 公开, 读取指定窗口上指定组件的配置内容，与"批量保存()"命令一起用的。【特别注意：组件的[标识]将作为读取配置的项名称，标识为空将不读取】
.参数 父窗口, 窗口, , 直接填写顶级窗口就行了，如:_启动窗口。
.参数 组件类型, 文本型, , 如：“编辑框、组合框、单选框”等等，多个组件请使用半角逗号分隔开。
.参数 例外组件, 文本型, 可空, 请输入不需要读取的组件标识名，如：User,Pass  多个请使用半角逗号分隔开
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_编辑框, 编辑框
.局部变量 局_单选框, 单选框
.局部变量 局_选择框, 选择框
.局部变量 局_组合框, 组合框
.局部变量 局_选择夹, 选择夹
.局部变量 局_组件数量, 整数型
.局部变量 局_文本, 文本型
.局部变量 局_配置项名称, 文本型
.局部变量 Arr, 文本型, , "0"
.如果真 (是否已创建 (父窗口) ＝ 假)
    输出调试文本 (“配置项，批量保存失败，原因：参数【父窗口】为载入！”)
    返回 (假)
.如果真结束
.如果真 (删首尾空 (组件类型) ＝ “”)
    输出调试文本 (“配置项，批量保存失败，原因：参数【组件类型】为空！”)
    返回 (假)
.如果真结束
.如果真 (删首尾空 (例外组件) ≠ “” 且 取文本右边 (例外组件, 1) ≠ “,”)
    例外组件 ＝ 例外组件 ＋ “,”
.如果真结束
.判断开始 (寻找文本 (组件类型, “,”, , 假) ≠ -1)
    Arr ＝ 分割文本 (组件类型, “,”, )
    .计次循环首 (取数组成员数 (Arr), 局_计次)
        批量读取 (父窗口, Arr [局_计次], 例外组件)
    .计次循环尾 ()
.默认
    局_寻找句柄 ＝ 寻找组件 (父窗口, , 组件类型, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        .判断开始 (组件类型 ＝ “选择框”)
            局_选择框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_选择框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            .如果真 (例外组件 ≠ “”)
                .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                    到循环尾 ()
                .如果真结束
            .如果真结束
            局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
            .如果真 (局_文本 ＝ “”)
                到循环尾 ()
            .如果真结束
            局_选择框.选中 ＝ 局_文本 ＝ “真”
        .判断 (组件类型 ＝ “单选框”)
            局_单选框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_单选框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            .如果真 (例外组件 ≠ “”)
                .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                    到循环尾 ()
                .如果真结束
            .如果真结束
            局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
            .如果真 (局_文本 ＝ “”)
                到循环尾 ()
            .如果真结束
            局_单选框.选中 ＝ 局_文本 ＝ “真”
        .判断 (组件类型 ＝ “组合框”)
            局_组合框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_组合框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            .如果真 (例外组件 ≠ “”)
                .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                    到循环尾 ()
                .如果真结束
            .如果真结束
            局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
            .如果真 (局_文本 ＝ “”)
                到循环尾 ()
            .如果真结束
            .如果 (局_文本 ＝ “-1”)
                局_组合框.内容 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称 ＋ “-内容”, “”, )
            .否则
                局_组合框.现行选中项 ＝ 到数值 (局_文本)
            .如果结束
        .判断 (组件类型 ＝ “编辑框”)
            局_编辑框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_编辑框.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            .如果真 (例外组件 ≠ “”)
                .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                    到循环尾 ()
                .如果真结束
            .如果真结束
            局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
            .如果真 (局_文本 ＝ “”)
                到循环尾 ()
            .如果真结束
            局_文本 ＝ 子文本替换 (局_文本, “%22”, #引号, , , 真)
            局_编辑框.内容 ＝ 子文本替换 (局_文本, “><br><”, #换行符, , , 真)
        .判断 (组件类型 ＝ “选择夹”)
            局_选择夹 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
            局_配置项名称 ＝ 删首尾空 (局_选择夹.标记)
            .如果真 (局_配置项名称 ＝ “”)
                到循环尾 ()
            .如果真结束
            .如果真 (例外组件 ≠ “”)
                .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                    到循环尾 ()
                .如果真结束
            .如果真结束
            局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
            .如果真 (局_文本 ＝ “”)
                到循环尾 ()
            .如果真结束
            局_选择夹.现行子夹 ＝ 到数值 (局_文本)
        .默认
        .判断结束
    .计次循环尾 ()
.判断结束
返回 (真)
.子程序 窗口位置_保存, , 公开
.参数 窗口, 窗口
.参数 是否保存窗口大小, 逻辑型, 可空, 可空，默认为假，不保存
.局部变量 节点名, 文本型
.如果真 (是否为调试版 ())
    输出调试文本 (“调试环境不会保存【窗口位置】”)
    返回 ()
.如果真结束
节点名 ＝ 取执行文件名 ()
写 (节点名, “WinTop”, 到文本 (窗口.顶边), )
写 (节点名, “WinLeft”, 到文本 (窗口.左边), )
.如果真 (是否保存窗口大小)
    写 (节点名, “WinWidth”, 到文本 (窗口.宽度), )
    写 (节点名, “WinHeight”, 到文本 (窗口.高度), )
.如果真结束
写 (节点名, “Maximization”, 到文本 (窗口.位置), )
.子程序 窗口位置_读取, , 公开
.参数 窗口, 窗口
.参数 是否读取窗口大小, 逻辑型, 可空, 可空，默认为假，不保存
.局部变量 精易_矩形, 精易_矩形
.局部变量 节点名, 文本型
节点名 ＝ 取执行文件名 ()
.如果真 (读 (节点名, “Maximization”, “0”, ) ＝ “3”)  ' 最大化
    窗口.位置 ＝ 3
    返回 ()
.如果真结束
精易_矩形.顶边 ＝ 到数值 (读 (节点名, “WinTop”, “-1”, ))
精易_矩形.左边 ＝ 到数值 (读 (节点名, “WinLeft”, “-1”, ))
.判断开始 (是否读取窗口大小)
    精易_矩形.右边 ＝ 到数值 (读 (节点名, “WinWidth”, “-1”, ))
    精易_矩形.底边 ＝ 到数值 (读 (节点名, “WinHeight”, “-1”, ))
.默认
    精易_矩形.右边 ＝ -1
    精易_矩形.底边 ＝ -1
.判断结束
.判断开始 (精易_矩形.左边 ＜ 0)
    精易_矩形.左边 ＝ 0
.判断 (精易_矩形.左边 ＞ 取屏幕宽度 () － 300)
    精易_矩形.左边 ＝ 取屏幕宽度 () ÷ 2
.默认
.判断结束
.判断开始 (精易_矩形.顶边 ＜ 0)
    精易_矩形.顶边 ＝ 0
.判断 (精易_矩形.顶边 ＞ 取屏幕高度 () － 300)
    精易_矩形.顶边 ＝ 取屏幕高度 () ÷ 2
.默认
.判断结束
.如果真 (精易_矩形.顶边 ≠ -1)
    .判断开始 (精易_矩形.右边 ＝ -1)
        窗口.移动 (精易_矩形.左边, 精易_矩形.顶边, , )
    .默认
        窗口.移动 (精易_矩形.左边, 精易_矩形.顶边, 精易_矩形.右边, 精易_矩形.底边)
    .判断结束
.如果真结束
.程序集 类_日志输出, , 公开
.程序集变量 集_目录, 文本型
.程序集变量 集_日志名, 文本型
.程序集变量 集_控制台句柄, 整数型
.程序集变量 集_日志文件句柄, 整数型
.子程序 _初始化
集_目录 ＝ 取运行目录 () ＋ “\Log\” ＋ 时间_格式化 (取现行时间 (), “yyyyMM\”)
集_日志名 ＝ 时间_格式化 (取现行时间 (), “yyyy-MM-dd”) ＋ “.txt”
.子程序 _销毁
.如果真 (集_控制台句柄 ＞ 0)
    FreeConsole ()
    集_控制台句柄 ＝ 0
.如果真结束
.如果真 (集_日志文件句柄 ＞ 0)
    关闭文件 (集_日志文件句柄)
    集_日志文件句柄 ＝ 0
.如果真结束
.子程序 文件路径, 文本型, 公开, 获取与设置日志输出文件目录，请在【输出文件】日志前设置目录。
.参数 参_目录, 文本型, 可空, 默认会在程序运行目录下生成(Log+年月)格式的目录
.参数 参_文件名, 文本型, 可空
.如果真 (集_日志文件句柄 ＞ 0)
    关闭文件 (集_日志文件句柄)
    集_日志文件句柄 ＝ 0
.如果真结束
.如果真 (取文本长度 (参_目录) ＞ 0)
    集_目录 ＝ 参_目录
    集_目录 ＝ 选择 (取文本右边 (集_目录, 1) ≠ “\”, 集_目录 ＋ “\”, 集_目录)
.如果真结束
.如果真 (取文本长度 (参_文件名) ＞ 0)
    集_日志名 ＝ 参_文件名
    集_日志名 ＝ 选择 (到小写 (取文本右边 (集_日志名, 4)) ≠ “.txt”, 集_日志名 ＋ “.txt”, 集_日志名)
.如果真结束
返回 (集_目录 ＋ 集_日志名)
.子程序 输出文件, 逻辑型, 公开, 输出内容到文件到
.参数 参_内容, 文本型
.参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
.参数 参_信息框, 逻辑型, 可空, 默认不提示
.局部变量 局_文件句柄, 整数型
.局部变量 局_提示图标, 整数型
.局部变量 局_返回值, 逻辑型
.如果真 (参_级别 ＜ 0 或 参_级别 ＞ 3)
    参_级别 ＝ 0
.如果真结束
.如果真 (目录_是否存在 (集_目录) ＝ 假)
    目录_创建 (集_目录)
.如果真结束
.判断开始 (参_级别 ＝ 1)
    局_提示图标 ＝ #警告图标
.判断 (参_级别 ＝ 2)
    局_提示图标 ＝ #错误图标
.判断 (参_级别 ＝ 3)
    局_提示图标 ＝ #信息图标
.默认
    局_提示图标 ＝ #信息图标
.判断结束
.如果真 (参_信息框)
    信息框 (参_内容, 局_提示图标, “日志输出”)
.如果真结束
.如果真 (集_日志文件句柄 ＝ 0)
    集_日志文件句柄 ＝ 打开文件 (文件路径 (), 5, 1)
    移到文件尾 (集_日志文件句柄)
.如果真结束
' 局_文件句柄 ＝ 打开文件 (文件路径 (), 6, 1)
局_返回值 ＝ 写出文本 (集_日志文件句柄, 取格式文本 (参_内容, 参_级别))
返回 (局_返回值)
.子程序 输出控制台, 逻辑型, 公开, 输入日志内容到控制台
.参数 参_内容, 文本型
.参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
.参数 参_标题, 文本型, 可空, 控制台标题，默认 程序日志
.参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
.局部变量 局_控制台属性, 整数型
.局部变量 局_日志, 文本型
.局部变量 匿名局部变量_逻辑型_63103, 逻辑型
.如果 (AllocConsole ())
    集_控制台句柄 ＝ GetStdHandle (#STD_OUTPUT_HANDLE)
    SetConsoleTitleA (选择 (取文本长度 (参_标题) ＞ 0, 参_标题, “程序日志”))
.否则
    集_控制台句柄 ＝ GetStdHandle (#STD_OUTPUT_HANDLE)
.如果结束
.如果真 (集_控制台句柄 ≠ 0)
    .如果真 (参_写到文件)
        输出文件 (参_内容, 参_级别)
    .如果真结束
    .判断开始 (参_级别 ＝ 1)
        局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_INTENSITY
    .判断 (参_级别 ＝ 2)
        局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_GREEN ＋ #FOREGROUND_INTENSITY
    .判断 (参_级别 ＝ 3)
        局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_GREEN ＋ #FOREGROUND_BLUE ＋ #FOREGROUND_INTENSITY
    .默认
        局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_GREEN ＋ #FOREGROUND_BLUE
    .判断结束
    局_日志 ＝ 取格式文本 (参_内容, 参_级别)
    SetConsoleTextAttribute (集_控制台句柄, 局_控制台属性)
    返回 (WriteConsoleA (集_控制台句柄, 局_日志, 取文本长度 (局_日志), 0, 0))
.如果真结束
返回 (假)
.子程序 输出易调试, , 公开, 只在调试模式下有效
.参数 参_内容, 文本型
.参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
.参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
.局部变量 局_日志, 文本型
局_日志 ＝ 取格式文本 (参_内容, 参_级别)
.如果真 (参_写到文件)
    输出文件 (参_内容, 参_级别)
.如果真结束
输出调试文本 (局_日志)
.子程序 输出调试器, , 公开, 输出到 调试器，编译模式下有效，可用DbgView 查看
.参数 参_内容, 文本型
.参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
.参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
.局部变量 局_日志, 文本型
局_日志 ＝ 取格式文本 (参_内容, 参_级别)
.如果真 (参_写到文件)
    输出文件 (参_内容, 参_级别)
.如果真结束
OutputDebugStringA (局_日志)
.子程序 输出编辑框, , 公开, 输出日志内容到编辑框
.参数 参_编辑框句柄, 整数型
.参数 参_内容, 文本型
.参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
.参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
.局部变量 局_日志, 文本型
局_日志 ＝ 取格式文本 (参_内容, 参_级别)
.如果真 (参_写到文件)
    输出文件 (参_内容, 参_级别)
.如果真结束
.如果真 (IsWindow (参_编辑框句柄) ＝ 1)
    SendMessageA (参_编辑框句柄, #EM_REPLACESEL, 0, 取指针文本_ (局_日志))
.如果真结束
.子程序 取格式文本, 文本型
.参数 参_日志内容, 文本型
.参数 参_日志级别, 整数型, 可空
.局部变量 局_系统时间, 精易_时间
.局部变量 局_格式, 文本型
.局部变量 局_日期, 文本型
.局部变量 局_时间, 文本型
.局部变量 局_日志级别, 文本型
.判断开始 (参_日志级别 ＝ 1)
    局_日志级别 ＝ “警告”
.判断 (参_日志级别 ＝ 2)
    局_日志级别 ＝ “错误”
.判断 (参_日志级别 ＝ 3)
    局_日志级别 ＝ “调试”
.默认
    局_日志级别 ＝ “信息”
.判断结束
GetLocalTime (局_系统时间)
局_日期 ＝ 取空白文本 (50)
GetDateFormatA (0, 0, 局_系统时间, “yyyy-MM-dd ”, 局_日期, 50)
局_时间 ＝ 取空白文本 (50)
GetTimeFormatA (0, #TIME_FORCE24HOURFORMAT, 局_系统时间, “hh:mm:ss.”, 局_时间, 50)
局_格式 ＝ 局_日期 ＋ 局_时间 ＋ 文本_自动补零 (到文本 (局_系统时间.毫), 3) ＋ “ ” ＋ 局_日志级别 ＋ “:” ＋ 参_日志内容 ＋ #换行符
返回 (局_格式)
.程序集 集_图片
.程序集变量 集_转换错误, 文本型
.子程序 图片_平铺拉伸, 字节集, 公开, 按指定宽高  平铺/拉伸  成功返回图片字节集  失败返回空字节集
.参数 参_原图片, 字节集
.参数 参_设定宽度, 整数型, 可空, 默认：1920
.参数 参_设定高度, 整数型, 可空, 默认：1080
.参数 参_处理类型, 整数型, 可空, 可空，默认0=平铺  1=拉伸
.局部变量 底位图, 类_位图操作
.局部变量 层位图, 类_位图操作
.局部变量 局_原宽度, 整数型
.局部变量 局_原高度, 整数型
.局部变量 局_相差宽度, 整数型
.局部变量 局_相差高度, 整数型
.局部变量 局_原图, 字节集
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 局_左边, 整数型
.局部变量 局_剩余宽度, 整数型
.局部变量 局_剩余高度, 整数型
.局部变量 局_顶边, 整数型
.局部变量 局_循环_横向, 整数型
.局部变量 局_循环_纵向, 整数型
.局部变量 局_新图片, 字节集
.局部变量 i, 整数型
.如果真 (图片_转换 (参_原图片, 1, , 局_原图, ) ＝ 假)
    输出调试文本 (“转换图片失败”)
    返回 ({  })
.如果真结束
.如果真 (参_设定宽度 ＝ 0)
    参_设定宽度 ＝ 1920
.如果真结束
.如果真 (参_设定高度 ＝ 0)
    参_设定高度 ＝ 1080
.如果真结束
.如果真 (层位图.从数据创建 (局_原图) ＝ 假)
    输出调试文本 (“创建创建层位图失败”)
    返回 ({  })
.如果真结束
局_原宽度 ＝ 层位图.取宽度 ()
局_原高度 ＝ 层位图.取高度 ()
.如果真 (参_处理类型 ＝ 0)
    .如果真 (参_设定宽度 ≤ 局_原宽度 或 参_设定高度 ≤ 局_原高度)
        输出调试文本 (“平铺模式下，设定的宽高需要大于原图片的宽高”)
        返回 ({  })
    .如果真结束
.如果真结束
.如果真 (底位图.创建空白位图 (参_设定宽度, 参_设定高度, 24) ＝ 假)
    输出调试文本 (“创建空白底位图失败”)
    返回 ({  })
.如果真结束
.判断开始 (参_处理类型 ＝ 0)
    局_相差宽度 ＝ 参_设定宽度 － 局_原宽度
    局_相差高度 ＝ 参_设定高度 － 局_原高度
    局_剩余宽度 ＝ 参_设定宽度 ％ 局_原宽度
    局_循环_横向 ＝ (参_设定宽度 － 局_剩余宽度) ÷ 局_原宽度
    局_剩余高度 ＝ 参_设定高度 ％ 局_原高度
    局_循环_纵向 ＝ (参_设定高度 － 局_剩余高度) ÷ 局_原高度
    局_左边 ＝ －局_原宽度
    .计次循环首 (局_循环_横向, a)
        局_左边 ＝ 局_左边 ＋ 局_原宽度
        层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_原高度, 局_左边, 0)  ' 横向平铺一张
        局_顶边 ＝ －局_原高度
        .计次循环首 (局_循环_纵向, a)
            局_顶边 ＝ 局_顶边 ＋ 局_原高度
            层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_原高度, 局_左边, 局_顶边)  ' 纵向平铺一张
            系统_处理事件 ()
        .计次循环尾 ()
        .如果真 (局_剩余高度 ≠ 0)
            层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_剩余高度, 局_左边, 局_顶边 ＋ 局_原高度)  ' 纵向剩余高度 再平铺一张
        .如果真结束
        系统_处理事件 ()
    .计次循环尾 ()
    .如果真 (局_剩余宽度 ≠ 0)
        局_顶边 ＝ －局_原高度
        .计次循环首 (局_循环_纵向, i)
            局_顶边 ＝ 局_顶边 ＋ 局_原高度
            层位图.复制到 (底位图, 0, 0, 局_剩余宽度, 局_原高度, 局_左边 ＋ 局_原宽度, 局_顶边)  ' 补全剩余宽度的纵向一列
            系统_处理事件 ()
        .计次循环尾 ()
        .如果真 (局_剩余高度 ≠ 0)
            层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_剩余高度, 局_左边 ＋ 局_原宽度, 局_顶边 ＋ 局_原高度)  ' 纵向剩余高度 再平铺一张
        .如果真结束
    .如果真结束
    局_新图片 ＝ 底位图.取出位图数据 ()
.默认
    局_新图片 ＝ 图片_缩放 (局_原图, 参_设定宽度, 参_设定高度, 真)
.判断结束
返回 (局_新图片)
.子程序 图片_到24位图, 字节集, 公开, 把非24位BMP、JPG、GIF的图片转化为24位图
.参数 参_原图片, 字节集
.参数 参_执行结果, 逻辑型, 参考 可空, 可以被省略，提供参数数据时只能提供变量。如果提供本参数，其中将被写入本命令的执行结果——执行成功时为真，执行失败时为假。
.局部变量 局_图片对象, 对象
.局部变量 局_图片, 字节集
' 例程收录自：https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=13978978&pid=10764012
.如果真 (取字节集左边 (参_原图片, 2) ≠ { 66, 77 } 或 取字节集数据 (参_原图片, #短整数型, 29) ≠ 24)
    .如果真 (局_图片对象.创建图片对象 (参_原图片))
        局_图片 ＝ 局_图片对象.取回图片 ()
        局_图片对象.清除 ()
        参_执行结果 ＝ 真
        返回 (局_图片)
    .如果真结束
.如果真结束
参_执行结果 ＝ 假
返回 (参_原图片)
.子程序 图片_分割, 逻辑型, 公开
.参数 参_原图片, 字节集
.参数 参_横向分割数量, 整数型, 可空, 默认：2
.参数 参_纵向分割数量, 整数型, 可空, 默认：2
.参数 参_图片数组, 字节集, 数组
.局部变量 局_总位图, 类_位图操作
.局部变量 局_单位图, 类_位图操作
.局部变量 局_宽度, 整数型
.局部变量 局_高度, 整数型
.局部变量 局_单宽度, 整数型
.局部变量 局_单高度, 整数型
.局部变量 局_纵向计次, 整数型
.局部变量 局_横向计次, 整数型
.局部变量 局_左边, 整数型
.局部变量 局_顶边, 整数型
.局部变量 局_单图片, 字节集
.局部变量 局_原图, 字节集
图片_转换 (参_原图片, 1, , 局_原图, )
.如果真 (局_总位图.从数据创建 (局_原图) ＝ 假)
    返回 (假)
.如果真结束
.如果真 (是否为空 (参_横向分割数量))
    参_横向分割数量 ＝ 2
.如果真结束
.如果真 (是否为空 (参_纵向分割数量))
    参_纵向分割数量 ＝ 2
.如果真结束
局_宽度 ＝ 局_总位图.取宽度 ()
局_高度 ＝ 局_总位图.取高度 ()
局_单宽度 ＝ 局_宽度 ÷ 参_横向分割数量
局_单高度 ＝ 局_高度 ÷ 参_纵向分割数量
局_单位图.创建空白位图 (局_单宽度, 局_单高度, 32)
局_顶边 ＝ 0 － 局_单高度
.计次循环首 (参_纵向分割数量, 局_纵向计次)
    局_顶边 ＝ 局_顶边 ＋ 局_单高度
    局_左边 ＝ 0 － 局_单宽度
    .计次循环首 (参_横向分割数量, 局_横向计次)
        局_左边 ＝ 局_左边 ＋ 局_单宽度
        局_总位图.复制到 (局_单位图, 局_左边, 局_顶边, 局_单宽度, 局_单高度, 0, 0)
        局_单图片 ＝ 局_单位图.取出位图数据 ()
        加入成员 (参_图片数组, 局_单图片)
    .计次循环尾 ()
    局_左边 ＝ 0 － 局_单宽度
.计次循环尾 ()
返回 (真)
.子程序 图片_取照片拍摄日期, 逻辑型, 公开
.参数 参数_文件名, 文本型
.参数 参_拍摄时间, 文本型, 参考
.局部变量 StartupInput, GdiplusStartupInput
.局部变量 token, 整数型
.局部变量 局_size, 整数型
.局部变量 局_缓冲区, 字节集
.局部变量 局_Image, 整数型
.局部变量 局_位置, 整数型
.局部变量 局_返回码, 整数型
.局部变量 i, 整数型
StartupInput.GdiplusVersion ＝ 1
GdiplusStartup (token, StartupInput, 0)
局_返回码 ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (参数_文件名, ), 局_Image)
.如果真 (局_返回码 ≠ 0)
    返回 (假)
.如果真结束
局_返回码 ＝ GdipGetPropertyItemSize (局_Image, 36867, 局_size)  ' PropertyTagExifDTOrig
.如果真 (局_返回码 ≠ 0)
    返回 (假)
.如果真结束
局_缓冲区 ＝ 取空白字节集 (局_size)
局_返回码 ＝ GdipGetPropertyItem (局_Image, 36867, 局_size, 局_缓冲区)
参_拍摄时间 ＝ 到文本 (取字节集中间 (局_缓冲区, 17, 20))
.如果真 (局_Image ＝ 0)
    返回 (假)
.如果真结束
局_返回码 ＝ GdipDisposeImage (局_Image)
.如果真 (局_返回码 ≠ 0)
    返回 (假)
.如果真结束
GdiplusShutdown (token)
返回 (token ≠ 0)
.子程序 图片_缩放, 字节集, 公开
.参数 图片, 字节集
.参数 宽度, 整数型
.参数 高度, 整数型
.参数 无损, 逻辑型, 可空, 假为快速 真为无损，默认为假
.局部变量 对象, 对象
.局部变量 数据1, 整数型, , "0"
.局部变量 数据2, 整数型, , "0"
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 位图, 类_位图操作
.局部变量 c, 整数型
.局部变量 d, 整数型
.局部变量 图片缩放, 类_像素组
' 命令收集地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14182970
CoInitialize (0)
对象.创建图片对象 (图片)
位图.从数据创建 (对象.取回图片 ())
CoUninitialize ()
图片缩放.位图_转_像素组 (位图, 数据1)
a ＝ 位图.取宽度 ()
b ＝ 位图.取高度 ()
c ＝ 宽度
d ＝ 高度
.判断开始 (无损 ＝ 假)
    图片缩放.像素组_缩放图片_快速 (数据1, a, b, c, d, 数据2)
.默认
    图片缩放.像素组_缩放图片_无损 (数据1, a, b, c, d, 数据2)
.判断结束
位图.创建空白位图 (1, 1, 24)
图片缩放.像素组_转_位图 (位图, 数据2, c, d)
返回 (位图.取出位图数据 ())
.子程序 图片_缩放_透明, 字节集, 公开, @大司命
.参数 参_图片, 字节集
.参数 参_宽度, 整数型, 可空, 留空或小于1默认取原来宽度
.参数 参_高度, 整数型, 可空, 留空或小于1默认取原来高度
.局部变量 Startup, GdiplusStartupInput
.局部变量 hMem, 整数型
.局部变量 nSize, 整数型
.局部变量 lpStr, 整数型
.局部变量 ipStr, 整数型
.局部变量 bitmap, 整数型
.局部变量 token, 整数型
.局部变量 bpStr, 整数型
.局部变量 xpStr, 字节集
' 该命令来自：https://bbs.125.la/thread-14322627-1-1.html
Startup.GdiplusVersion ＝ 1
GdiplusStartup (token, Startup, 0)
nSize ＝ 取字节集长度 (参_图片)
hMem ＝ GlobalAlloc (#GMEM_MOVEABLE, nSize)
lpStr ＝ GlobalLock (hMem)
CreateStreamOnHGlobal (hMem, 假, ipStr)
RtlMoveMemory_字节集 (lpStr, 参_图片, nSize)
GlobalUnlock (hMem)
GdipLoadImageFromStream (ipStr, bitmap)
.如果真 (参_宽度 ＜ 1)
    GdipGetImageWidth (bitmap, 参_宽度)
.如果真结束
.如果真 (参_高度 ＜ 1)
    GdipGetImageHeight (bitmap, 参_高度)
.如果真结束
GdipGetImageThumbnail (bitmap, 参_宽度, 参_高度, bpStr, 0, 0)
GdipDisposeImage (bitmap)
GlobalFree (hMem)
hMem ＝ GlobalAlloc (位或 (#GMEM_ZEROINIT, #GMEM_MOVEABLE), 0)
CreateStreamOnHGlobal (hMem, 假, ipStr)
xpStr ＝ 取空白字节集 (16)
CLSIDFromString_字节集传址2 ({ 123, 0, 53, 0, 53, 0, 55, 0, 67, 0, 70, 0, 52, 0, 48, 0, 54, 0, 45, 0, 49, 0, 65, 0, 48, 0, 52, 0, 45, 0, 49, 0, 49, 0, 68, 0, 51, 0, 45, 0, 57, 0, 65, 0, 55, 0, 51, 0, 45, 0, 48, 0, 48, 0, 48, 0, 48, 0, 70, 0, 56, 0, 49, 0, 69, 0, 70, 0, 51, 0, 50, 0, 69, 0, 125, 0, 0, 0 }, xpStr)
GdipSaveImageToStream_字节集 (bpStr, ipStr, xpStr, 0)
lpStr ＝ GlobalLock (hMem)
nSize ＝ GlobalSize (hMem)
xpStr ＝ 指针到字节集 (lpStr, nSize)
GlobalUnlock (hMem)
GlobalFree (hMem)
GdipDisposeImage (bpStr)
GdiplusShutdown (token)
返回 (xpStr)
.子程序 加入_RGB
.参数 颜色, 整数型
.参数 R, 整数型, 参考
.参数 G, 整数型, 参考
.参数 B, 整数型, 参考
.参数 N, 整数型, 参考
.局部变量 ls_zjj, 字节集
ls_zjj ＝ 到字节集 (颜色)
R ＝ R ＋ ls_zjj [1]
G ＝ G ＋ ls_zjj [2]
B ＝ B ＋ ls_zjj [3]
N ＝ N ＋ 1
.子程序 RGB_整数, 整数型
.参数 r, 整数型
.参数 g, 整数型
.参数 b, 整数型
.局部变量 shu_, 整数型
.局部变量 ls_zjj, 字节集
ls_zjj ＝ 取空白字节集 (4)
ls_zjj [1] ＝ r
ls_zjj [2] ＝ g
ls_zjj [3] ＝ b
写到内存 (ls_zjj, 取变量地址_字节 (shu_), 4)
返回 (shu_)
.子程序 图片_拼接, 字节集, 公开, 仅支持bmp格式的图片拼接，如需其他格式的图片请先转换
.参数 参_图片数组, 文本型, 数组, 图片文件的路径数组
.参数 参_行总数, 整数型
.参数 参_列总数, 整数型
.参数 参_图片宽度, 整数型
.参数 参_图片高度, 整数型
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 局_单图片, 字节集
.局部变量 局_总位图, 类_位图操作
.局部变量 局_单位图, 类_位图操作
.局部变量 局_宽度, 整数型
.局部变量 局_高度, 整数型
.局部变量 局_位深, 短整数型
.局部变量 局_目标左, 整数型
.局部变量 局_目标顶, 整数型
.局部变量 局_拼接结果, 字节集
.局部变量 局_数组, 文本型, , "0"
.局部变量 局_索引, 整数型
局_宽度 ＝ 参_图片宽度 × 参_行总数
局_高度 ＝ 参_图片高度 × 参_列总数
局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
.计次循环首 (参_行总数, a)
    局_目标左 ＝ (a － 1) × 参_图片宽度
    .计次循环首 (参_列总数, b)
        局_目标顶 ＝ (b － 1) × 参_图片高度
        局_索引 ＝ 局_索引 ＋ 1
        .如果真 (局_索引 ＞ 取数组成员数 (参_图片数组))
            返回 ({  })
        .如果真结束
        局_单图片 ＝ 读入文件 (参_图片数组 [局_索引])
        局_单图片 ＝ 图片_缩放 (局_单图片, 参_图片宽度, 参_图片高度, 真)
        局_单位图.从数据创建 (局_单图片)
        局_单位图.复制到 (局_总位图, 0, 0, 参_图片宽度, 参_图片高度, 局_目标左, 局_目标顶)
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
局_拼接结果 ＝ 局_总位图.取出位图数据 ()
返回 (局_拼接结果)
.子程序 图片_拼接1, 字节集, 公开, 两张图片拼接为一张，支持上下拼接和左右拼接，图片自动居中
.参数 图片1, 字节集
.参数 图片2, 字节集
.参数 拼接方式, 逻辑型, , 上下拼接传入：真 左右拼接传入：假
.参数 合成底色, 整数型, 可空, 默认白底
.局部变量 _图片1, 字节集
.局部变量 _图片2, 字节集
.局部变量 局_总位图, 类_位图操作
.局部变量 局_单位图, 类_位图操作
.局部变量 局_宽度, 整数型
.局部变量 局_高度, 整数型
.局部变量 局_拼接结果, 字节集
.局部变量 y, 整数型
.局部变量 x, 整数型
.局部变量 局_左边, 整数型
.局部变量 局_顶边, 整数型
' 源码收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14339636
图片_转换 (图片1, 1, , _图片1, )
图片_转换 (图片2, 1, , _图片2, )
.如果真 (合成底色 ＝ 0)
    合成底色 ＝ #白色
.如果真结束
.如果 (拼接方式)
    ' 上下拼接取最宽宽度
    局_宽度 ＝ 图片_取宽度 (_图片1)
    .如果真 (局_宽度 ＜ 图片_取宽度 (_图片2))
        局_宽度 ＝ 图片_取宽度 (_图片2)
    .如果真结束
    ' 上下拼接取两张图片高度和
    局_高度 ＝ 图片_取高度 (_图片1) ＋ 图片_取高度 (_图片2)
    局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
    .计次循环首 (局_宽度, x)
        .计次循环首 (局_高度, y)
            局_总位图.置某点颜色 (x － 1, y － 1, 合成底色)
        .计次循环尾 ()
    .计次循环尾 ()
    局_左边 ＝ 0
    .如果真 (图片_取宽度 (_图片1) ≠ 局_宽度)
        局_左边 ＝ 到整数 ((局_宽度 － 图片_取宽度 (_图片1)) ÷ 2)
    .如果真结束
    局_单位图.从数据创建 (_图片1)
    局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片1), 图片_取高度 (_图片1), 局_左边, 0)
    处理事件 ()
    局_左边 ＝ 0
    .如果真 (图片_取宽度 (_图片2) ≠ 局_宽度)
        局_左边 ＝ 到整数 ((局_宽度 － 图片_取宽度 (_图片2)) ÷ 2)
    .如果真结束
    局_单位图.从数据创建 (_图片2)
    局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片2), 图片_取高度 (_图片2), 局_左边, 图片_取高度 (_图片1))
    处理事件 ()
.否则
    ' 左右拼接取最高高度
    局_高度 ＝ 图片_取高度 (_图片1)
    .如果真 (局_高度 ＜ 图片_取高度 (_图片2))
        局_高度 ＝ 图片_取高度 (_图片2)
    .如果真结束
    ' 左右拼接取两张图片宽度和
    局_宽度 ＝ 图片_取宽度 (_图片1) ＋ 图片_取宽度 (_图片2)
    局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
    .计次循环首 (局_宽度, x)
        .计次循环首 (局_高度, y)
            局_总位图.置某点颜色 (x － 1, y － 1, 合成底色)
        .计次循环尾 ()
    .计次循环尾 ()
    局_顶边 ＝ 0
    .如果真 (图片_取高度 (_图片1) ≠ 局_高度)
        局_顶边 ＝ 到整数 ((局_高度 － 图片_取高度 (_图片1)) ÷ 2)
    .如果真结束
    局_单位图.从数据创建 (_图片1)
    局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片1), 图片_取高度 (_图片1), 0, 局_顶边)
    处理事件 ()
    局_顶边 ＝ 0
    .如果真 (图片_取高度 (_图片2) ≠ 局_高度)
        局_顶边 ＝ 到整数 ((局_高度 － 图片_取高度 (_图片2)) ÷ 2)
    .如果真结束
    局_单位图.从数据创建 (_图片2)
    局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片2), 图片_取高度 (_图片2), 图片_取宽度 (_图片1), 局_顶边)
    处理事件 ()
.如果结束
局_拼接结果 ＝ 局_总位图.取出位图数据 ()
返回 (局_拼接结果)
.子程序 RGB2ARGB, 整数型
.参数 RGB颜色, 整数型
.参数 透明度, 整数型, 可空, 0-255
.局部变量 Color, 字节集
.如果真 (是否为空 (透明度))
    透明度 ＝ 255
.如果真结束
Color ＝ 到字节集 (RGB颜色)
RGB颜色 ＝ 位或 (Color [3] ＋ Color [2] × 256 ＋ Color [1] × 65536, 左移 (透明度, 24))  ' 转换成GDI+的颜色值
返回 (RGB颜色)
.子程序 图片_高斯模糊, 字节集, 公开, BMP
.参数 参_BMP图片, 字节集
.参数 参_衰减, 整数型, 可空
.局部变量 BMP图片宽度, 整数型
.局部变量 BMP图片高度, 整数型
.局部变量 BMP起始位置, 整数型
.局部变量 i, 整数型
.局部变量 BMPY, 整数型
.局部变量 BMPX, 整数型
.局部变量 当前x, 整数型
.局部变量 当前y, 整数型
.局部变量 平均R, 整数型
.局部变量 平均B, 整数型
.局部变量 平均G, 整数型
.局部变量 当前R, 整数型
.局部变量 当前G, 整数型
.局部变量 当前B, 整数型
.局部变量 当前N, 整数型
.局部变量 Y, 整数型
.局部变量 输出BMP, 字节集
.局部变量 衰减_整数, 整数型
输出BMP ＝ 参_BMP图片
BMP起始位置 ＝ 参_BMP图片 [3]
BMP图片宽度 ＝ 参_BMP图片 [19] ＋ 参_BMP图片 [20] × 256
BMP图片高度 ＝ 参_BMP图片 [23] ＋ 参_BMP图片 [24] × 256
衰减_整数 ＝ 0
.如果真 (是否为空 (参_衰减) ＝ 假)
    衰减_整数 ＝ 参_衰减
.如果真结束
.变量循环首 (0, BMP图片高度 － 1, 1, BMPY)
    .变量循环首 (0, BMP图片宽度 － 1, 1, BMPX)
        平均R ＝ 0
        平均G ＝ 0
        平均B ＝ 0
        当前N ＝ 0
        .如果真 (图片_取像素RGB (参_BMP图片, BMPX － 1, BMPY, 当前R, 当前G, 当前B))
            平均R ＝ 平均R ＋ 当前R
            平均G ＝ 平均G ＋ 当前G
            平均B ＝ 平均B ＋ 当前B
            当前N ＝ 当前N ＋ 1
        .如果真结束
        .如果真 (图片_取像素RGB (参_BMP图片, BMPX ＋ 1, BMPY, 当前R, 当前G, 当前B))
            平均R ＝ 平均R ＋ 当前R
            平均G ＝ 平均G ＋ 当前G
            平均B ＝ 平均B ＋ 当前B
            当前N ＝ 当前N ＋ 1
        .如果真结束
        .如果真 (图片_取像素RGB (参_BMP图片, BMPX, BMPY ＋ 1, 当前R, 当前G, 当前B))
            平均R ＝ 平均R ＋ 当前R
            平均G ＝ 平均G ＋ 当前G
            平均B ＝ 平均B ＋ 当前B
            当前N ＝ 当前N ＋ 1
        .如果真结束
        .如果真 (图片_取像素RGB (参_BMP图片, BMPX, BMPY － 1, 当前R, 当前G, 当前B))
            平均R ＝ 平均R ＋ 当前R
            平均G ＝ 平均G ＋ 当前G
            平均B ＝ 平均B ＋ 当前B
            当前N ＝ 当前N ＋ 1
        .如果真结束
        平均B ＝ 取整 (平均B ÷ 当前N) － 衰减_整数
        平均G ＝ 取整 (平均G ÷ 当前N) － 衰减_整数
        平均R ＝ 取整 (平均R ÷ 当前N) － 衰减_整数
        .如果真 (平均B ＜ 0)
            平均B ＝ 0
        .如果真结束
        .如果真 (平均G ＜ 0)
            平均G ＝ 0
        .如果真结束
        .如果真 (平均R ＜ 0)
            平均R ＝ 0
        .如果真结束
        输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 1] ＝ 平均B
        输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 2] ＝ 平均G
        输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 3] ＝ 平均R
    .变量循环尾 ()
.变量循环尾 ()
返回 (输出BMP)
.子程序 图片_取像素RGB, 逻辑型, 公开
.参数 BMP图片, 字节集
.参数 图片X, 整数型
.参数 图片Y, 整数型
.参数 图片R, 整数型, 参考
.参数 图片G, 整数型, 参考
.参数 图片B, 整数型, 参考
.局部变量 BMP图片宽度, 整数型
.局部变量 BMP图片高度, 整数型
.局部变量 BMP起始位置, 整数型
.局部变量 BMP占用字节, 整数型
.局部变量 dwLen, 整数型
dwLen ＝ 取字节集长度 (BMP图片)
.如果真 (dwLen ＜ 24)
    返回 (假)
.如果真结束
.如果真 (BMP图片 [3] ＜ 58 或 BMP图片 [29] ≠ 24)  ' 判断文件长度 和  图片深度
    返回 (假)
.如果真结束
BMP图片宽度 ＝ BMP图片 [19] ＋ BMP图片 [20] × 256
BMP图片高度 ＝ BMP图片 [23] ＋ BMP图片 [24] × 256
BMP占用字节 ＝ 取整 ((BMP图片宽度 × 24 ＋ 31) ÷ 32) × 4  ' 取一行像素占用字节数
.如果真 (图片X ＜ 0 或 图片X ≥ BMP图片宽度)
    返回 (假)
.如果真结束
.如果真 (图片Y ＜ 0 或 图片Y ≥ BMP图片高度)
    返回 (假)
.如果真结束
BMP起始位置 ＝ 55 ＋ (BMP图片高度 － 图片Y － 1) × BMP占用字节 ＋ 图片X × 3
图片R ＝ BMP图片 [BMP起始位置 ＋ 2]
图片G ＝ BMP图片 [BMP起始位置 ＋ 1]
图片B ＝ BMP图片 [BMP起始位置]
返回 (真)
.子程序 图片_置像素RGB, 逻辑型, 公开
.参数 BMP图片, 字节集
.参数 图片X, 整数型
.参数 图片Y, 整数型
.参数 图片R, 整数型
.参数 图片G, 整数型
.参数 图片B, 整数型
.局部变量 BMP图片宽度, 整数型
.局部变量 BMP图片高度, 整数型
.局部变量 BMP起始位置, 整数型
BMP起始位置 ＝ BMP图片 [3]
BMP图片宽度 ＝ BMP图片 [19] ＋ BMP图片 [20] × 256
BMP图片高度 ＝ BMP图片 [23] ＋ BMP图片 [24] × 256
.如果真 (图片X ＜ 0 或 图片X ≥ BMP图片宽度)
    返回 (假)
.如果真结束
.如果真 (图片Y ＜ 0 或 图片Y ≥ BMP图片高度)
    返回 (假)
.如果真结束
BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 1] ＝ 图片B
BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 2] ＝ 图片G
BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 3] ＝ 图片R
返回 (真)
.子程序 图片_加水印, 字节集, 公开, 给24位图加水印,如不是24位图请先转换
.参数 源图_图数据, 字节集
.参数 水印_图数据, 字节集
.参数 水印图_左边, 整数型, 可空, 默认：水印右边空白留20，水印左边程序自动计算
.参数 水印图_顶边, 整数型, 可空, 默认：水印底边空白留20，水印顶边程序自动计算
.参数 透明颜色, 整数型, 可空, 默认：白色
.局部变量 图数据, 字节集
.局部变量 原图_头长
.局部变量 原图_宽
.局部变量 原图_高
.局部变量 原图_纠正位
.局部变量 原图_图数宽
.局部变量 原图_图数长
.局部变量 原图_大小
.局部变量 水印_图头长
.局部变量 水印_宽
.局部变量 水印_高
.局部变量 水印_纠正位
.局部变量 水印_图数宽
.局部变量 水印_图数长
.局部变量 水印_大小
.局部变量 加左边
.局部变量 加顶边
.局部变量 首点1
.局部变量 首点2
.局部变量 计次1
.局部变量 局_偏移
.如果真 (取字节集数据 (源图_图数据, #短整数型, 29) ≠ 24 或 取字节集数据 (水印_图数据, #短整数型, 29) ≠ 24)
    返回 ({  })
.如果真结束
透明颜色 ＝ 选择 (是否为空 (透明颜色), 16777215, 透明颜色)
原图_头长 ＝ 取字节集数据 (源图_图数据, #短整数型, 11)
原图_宽 ＝ 取字节集数据 (源图_图数据, #整数型, 19)
原图_高 ＝ 取字节集数据 (源图_图数据, #整数型, 23)
原图_纠正位 ＝ 位与 (原图_宽, 3)
原图_图数宽 ＝ 原图_宽 × 3 ＋ 原图_纠正位
原图_图数长 ＝ 原图_图数宽 × 原图_高
原图_大小 ＝ 原图_图数长 ＋ 原图_头长
水印_图头长 ＝ 取字节集数据 (水印_图数据, #短整数型, 11)
水印_宽 ＝ 取字节集数据 (水印_图数据, #整数型, 19)
水印_高 ＝ 取字节集数据 (水印_图数据, #整数型, 23)
水印_纠正位 ＝ 位与 (水印_宽, 3)
水印_图数宽 ＝ 水印_宽 × 3 ＋ 水印_纠正位
水印_图数长 ＝ 水印_图数宽 × 水印_高
水印_大小 ＝ 水印_图数长 ＋ 水印_图头长
.如果真 (是否为空 (水印图_左边))
    水印图_左边 ＝ 原图_宽 － 水印_宽 － 20
.如果真结束
.如果真 (是否为空 (水印图_顶边))
    水印图_顶边 ＝ 原图_高 － 水印_高 － 20
.如果真结束
.如果真 (水印图_左边 ＜ 0)
    水印图_左边 ＝ 0
.如果真结束
.如果真 (水印图_顶边 ＜ 0)
    水印图_顶边 ＝ 0
.如果真结束
.如果真 (原图_高 ＜ 水印_高)
    水印_高 ＝ 原图_高
.如果真结束
.如果真 (原图_宽 ＜ 水印_宽)
    水印_宽 ＝ 原图_宽
.如果真结束
.如果真 (原图_宽 － 水印图_左边 － 水印_宽 ＜ 0)
    水印_宽 ＝ 原图_宽 － 水印图_左边
.如果真结束
.如果真 (原图_高 － 水印图_顶边 － 水印_高 ＜ 0)
    水印_高 ＝ 原图_高 － 水印图_顶边
.如果真结束
图数据 ＝ 源图_图数据
.计次循环首 (水印_高, 计次1)
    首点1 ＝ 原图_大小 － (水印图_顶边 ＋ 计次1) × 原图_图数宽 ＋ 水印图_左边 × 3
    首点2 ＝ 水印_大小 － 计次1 × 水印_图数宽
    .计次循环首 (水印_宽, )
        .如果真 (取颜色值 (水印_图数据 [首点2 ＋ 3], 水印_图数据 [首点2 ＋ 2], 水印_图数据 [首点2 ＋ 1]) ≠ 透明颜色)
            图数据 [首点1 ＋ 1] ＝ 水印_图数据 [首点2 ＋ 1]
            图数据 [首点1 ＋ 2] ＝ 水印_图数据 [首点2 ＋ 2]
            图数据 [首点1 ＋ 3] ＝ 水印_图数据 [首点2 ＋ 3]
        .如果真结束
        首点1 ＝ 首点1 ＋ 3
        首点2 ＝ 首点2 ＋ 3
    .计次循环尾 ()
.计次循环尾 ()
返回 (图数据)
.子程序 图片_转换, 逻辑型, 公开, 支持bmp、jpg、gif、tiff、png互转；成功返回转换好的图片数据，失败返回空字节集；
.参数 图像数据, 字节集, , 被转换的图像数据；
.参数 转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；
.参数 保存路径, 文本型, 可空, 把转换后的图像保存到指定位置；
.参数 返回数据, 字节集, 参考 可空, 变量储存返回数据.
.参数 含透明色, 逻辑型, 可空, 转换PNG图片时是否需要处理透明色，可为空，默认不处理。
.局部变量 新图像, 字节集, , , 用于保存新图像的变量
.局部变量 Clsid, GUID
.局部变量 pStr, 文本型
.局部变量 hMem, 整数型
.局部变量 Stream
.局部变量 lpvoid, 整数型
.局部变量 pStream, 整数型
.局部变量 bitmap, 整数型
.局部变量 DataStream
.局部变量 hMemDataStream, 整数型
.局部变量 pDataStream, 整数型
.局部变量 nStreamSize, 整数型
.局部变量 bRet, 逻辑型
.局部变量 GpInput, GdiplusStartupInput
.局部变量 局_Token, 整数型
.局部变量 局_hBitMap, 整数型
.局部变量 局_后缀名, 文本型
.如果真 (取字节集长度 (图像数据) ＜ 3)
    返回 (假)
.如果真结束
GpInput.GdiplusVersion ＝ 1
GdiplusStartup (局_Token, GpInput, 0)  ' 启动GDI+
.判断开始 (转换格式 ＝ 1)  ' bmp
    pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
    局_后缀名 ＝ “.bmp”
.判断 (转换格式 ＝ 2)  ' jpg
    pStr ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
    局_后缀名 ＝ “.jpg”
.判断 (转换格式 ＝ 3)  ' gif
    pStr ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
    局_后缀名 ＝ “.gif”
.判断 (转换格式 ＝ 4)  ' tiff
    pStr ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
    局_后缀名 ＝ “.tiff”
.判断 (转换格式 ＝ 5)  ' png
    pStr ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
    局_后缀名 ＝ “.png”
.默认
.判断结束
Clsid ＝ COM_StringToCLSID (pStr)
hMem ＝ GlobalAlloc (2, 取字节集长度 (图像数据))  ' 分配内存
CreateStreamOnHGlobal (hMem, 假, Stream)
lpvoid ＝ GlobalLock (hMem)
写到内存 (图像数据, lpvoid, 取字节集长度 (图像数据))
GlobalUnlock (hMem)
pStream ＝ lstrcpyn_整数型 (Stream, Stream, 0)
GDIpCreateBitmapFromStream (取字节集数据 (指针到字节集 (pStream, 4), #整数型, ), bitmap)
.如果真 (含透明色)
    GdipCreateHBITMAPFromBitmap (bitmap, 局_hBitMap, #白色)
    GdipCreateBitmapFromHBITMAP (局_hBitMap, 0, bitmap)
    DeleteObject (局_hBitMap)
.如果真结束
CreateStreamOnHGlobal (0, 真, DataStream)
pStream ＝ lstrcpyn_整数型 (DataStream, DataStream, 0)
pStream ＝ 取字节集数据 (指针到字节集 (pStream, 4), #整数型, )
GDIpSaveImageToStream_GUID (bitmap, pStream, Clsid, 0)
GetHGlobalFromStream (pStream, hMemDataStream)
pDataStream ＝ GlobalLock (hMemDataStream)
nStreamSize ＝ GlobalSize (hMemDataStream)
.如果真 (pDataStream ≠ 0)
    新图像 ＝ 取空白字节集 (nStreamSize)
    RtlMoveMemory_int2Bytes (新图像, pDataStream, nStreamSize)
    .如果真 (删首尾空 (保存路径) ≠ “”)
        写到文件 (选择 (到小写 (取文本右边 (保存路径, 取文本长度 (局_后缀名))) ≠ 到小写 (局_后缀名), 保存路径 ＋ 局_后缀名, 保存路径), 新图像)
    .如果真结束
    返回数据 ＝ 新图像
    bRet ＝ 真
.如果真结束
COM_Release (Stream)
COM_Release (DataStream)
GlobalUnlock (hMemDataStream)
GlobalFree (hMemDataStream)
GdipDisposeImage (bitmap)
GlobalFree (hMem)
GdiplusShutdown (局_Token)  ' GDI关闭 +
返回 (bRet)
.子程序 图片_转换1, 字节集, 公开
.参数 参_原始图片, 字节集
.参数 参_转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；
.参数 参_输出质量, 整数型, , 0-100
.局部变量 局_图像转换, 类_图像格式转换类
.局部变量 局_转换结果, 字节集
.如果真 (局_图像转换.载入图像 (参_原始图片) ＝ 假)
    返回 ({  })
.如果真结束
局_转换结果 ＝ 局_图像转换.转换到字节集 (参_转换格式, 参_输出质量)
返回 (局_转换结果)
.子程序 图片_转换Ex, 字节集, 公开, 支持bmp、jpg、gif、tiff、png互转；成功返回转换好的图片数据，失败返回空字节集；
.参数 图像数据, 字节集, , 被转换的图像数据；
.参数 转换格式, 整数型, 可空, 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；其他=png；
.参数 保存路径, 文本型, 可空, 把转换后的图像保存到指定位置；
.参数 含透明色, 逻辑型, 可空, 转换PNG图片时是否需要处理透明色，可为空，默认不处理。
.局部变量 Clsid, 字节集, , , 转换标志
.局部变量 szText, 文本型, , , gdi+图片转换标志
.局部变量 hMem, 整数型, , , 原图片存放的内存句柄
.局部变量 hMemData, 整数型, , , 转换后的图片内存句柄
.局部变量 hBmp, 整数型, , , 从流指针里创建的位图句柄
.局部变量 hBmp1, 整数型, , , 位图
.局部变量 pStream, 整数型, , , 原图片流对象指针
.局部变量 pAddrStream, 整数型, , , 原图片内存地址,图片数据写入这里
.局部变量 pDataStream, 整数型, , , 转换后图片流对象指针
.局部变量 pAddrDataStream, 整数型, , , 图片转换后的内存地址
.局部变量 dwLen, 整数型, , , 转换后图片的大小
.局部变量 Ret, 字节集, , , 返回值
.局部变量 Token, 整数型, , , gdi+token
.局部变量 扩展名, 文本型
.局部变量 Error, 整数型, , , gdi+错误代码
.局部变量 input, GdiplusStartupInput
.局部变量 wzText, 字节集
.如果真 (取字节集长度 (图像数据) ＜ 3)
    返回 ({  })
.如果真结束
' Clsid ＝ 取空白字节集 (16)  ' 临时借用一下这个变量做缓冲区,相当于 GdiplusStartupInput 这个数据结构,4个成员
' __set (取指针_字节集型 (Clsid), 0, 1)  ' 设置 第一个成员 GdiplusVersion 为1
' Error ＝ GdiplusStartupA (Token, 取指针_字节集型 (Clsid), 0)  ' 启动GDI+
input.GdiplusVersion ＝ 1
Error ＝ GdiplusStartup (Token, input, 0)  ' 启动GDI+
.如果真 (Error ≠ 0)
    返回 ({  })
.如果真结束
.判断开始 (转换格式 ＝ 1)  ' bmp
    szText ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
    扩展名 ＝ “.bmp”
.判断 (转换格式 ＝ 2)  ' jpg
    szText ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
    扩展名 ＝ “.jpg”
.判断 (转换格式 ＝ 3)  ' gif
    szText ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
    扩展名 ＝ “.gif”
.判断 (转换格式 ＝ 4)  ' tiff
    szText ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
    扩展名 ＝ “.tiff”
.默认
    szText ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
    扩展名 ＝ “.png”
.判断结束
Clsid ＝ 取空白字节集 (16)
wzText ＝ A2W (szText, )
CLSIDFromString (取指针_字节集型 (wzText), Clsid)
hMem ＝ GlobalAlloc (66, 取字节集长度 (图像数据))  ' 申请内存
pAddrStream ＝ GlobalLock (hMem)  ' 锁定内存,返回这个内存句柄的内存首地址
RtlMoveMemory (pAddrStream, 取指针_字节集型 (图像数据), 取字节集长度 (图像数据))  ' 把图片数据写入这个内存
.如果真 (GlobalUnlock (hMem) ≠ 0)  ' 解锁内存
    集_转换错误 ＝ “解锁原图片内存失败”
.如果真结束
CreateStreamOnHGlobal_整数型 (hMem, 0, pStream)  ' 创建流对象
Error ＝ GDIpCreateBitmapFromStream (pStream, hBmp)  ' 从流里创建位图
.如果真 (Error ≠ 0)
    SafeRelease (pStream)  ' 释放流对象
    .如果真 (GlobalFree (hMem) ≠ 0)  ' 释放内存
        集_转换错误 ＝ “从流里创建位图失败,并且释放内存失败”
    .如果真结束
    返回 ({  })
.如果真结束
.如果真 (含透明色)
    GdipCreateHBITMAPFromBitmap (hBmp, hBmp1, #白色)  ' 返回位图句柄。需要调用 DeleteObject 释放
    GdipCreateBitmapFromHBITMAP (hBmp1, 0, hBmp)
.如果真结束
CreateStreamOnHGlobal_整数型 (0, 0, pDataStream)  ' 创建流,从这个流里取转换后的数据
GdipSaveImageToStream_字节集 (hBmp, pDataStream, Clsid, 0)  ' 转换图片
GetHGlobalFromStream (pDataStream, hMemData)  ' 从流里获取内存句柄
pAddrDataStream ＝ GlobalLock (hMemData)  ' 锁定内存句柄
dwLen ＝ GlobalSize (hMemData)  ' 取转换后内存大小
.如果真 (pAddrDataStream ≠ 0)
    Ret ＝ 取空白字节集 (dwLen)  ' 缓冲区
    RtlMoveMemory (取指针_字节集型 (Ret), pAddrDataStream, dwLen)  ' 把转换后的图片数据写入到缓冲区
    .如果真 (删首尾空 (保存路径) ≠ “”)
        写到文件 (选择 (到小写 (取文本右边 (保存路径, 取文本长度 (扩展名))) ≠ 到小写 (扩展名), 保存路径 ＋ 扩展名, 保存路径), Ret)
    .如果真结束
.如果真结束
SafeRelease (pStream)  ' 释放原图片流对象
SafeRelease (pDataStream)  ' 释放转换后流对象
.如果真 (GlobalUnlock (hMemData) ≠ 0)  ' 解锁转换后的内存
    集_转换错误 ＝ “解锁转换后的内存失败”
.如果真结束
.如果真 (GlobalFree (hMemData) ≠ 0)  ' 释放转换后的内存
    集_转换错误 ＝ “释放转换后的内存失败”
.如果真结束
.如果真 (hBmp1 ≠ 0)
    .如果真 (DeleteObject (hBmp1) ＝ 0)  ' 删除位图
        集_转换错误 ＝ “删除位图失败”
    .如果真结束
.如果真结束
Error ＝ GdipDisposeImage (hBmp)  ' 释放gdi+位图
.如果真 (Error ≠ 0)
    集_转换错误 ＝ “释放gdi+位图失败”
.如果真结束
.如果真 (GlobalFree (hMem) ≠ 0)  ' 释放第一个申请的内存
    集_转换错误 ＝ “释放原图片内存失败”
.如果真结束
GdiplusShutdown (Token)  ' 关闭 gdi+
返回 (Ret)
.子程序 图片_转换Ex_取最后错误, 文本型, 公开
返回 (集_转换错误)
.子程序 图标_取数量, 整数型, 公开, 取出文件的图标数量
.参数 文件路径, 文本型
返回 (ExtractIconA (0, 文件路径, -1))
.子程序 图片_取句柄, 整数型, 公开, 取图片句柄,成功返回图片句柄,失败返回0
.参数 参_图片, 字节集, , 欲添加为菜单图片的资源
.局部变量 局_对象, 对象, 静态, "0"
.局部变量 局_句柄, 整数型
.局部变量 局_成员数, 整数型
局_成员数 ＝ 取数组成员数 (局_对象) ＋ 1
重定义数组 (局_对象, 真, 局_成员数)
CoInitialize (0)
.如果真 (局_对象 [局_成员数].创建图片对象 (参_图片))
    CoUninitialize ()
    返回 (局_对象 [局_成员数].读数值属性 (“handle”, ))
.如果真结束
CoUninitialize ()
返回 (0)
.子程序 图标_取句柄, 整数型, 公开, 取“位图 鼠标图片 图标“句柄,成功返回句柄,失败返回0
.参数 图片路径, 文本型
.参数 图像类型, 整数型, 可空, IMAGE_ 开头的常量  默认为 #IMAGE_ICON 图标
.局部变量 局_图片高度, 整数型
.局部变量 局_图片宽度, 整数型
局_图片宽度 ＝ GetSystemMetrics (71)
局_图片高度 ＝ GetSystemMetrics (72)  ' SM_CYMENUCHECK 获取菜单复选号位图的大小
.如果真 (是否为空 (图像类型))
    图像类型 ＝ #IMAGE_ICON
.如果真结束
返回 (LoadImage (0, 图片路径, 图像类型, 局_图片宽度, 局_图片高度, 16))
.子程序 颜色_取反色, 整数型, 公开, 取一个颜色的反色
.参数 要取反色的10进程颜色, 整数型
.局部变量 bin, 字节集
bin ＝ 到字节集 (要取反色的10进程颜色)
bin [1] ＝ 255 － bin [1]
bin [2] ＝ 255 － bin [2]
bin [3] ＝ 255 － bin [3]
返回 (取字节集数据 (bin, #整数型, ))
.子程序 图片_后台截图, 字节集, 公开, 后台截图
.参数 窗口句柄, 整数型, , 要截取的图片的窗口句柄
.局部变量 矩形区域, 精易_矩形
.局部变量 屏幕设备上下文句柄, 整数型
.局部变量 内存设备上下文句柄, 整数型
.局部变量 位图句柄, 整数型
.局部变量 旧位图句柄, 整数型
.局部变量 位图, BITMAP
.局部变量 位图像素点阵, 字节集
.局部变量 位图文件头, BITMAPFILEHEADER
.局部变量 位图文件头字节集, 字节集
.局部变量 位图信息, BITMAPINFO
.局部变量 位图信息字节集, 字节集
.如果真 (取反 (窗口_句柄是否有效 (窗口句柄)))
    返回 ({  })
.如果真结束
GetWindowRect (窗口句柄, 矩形区域)
屏幕设备上下文句柄 ＝ GetDC (0)
内存设备上下文句柄 ＝ CreateCompatibleDC (屏幕设备上下文句柄)
位图句柄 ＝ CreateCompatibleBitmap (屏幕设备上下文句柄, 矩形区域.右边 － 矩形区域.左边, 矩形区域.底边 － 矩形区域.顶边)
旧位图句柄 ＝ SelectObject (内存设备上下文句柄, 位图句柄)
.如果真 (取反 (PrintWindow (窗口句柄, 内存设备上下文句柄, 0)))
    SelectObject (内存设备上下文句柄, 旧位图句柄)
    DeleteObject (位图句柄)
    DeleteDC (内存设备上下文句柄)
    ReleaseDC (0, 屏幕设备上下文句柄)
    返回 ({  })
.如果真结束
GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
位图信息.BITMAPINFOHEADER.biSize ＝ 4 × 11
GetDIBits1 (内存设备上下文句柄, 位图句柄, 0, 0, 0, 位图信息, 0)
位图像素点阵 ＝ 取空白字节集 (位图信息.BITMAPINFOHEADER.biSizeImage)
位图信息.BITMAPINFOHEADER.biCompression ＝ 0
GetDIBits (内存设备上下文句柄, 位图句柄, 0, 位图.bmHeight, 位图像素点阵, 位图信息, 0)
' 构造位图信息
位图信息字节集 ＝ 取空白字节集 (位图信息.BITMAPINFOHEADER.biSize)
RtlMoveMemory_BITMAPINFO (位图信息字节集, 位图信息, 位图信息.BITMAPINFOHEADER.biSize)
' 构造位图文件头
位图文件头.bfType ＝ 19778
位图文件头.bfOffBits ＝ 2 × 4 ＋ 3 × 2 ＋ 位图信息.BITMAPINFOHEADER.biSize
位图文件头.bfSize ＝ 位图文件头.bfOffBits ＋ 位图信息.BITMAPINFOHEADER.biSizeImage
位图文件头.bfReserved1 ＝ 0
位图文件头.bfReserved2 ＝ 0
位图文件头字节集 ＝ 取空白字节集 (14)
RtlMoveMemory_BITMAPFILEHEADER (位图文件头字节集, 位图文件头, 14)
SelectObject (内存设备上下文句柄, 旧位图句柄)
DeleteObject (位图句柄)
DeleteDC (内存设备上下文句柄)
ReleaseDC (0, 屏幕设备上下文句柄)
返回 (位图文件头字节集 ＋ 位图信息字节集 ＋ 位图像素点阵)
.子程序 图片_后台区域截图, 字节集, 公开, 可后台截取指定位置大小的图片。窗口不能最小化，否则会导致截取失败。
.参数 窗口句柄, 整数型, , 要截取的图片的窗口句柄
.参数 欲截取的左边, 整数型
.参数 欲截取的顶边, 整数型
.参数 欲截取的宽度, 整数型
.参数 欲截取的高度, 整数型
返回 (图片_取图片区域 (图片_后台截图 (窗口句柄), 欲截取的左边, 欲截取的顶边, 欲截取的宽度, 欲截取的高度))
.子程序 图片_取图片区域, 字节集, 公开, 提供一张图片，取出指定位置大小的图片。
.参数 原位图, 字节集, , 24位BMP位图
.参数 图片左边, 整数型, , 欲取出的图片左边
.参数 图片顶边, 整数型, , 欲取出的图片顶边
.参数 图片宽度, 整数型, , 欲取出的图片宽度
.参数 图片高度, 整数型, , 欲取出的图片高度
.局部变量 图像宽度, 整数型
.局部变量 图像高度, 整数型
.局部变量 图像位数, 整数型
.局部变量 图像压缩, 整数型
.局部变量 新位图, 字节集
.局部变量 新位图信息头, BITMAPINFOHEADER
.局部变量 新位图文件头, BITMAPFILEHEADER
.局部变量 文件长度, 整数型
.局部变量 i, 整数型
.局部变量 颜色点阵偏移量, 整数型
.局部变量 点的大小, 整数型
.局部变量 颜色表, 字节集
.局部变量 总数据偏移, 整数型
.局部变量 新行宽, 整数型
.局部变量 原行宽, 整数型
.局部变量 时间, 整数型
图像宽度 ＝ 取字节集数据 (取字节集中间 (原位图, 19, 4), #整数型, )
图像高度 ＝ 取字节集数据 (取字节集中间 (原位图, 23, 4), #整数型, )
图像位数 ＝ 取字节集数据 (取字节集中间 (原位图, 29, 2), #短整数型, )
图像压缩 ＝ 取字节集数据 (取字节集中间 (原位图, 31, 4), #整数型, )
.如果真 (图像压缩 ≠ 0)
    返回 ({  })
.如果真结束
.如果真 (图像位数 ＝ 32)
    颜色点阵偏移量 ＝ 54
    点的大小 ＝ 4
.如果真结束
.如果真 (图像位数 ＝ 24)
    颜色点阵偏移量 ＝ 54
    点的大小 ＝ 3
.如果真结束
.如果真 (图像位数 ＝ 16)
    颜色点阵偏移量 ＝ 54
    点的大小 ＝ 2
.如果真结束
.如果真 (图像位数 ＝ 8)
    颜色点阵偏移量 ＝ 1078
    点的大小 ＝ 1
    颜色表 ＝ 取字节集中间 (原位图, 55, 1024)
.如果真结束
.如果真 (图像位数 ＜ 8)
    输出调试文本 (“错误！ 图像位深小于8！”)
    返回 ({  })
.如果真结束
' 输出调试文本 (“参数错误！请检查输入的参数！”)
' 返回 ({  })
.如果真 (图片左边 ＜ 0)
    图片左边 ＝ 0
.如果真结束
.如果真 (图片顶边 ＜ 0)
    图片顶边 ＝ 0
.如果真结束
.如果真 (图片左边 ＞ 图像宽度 或 图片顶边 ＞ 图像高度)
    输出调试文本 (“参数错误，错误原因：图片左边或图片顶边小于截取出来图片的宽度或高度”)
    返回 ({  })
.如果真结束
.如果真 (图片宽度 ≤ 0 或 图片高度 ≤ 0)
    输出调试文本 (“参数错误，错误原因：图片宽度或图片高度小于等于0”)
    返回 ({  })
.如果真结束
.如果真 (图片左边 ＋ 图片宽度 ＞ 图像宽度)
    图片宽度 ＝ 图像宽度 － 图片左边
.如果真结束
.如果真 (图片顶边 ＋ 图片高度 ＞ 图像高度)
    图片高度 ＝ 图像高度 － 图片顶边
.如果真结束
原行宽 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2)
新行宽 ＝ 左移 (右移 (图片宽度 × 图像位数 ＋ 31, 5), 2)
文件长度 ＝ 新行宽 × 图片高度
新位图 ＝ 取空白字节集 (文件长度 ＋ 54 ＋ 取字节集长度 (颜色表))
新位图文件头.bfType ＝ 19778
新位图文件头.bfOffBits ＝ 颜色点阵偏移量
新位图文件头.bfSize ＝ 颜色点阵偏移量 ＋ 文件长度
RtlMoveMemory_BITMAPFILEHEADER_字节型 (新位图 [1], 新位图文件头, 14)
新位图信息头.biSize ＝ 40
新位图信息头.biWidth ＝ 图片宽度
新位图信息头.biHeight ＝ 图片高度
新位图信息头.biPlanes ＝ 1
新位图信息头.biBitCount ＝ 图像位数
RtlMoveMemory_BITMAPINFOHEADER (新位图 [15], 新位图信息头, 40)
.如果真 (图像位数 ＝ 8)
    RtlMoveMemory_字节型 (新位图 [55], 颜色表 [1], 1024)
.如果真结束
总数据偏移 ＝ 原行宽 × (图像高度 － 图片高度 － 图片顶边) ＋ 图片左边 × 点的大小  ' 总偏移=高偏移+宽偏移
.计次循环首 (图片高度, i)
    RtlMoveMemory_字节型 (新位图 [(i － 1) × 新行宽 ＋ 颜色点阵偏移量 ＋ 1], 原位图 [颜色点阵偏移量 ＋ 总数据偏移 ＋ (i － 1) × 原行宽 ＋ 1], 新行宽)
.计次循环尾 ()
返回 (新位图)
.子程序 图片_屏幕截图, 字节集, 公开, 截取桌面指定大小的图片
.参数 屏幕宽度, 整数型
.参数 屏幕高度, 整数型
.参数 图片位数, 整数型, 可空, 这里支持 4 8 24 32 默认是24位图!
.局部变量 桌面句柄, 整数型
.局部变量 源场景, 整数型
.局部变量 位图句柄, 整数型
.局部变量 位图像素点阵, 字节集
.局部变量 位图文件头, BITMAPFILEHEADER
.局部变量 位图文件头字节集, 字节集
.局部变量 位图信息, 位图信息_
.局部变量 位图信息字节集, 字节集
.局部变量 颜色表, 字节集
.局部变量 颜色表大小, 整数型
.判断开始 (图片位数 ＝ 0)
    位图信息.位深度 ＝ 24
.默认
    位图信息.位深度 ＝ 图片位数
.判断结束
位图信息.位图位面数 ＝ 1
位图信息.位图宽度 ＝ 屏幕宽度
位图信息.位图高度 ＝ 屏幕高度
位图信息.位图大小 ＝ 位图信息.位图宽度 × 位图信息.位图高度 × 位图信息.位深度 ÷ 8
位图信息.结果大小 ＝ 40
位图信息.压缩率 ＝ 0
颜色表大小 ＝ 取位图深度 (位图信息.位深度)
位图像素点阵 ＝ 取空白字节集 (位图信息.位图大小)
颜色表 ＝ 取空白字节集 (颜色表大小)
桌面句柄 ＝ GetDC (0)
源场景 ＝ CreateCompatibleDC (桌面句柄)
位图句柄 ＝ CreateDIBSection (源场景, 位图信息, 1, 0, 0, 0)  ' 不知是不是这里后面的三个参数导致的这些原因,但不知要如何弄这里的参数
SelectObject (源场景, 位图句柄)
GetDIBColorTable (源场景, 0, 颜色表大小, 颜色表)  ' 是不是不能这样取颜色表?虽然能出图了,但颜色好象还是不正常,是这里取出的颜色表有问题?
StretchBlt (源场景, 0, 0, 位图信息.位图宽度, 位图信息.位图高度, 桌面句柄, 0, 位图信息.位图高度, 位图信息.位图宽度, －位图信息.位图高度, 13369376)
GetBitmapBits (位图句柄, 位图信息.位图大小, 位图像素点阵)
' 取位图二进制位_ (源场景, 位图句柄, 0, 位图信息.位图高度, 位图像素点阵 [1], 位图信息, #DIB_PAL_COLORS)
' 不知道为什么不能用这个(取位图二进制位_)API,而用(复制位图_)API却不会出错
位图信息字节集 ＝ 取空白字节集 (位图信息.结果大小)
RtlMoveMemory_位图信息 (位图信息字节集, 位图信息, 位图信息.结果大小)
位图文件头.bfType ＝ 19778
位图文件头.bfOffBits ＝ 颜色表大小 ＋ 54
位图文件头.bfSize ＝ 54 ＋ 位图信息.位图大小
位图文件头字节集 ＝ 取空白字节集 (14)
RtlMoveMemory_BITMAPFILEHEADER (位图文件头字节集, 位图文件头, 14)
DeleteObject (位图句柄)
DeleteDC (源场景)
ReleaseDC (0, 桌面句柄)
返回 (位图文件头字节集 ＋ 位图信息字节集 ＋ 颜色表 ＋ 位图像素点阵)
.子程序 图片_屏幕区域截图, 字节集, 公开, 截取桌面指定位置和大小的图片
.参数 欲截取的左边, 整数型
.参数 欲截取的顶边, 整数型
.参数 欲截取的宽度, 整数型
.参数 欲截取的高度, 整数型
.局部变量 行宽, 整数型
.局部变量 文件长度, 整数型
.局部变量 Head, 字节集
.局部变量 Data, 字节集
.局部变量 BitmapHead, BITMAPINFOHEADER
.局部变量 源场景, 整数型
.局部变量 色深, 整数型
.局部变量 目标场景, 整数型
.局部变量 位图句柄, 整数型
.局部变量 原位图句柄, 整数型
源场景 ＝ GetDC (0)
色深 ＝ GetDeviceCaps (源场景, 12)
目标场景 ＝ CreateCompatibleDC (源场景)
位图句柄 ＝ CreateCompatibleBitmap (源场景, 欲截取的宽度, 欲截取的高度)
原位图句柄 ＝ SelectObject (目标场景, 位图句柄)
BitBlt (目标场景, 0, 0, 欲截取的宽度, 欲截取的高度, 源场景, 欲截取的左边, 欲截取的顶边, 13369376)  ' #SRCCOPY＝13369376
ReleaseDC (0, 源场景)
SelectObject (目标场景, 原位图句柄)
BitmapHead.biSize ＝ 40
BitmapHead.biWidth ＝ 欲截取的宽度
BitmapHead.biHeight ＝ 欲截取的高度
BitmapHead.biPlanes ＝ 1
BitmapHead.biBitCount ＝ 到短整数 (色深)
行宽 ＝ 左移 (右移 (欲截取的宽度 × 色深 ＋ 31, 5), 2)
Data ＝ 取空白字节集 (BitmapHead.biSize ＋ 行宽 × 欲截取的高度)
.如果真 (Data ＝ {  })
    返回 ({  })
.如果真结束
RtlMoveMemory_BITMAPINFOHEADER (Data [1], BitmapHead, BitmapHead.biSize)
.如果 (GetDIBits2 (目标场景, 位图句柄, 0, 欲截取的高度, Data [BitmapHead.biSize ＋ 1], Data [1], 0) ≠ 0)
    文件长度 ＝ 14 ＋ 行宽 × 欲截取的高度
    Data ＝ 到字节集 (“BM”) ＋ 到字节集 (文件长度) ＋ { 0, 0, 0, 0, 54, 0, 0, 0 } ＋ Data
.否则
    Data ＝ {  }
.如果结束
DeleteObject (位图句柄)
DeleteDC (目标场景)
返回 (Data)
.子程序 取位图深度, 整数型
.参数 位深, 整数型
.判断开始 (位深 ＝ 1)
    返回 (8)
.判断 (位深 ＝ 4)
    返回 (64)
.判断 (位深 ＝ 8)
    返回 (1024)
.默认
    返回 (0)
.判断结束
.子程序 图片_通过句柄取图标, 字节集, 公开
.参数 窗口句柄, 整数型, , 当前窗口句柄
.参数 图标句柄, 整数型
.参数 图标宽度, 整数型, 可空
.参数 图标高度, 整数型, 可空
.参数 背景颜色, 整数型, 可空
.局部变量 sRect, 精易_矩形
.局部变量 sIco, 字节集
.局部变量 位图操作, 类_位图操作
.局部变量 SrchDC, 整数型
.局部变量 newDC, 整数型
.局部变量 hwnd, 整数型
.局部变量 hBmp, 整数型
.局部变量 hBmpPrev, 整数型
.局部变量 mBrush, 整数型
.如果真 (是否为空 (图标宽度))
    图标宽度 ＝ 32
.如果真结束
.如果真 (是否为空 (图标高度))
    图标高度 ＝ 32
.如果真结束
.如果真 (是否为空 (背景颜色))
    背景颜色 ＝ #白色
.如果真结束
sRect.顶边 ＝ 0
sRect.左边 ＝ 0
sRect.右边 ＝ 图标宽度
sRect.底边 ＝ 图标高度
SrchDC ＝ GetDC (窗口句柄)
newDC ＝ CreateCompatibleDC (SrchDC)
' 验证 (newDC)
hBmp ＝ CreateCompatibleBitmap (SrchDC, 48, 48)
' 验证 (hBmp)
hBmpPrev ＝ SelectObject (newDC, hBmp)
' 验证 (hBmpPrev)
mBrush ＝ CreateSolidBrush (背景颜色)
FillRect (newDC, sRect, mBrush)
DrawIconEx (newDC, 0, 0, 图标句柄, 图标宽度, 图标高度, 0, 0, 3)
位图操作.从场景创建 (newDC, sRect, 32)
sIco ＝ 位图操作.取出位图数据 ()
ReleaseDC (hwnd, SrchDC)
DeleteDC (newDC)
DeleteObject (hBmpPrev)
DeleteObject (hBmp)
DeleteObject (mBrush)
返回 (sIco)
.子程序 图片_取宽度, 整数型, 公开, 快速读取图片宽度，失败返回零。
.参数 参_图片数据, 字节集, , 支持文件路径与图片内容，路径非unicode编码，可用 到字节集()转换
.局部变量 gdip_Image
.局部变量 Wid, 整数型
.局部变量 Hgt, 整数型
.局部变量 hresult
.局部变量 GpInput, GdiplusStartupInput
.局部变量 gdip_Token, 整数型
.局部变量 FileName, 文本型
.局部变量 FileExists, 逻辑型
.局部变量 dwFileSize, 整数型
.局部变量 hImageMemory, 整数型
.局部变量 pImageMemory, 整数型
.局部变量 pIStream, 整数型
FileName ＝ 到文本 (参_图片数据)
FileExists ＝ 文件_是否存在 (FileName)
GpInput.GdiplusVersion ＝ 1
hresult ＝ GdiplusStartup (gdip_Token, GpInput, 0)  ' 启动GDI+
.如果真 (hresult ＝ 0)
    .如果 (FileExists)
        hresult ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (FileName, ), gdip_Image)
    .否则
        dwFileSize ＝ 取字节集长度 (参_图片数据)
        hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize)  ' ; //给图片分配全局内存
        pImageMemory ＝ GlobalLock (hImageMemory)  ' ; //锁定内存
        CopyMemory_Bytes2int (pImageMemory, 参_图片数据, dwFileSize)
        hresult ＝ CreateStreamOnHGlobal (hImageMemory, 假, pIStream)  ' //用全局内存初使化IStream接口指针
        GdipLoadImageFromStream (pIStream, gdip_Image)
        .如果真 (hresult ＝ 0)
            COM_Release (pIStream)
        .如果真结束
        GlobalUnlock (pImageMemory)  ' ; //解锁内存
        GlobalFree (hImageMemory)
    .如果结束
    GdipGetImageWidth (gdip_Image, Wid)
    GdipDisposeImage (gdip_Image)
    GdiplusShutdown (gdip_Token)  ' GDI关闭 +
.如果真结束
返回 (Wid)
.子程序 图片_取高度, 整数型, 公开, 快速读取图片高度，失败返回零。
.参数 参_图片数据, 字节集, , 支持文件路径与图片内容，路径非unicode编码，可用 到字节集()转换
.局部变量 gdip_Image
.局部变量 Wid, 整数型
.局部变量 Hgt, 整数型
.局部变量 hresult
.局部变量 GpInput, GdiplusStartupInput
.局部变量 gdip_Token, 整数型
.局部变量 FileName, 文本型
.局部变量 FileExists, 逻辑型
.局部变量 dwFileSize, 整数型
.局部变量 hImageMemory, 整数型
.局部变量 pImageMemory, 整数型
.局部变量 pIStream, 整数型
FileName ＝ 到文本 (参_图片数据)
FileExists ＝ 文件_是否存在 (FileName)
GpInput.GdiplusVersion ＝ 1
hresult ＝ GdiplusStartup (gdip_Token, GpInput, 0)  ' 启动GDI+
.如果真 (hresult ＝ 0)
    .如果 (FileExists)
        hresult ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (FileName, ), gdip_Image)
    .否则
        dwFileSize ＝ 取字节集长度 (参_图片数据)
        hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize)  ' ; //给图片分配全局内存
        pImageMemory ＝ GlobalLock (hImageMemory)  ' ; //锁定内存
        CopyMemory_Bytes2int (pImageMemory, 参_图片数据, dwFileSize)
        CreateStreamOnHGlobal (hImageMemory, 假, pIStream)  ' //用全局内存初使化IStream接口指针
        GdipLoadImageFromStream (pIStream, gdip_Image)
        .如果真 (hresult ＝ 0)
            COM_Release (pIStream)
        .如果真结束
        GlobalUnlock (pImageMemory)  ' ; //解锁内存
        GlobalFree (hImageMemory)
    .如果结束
    GdipGetImageHeight (gdip_Image, Hgt)
    GdipDisposeImage (gdip_Image)
    GdiplusShutdown (gdip_Token)  ' GDI关闭 +
.如果真结束
返回 (Hgt)
.子程序 图片_取格式, 文本型, 公开, 根据文件头部判断文件格式，成功返回格式名称，失败返回空。
.参数 绝对路径, 文本型, , 绝对路径
返回 (图片_取格式W (编码_Ansi到Unicode (绝对路径)))
.子程序 图片_取格式W, 文本型, 公开, 根据文件头部判断文件格式，成功返回格式名称，失败返回空。
.参数 绝对路径, 字节集, , 绝对路径->Unicode
.局部变量 hFile, 整数型
.局部变量 data, 字节集
.局部变量 Hex, 文本型
.局部变量 readSize, 整数型
hFile ＝ CreateFileW (绝对路径, #FILE_GENERIC_READ, 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE, #FILE_SHARE_DELETE), #NULL, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, #NULL)
.如果真 (hFile ＝ #INVALID_HANDLE_VALUE)
    返回 (“”)
.如果真结束
data ＝ 取空白字节集 (16)
ReadFile_字节集 (hFile, data, 16, readSize, #NULL)
CloseHandle (hFile)
.如果真 (readSize ＝ 16)
    Hex ＝ 字节集_字节集到十六进制 (data)
    .判断开始 (Hex ≈ “FFD8FF”)  ' JPEG
        返回 (“JPEG”)
    .判断 (Hex ≈ “89504E470D0A1A0A0000000D49484452”)  ' PNG
        返回 (“PNG”)
    .判断 (Hex ≈ “47494638” 或 Hex ≈ “474946383761” 或 Hex ≈ “474946383961”)  ' GIF
        返回 (“GIF”)
    .判断 (Hex ≈ “49492A00” 或 Hex ≈ “4D4D002A” 或 Hex ≈ “49492A00”)  ' TIFF
        返回 (“TIFF”)
    .判断 (Hex ≈ “424D”)  ' BMP
        返回 (“BMP”)
    .判断 (Hex ≈ “0A”)  ' PCX
        返回 (“PCX”)
    .判断 (Hex ≈ “3C”)  ' SVG
        返回 (“SVG”)
    .判断 (Hex ≈ “38425053000100000000000000”)  ' PSD
        返回 (“PSD”)
    .判断 (Hex ≈ “465753”)  ' SWF
        返回 (“SWF”)
    .判断 (Hex ≈ “D7CDC69A0000”)  ' WMF
        返回 (“WMF”)
    .判断 (Hex ≈ “01000000”)  ' EMF
        返回 (“EMF”)
    .判断 (Hex ≈ “C5D0D3C6”)  ' EPS
        返回 (“EPS”)
    .判断 (Hex ≈ “0000020000” 或 Hex ≈ “0000100000”)  ' TGA
        返回 (“TGA”)
    .判断 (Hex ≈ “00000100”)  ' ICO
        返回 (“ICO”)
    .判断 (Hex ≈ “00000200”)  ' CUR
        返回 (“CUR”)
    .判断 (Hex ≈ “52494646”)  ' ANI
        返回 (“ANI”)
    .判断 (Hex ≈ “464F524D”)  ' IFF
        返回 (“IFF”)
    .默认
    .判断结束
.如果真结束
返回 (“”)
.程序集 类_识图, , 公开
.程序集变量 LF内容, 文本型
.程序集变量 LF颜色, 整数型
.程序集变量 LF大小, 整数型
.程序集变量 LF加粗, 整数型
.程序集变量 LF斜体, 逻辑型
.程序集变量 LF下划线, 逻辑型
.程序集变量 LF删除线, 逻辑型
.程序集变量 LF字体名称, 文本型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 制作范围, 精易_矩形, 公开, 生成一个矩形的范围,并返回
.参数 左边, 整数型, 可空, 查找范围的左边
.参数 顶边, 整数型, 可空, 查找范围的顶边
.参数 宽度, 整数型, 可空, 查找范围的宽度
.参数 高度, 整数型, 可空, 查找范围的高度
.局部变量 矩形, 精易_矩形
矩形.左边 ＝ 左边
矩形.顶边 ＝ 顶边
矩形.右边 ＝ 矩形.左边 ＋ 宽度
矩形.底边 ＝ 矩形.顶边 ＋ 高度
返回 (矩形)
.子程序 找图_从句柄, 精易_坐标, 公开, 在屏幕或指定窗口上找图，成功返回找到的位置坐标，失败坐标返回-1。，BUG命令谨慎使用
.参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
.参数 目标图片, 字节集, , 要查找的图片数据   bmp图片
.参数 寻找范围, 精易_矩形, 可空, 可空。可用 制作范围() 制作返回。留空为查找整个屏幕或窗口。
.参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
.局部变量 找到坐标, 精易_坐标
.局部变量 位图, 类_位图操作
.局部变量 保存位图1, 字节集
.局部变量 宽1, 整数型
.局部变量 高1, 整数型
.局部变量 保存位图2, 字节集
.局部变量 保存位图集, 字节集, , "0"
.局部变量 宽2, 整数型
.局部变量 高2, 整数型
.局部变量 补零2, 整数型
.局部变量 i, 整数型
.局部变量 找到位置, 整数型
.局部变量 i2, 整数型
.局部变量 窗口坐标, 精易_坐标
.局部变量 矩形范围, 精易_矩形
找到坐标.横 ＝ -1
找到坐标.纵 ＝ -1
.判断开始 (是否在后台)
    位图.从窗口创建 (窗口句柄, 寻找范围.左边, 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
.默认
    .如果真 (窗口句柄 ≠ 0)
        ClientToScreen (窗口句柄, 窗口坐标)
        GetClientRect (窗口句柄, 矩形范围)
        .如果真 (寻找范围.右边 ＝ 0 或 寻找范围.右边 ＞ 矩形范围.右边 － 寻找范围.左边)
            寻找范围.右边 ＝ 矩形范围.右边 － 寻找范围.左边
        .如果真结束
        .如果真 (寻找范围.底边 ＝ 0 或 寻找范围.底边 ＞ 矩形范围.底边 － 寻找范围.顶边)
            寻找范围.底边 ＝ 矩形范围.底边 － 寻找范围.顶边
        .如果真结束
    .如果真结束
    位图.从屏幕创建 (窗口坐标.横 ＋ 寻找范围.左边, 窗口坐标.纵 ＋ 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
.判断结束
保存位图1 ＝ 位图.取出颜色数据 ()
宽1 ＝ 位图.取宽度2 ()
高1 ＝ 位图.取高度2 ()
宽1 ＝ 宽1 ＋ (4 － 宽1 ％ 4) ％ 4  ' 将宽补足4位
.如果真 (位图.从数据创建 (目标图片) ＝ 假)  ' 创建失败,直接返回
    返回 (找到坐标)
.如果真结束
位图.转换位深度 (8)
保存位图2 ＝ 位图.取出颜色数据 ()
宽2 ＝ 位图.取宽度2 ()
高2 ＝ 位图.取高度2 ()
补零2 ＝ (4 － 宽2 ％ 4) ％ 4
清除数组 (保存位图集)
.计次循环首 (高2, i)
    加入成员 (保存位图集, 取字节集中间 (保存位图2, (宽2 ＋ 补零2) × (i － 1) ＋ 1, 宽2))
.计次循环尾 ()
.循环判断首 ()
    找到位置 ＝ 寻找字节集 (保存位图1, 保存位图集 [1], 找到位置 ＋ 1)
    ' 输出调试文本 (找到位置)
    .如果真 (找到位置 ＝ -1)
        返回 (找到坐标)
    .如果真结束
    .计次循环首 (高2 － 1, i2)
        .如果 (取字节集中间 (保存位图1, 找到位置 ＋ 宽1 × i2, 宽2) ＝ 保存位图集 [i2 ＋ 1])
            .如果真 (i2 ＝ 高2 － 1)
                找到坐标.横 ＝ (找到位置 － 1) ％ 宽1  ' 得到初始点坐标
                找到坐标.纵 ＝ 高1 － (找到位置 － 1) ＼ 宽1 － 1
                找到坐标.横 ＝ 找到坐标.横 ＋ 宽2 ＼ 2 ＋ 寻找范围.左边 ＋ 窗口坐标.横  ' 得到中心坐标
                找到坐标.纵 ＝ 找到坐标.纵 － 高2 ＼ 2 ＋ 寻找范围.顶边 ＋ 窗口坐标.纵
                返回 (找到坐标)
            .如果真结束
        .否则
            跳出循环 ()
        .如果结束
    .计次循环尾 ()
.循环判断尾 (找到位置 ＞ 0)
返回 (找到坐标)
.子程序 找图_从字节集, 精易_坐标, 公开, 在位图数据中找图片(返回找到的图片中心坐标,找不到返回-1坐标)，BUG命令谨慎使用
.参数 范围图片, 字节集, , 默认为上次范围图片
.参数 目标图片, 字节集, , 默认为上次目标图片
.局部变量 找到坐标, 精易_坐标
.局部变量 位图, 类_位图操作
.局部变量 保存位图1, 字节集
.局部变量 宽1, 整数型
.局部变量 高1, 整数型
.局部变量 保存位图2, 字节集
.局部变量 保存位图集, 字节集, , "0"
.局部变量 宽2, 整数型
.局部变量 高2, 整数型
.局部变量 补零2, 整数型
.局部变量 i, 整数型
.局部变量 找到位置, 整数型
.局部变量 i2, 整数型
找到坐标.横 ＝ -1
找到坐标.纵 ＝ -1
.如果真 (位图.从数据创建 (范围图片) ＝ 假)
    返回 (找到坐标)
.如果真结束
位图.转换位深度 (8)
保存位图1 ＝ 位图.取出颜色数据 ()
宽1 ＝ 位图.取宽度2 ()
高1 ＝ 位图.取高度2 ()
宽1 ＝ 宽1 ＋ (4 － 宽1 ％ 4) ％ 4  ' 将宽补足4位
.如果真 (位图.从数据创建 (目标图片) ＝ 假)
    返回 (找到坐标)
.如果真结束
位图.转换位深度 (8)
保存位图2 ＝ 位图.取出颜色数据 ()
宽2 ＝ 位图.取宽度2 ()
高2 ＝ 位图.取高度2 ()
补零2 ＝ (4 － 宽2 ％ 4) ％ 4
.计次循环首 (高2, i)
    加入成员 (保存位图集, 取字节集中间 (保存位图2, (宽2 ＋ 补零2) × (i － 1) ＋ 1, 宽2))
.计次循环尾 ()
.循环判断首 ()
    找到位置 ＝ 寻找字节集 (保存位图1, 保存位图集 [1], 找到位置 ＋ 1)
    .如果真 (找到位置 ＝ -1)
        返回 (找到坐标)
    .如果真结束
    .计次循环首 (高2 － 1, i2)
        .如果 (取字节集中间 (保存位图1, 找到位置 ＋ 宽1 × i2, 宽2) ＝ 保存位图集 [i2 ＋ 1])
            .如果真 (i2 ＝ 高2 － 1)
                找到坐标.横 ＝ (找到位置 － 1) ％ 宽1  ' 得到初始点坐标
                找到坐标.纵 ＝ 高1 － (找到位置 － 1) ＼ 宽1 － 1
                找到坐标.横 ＝ 找到坐标.横 ＋ 宽2 ＼ 2  ' 得到中心坐标
                找到坐标.纵 ＝ 找到坐标.纵 － 高2 ＼ 2
                返回 (找到坐标)
            .如果真结束
        .否则
            跳出循环 ()
        .如果结束
    .计次循环尾 ()
.循环判断尾 (找到位置 ＞ 0)
返回 (找到坐标)
.子程序 找字_初始化, , 公开, 在使用 找字() 命令前,必须先初始化本命令
.参数 要查找的文字, 文本型
.参数 文字的颜色, 整数型
.参数 文字的字体, 字体, 可空, 可空。默认：9号宋体
LF内容 ＝ 要查找的文字
LF颜色 ＝ 文字的颜色
LF大小 ＝ 文字的字体.字体大小
.如果 (文字的字体.加粗)
    LF加粗 ＝ 700
.否则
    LF加粗 ＝ 400
.如果结束
LF斜体 ＝ 文字的字体.倾斜
LF下划线 ＝ 文字的字体.下划线
LF删除线 ＝ 文字的字体.删除线
LF字体名称 ＝ 文字的字体.字体名称
.子程序 找字, 精易_坐标, 公开, 在屏幕或指定窗口上找字。使用此命令前，必须先使用 找字_初始化() 命令。成功返回找到的位置坐标，失败坐标返回-1。
.参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
.参数 寻找范围, 精易_矩形, 可空, 可空。可用 制作范围() 制作返回。留空为查找整个屏幕或窗口。
.参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
.参数 吻合值, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
.参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
.局部变量 找到坐标, 精易_坐标
.局部变量 位图, 类_位图操作
.局部变量 相同点阵, 精易_坐标, , "0"
.局部变量 不同点阵, 精易_坐标, , "0"
.局部变量 窗口坐标, 精易_坐标
.局部变量 矩形范围, 精易_矩形
.如果 (是否在后台)
    位图.从窗口创建 (窗口句柄, 寻找范围.左边, 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
.否则
    .如果真 (窗口句柄 ≠ 0)
        ClientToScreen (窗口句柄, 窗口坐标)
        GetClientRect (窗口句柄, 矩形范围)
        .如果真 (寻找范围.右边 ＝ 0 或 寻找范围.右边 ＞ 矩形范围.右边 － 寻找范围.左边)
            寻找范围.右边 ＝ 矩形范围.右边 － 寻找范围.左边
        .如果真结束
        .如果真 (寻找范围.底边 ＝ 0 或 寻找范围.底边 ＞ 矩形范围.底边 － 寻找范围.顶边)
            寻找范围.底边 ＝ 矩形范围.底边 － 寻找范围.顶边
        .如果真结束
    .如果真结束
    位图.从屏幕创建 (窗口坐标.横 ＋ 寻找范围.左边, 窗口坐标.纵 ＋ 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
.如果结束
取文字点阵 (相同点阵, 不同点阵)
找到坐标 ＝ 找点阵 (位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵, 误差值, 吻合值)
.如果真 (找到坐标.横 ＝ -1)
    返回 (找到坐标)
.如果真结束
找到坐标.横 ＝ 找到坐标.横 ＋ 寻找范围.左边 ＋ 窗口坐标.横
找到坐标.纵 ＝ 找到坐标.纵 ＋ 寻找范围.顶边 ＋ 窗口坐标.纵
返回 (找到坐标)
.子程序 找字_从字节集, 精易_坐标, 公开, 在指定的图片位图上寻找指定的文字。使用此命令前，必须先使用 找字_初始化() 命令。成功返回找到的位置坐标，失败坐标返回-1。
.参数 位图数据, 字节集, , 欲被查找的图片
.参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
.参数 吻合值, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
.局部变量 位图, 类_位图操作
.局部变量 相同点阵, 精易_坐标, , "0"
.局部变量 不同点阵, 精易_坐标, , "0"
位图.从数据创建 (位图数据)
.如果真 (位图.取位深度 () ≠ 8)
    位图.转换位深度 (8)
.如果真结束
取文字点阵 (相同点阵, 不同点阵)
返回 (找点阵 (位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵, 误差值, 吻合值))
.子程序 找字_批量, 整数型, 公开, 在指定的图片位图上找出所有指定文字的坐标。使用此命令前，必须先使用 找字_初始化() 命令。成功返回坐标数组。
.参数 坐标数组, 精易_坐标, 可空 数组, 请提供一个"精易_坐标"类型的变量数组，用于接收找到的坐标数组。
.参数 位图数据, 字节集, , 欲被查找的图片
.参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
.参数 前景吻合度, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
.参数 背景吻合度, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
.局部变量 位图, 类_位图操作
.局部变量 相同点阵, 精易_坐标, , "0"
.局部变量 不同点阵, 精易_坐标, , "0"
位图.从数据创建 (位图数据)
.如果真 (位图.取位深度 () ≠ 8)
    位图.转换位深度 (8)
.如果真结束
取文字点阵 (相同点阵, 不同点阵)
返回 (找点阵2 (坐标数组, 位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵, 误差值, 前景吻合度, 背景吻合度))
.子程序 取色, 整数型, 公开, 在屏幕或指定窗口上取出某点的颜色值，成功返回10进制颜色值。
.参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
.参数 水平位置, 整数型, , 目标横坐标
.参数 垂直位置, 整数型, , 目标纵坐标
.参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
.局部变量 位图, 类_位图操作
.局部变量 坐标, 精易_坐标
.如果 (是否在后台)
    位图.从窗口创建 (窗口句柄, 水平位置, 垂直位置, 1, 1, 24)
.否则
    .如果真 (窗口句柄 ≠ 0)
        ClientToScreen (窗口句柄, 坐标)
    .如果真结束
    位图.从屏幕创建 (坐标.横 ＋ 水平位置, 坐标.纵 ＋ 垂直位置, 1, 1, 24)
.如果结束
返回 (位图.取某点颜色 (0, 0))
.子程序 找色, 精易_坐标, 公开, 在屏幕或指定窗口上找指定的颜色，成功返回此颜色的坐标，失败坐标返回为-1
.参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
.参数 要查找的颜色值, 整数型, , 要查找的颜色值
.参数 寻找范围, 精易_矩形, 可空, 可空。可用 制作范围() 制作返回。留空为查找整个屏幕或窗口。
.参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
.参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
.局部变量 保存颜色值, 字节集
.局部变量 找到位置, 整数型
.局部变量 位图, 类_位图操作
.局部变量 坐标, 精易_坐标
.局部变量 实际宽, 整数型
.局部变量 矩形范围, 精易_矩形
保存颜色值 ＝ 到可用颜色2 (要查找的颜色值)
.如果 (是否在后台)
    位图.从窗口创建 (窗口句柄, 寻找范围.左边, 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
.否则
    .如果真 (窗口句柄 ≠ 0)
        ClientToScreen (窗口句柄, 坐标)
        GetClientRect (窗口句柄, 矩形范围)
        .如果真 (寻找范围.右边 ＝ 0 或 寻找范围.右边 ＞ 矩形范围.右边 － 寻找范围.左边)
            寻找范围.右边 ＝ 矩形范围.右边 － 寻找范围.左边
        .如果真结束
        .如果真 (寻找范围.底边 ＝ 0 或 寻找范围.底边 ＞ 矩形范围.底边 － 寻找范围.顶边)
            寻找范围.底边 ＝ 矩形范围.底边 － 寻找范围.顶边
        .如果真结束
    .如果真结束
    位图.从屏幕创建 (坐标.横 ＋ 寻找范围.左边, 坐标.纵 ＋ 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
.如果结束
坐标.横 ＝ -1
坐标.纵 ＝ -1
实际宽 ＝ 位图.取宽度2 ()
实际宽 ＝ 实际宽 ＋ (4 － 实际宽 ％ 4) ％ 4  ' 将宽补足4位
.如果 (误差值 ＝ 0)
    找到位置 ＝ 寻找字节集 (位图.取出颜色数据 (), 保存颜色值, 找到位置 ＋ 1)
.否则
    找到位置 ＝ 寻找字节集_字节 (位图.取出颜色数据 (), 取字节集数据 (保存颜色值, #字节型, ), 误差值, 找到位置 ＋ 1)
.如果结束
.如果真 (找到位置 ≠ -1)
    坐标.横 ＝ (找到位置 － 1) ％ 实际宽
    坐标.纵 ＝ 位图.取高度2 () － (找到位置 － 1) ＼ 实际宽 － 1
.如果真结束
返回 (坐标)
.子程序 取出数值, 整数型, , 从标准数值的截图中取出它的数值(成功返回数值,失败返回-1)
.参数 位图数据, 字节集, , 标准数值的截图(建议小图,不宜掺杂多余数字)
.参数 颜色, 整数型, 可空, 默认为 #白色
.参数 字体, 字体, 可空, 默认为9号宋体字
.局部变量 位图, 类_位图操作
.局部变量 字符表, 文本型, , "0"
.局部变量 相同点阵, 精易_坐标, , "0"
.局部变量 不同点阵, 精易_坐标, , "0"
.局部变量 找到坐标, 精易_坐标, , "0"
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 位置, 整数型
.局部变量 结果, 文本型, , "0"
.局部变量 返回内容, 文本型
位图.从数据创建 (位图数据)
.如果真 (位图.取位深度 () ≠ 8)
    位图.转换位深度 (8)
.如果真结束
找字_初始化 (“”, 颜色, 字体)
重定义数组 (结果, 假, 位图.取宽度2 ())
字符表 ＝ { “0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”, “8”, “9” }
.计次循环首 (取数组成员数 (字符表), i)
    LF内容 ＝ 字符表 [i]
    取文字点阵 (相同点阵, 不同点阵)
    .计次循环首 (找点阵5 (找到坐标, 位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵), i2)
        位置 ＝ 找到坐标 [i2].横
        结果 [位置] ＝ 字符表 [i]
    .计次循环尾 ()
.计次循环尾 ()
.计次循环首 (取数组成员数 (结果), i)
    .如果真 (结果 [i] ≠ “”)
        返回内容 ＝ 返回内容 ＋ 结果 [i]
    .如果真结束
.计次循环尾 ()
.如果真 (返回内容 ＝ “”)
    返回 (-1)
.如果真结束
返回 (到数值 (返回内容))
.子程序 高级找色, 精易_坐标, , 在位图数据中找颜色(返回找到的颜色所在位图中的坐标,找不到返回-1坐标)
.参数 位图数据, 字节集, 可空, 非首次查找可将本参数留空,表示采用上次的位图数据
.参数 颜色值, 整数型, 可空, 非首次查找可将本参数留空,可接着上次找到的点往下找
.参数 误差, 整数型, 可空, 默认为0 表示最低误差值 最大值为255,建议0-10之间
.局部变量 保存位图, 字节集, 静态
.局部变量 保存颜色值, 字节集, 静态
.局部变量 找到位置, 整数型, 静态
.局部变量 宽, 整数型, 静态
.局部变量 高, 整数型, 静态
.局部变量 位图, 类_位图操作
.局部变量 坐标, 精易_坐标
.如果真 (是否为空 (颜色值) ＝ 假)
    保存颜色值 ＝ 到可用颜色2 (颜色值)
    找到位置 ＝ 0
.如果真结束
.如果真 (位图数据 ≠ {  })
    位图.从数据创建 (位图数据)
    位图.转换位深度 (8)
    保存位图 ＝ 位图.取出颜色数据 ()
    宽 ＝ 位图.取宽度2 ()
    高 ＝ 位图.取高度2 ()
    宽 ＝ 宽 ＋ (4 － 宽 ％ 4) ％ 4  ' 将宽补足4位
.如果真结束
坐标.横 ＝ -1
坐标.纵 ＝ -1
.如果 (误差 ＝ 0)
    找到位置 ＝ 寻找字节集 (保存位图, 保存颜色值, 找到位置 ＋ 1)
.否则
    找到位置 ＝ 寻找字节集_字节 (保存位图, 取字节集数据 (保存颜色值, #字节型, ), 误差, 找到位置 ＋ 1)
.如果结束
.如果真 (找到位置 ≠ -1)
    坐标.横 ＝ (找到位置 － 1) ％ 宽
    坐标.纵 ＝ 高 － (找到位置 － 1) ＼ 宽 － 1
.如果真结束
返回 (坐标)
.子程序 高级找图, 精易_坐标, , 在位图数据中找图片(返回找到的图片左下角第一个有效点的坐标,找不到返回-1坐标)
.参数 范围图片, 字节集, 可空, 默认为上次范围图片
.参数 目标图片, 字节集, 可空, 默认为上次目标图片 (建议使用10*10以内位图)
.参数 透明色, 整数型, 可空, 目标图片中欲被忽略的颜色值  默认为-1 如果目标图片为空,为上次透明色
.参数 吻合度, 整数型, 可空, 默认为100完全吻合 相吻合的百分比(0-100之间)建议90以上
.参数 误差值, 整数型, 可空, 默认为0 表示最低误差值 最大值为255,建议0-10之间
.局部变量 找到坐标, 精易_坐标
.局部变量 位图, 类_位图操作
.局部变量 保存位图1, 字节集, 静态
.局部变量 宽1, 整数型, 静态
.局部变量 高1, 整数型, 静态
.局部变量 基色, 整数型, 静态
.局部变量 颜色点阵, 点阵型, 静态, "0"
找到坐标.横 ＝ -1
找到坐标.纵 ＝ -1
.如果 (范围图片 ≠ {  })
    保存位图1 ＝ {  }
    .如果真 (位图.从数据创建 (范围图片) ＝ 假)
        返回 (找到坐标)
    .如果真结束
    位图.转换位深度 (8)
    保存位图1 ＝ 位图.取出颜色数据 ()
    宽1 ＝ 位图.取宽度2 ()
    高1 ＝ 位图.取高度2 ()
.否则
    .如果真 (保存位图1 ＝ {  })
        返回 (找到坐标)
    .如果真结束
.如果结束
.如果真 (是否为空 (透明色))
    透明色 ＝ -1
.如果真结束
.如果真 (是否为空 (目标图片) ＝ 假)
    基色 ＝ 取图片点阵 (目标图片, 透明色, 颜色点阵)
.如果真结束
.如果真 (基色 ＝ -1)
    返回 (找到坐标)
.如果真结束
返回 (找点阵3 (保存位图1, 宽1, 高1, 颜色点阵, 基色, 误差值, 吻合度))
.子程序 高级找图2, 整数型, , 在位图数据中找出图片所有坐标点(返回找到的图片数目,找不到返回0)
.参数 找到坐标, 精易_坐标, 可空 数组, 返回所有找到的(图片左下角第一个有效点的坐标)坐标数组
.参数 范围图片, 字节集, 可空, 默认为上次范围图片
.参数 目标图片, 字节集, 可空, 默认为上次目标图片 (建议使用10*10以内位图)
.参数 透明色, 整数型, 可空, 目标图片中欲被忽略的颜色值  默认为-1 如果目标图片为空,为上次透明色
.参数 吻合度, 整数型, 可空, 默认为100完全吻合 相吻合的百分比(0-100之间)建议90以上
.参数 误差值, 整数型, 可空, 默认为0 表示最低误差值 最大值为255,建议0-10之间
.局部变量 位图, 类_位图操作
.局部变量 保存位图1, 字节集, 静态
.局部变量 宽1, 整数型, 静态
.局部变量 高1, 整数型, 静态
.局部变量 基色, 整数型, 静态
.局部变量 颜色点阵, 点阵型, 静态, "0"
.如果 (范围图片 ≠ {  })
    保存位图1 ＝ {  }
    .如果真 (位图.从数据创建 (范围图片) ＝ 假)
        返回 (0)
    .如果真结束
    位图.转换位深度 (8)
    保存位图1 ＝ 位图.取出颜色数据 ()
    宽1 ＝ 位图.取宽度2 ()
    高1 ＝ 位图.取高度2 ()
.否则
    .如果真 (保存位图1 ＝ {  })
        返回 (0)
    .如果真结束
.如果结束
.如果真 (是否为空 (透明色))
    透明色 ＝ -1
.如果真结束
.如果真 (是否为空 (目标图片) ＝ 假)
    基色 ＝ 取图片点阵 (目标图片, 透明色, 颜色点阵)
.如果真结束
.如果真 (基色 ＝ -1)
    返回 (0)
.如果真结束
返回 (找点阵4 (找到坐标, 保存位图1, 宽1, 高1, 颜色点阵, 基色, 误差值, 吻合度))
.子程序 高级精确找图2, 整数型, , 在位图数据中找出图片所有坐标点(返回找到的图片数目,找不到返回0)
.参数 找到坐标, 精易_坐标, 可空 数组, 返回所有找到的(图片中心)坐标数组
.参数 范围图片, 字节集, 可空, 默认为上次范围图片
.参数 目标图片, 字节集, 可空, 默认为上次目标图片
.局部变量 临时坐标, 精易_坐标
.局部变量 位图, 类_位图操作
.局部变量 保存位图1, 字节集, 静态
.局部变量 宽1, 整数型, 静态
.局部变量 高1, 整数型, 静态
.局部变量 保存位图2, 字节集, 静态
.局部变量 保存位图集, 字节集, 静态, "0"
.局部变量 宽2, 整数型, 静态
.局部变量 高2, 整数型, 静态
.局部变量 补零2, 整数型, 静态
.局部变量 保存忽略色, 整数型, 静态
.局部变量 i, 整数型
.局部变量 找到位置, 整数型
.局部变量 i2, 整数型
.如果 (范围图片 ≠ {  })
    保存位图1 ＝ {  }
    .如果真 (位图.从数据创建 (范围图片) ＝ 假)
        返回 (0)
    .如果真结束
    位图.转换位深度 (8)
    保存位图1 ＝ 位图.取出颜色数据 ()
    宽1 ＝ 位图.取宽度2 ()
    高1 ＝ 位图.取高度2 ()
    宽1 ＝ 宽1 ＋ (4 － 宽1 ％ 4) ％ 4  ' 将宽补足4位
.否则
    .如果真 (保存位图1 ＝ {  })
        返回 (0)
    .如果真结束
.如果结束
.如果 (目标图片 ≠ {  })
    保存位图2 ＝ {  }
    .如果真 (位图.从数据创建 (目标图片) ＝ 假)
        返回 (0)
    .如果真结束
    位图.转换位深度 (8)
    保存位图2 ＝ 位图.取出颜色数据 ()
    宽2 ＝ 位图.取宽度2 ()
    高2 ＝ 位图.取高度2 ()
    补零2 ＝ (4 － 宽2 ％ 4) ％ 4
    清除数组 (保存位图集)
    .计次循环首 (高2, i)
        加入成员 (保存位图集, 取字节集中间 (保存位图2, (宽2 ＋ 补零2) × (i － 1) ＋ 1, 宽2))
    .计次循环尾 ()
.否则
    .如果真 (保存位图2 ＝ {  })
        返回 (0)
    .如果真结束
.如果结束
.循环判断首 ()
    找到位置 ＝ 寻找字节集 (保存位图1, 保存位图集 [1], 找到位置 ＋ 1)
    ' 输出调试文本 (找到位置)
    .如果真 (找到位置 ＝ -1)
        跳出循环 ()
    .如果真结束
    .计次循环首 (高2 － 1, i2)
        .如果 (取字节集中间 (保存位图1, 找到位置 ＋ 宽1 × i2, 宽2) ＝ 保存位图集 [i2 ＋ 1])
            .如果真 (i2 ＝ 高2 － 1)
                临时坐标.横 ＝ (找到位置 － 1) ％ 宽1  ' 得到初始点坐标
                临时坐标.纵 ＝ 高1 － (找到位置 － 1) ＼ 宽1 － 1
                临时坐标.横 ＝ 临时坐标.横 ＋ 宽2 ＼ 2  ' 得到中心坐标
                临时坐标.纵 ＝ 临时坐标.纵 － 高2 ＼ 2
                加入成员 (找到坐标, 临时坐标)
            .如果真结束
        .否则
            跳出循环 ()
        .如果结束
    .计次循环尾 ()
.循环判断尾 (找到位置 ＞ 0)
返回 (取数组成员数 (找到坐标))
.子程序 到可用颜色, 整数型
.参数 颜色值, 整数型
.局部变量 位图, 类_位图操作
' 0.299R 0.587G 0.114B
位图.创建空白位图 (1, 1, 32)
位图.置某点颜色 (0, 0, 颜色值)
位图.转换位深度 (8)
返回 (取字节集数据 (位图.取出颜色数据 (), #字节型, 1))
.子程序 到可用颜色2, 字节集
.参数 颜色值, 整数型
.局部变量 位图, 类_位图操作
位图.创建空白位图 (1, 1, 32)
位图.置某点颜色 (0, 0, 颜色值)
位图.转换位深度 (8)
返回 (取字节集左边 (位图.取出颜色数据 (), 1))
.子程序 到可用图片, 字节集, , <用不到,仅作参考>
.参数 图片数据, 字节集
.局部变量 位图, 类_位图操作
位图.从数据创建 (图片数据)
位图.转换位深度 (8)
返回 (位图.取出颜色数据 ())
.子程序 寻找字节集_字节, 整数型
.参数 字节集, 字节集
.参数 字节, 整数型
.参数 误差, 整数型
.参数 起始位置, 整数型, 可空
.局部变量 i, 整数型
.计次循环首 (取字节集长度 (字节集), i)
    .如果真 (取绝对值 (字节集 [i] － 字节) ≤ 误差 且 i ≥ 起始位置)
        返回 (i)
    .如果真结束
.计次循环尾 ()
返回 (-1)
.子程序 寻找字节集3, 整数型, , 返回一字节集在另一字节集中最先出现的位置，位置值从 1 开始。如果未找到，返回 -1
.参数 被搜寻的字节集, 字节集
.参数 欲寻找的字节集, 字节集
.参数 起始寻找位置, 整数型, 可空, 可空为1
.参数 忽略值, 整数型, 可空, 欲寻找的字节集中,被忽略的字节值
.参数 误差值, 整数型, 可空, 寻找字节集的误差值 每个字节(0-255)所允许的最大差值
.局部变量 计次1, 整数型
.局部变量 长度, 整数型
.局部变量 计次2, 整数型
.局部变量 总长度, 整数型
.如果真 (起始寻找位置 ＜ 1)
    起始寻找位置 ＝ 1
.如果真结束
长度 ＝ 取字节集长度 (欲寻找的字节集)
总长度 ＝ 取字节集长度 (被搜寻的字节集)
.如果 (忽略值 ＝ -1)
    .如果 (误差值 ＝ 0)
        返回 (寻找字节集 (被搜寻的字节集, 欲寻找的字节集, 起始寻找位置))
    .否则
        .计次循环首 (总长度 － 长度 ＋ 1, 计次1)
            .如果真 (计次1 ≥ 起始寻找位置 且 取绝对值 (欲寻找的字节集 [1] － 被搜寻的字节集 [计次1]) ≤ 误差值)
                计次2 ＝ 1
                .循环判断首 ()  ' 循环判断比计次循环效率要高得多
                    .如果真 (计次2 ＝ 长度)
                        返回 (计次1)
                    .如果真结束
                    计次2 ＝ 计次2 ＋ 1
                .循环判断尾 (取绝对值 (欲寻找的字节集 [计次2] － 被搜寻的字节集 [计次1 ＋ 计次2 － 1]) ≤ 误差值)
            .如果真结束
        .计次循环尾 ()
    .如果结束
.否则
    .如果 (误差值 ＝ 0)
        .计次循环首 (总长度 － 长度 ＋ 1, 计次1)
            .如果真 (计次1 ≥ 起始寻找位置 且 欲寻找的字节集 [1] ＝ 被搜寻的字节集 [计次1])
                计次2 ＝ 1
                .循环判断首 ()  ' 循环判断比计次循环效率要高得多
                    .如果真 (计次2 ＝ 长度)
                        返回 (计次1)
                    .如果真结束
                    计次2 ＝ 计次2 ＋ 1
                .循环判断尾 (忽略值 ＝ 欲寻找的字节集 [计次2] 或 欲寻找的字节集 [计次2] ＝ 被搜寻的字节集 [计次1 ＋ 计次2 － 1])
            .如果真结束
        .计次循环尾 ()
    .否则
        .计次循环首 (总长度 － 长度 ＋ 1, 计次1)
            .如果真 (计次1 ≥ 起始寻找位置)
                计次2 ＝ 1
                .判断循环首 (忽略值 ＝ 欲寻找的字节集 [计次2] 或 取绝对值 (欲寻找的字节集 [计次2] － 被搜寻的字节集 [计次1 ＋ 计次2 － 1]) ≤ 误差值)
                    .如果真 (计次2 ＝ 长度)
                        返回 (计次1)
                    .如果真结束
                    计次2 ＝ 计次2 ＋ 1
                .判断循环尾 ()
            .如果真结束
        .计次循环尾 ()
    .如果结束
.如果结束
返回 (-1)
.子程序 是否吻合, 逻辑型, , 判断两段同长度字节集是否相似
.参数 字节集1, 字节集
.参数 字节集2, 字节集, , 忽略值
.参数 忽略值, 整数型, , -1
.参数 误差值, 整数型, , 0-255之间,0为必须完全吻合
.局部变量 长, 整数型
.局部变量 I, 整数型
长 ＝ 取字节集长度 (字节集1)
.如果真 (取字节集长度 (字节集2) ≠ 长)
    返回 (假)
.如果真结束
.如果 (忽略值 ＝ -1)
    .如果 (误差值 ＝ 0)
        .计次循环首 (长, I)
            .如果真 (字节集1 [I] ≠ 字节集2 [I])
                返回 (假)
            .如果真结束
        .计次循环尾 ()
    .否则
        .计次循环首 (长, I)
            .如果真 (取绝对值 (字节集1 [I] － 字节集2 [I]) ＞ 误差值)
                返回 (假)
            .如果真结束
        .计次循环尾 ()
    .如果结束
.否则
    .如果 (误差值 ＝ 0)
        .计次循环首 (长, I)
            .如果真 (忽略值 ≠ 字节集2 [I] 且 字节集1 [I] ≠ 字节集2 [I])
                返回 (假)
            .如果真结束
        .计次循环尾 ()
    .否则
        .计次循环首 (长, I)
            .如果真 (忽略值 ≠ 字节集2 [I] 且 取绝对值 (字节集1 [I] － 字节集2 [I]) ＞ 误差值)
                返回 (假)
            .如果真结束
        .计次循环尾 ()
    .如果结束
.如果结束
返回 (真)
.子程序 取文字点阵
.参数 前景偏移点, 精易_坐标, 参考 可空 数组
.参数 背景偏移点, 精易_坐标, 参考 可空 数组
.局部变量 点, 精易_坐标
.局部变量 基点, 精易_坐标
.局部变量 hdc, 整数型
.局部变量 场景句柄, 整数型
.局部变量 高, 整数型
.局部变量 hf, 整数型
.局部变量 h, 整数型
.局部变量 hbk, 整数型
.局部变量 htext, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 位图句柄, 整数型
清除数组 (前景偏移点)
清除数组 (背景偏移点)
hdc ＝ GetDC (0)
高 ＝ LF大小 × GetDeviceCaps (hdc, 90) ÷ 72
场景句柄 ＝ CreateCompatibleDC (hdc)
位图句柄 ＝ CreateCompatibleBitmap (hdc, 高 × 取文本长度 (LF内容) ＼ 2, 高)
SelectObject (场景句柄, 位图句柄)
hf ＝ CreateFontA (高, 0, 0, 0, LF加粗, LF斜体, LF下划线, LF删除线, 134, 0, 0, 0, 0, LF字体名称)
h ＝ SelectObject (场景句柄, hf)
hbk ＝ SetBkMode (场景句柄, 1)
htext ＝ SetTextColor (场景句柄, 255)
TextOutA (场景句柄, 0, 0, LF内容, 取文本长度 (LF内容))
SetBkMode (场景句柄, hbk)
SetTextColor (场景句柄, htext)
SelectObject (场景句柄, h)
DeleteObject (hf)
基点.横 ＝ -1
.计次循环首 (高, y)
    .计次循环首 (高 × 取文本长度 (LF内容) ＼ 2, x)
        .如果 (基点.横 ＝ -1)
            .如果真 (GetPixel (场景句柄, x － 1, 高 － y) ＞ 0)
                基点.横 ＝ x － 1
                基点.纵 ＝ 高 － y
            .如果真结束
        .否则
            点.横 ＝ x － 1 － 基点.横
            点.纵 ＝ 基点.纵 － (高 － y)
            .如果 (GetPixel (场景句柄, x － 1, 高 － y) ＞ 0)
                加入成员 (前景偏移点, 点)
            .否则
                加入成员 (背景偏移点, 点)
            .如果结束
        .如果结束
    .计次循环尾 ()
.计次循环尾 ()
.计次循环首 (高, y)
    .计次循环首 (高 × 取文本长度 (LF内容) ＼ 2, x)
        .如果真 (GetPixel (场景句柄, x － 1, 高 － y) ＞ 0)
            跳出循环 ()
        .如果真结束
        点.横 ＝ x － 1 － 基点.横
        点.纵 ＝ 基点.纵 － (高 － y)
        加入成员 (背景偏移点, 点)
    .计次循环尾 ()
    .如果真 (基点.纵 ＝ 高 － y)
        .如果真 (基点.横 ＝ x － 1)
            跳出循环 ()
        .如果真结束
    .如果真结束
.计次循环尾 ()
DeleteDC (场景句柄)
ReleaseDC (0, hdc)
.子程序 取图片点阵, 整数型, , 成功返回255基点颜色,失败返回-1
.参数 目标图片, 字节集
.参数 透明色, 整数型, 参考, 返回255颜色值,无透明色-1
.参数 前景偏移点, 点阵型, 参考 数组
.局部变量 位图, 类_位图操作
.局部变量 颜色数据, 字节集
.局部变量 宽, 整数型
.局部变量 高, 整数型
.局部变量 补零, 整数型
.局部变量 临时字节集, 字节集
.局部变量 y, 整数型
.局部变量 x, 整数型
.局部变量 临时偏移点, 点阵型
.局部变量 基点, 点阵型
.如果真 (位图.从数据创建 (目标图片) ＝ 假)
    返回 (-1)
.如果真结束
位图.转换位深度 (8)
颜色数据 ＝ 位图.取出颜色数据 ()
宽 ＝ 位图.取宽度2 ()
高 ＝ 位图.取高度2 ()
补零 ＝ (4 － 宽 ％ 4) ％ 4
.如果真 (透明色 ≠ -1)
    透明色 ＝ 到可用颜色 (透明色)
.如果真结束
基点.z ＝ -1
.计次循环首 (高, y)
    临时字节集 ＝ 取字节集中间 (颜色数据, (宽 ＋ 补零) × (y － 1) ＋ 1, 宽)
    .计次循环首 (宽, x)
        .如果真 (临时字节集 [x] ≠ 透明色)
            .如果 (基点.z ＝ -1)
                基点.x ＝ x － 1
                基点.y ＝ 高 － y
                基点.z ＝ 临时字节集 [x]
            .否则
                临时偏移点.x ＝ x － 1 － 基点.x
                临时偏移点.y ＝ 基点.y － (高 － y)
                临时偏移点.z ＝ 临时字节集 [x]
                加入成员 (前景偏移点, 临时偏移点)
                ' 输出调试文本 (临时偏移点.z)
            .如果结束
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
返回 (基点.z)
.子程序 找点阵, 精易_坐标, , 找字
.参数 数据, 字节集
.参数 宽, 整数型
.参数 高, 整数型
.参数 点阵, 精易_坐标, 数组
.参数 不同点阵, 精易_坐标, 数组
.参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
.参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
.局部变量 颜色值, 整数型
.局部变量 找到坐标, 精易_坐标
.局部变量 总长, 整数型
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 i3, 整数型
.局部变量 i4, 整数型
.局部变量 行字节集, 字节集
.局部变量 位置, 整数型
.局部变量 吻合值, 整数型
.局部变量 已吻合值, 整数型
.局部变量 不吻合值, 整数型
.局部变量 临时颜色值, 整数型
.局部变量 补零, 字节型
找到坐标.横 ＝ -1
找到坐标.纵 ＝ -1
总长 ＝ 取字节集长度 (数据)
颜色值 ＝ 到可用颜色 (LF颜色)
.如果 (符合程度 ＝ 0)
    吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
    不吻合值 ＝ 取数组成员数 (不同点阵) × 100 ＼ 100
.否则
    吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
    不吻合值 ＝ 取数组成员数 (不同点阵) × 符合程度 ＼ 100
.如果结束
补零 ＝ (4 － 宽 ％ 4) ％ 4
.计次循环首 (高, i)
    行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
    .计次循环首 (宽, i2)
        .如果真 (取绝对值 (行字节集 [i2] － 颜色值) ≤ 误差值)
            已吻合值 ＝ 0
            .计次循环首 (取数组成员数 (点阵), i3)
                位置 ＝ i2 ＋ 点阵 [i3].横 － 1  ' 这是X位置
                .如果真 (位置 ＞ 宽)  ' 偏移点超出范围
                    ' 输出调试文本 (“超出”)
                    跳出循环 ()
                .如果真结束
                位置 ＝ (宽 ＋ 补零) × (点阵 [i3].纵 ＋ i － 1) ＋ 位置 ＋ 1
                .如果真 (总长 ＜ 位置)
                    ' 输出调试文本 (“超出2”)
                    跳出循环 ()
                .如果真结束
                .如果真 (取绝对值 (数据 [位置] － 行字节集 [i2]) ≤ 误差值)
                    已吻合值 ＝ 已吻合值 ＋ 1
                    临时颜色值 ＝ 行字节集 [i2]
                    .如果真 (已吻合值 ≥ 吻合值)
                        .如果真 (取数组成员数 (不同点阵) ＝ 0)
                            ' 输出调试文本 (当前吻合值)
                            找到坐标.横 ＝ i2 － 1
                            找到坐标.纵 ＝ 高 － i
                            返回 (找到坐标)
                        .如果真结束
                        已吻合值 ＝ 0
                        .计次循环首 (取数组成员数 (不同点阵), i4)  ' 判断文字以外点与文字颜色不同,防止找到的是色块不是文字!!
                            位置 ＝ i2 ＋ 不同点阵 [i4].横 － 1
                            .如果真 (位置 ＞ 宽)
                                跳出循环 ()
                            .如果真结束
                            位置 ＝ 1 ＋ (宽 ＋ 补零) × (不同点阵 [i4].纵 ＋ i － 1) ＋ 位置
                            .如果真 (总长 ＜ 位置 ＋ 2)
                                跳出循环 ()
                            .如果真结束
                            .如果真 (数据 [位置] ＝ 临时颜色值)
                                到循环尾 ()
                            .如果真结束
                            已吻合值 ＝ 已吻合值 ＋ 1
                            .如果真 (已吻合值 ≥ 不吻合值)
                                找到坐标.横 ＝ i2 － 1
                                找到坐标.纵 ＝ 高 － i
                                返回 (找到坐标)
                            .如果真结束
                        .计次循环尾 ()
                        跳出循环 ()
                    .如果真结束
                .如果真结束
            .计次循环尾 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
返回 (找到坐标)
.子程序 找点阵2, 整数型, , 找所有字
.参数 坐标组, 精易_坐标, 可空 数组
.参数 数据, 字节集
.参数 宽, 整数型
.参数 高, 整数型
.参数 点阵, 精易_坐标, 数组
.参数 不同点阵, 精易_坐标, 数组
.参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
.参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
.参数 符合程度2, 整数型
.局部变量 颜色值, 整数型
.局部变量 找到坐标, 精易_坐标
.局部变量 总长, 整数型
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 i3, 整数型
.局部变量 i4, 整数型
.局部变量 行字节集, 字节集
.局部变量 位置, 整数型
.局部变量 吻合值, 整数型
.局部变量 已吻合值, 整数型
.局部变量 不吻合值, 整数型
.局部变量 临时颜色值, 整数型
.局部变量 补零, 字节型
清除数组 (坐标组)
找到坐标.横 ＝ -1
找到坐标.纵 ＝ -1
总长 ＝ 取字节集长度 (数据)
颜色值 ＝ 到可用颜色 (LF颜色)
.如果 (符合程度 ＝ 0)
    吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
.否则
    吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
.如果结束
.如果 (符合程度2 ＝ 0)
    不吻合值 ＝ 取数组成员数 (不同点阵) × 100 ＼ 100
.否则
    不吻合值 ＝ 取数组成员数 (不同点阵) × 符合程度2 ＼ 100
.如果结束
补零 ＝ (4 － 宽 ％ 4) ％ 4
.计次循环首 (高, i)
    行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
    .计次循环首 (宽, i2)
        .如果真 (取绝对值 (行字节集 [i2] － 颜色值) ≤ 误差值)
            已吻合值 ＝ 0
            .计次循环首 (取数组成员数 (点阵), i3)
                位置 ＝ i2 ＋ 点阵 [i3].横 － 1  ' 这是X位置
                .如果真 (位置 ＞ 宽)  ' 偏移点超出范围
                    跳出循环 ()
                .如果真结束
                位置 ＝ (宽 ＋ 补零) × (点阵 [i3].纵 ＋ i － 1) ＋ 位置 ＋ 1
                .如果真 (总长 ＜ 位置)
                    跳出循环 ()
                .如果真结束
                .如果真 (取绝对值 (数据 [位置] － 行字节集 [i2]) ≤ 误差值)
                    已吻合值 ＝ 已吻合值 ＋ 1
                    临时颜色值 ＝ 行字节集 [i2]
                    .如果真 (已吻合值 ≥ 吻合值)
                        .如果真 (取数组成员数 (不同点阵) ＝ 0)
                            找到坐标.横 ＝ i2 － 1
                            找到坐标.纵 ＝ 高 － i
                            加入成员 (坐标组, 找到坐标)
                            跳出循环 ()
                        .如果真结束
                        已吻合值 ＝ 0
                        .计次循环首 (取数组成员数 (不同点阵), i4)  ' 判断文字以外点与文字颜色不同,防止找到的是色块不是文字!!
                            位置 ＝ i2 ＋ 不同点阵 [i4].横 － 1
                            .如果真 (位置 ＞ 宽)
                                跳出循环 ()
                            .如果真结束
                            位置 ＝ 1 ＋ (宽 ＋ 补零) × (不同点阵 [i4].纵 ＋ i － 1) ＋ 位置
                            .如果真 (总长 ＜ 位置 ＋ 2)
                                跳出循环 ()
                            .如果真结束
                            .如果真 (数据 [位置] ＝ 临时颜色值)
                                到循环尾 ()
                            .如果真结束
                            已吻合值 ＝ 已吻合值 ＋ 1
                            .如果真 (已吻合值 ≥ 不吻合值)
                                找到坐标.横 ＝ i2 － 1
                                找到坐标.纵 ＝ 高 － i
                                加入成员 (坐标组, 找到坐标)
                                跳出循环 ()
                            .如果真结束
                        .计次循环尾 ()
                        跳出循环 ()
                    .如果真结束
                .如果真结束
            .计次循环尾 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
返回 (取数组成员数 (坐标组))
.子程序 找点阵3, 精易_坐标, , 找图
.参数 数据, 字节集
.参数 宽, 整数型
.参数 高, 整数型
.参数 点阵, 点阵型, 数组
.参数 基色, 整数型
.参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
.参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
.局部变量 找到坐标, 精易_坐标
.局部变量 总长, 整数型
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 i3, 整数型
.局部变量 i4, 整数型
.局部变量 行字节集, 字节集
.局部变量 位置, 整数型
.局部变量 吻合值, 整数型
.局部变量 已吻合值, 整数型
.局部变量 临时颜色值, 整数型
.局部变量 补零, 字节型
找到坐标.横 ＝ -1
找到坐标.纵 ＝ -1
总长 ＝ 取字节集长度 (数据)
.如果 (符合程度 ＝ 0)
    吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
.否则
    吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
.如果结束
补零 ＝ (4 － 宽 ％ 4) ％ 4
.计次循环首 (高, i)
    行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
    .计次循环首 (宽, i2)
        .如果真 (取绝对值 (行字节集 [i2] － 基色) ≤ 误差值)
            已吻合值 ＝ 0
            .计次循环首 (取数组成员数 (点阵), i3)
                位置 ＝ i2 ＋ 点阵 [i3].x － 1  ' 这是X位置
                .如果真 (位置 ＞ 宽)  ' 偏移点超出范围
                    跳出循环 ()
                .如果真结束
                位置 ＝ (宽 ＋ 补零) × (点阵 [i3].y ＋ i － 1) ＋ 位置 ＋ 1
                .如果真 (总长 ＜ 位置)
                    跳出循环 ()
                .如果真结束
                .如果真 (取绝对值 (数据 [位置] － 点阵 [i3].z) ≤ 误差值)
                    已吻合值 ＝ 已吻合值 ＋ 1
                    临时颜色值 ＝ 行字节集 [i2]
                    .如果真 (已吻合值 ≥ 吻合值)
                        找到坐标.横 ＝ i2 － 1
                        找到坐标.纵 ＝ 高 － i
                        返回 (找到坐标)
                    .如果真结束
                .如果真结束
                处理事件 ()
            .计次循环尾 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
返回 (找到坐标)
.子程序 找点阵4, 整数型, , 找所有图
.参数 所有坐标, 精易_坐标, 参考 数组
.参数 数据, 字节集
.参数 宽, 整数型
.参数 高, 整数型
.参数 点阵, 点阵型, 数组
.参数 基色, 整数型
.参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
.参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
.局部变量 找到坐标, 精易_坐标
.局部变量 总长, 整数型
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 i3, 整数型
.局部变量 i4, 整数型
.局部变量 行字节集, 字节集
.局部变量 位置, 整数型
.局部变量 吻合值, 整数型
.局部变量 已吻合值, 整数型
.局部变量 临时颜色值, 整数型
.局部变量 补零, 字节型
清除数组 (所有坐标)
总长 ＝ 取字节集长度 (数据)
.如果 (符合程度 ＝ 0)
    吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
.否则
    吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
.如果结束
补零 ＝ (4 － 宽 ％ 4) ％ 4
.计次循环首 (高, i)
    行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
    .计次循环首 (宽, i2)
        .如果真 (取绝对值 (行字节集 [i2] － 基色) ≤ 误差值)
            已吻合值 ＝ 0
            .计次循环首 (取数组成员数 (点阵), i3)
                位置 ＝ i2 ＋ 点阵 [i3].x － 1  ' 这是X位置
                .如果真 (位置 ＞ 宽)  ' 偏移点超出范围
                    跳出循环 ()
                .如果真结束
                位置 ＝ (宽 ＋ 补零) × (点阵 [i3].y ＋ i － 1) ＋ 位置 ＋ 1
                .如果真 (总长 ＜ 位置)
                    跳出循环 ()
                .如果真结束
                .如果真 (取绝对值 (数据 [位置] － 点阵 [i3].z) ≤ 误差值)
                    已吻合值 ＝ 已吻合值 ＋ 1
                    临时颜色值 ＝ 行字节集 [i2]
                    .如果真 (已吻合值 ≥ 吻合值)
                        ' 输出调试文本 (当前吻合值)
                        找到坐标.横 ＝ i2 － 1
                        找到坐标.纵 ＝ 高 － i
                        加入成员 (所有坐标, 找到坐标)
                        跳出循环 ()
                    .如果真结束
                .如果真结束
                处理事件 ()
            .计次循环尾 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
返回 (取数组成员数 (所有坐标))
.子程序 找点阵5, 整数型, , 快速找所有字
.参数 坐标组, 精易_坐标, 可空 数组
.参数 数据, 字节集
.参数 宽, 整数型
.参数 高, 整数型
.参数 点阵, 精易_坐标, 数组
.参数 不同点阵, 精易_坐标, 数组
.局部变量 颜色值, 整数型
.局部变量 找到坐标, 精易_坐标
.局部变量 总长, 整数型
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 i3, 整数型
.局部变量 i4, 整数型
.局部变量 行字节集, 字节集
.局部变量 位置, 整数型
.局部变量 吻合值, 整数型
.局部变量 已吻合值, 整数型
.局部变量 不吻合值, 整数型
.局部变量 临时颜色值, 整数型
.局部变量 补零, 字节型
清除数组 (坐标组)
总长 ＝ 取字节集长度 (数据)
颜色值 ＝ 到可用颜色 (LF颜色)
吻合值 ＝ 取数组成员数 (点阵)
不吻合值 ＝ 取数组成员数 (不同点阵)
补零 ＝ (4 － 宽 ％ 4) ％ 4
.计次循环首 (高, i)
    行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
    .计次循环首 (宽, i2)
        .如果真 (行字节集 [i2] ＝ 颜色值)
            已吻合值 ＝ 0
            .计次循环首 (取数组成员数 (点阵), i3)
                位置 ＝ i2 ＋ 点阵 [i3].横 － 1  ' 这是X位置
                .如果真 (位置 ＞ 宽)  ' 偏移点超出范围
                    跳出循环 ()
                .如果真结束
                位置 ＝ (宽 ＋ 补零) × (点阵 [i3].纵 ＋ i － 1) ＋ 位置 ＋ 1
                .如果真 (总长 ＜ 位置)
                    跳出循环 ()
                .如果真结束
                .如果真 (数据 [位置] ＝ 行字节集 [i2])
                    已吻合值 ＝ 已吻合值 ＋ 1
                    临时颜色值 ＝ 行字节集 [i2]
                    .如果真 (已吻合值 ≥ 吻合值)
                        已吻合值 ＝ 0
                        .计次循环首 (取数组成员数 (不同点阵), i4)  ' 判断文字以外点与文字颜色不同,防止找到的是色块不是文字!!
                            位置 ＝ i2 ＋ 不同点阵 [i4].横 － 1
                            .如果真 (位置 ＞ 宽)
                                跳出循环 ()
                            .如果真结束
                            位置 ＝ 1 ＋ (宽 ＋ 补零) × (不同点阵 [i4].纵 ＋ i － 1) ＋ 位置
                            .如果真 (总长 ＜ 位置 ＋ 2)
                                跳出循环 ()
                            .如果真结束
                            .如果真 (数据 [位置] ＝ 临时颜色值)
                                到循环尾 ()
                            .如果真结束
                            已吻合值 ＝ 已吻合值 ＋ 1
                            .如果真 (已吻合值 ≥ 不吻合值)
                                找到坐标.横 ＝ i2 － 1
                                找到坐标.纵 ＝ 高 － i
                                加入成员 (坐标组, 找到坐标)
                                跳出循环 ()
                            .如果真结束
                        .计次循环尾 ()
                        跳出循环 ()
                    .如果真结束
                .如果真结束
            .计次循环尾 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.计次循环尾 ()
返回 (取数组成员数 (坐标组))
.程序集 类_位图操作, , 公开, 此类由坛友提供
.程序集变量 颜色表_1位深, 字节集, , , 2色biBitCount=1
.程序集变量 颜色表_4位深, 字节集, , , 16色biBitCount=4
.程序集变量 颜色表_8位深, 字节集, , , 256色biBitCount=8
.程序集变量 屏幕设备句柄, 整数型
.程序集变量 场景句柄, 整数型
.程序集变量 位图句柄, 整数型
.程序集变量 旧位图句柄, 整数型
.程序集变量 位图数据, 字节集, , , 位图数据
.程序集变量 位图指针, 整数型
.程序集变量 场景被更新, 逻辑型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
初始化颜色表 ()
屏幕设备句柄 ＝ GetDC (0)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
SelectObject (场景句柄, 旧位图句柄)
DeleteObject (位图句柄)
DeleteDC (场景句柄)
ReleaseDC (0, 屏幕设备句柄)
.子程序 释放旧位图
.如果真 (位图数据 ＝ {  } 且 位图句柄 ＝ 0)
    返回 ()
.如果真结束
SelectObject (场景句柄, 旧位图句柄)
DeleteObject (位图句柄)
DeleteDC (场景句柄)
ReleaseDC (0, 屏幕设备句柄)
连续赋值 (0, 位图句柄, 位图指针, 场景句柄, 旧位图句柄)
位图数据 ＝ {  }
屏幕设备句柄 ＝ GetDC (0)
场景被更新 ＝ 假
.子程序 初始化颜色表
颜色表_1位深 ＝ {  }
颜色表_1位深 ＝ 颜色表_1位深 ＋ { 0, 0, 0, 0 }
颜色表_1位深 ＝ 颜色表_1位深 ＋ { 255, 255, 255, 0 }
颜色表_4位深 ＝ {  }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 0, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 0, 128, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 128, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 128, 128, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 0, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 0, 128, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 128, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 128, 128, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 192, 192, 192, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 0, 255, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 255, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 255, 255, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 0, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 0, 255, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 255, 0, 0 }
颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 255, 255, 0 }
颜色表_8位深 ＝ {  }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 0, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 0, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 220, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 240, 202, 166, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 192, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 224, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 32, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 64, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 96, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 240, 251, 255, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 164, 160, 160, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 128, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 0, 255, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 255, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 255, 255, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 0, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 0, 255, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 255, 0, 0 }
颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 255, 255, 0 }
.子程序 从数据创建, 逻辑型, 公开, 从位图字节集载入位图数据创建位图(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 位图文件数据, 字节集
.局部变量 a, 逻辑型
写到文件 (目录_取特定目录 (11) ＋ “新位图操作类_载入位图.bmp”, 位图文件数据)
a ＝ 类_位图操作.从文件创建 (目录_取特定目录 (11) ＋ “新位图操作类_载入位图.bmp”)
删除文件 (目录_取特定目录 (11) ＋ “新位图操作类_载入位图.bmp”)
返回 (a)
.子程序 从数据创建2, 逻辑型, , 怎么不行啊
.参数 位图文件数据, 字节集
.局部变量 宽, 整数型
.局部变量 高, 整数型
.局部变量 位深度, 整数型
释放旧位图 ()
.如果真 (取字节集长度 (位图文件数据) ＜ 55)
    返回 (假)
.如果真结束
宽 ＝ 位图文件数据 [19] ＋ 位图文件数据 [20] × 256
高 ＝ 位图文件数据 [23] ＋ 位图文件数据 [24] × 256
位深度 ＝ 位图文件数据 [29] ＋ 位图文件数据 [30] × 256
输出调试文本 (位深度)
.如果真 (宽 ＜ 1 或 高 ＜ 1)
    返回 (假)
.如果真结束
创建空白位图 (宽, 高, 位深度)
' 场景句柄 ＝ 创建内存场景_ (屏幕设备句柄)
' 位图句柄 ＝ 创建GDI对象2_ (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
' 旧位图句柄 ＝ 选入设备场景_ (场景句柄, 位图句柄)
位图数据 ＝ 取字节集右边 (位图文件数据, 取字节集长度 (位图数据))
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
返回 (真)
.子程序 从文件创建, 逻辑型, 公开, 从bmp文件载入位图数据创建位图(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 文件名, 文本型, , 位图文件路径
.局部变量 位图句柄1, 整数型
.局部变量 a, 逻辑型
位图句柄1 ＝ LoadImage (0, 文件名, 0, 0, 0, 16)
a ＝ 从位图句柄创建 (位图句柄1)
DeleteObject (位图句柄1)
返回 (a)
.子程序 从位图句柄创建, 逻辑型, 公开, 通过已有的位图句柄创建新的位图存于本类中(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 已知的位图句柄, 整数型, , 已经获得的位图句柄,该句柄需另外删除!
.参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为原来的位深度
.局部变量 位图, BITMAP
.局部变量 场景句柄1, 整数型
.局部变量 旧位图句柄1, 整数型
释放旧位图 ()
.如果真 (GetObjectA (已知的位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
    返回 (假)
.如果真结束
场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
旧位图句柄1 ＝ SelectObject (场景句柄1, 已知的位图句柄)
创建空位图 (位图.bmWidth, 位图.bmHeight, 选择 (位深度 ＝ 0, 位图.bmBitsPixel, 位深度), )
场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
BitBlt (场景句柄, 0, 0, 位图.bmWidth, 位图.bmHeight, 场景句柄1, 0, 0, #SRCCOPY)
GdiFlush ()
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
SelectObject (场景句柄1, 旧位图句柄1)
' 删除对象_ (已知位图句柄)
DeleteDC (场景句柄1)
返回 (真)
.子程序 从图标句柄创建, 逻辑型, 公开, 通过文件图标句柄创建图标位图(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 图标句柄, 整数型, , 文件图标句柄
.参数 图标宽度, 整数型, 可空, 默认为32
.参数 图标高度, 整数型, 可空, 默认为32
.参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为32位
.局部变量 矩形, 精易_矩形
.局部变量 场景句柄1, 整数型
.局部变量 位图句柄1, 整数型
.局部变量 旧位图句柄1, 整数型
.局部变量 mBrush, 整数型
.如果真 (是否为空 (图标宽度))
    图标宽度 ＝ 32
.如果真结束
.如果真 (是否为空 (图标高度))
    图标高度 ＝ 32
.如果真结束
.如果真 (是否为空 (位深度))
    位深度 ＝ 32
.如果真结束
矩形.右边 ＝ 图标宽度
矩形.底边 ＝ 图标高度
场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄1 ＝ CreateCompatibleBitmap (屏幕设备句柄, 图标宽度, 图标高度)
旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
mBrush ＝ CreateSolidBrush (#白色)
FillRect (场景句柄1, 矩形, mBrush)
DrawIconEx (场景句柄1, 0, 0, 图标句柄, 图标宽度, 图标高度, 0, 0, 3)
从场景创建 (场景句柄1, 矩形, 位深度)
DeleteDC (场景句柄1)
DeleteObject (旧位图句柄1)
DeleteObject (位图句柄1)
DeleteObject (mBrush)
返回 (位图句柄 ≠ 0)
.子程序 从屏幕创建, 逻辑型, 公开, 从屏幕创建位图,抓取屏幕画面(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 左边, 整数型, 可空, 抓取的屏幕区域左边  默认为0
.参数 顶边, 整数型, 可空, 抓取的屏幕区域顶边  默认为0
.参数 宽度, 整数型, 可空, 创建位图的宽度  默认为屏幕宽度-左边
.参数 高度, 整数型, 可空, 创建位图的高度  默认为屏幕高度-顶边
.参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为当前屏幕色深
.局部变量 场景句柄1, 整数型
.局部变量 位图句柄1, 整数型
.局部变量 旧位图句柄1, 整数型
.局部变量 局部_位图信息, 位图信息_
.局部变量 DEVMODE, 短整数型, , "61"
释放旧位图 ()
EnumDisplaySettingsA (0, -1, DEVMODE [1])
.如果真 (位深度 ＝ 0)
    位深度 ＝ DEVMODE [53]
.如果真结束
.如果真 (位深度 ≠ 1 且 位深度 ≠ 4 且 位深度 ≠ 8 且 位深度 ≠ 16 且 位深度 ≠ 24 且 位深度 ≠ 32)
    返回 (假)
.如果真结束
.如果真 (宽度 ＝ 0)
    宽度 ＝ DEVMODE [55] － 左边
.如果真结束
.如果真 (高度 ＝ 0)
    高度 ＝ DEVMODE [57] － 顶边
.如果真结束
局部_位图信息.位深度 ＝ 位深度
局部_位图信息.压缩率 ＝ 0
局部_位图信息.位图位面数 ＝ 1
局部_位图信息.结果大小 ＝ 40
局部_位图信息.位图宽度 ＝ 宽度
局部_位图信息.位图高度 ＝ 高度
场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄1 ＝ CreateDIBSection (场景句柄1, 局部_位图信息, 0, 0, 0, 0)
旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
创建空位图 (局部_位图信息.位图宽度, 局部_位图信息.位图高度, 局部_位图信息.位深度, )
场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
BitBlt (场景句柄, 0, 0, 局部_位图信息.位图宽度, 局部_位图信息.位图高度, 屏幕设备句柄, 左边, 顶边, #SRCCOPY)
GdiFlush ()
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
SelectObject (场景句柄1, 旧位图句柄1)
DeleteObject (位图句柄1)
DeleteDC (场景句柄1)
返回 (真)
.子程序 从窗口创建, 逻辑型, 公开, 从窗口创建位图,获取窗口客户区画面(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 窗口句柄, 整数型, , 欲获取窗口位图的窗口句柄,必须保证窗口可视性,且不能是最小化窗口
.参数 左边, 整数型, 可空, 抓取的窗口客户区域左边  默认为0
.参数 顶边, 整数型, 可空, 抓取的窗口客户区域顶边  默认为0
.参数 宽度, 整数型, 可空, 创建位图的宽度  默认为窗口客户区域的宽度-左边
.参数 高度, 整数型, 可空, 创建位图的高度  默认为窗口客户区域的高度-顶边
.参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为24位
.局部变量 矩形区域, 精易_矩形
.局部变量 窗口大小, 精易_矩形
.局部变量 窗口位置, 精易_坐标
.局部变量 场景句柄1, 整数型
.局部变量 位图句柄1, 整数型
.局部变量 旧位图句柄1, 整数型
释放旧位图 ()
.如果真 (IsIconic (窗口句柄))
    返回 (假)
.如果真结束
.如果真 (IsWindowVisible (窗口句柄) ＝ 假)
    返回 (假)
.如果真结束
.如果真 (位深度 ＝ 0)
    位深度 ＝ 24
.如果真结束
.如果真 (位深度 ≠ 1 且 位深度 ≠ 4 且 位深度 ≠ 8 且 位深度 ≠ 16 且 位深度 ≠ 24 且 位深度 ≠ 32)
    返回 (假)
.如果真结束
GetWindowRect (窗口句柄, 矩形区域)
场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄1 ＝ CreateCompatibleBitmap (屏幕设备句柄, 矩形区域.右边 － 矩形区域.左边, 矩形区域.底边 － 矩形区域.顶边)
旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
.如果真 (取反 (PrintWindow (窗口句柄, 场景句柄1, 0)))
    SelectObject (场景句柄1, 旧位图句柄1)
    DeleteObject (位图句柄1)
    DeleteDC (场景句柄1)
    返回 (假)
.如果真结束
GetClientRect (窗口句柄, 窗口大小)
.如果真 (宽度 ＝ 0)
    宽度 ＝ 窗口大小.右边 － 左边
.如果真结束
.如果真 (高度 ＝ 0)
    高度 ＝ 窗口大小.底边 － 顶边
.如果真结束
ClientToScreen (窗口句柄, 窗口位置)
场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
创建空位图 (宽度, 高度, 位深度, )
位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
BitBlt (场景句柄, 0, 0, 宽度, 高度, 场景句柄1, 窗口位置.横 － 矩形区域.左边 ＋ 左边, 窗口位置.纵 － 矩形区域.顶边 ＋ 顶边, 13369376)
SelectObject (场景句柄1, 旧位图句柄1)
DeleteObject (位图句柄1)
DeleteDC (场景句柄1)
GdiFlush ()
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
返回 (真)
.子程序 从场景创建, 逻辑型, 公开, 从DC场景创建位图,复制DC上的内容到DIB获取场景中画面(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 DC场景句柄, 整数型, , 已经的DC场景
.参数 区域, 精易_矩形, , 欲获取场景的区域范围
.参数 位深度, 整数型, , 位深度:  1, 4, 8, 16, 24, 32
.局部变量 位图宽度, 整数型
.局部变量 位图高度, 整数型
释放旧位图 ()
.如果真 (位深度 ≠ 1 且 位深度 ≠ 4 且 位深度 ≠ 8 且 位深度 ≠ 16 且 位深度 ≠ 24 且 位深度 ≠ 32)
    返回 (假)
.如果真结束
位图宽度 ＝ 区域.右边 － 区域.左边
位图高度 ＝ 区域.底边 － 区域.顶边
创建空位图 (位图宽度, 位图高度, 位深度, )
场景句柄 ＝ CreateCompatibleDC (DC场景句柄)
位图句柄 ＝ CreateDIBSection1 (DC场景句柄, 位图数据, 0, 位图指针, 0, 0)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
BitBlt (场景句柄, 0, 0, 位图宽度, 位图高度, DC场景句柄, 区域.左边, 区域.顶边, #SRCCOPY)
GdiFlush ()
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
返回 (真)
.子程序 从资料创建, , , 通过现有内存创建的位图信息资料移植到本类,必须保证资料的准确性(本命令为高级成员命令,本类原有位图将自动被释放)
.参数 资料_位图句柄, 整数型
.参数 资料_场景句柄, 整数型
.参数 资料_位图数据, 字节集, , 位图颜色数据
释放旧位图 ()
位图句柄 ＝ 资料_位图句柄
场景句柄 ＝ 资料_场景句柄
位图数据 ＝ 资料_位图数据
场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
.子程序 从剪辑板创建, 逻辑型, 公开, 取得剪辑板中位图(成功返回真,剪辑板中没有位图或失败返回假,本类原有位图将自动被释放)
.参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为系统色深
.局部变量 位图句柄1, 整数型
.局部变量 a, 逻辑型
释放旧位图 ()
OpenClipboard (0)
位图句柄1 ＝ GetClipboardData (2)
CloseClipboard ()
a ＝ 从位图句柄创建 (位图句柄1, 位深度)
DeleteObject (位图句柄1)
返回 (a)
.子程序 创建空白位图, 逻辑型, 公开, 创建一幅指定大小与位深度的空白位图(成功返回真,失败返回假,本类原有位图将自动被释放)
.参数 宽度, 整数型
.参数 高度, 整数型
.参数 位深度, 整数型, , 位深度:  1, 4, 8, 16, 24, 32
释放旧位图 ()
创建空位图 (宽度, 高度, 位深度)
场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
GdiFlush ()
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
返回 (真)
.子程序 更新位图, , 公开, 强制立即更新位图中所作的操作(通常不使用)
.如果真 (位图数据 ＝ {  })
    返回 ()
.如果真结束
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
.子程序 创建空位图, 逻辑型
.参数 宽度, 整数型
.参数 高度, 整数型
.参数 位深度, 整数型
.参数 填充的颜色, 长整数型, 可空, 默认填充的颜色,4294967295
.局部变量 iColors, 整数型
.局部变量 iSize, 整数型
.局部变量 pBI, BITMAPINFOHEADER
.' 如果真 (是否为空 (填充的颜色))
    ' 填充的颜色 ＝ 4294967295
.如果真结束
.如果 (位深度 ＝ 1)
    iColors ＝ 2
.否则
    .如果 (位深度 ＝ 4)
        iColors ＝ 16
    .否则
        .如果 (位深度 ＝ 8)
            iColors ＝ 256
        .否则
            .如果 (位深度 ＝ 16 或 位深度 ＝ 24 或 位深度 ＝ 32)
                iColors ＝ 0
            .否则
                返回 (假)
            .如果结束
        .如果结束
    .如果结束
.如果结束
iSize ＝ iColors × 4 ＋ 扫描行对齐 (宽度 × 位深度) × 高度
位图数据 ＝ 取空白字节集 (iSize)  ' 分配空间
' 填写BMP文件头
pBI.biSize ＝ 40
pBI.biWidth ＝ 宽度
pBI.biHeight ＝ 高度
pBI.biPlanes ＝ 1
pBI.biBitCount ＝ 位深度
位图数据 ＝ 位图信息头转字节集 (pBI) ＋ 位图数据
' 初始化颜色表
.判断开始 (位深度 ＝ 1)
    RtlMoveMemory (取颜色表指针 (), lstrcpyn_字节集 (颜色表_1位深, 颜色表_1位深, 0), 取颜色表大小 ())
.判断 (位深度 ＝ 4)
    RtlMoveMemory (取颜色表指针 (), lstrcpyn_字节集 (颜色表_4位深, 颜色表_4位深, 0), 取颜色表大小 ())
.默认
    .如果真 (位深度 ＝ 8)
        RtlMoveMemory (取颜色表指针 (), lstrcpyn_字节集 (颜色表_8位深, 颜色表_8位深, 0), 取颜色表大小 ())
    .如果真结束
.判断结束
返回 (真)
.子程序 转换位深度, 逻辑型, 公开, 转换当前类中位图的位深度(成功返回真,失败返回假)
.参数 新的位深度, 整数型, , 位深度:  1, 4, 8, 16, 24, 32
.局部变量 位图, BITMAP
.局部变量 场景句柄1, 整数型
.局部变量 位图句柄1, 整数型
.局部变量 旧位图句柄1, 整数型
.如果真 (GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
    返回 (假)
.如果真结束
场景句柄1 ＝ 场景句柄
位图句柄1 ＝ 位图句柄
旧位图句柄1 ＝ 旧位图句柄
位图数据 ＝ {  }
创建空位图 (位图.bmWidth, 位图.bmHeight, 新的位深度, )
场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
BitBlt (场景句柄, 0, 0, 位图.bmWidth, 位图.bmHeight, 场景句柄1, 0, 0, #SRCCOPY)
GdiFlush ()
RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
SelectObject (场景句柄1, 旧位图句柄1)
DeleteObject (位图句柄1)
DeleteDC (场景句柄1)
返回 (真)
.子程序 复制到, 逻辑型, 公开, 将当前类中位图复制到目标位图类中(成功返回真,失败返回假)
.参数 目标位图, 类_位图操作, 参考, 复制到的目标位图
.参数 左边, 整数型, 可空, 复制源位图区域的左边 默认为0
.参数 顶边, 整数型, 可空, 复制源位图区域的顶边 默认为0
.参数 宽度, 整数型, 可空, 复制源位图的宽度 默认为源位图最大有效宽度
.参数 高度, 整数型, 可空, 复制源位图的高度 默认为源位图最大有效高度
.参数 目标左边, 整数型, 可空, 复制到目标位图的横坐标 默认为0
.参数 目标顶边, 整数型, 可空, 复制到目标位图的纵坐标 默认为0
.局部变量 位图, BITMAP
.如果真 (GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
    返回 (假)
.如果真结束
.如果真 (是否为空 (宽度))
    宽度 ＝ 位图.bmWidth
.如果真结束
.如果真 (是否为空 (高度))
    高度 ＝ 位图.bmHeight
.如果真结束
' 目标位图.创建空白位图 (宽度 ＋ 目标左边, 高度 ＋ 目标顶边, 位图.bmBitsPixel)
BitBlt (目标位图.取场景句柄 (), 目标左边, 目标顶边, 宽度 ＋ 目标左边, 高度 ＋ 目标顶边, 场景句柄, 左边, 顶边, #SRCCOPY)
目标位图.更新位图 ()
返回 (真)
.子程序 取位图句柄, 整数型, 公开, 取得当前类中位图的位图句柄(返回位图句柄,本类中没有位图返回0)
返回 (位图句柄)
.子程序 取场景句柄, 整数型, 公开, 取得当前类中位图所在DC场景句柄(返回场景句柄,本类中没有位图返回0)
返回 (场景句柄)
.子程序 取宽度, 整数型, 公开, (数据方式)取位图宽度,失败返回0
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
返回 (取字节集数据 (取字节集中间 (位图数据, 5, 4), #整数型, ))
.子程序 取高度, 整数型, 公开, (数据方式)取位图高度,失败返回0
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
返回 (取字节集数据 (位图数据, #整数型, 9))
.子程序 取位深度, 整数型, 公开, (数据方式)取位图颜色位数,失败返回0
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
返回 (到整数 (到短整数 (取字节集中间 (位图数据, 15, 2))))
.子程序 取宽度2, 整数型, 公开, (函数方式)取位图宽度,失败返回0
.局部变量 位图, BITMAP
GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
返回 (位图.bmWidth)
.子程序 取高度2, 整数型, 公开, (函数方式)取位图高度,失败返回0
.局部变量 位图, BITMAP
GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
返回 (位图.bmHeight)
.子程序 取位深度2, 整数型, 公开, (函数方式)取位图颜色位数,失败返回0
.局部变量 位图, BITMAP
GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
返回 (位图.bmBitsPixel)
.子程序 取指针, 整数型, 公开, 取位图数据BITMAPINFO指针,失败返回0
返回 (lstrcpyn_字节集 (位图数据, 位图数据, 0))
.子程序 取颜色点阵地址, 整数型, 公开, 取颜色点阵地址,失败返回0
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
返回 (lstrcpyn_字节集 (位图数据, 位图数据, 0) ＋ 40 ＋ 取颜色表大小 ())
.子程序 取颜色点阵大小, 整数型, 公开, 取颜色点阵大小,失败返回0
.局部变量 r
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
r ＝ 取行字节数 ()
返回 (取高度 () × 取行字节数 ())
.子程序 取颜色表指针, 整数型, 公开, 取颜色表指针,失败返回0,大于256色的位图不使用颜色表
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
.如果真 (取位深度 () ≥ 16)
    返回 (0)
.如果真结束
返回 (lstrcpyn_字节集 (位图数据, 位图数据, 0) ＋ 40)
.子程序 取颜色表大小, 整数型, 公开, 取颜色表大小,失败返回0
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
返回 (取颜色表颜色个数 (取字节集左边 (位图数据, 40)) × 4)
.子程序 取颜色表颜色个数, 整数型, , 取颜色表数组颜色个数
.参数 pBmpInfo, 字节集
.局部变量 iBitCount, 短整数型
iBitCount ＝ 取字节集数据 (取字节集中间 (pBmpInfo, 15, 2), #短整数型, )
.判断开始 (iBitCount ＝ 1)
    返回 (2)
.判断 (iBitCount ＝ 4)
    返回 (16)
.判断 (iBitCount ＝ 8)
    返回 (256)
.默认
    .如果真 (iBitCount ＝ 16 或 iBitCount ＝ 24 或 iBitCount ＝ 32)
        返回 (0)
    .如果真结束
.判断结束
返回 (0)
.子程序 取行字节数, 整数型, 公开, 取得位图颜色数据一行的字节数
.如果真 (位图数据 ＝ {  })
    返回 (0)
.如果真结束
返回 (扫描行对齐 (取字节集数据 (取字节集中间 (位图数据, 5, 4), #整数型, ) × 取字节集数据 (取字节集中间 (位图数据, 13, 2), #整数型, ) × 取字节集数据 (取字节集中间 (位图数据, 15, 2), #整数型, )))
.子程序 扫描行对齐, 整数型, , 保图像的扫描行DWORD对齐
.参数 bits, 整数型
bits ＝ bits ＋ 31
返回 (左移 (右移 (bits, 5), 2))
.子程序 位图信息头转字节集, 字节集
.参数 欲转成字节集的信息, BITMAPINFOHEADER
.局部变量 返回值, 字节集
返回值 ＝ 到字节集 (欲转成字节集的信息.biSize)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biWidth)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biHeight)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biPlanes)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biBitCount)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biCompression)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biSizeImage)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biXPelsPerMeter)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biYPelsPerMeter)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biClrUsed)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biClrImportant)
返回 (返回值)
.子程序 位图文件头转字节集, 字节集
.参数 欲转成字节集的信息, BITMAPFILEHEADER
.局部变量 返回值, 字节集
返回值 ＝ 到字节集 (欲转成字节集的信息.bfType)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfSize)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfReserved1)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfReserved2)
返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfOffBits)
返回 (返回值)
.子程序 取出位图数据, 字节集, 公开, 返回位图文件数据(写到文件后就是.BMP图片)
.如果真 (场景被更新)
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    场景被更新 ＝ 假
.如果真结束
返回 (到字节集 (到短整数 (19778)) ＋ 到字节集 (到整数 (取字节集长度 (位图数据) ＋ 54)) ＋ { 0, 0 } ＋ { 0, 0 } ＋ 到字节集 (到整数 (54 ＋ 取颜色表大小 ())) ＋ 位图数据)
' 给位图数据加上位图文件头
.子程序 取出颜色数据, 字节集, 公开, 不含文件头的颜色部分的数据
.如果真 (场景被更新)
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    场景被更新 ＝ 假
.如果真结束
返回 (取字节集右边 (位图数据, 取颜色点阵大小 ()))
.子程序 取某点颜色, 整数型, 公开, 取得位图中某点颜色值(成功返回十进制颜色值,失败返回-1)
.参数 横坐标, 整数型
.参数 纵坐标, 整数型
.如果真 (场景被更新)
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    场景被更新 ＝ 假
.如果真结束
返回 (GetPixel (场景句柄, 横坐标, 纵坐标))
.子程序 置某点颜色, 逻辑型, 公开, 设置位图中某点颜色值(成功返回真,失败返回假)
.参数 横坐标, 整数型
.参数 纵坐标, 整数型
.参数 颜色值, 整数型, , 十进制RGB颜色值
场景被更新 ＝ SetPixelV (场景句柄, 横坐标, 纵坐标, 颜色值) ≠ 0
返回 (场景被更新)
.子程序 置剪辑板位图, 逻辑型, 公开, 将指定位图存放到当前Windows系统剪辑板中,剪辑板中的原有内容被覆盖(成功返回真,失败返回假)
.局部变量 a, 整数型
.局部变量 场景句柄1, 整数型
.局部变量 位图句柄1, 整数型
.局部变量 旧位图句柄1, 整数型
.局部变量 位图, BITMAP
GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
场景句柄1 ＝ CreateCompatibleDC (0)
位图句柄1 ＝ CreateCompatibleBitmap (屏幕设备句柄, 位图.bmWidth, 位图.bmHeight)
旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
BitBlt (场景句柄1, 0, 0, 位图.bmWidth, 位图.bmHeight, 场景句柄, 0, 0, #SRCCOPY)
SelectObject (场景句柄1, 旧位图句柄1)
DeleteDC (场景句柄1)
OpenClipboard (0)
EmptyClipboard ()
a ＝ SetClipboardData (#CF_BITMAP, 位图句柄1)
CloseClipboard ()
返回 (a ≠ 0)
.子程序 置窗口位图, 逻辑型, 公开, 将位图画入指定窗口中(成功返回真,失败返回假)
.参数 窗口句柄, 整数型
.局部变量 局部_位图信息, 位图信息_
.局部变量 局部_空白字节集, 字节集
.局部变量 位图, BITMAP
.局部变量 窗口设备句柄, 整数型
.如果真 (GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
    返回 (假)
.如果真结束
局部_位图信息.位深度 ＝ 位图.bmBitsPixel
局部_位图信息.压缩率 ＝ 0
局部_位图信息.位图位面数 ＝ 1
局部_位图信息.结果大小 ＝ 40
局部_位图信息.位图宽度 ＝ 位图.bmWidth
局部_位图信息.位图高度 ＝ 位图.bmHeight
局部_空白字节集 ＝ 取空白字节集 (局部_位图信息.位图宽度 × 局部_位图信息.位图高度 × 4)
GetDIBits3 (场景句柄, 位图句柄, 0, 局部_位图信息.位图高度, 局部_空白字节集 [1], 局部_位图信息, 0)
窗口设备句柄 ＝ GetDC (窗口句柄)
SetDIBitsToDevice (窗口设备句柄, 0, 0, 局部_位图信息.位图宽度, 局部_位图信息.位图高度, 0, 0, 0, 局部_位图信息.位图高度, 局部_空白字节集 [1], 局部_位图信息, 0)
DeleteDC (窗口设备句柄)
返回 (真)
.程序集 类_位图处理, , 公开, 作: 为你芯冻
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 取位图颜色, 整数型, 公开
.参数 位图, 字节集
.参数 横坐标, 整数型, 可空, 范围为 0~图像宽度 - 1；留空为0。表示图像最左侧。
.参数 纵坐标, 整数型, 可空, 范围为 0~图像高度 - 1；留空为0。表示图像最顶边。
.局部变量 信息大小, 整数型, , , BITMAPINFOHEADER -> biSize        一般为 40，但从实际数据获取较保险
.局部变量 图像宽度, 整数型, , , BITMAPINFOHEADER -> biWidth
.局部变量 图像高度, 整数型, , , BITMAPINFOHEADER -> biHeight       > 0 从下至上逆向存储； < 0 从上至下正向存储
.局部变量 图像位数, 短整数型, , , BITMAPINFOHEADER -> biBitCount
.局部变量 图像压缩, 整数型, , , BITMAPINFOHEADER -> biCompression  1/2-压缩图像; 4/5-JPG/PNG  0-未压缩; 3-未压缩且调色板为3色掩码(位域方式)
.局部变量 扫描行, 整数型, , , 固定公式计算
.局部变量 坐标偏移, 整数型, , , 固定公式计算，返回相对于图像数据阵列起始位置的偏移量
.局部变量 数据偏移, 整数型, , , 文件头 + 信息头 + 调色板(如果有) + 坐标偏移，即指定坐标颜色数据(或其调色板索引)相对于图形数据的偏移量
.局部变量 色板大小, 整数型, , , 调色板大小，如果有。
.局部变量 RGB, 字节集
.局部变量 字节位移, 整数型, , , 用于 图像位数 = 1 或 4 时取指定位
.局部变量 定点数据, 整数型, , , 颜色数据所在位置、颜色(或调色板)索引等
.如果真 (取字节集左边 (位图, 2) ≠ { 66, 77 })  ' { 66, 77 } BM 标志
    返回 (-1)
.如果真结束
信息大小 ＝ 取字节集数据 (取字节集中间 (位图, 15, 4), #整数型, )
图像宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), #整数型, )
图像高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), #整数型, )
图像位数 ＝ 取字节集数据 (取字节集中间 (位图, 29, 2), #短整数型, )
图像压缩 ＝ 取字节集数据 (取字节集中间 (位图, 31, 4), #整数型, )
.如果真 (图像压缩 ≠ 0 且 图像压缩 ≠ 3)
    返回 (-1)
.如果真结束
.如果真 (横坐标 ＜ 0 或 纵坐标 ＜ 0 或 横坐标 ＞ 图像宽度 － 1 或 纵坐标 ＞ 图像高度 － 1)
    返回 (-1)
.如果真结束
.判断开始 (图像位数 ＝ 16 或 图像位数 ＝ 32)
    色板大小 ＝ 选择 (图像压缩 ＝ 0, 0, 12)
.判断 (图像位数 ＝ 24)
    色板大小 ＝ 0
.判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8)  ' 有调色板
    色板大小 ＝ 左移 (取字节集数据 (取字节集中间 (位图, 47, 4), #整数型, ), 2)  ' 实际使用色彩数 * 4
    .如果真 (色板大小 ＝ 0)
        色板大小 ＝ 左移 (4, 图像位数)
    .如果真结束
.默认
    返回 (-1)
.判断结束
扫描行 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2)  ' 备用写法：右移 (位与 (图像宽度 × 图像位数 ＋ 31, 位取反 (31)), 3)
坐标偏移 ＝ (右移 (图像高度, 31) × (图像高度 ＋ 1) ＋ 图像高度 － 位或 (右移 (图像高度, 31), 1) × (纵坐标 ＋ 1)) × 扫描行 ＋ 右移 (横坐标 × 图像位数, 3) ＋ 1
数据偏移 ＝ 14 ＋ 信息大小 ＋ 色板大小 ＋ 坐标偏移
RGB ＝ { 0, 0, 0, 0 }
.判断开始 (图像位数 ＝ 32)  ' 3 字节表示 1个像素颜色
    RGB ＝ 取字节集中间 (位图, 数据偏移, 4)
.判断 (图像位数 ＝ 24)
    RGB [1] ＝ 位图 [数据偏移 ＋ 2]
    RGB [2] ＝ 位图 [数据偏移 ＋ 1]
    RGB [3] ＝ 位图 [数据偏移]
.判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8)  ' 有调色板，1 字节表示 8/2/1 个像素颜色的调色板索引
    定点数据 ＝ 位图 [数据偏移]  ' 色彩索引字节
    字节位移 ＝ 位与 (横坐标 ＋ 1, 8 ÷ 图像位数 － 1)
    .如果真 (字节位移 ＞ 0)
        定点数据 ＝ 右移 (定点数据, 8 － 图像位数 × 字节位移)
    .如果真结束
    定点数据 ＝ 位与 (定点数据, 左移 (1, 图像位数) － 1)
    定点数据 ＝ 14 ＋ 信息大小 ＋ 左移 (定点数据, 2) ＋ 1  ' 指定色调色板偏移基址
    RGB [1] ＝ 位图 [定点数据 ＋ 2]
    RGB [2] ＝ 位图 [定点数据 ＋ 1]
    RGB [3] ＝ 位图 [定点数据]
.默认
.判断结束
返回 (取字节集数据 (RGB, #整数型, ))
.子程序 置位图颜色, 字节集, 公开
.参数 位图, 字节集
.参数 横坐标, 整数型, 可空, 范围为 0~图像宽度 - 1；留空为0。表示图像最左侧。
.参数 纵坐标, 整数型, 可空, 范围为 0~图像高度 - 1；留空为0。表示图像最顶边。
.参数 颜色值, 整数型
.局部变量 信息大小, 整数型, , , BITMAPINFOHEADER -> biSize        一般为 40，但从实际数据获取较保险
.局部变量 图像宽度, 整数型, , , BITMAPINFOHEADER -> biWidth
.局部变量 图像高度, 整数型, , , BITMAPINFOHEADER -> biHeight       > 0 从下至上逆向存储； < 0 从上至下正向存储
.局部变量 图像位数, 短整数型, , , BITMAPINFOHEADER -> biBitCount
.局部变量 图像压缩, 整数型, , , BITMAPINFOHEADER -> biCompression  1/2-压缩图像; 4/5-JPG/PNG  0-未压缩; 3-未压缩且调色板为3色掩码(位域方式)
.局部变量 扫描行, 整数型, , , 固定公式计算
.局部变量 坐标偏移, 整数型, , , 固定公式计算，返回相对于图像数据阵列起始位置的偏移量
.局部变量 数据偏移, 整数型, , , 文件头 + 信息头 + 调色板(如果有) + 坐标偏移，即指定坐标颜色数据(或其调色板索引)相对于图形数据的偏移量
.局部变量 色板大小, 整数型, , , 调色板大小，如果有。
.局部变量 RGB, 字节集
.如果真 (取字节集左边 (位图, 2) ≠ { 66, 77 })  ' { 66, 77 } BM 标志
    返回 ({  })
.如果真结束
信息大小 ＝ 取字节集数据 (取字节集中间 (位图, 15, 4), #整数型, )
图像宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), #整数型, )
图像高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), #整数型, )
图像位数 ＝ 取字节集数据 (取字节集中间 (位图, 29, 2), #短整数型, )
图像压缩 ＝ 取字节集数据 (取字节集中间 (位图, 31, 4), #整数型, )
.如果真 (图像压缩 ≠ 0 且 图像压缩 ≠ 3)
    返回 (位图)
.如果真结束
.如果真 (横坐标 ＜ 0 或 纵坐标 ＜ 0 或 横坐标 ＞ 图像宽度 － 1 或 纵坐标 ＞ 图像高度 － 1)
    返回 (位图)
.如果真结束
.判断开始 (图像位数 ＝ 16 或 图像位数 ＝ 32)
    色板大小 ＝ 选择 (图像压缩 ＝ 0, 0, 12)
.判断 (图像位数 ＝ 24)
    色板大小 ＝ 0
.默认
    返回 (位图)
.判断结束
扫描行 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2)  ' 备用写法：右移 (位与 (图像宽度 × 图像位数 ＋ 31, 位取反 (31)), 3)
坐标偏移 ＝ (右移 (图像高度, 31) × (图像高度 ＋ 1) ＋ 图像高度 － 位或 (右移 (图像高度, 31), 1) × (纵坐标 ＋ 1)) × 扫描行 ＋ 右移 (横坐标 × 图像位数, 3) ＋ 1
数据偏移 ＝ 14 ＋ 信息大小 ＋ 色板大小 ＋ 坐标偏移
RGB ＝ 到字节集 (颜色值)
.判断开始 (图像位数 ＝ 32)  ' 3 字节表示 1个像素颜色
    位图 ＝ 字节集替换 (位图, 数据偏移, 4, RGB)
.判断 (图像位数 ＝ 24)
    位图 [数据偏移 ＋ 2] ＝ RGB [1]
    位图 [数据偏移 ＋ 1] ＝ RGB [2]
    位图 [数据偏移] ＝ RGB [3]
.默认
.判断结束
返回 (位图)
.子程序 取位图颜色表, 整数型, 公开
.参数 位图, 字节集
.参数 颜色表, 整数型, 参考 数组
.局部变量 信息大小, 整数型, , , BITMAPINFOHEADER -> biSize        一般为 40，但从实际数据获取较保险
.局部变量 图像宽度, 整数型, , , BITMAPINFOHEADER -> biWidth
.局部变量 图像高度, 整数型, , , BITMAPINFOHEADER -> biHeight       > 0 从下至上逆向存储； < 0 从上至下正向存储
.局部变量 图像位数, 短整数型, , , BITMAPINFOHEADER -> biBitCount
.局部变量 图像压缩, 整数型, , , BITMAPINFOHEADER -> biCompression  1/2-压缩图像; 4/5-JPG/PNG  0-未压缩; 3-未压缩且调色板为3色掩码(位域方式)
.局部变量 扫描行, 整数型, , , 固定公式计算
.局部变量 坐标偏移, 整数型, , , 固定公式计算，返回相对于图像数据阵列起始位置的偏移量
.局部变量 数据偏移, 整数型, , , 文件头 + 信息头 + 调色板(如果有) + 坐标偏移，即指定坐标颜色数据(或其调色板索引)相对于图形数据的偏移量
.局部变量 色板大小, 整数型, , , 调色板大小，如果有。
.局部变量 RGB, 字节集
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 定点数据, 整数型
.局部变量 字节位移, 整数型
.如果真 (取字节集左边 (位图, 2) ≠ { 66, 77 })  ' { 66, 77 } BM 标志
    返回 (0)
.如果真结束
信息大小 ＝ 取字节集数据 (取字节集中间 (位图, 15, 4), #整数型, )
图像宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), #整数型, )
图像高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), #整数型, )
图像位数 ＝ 取字节集数据 (取字节集中间 (位图, 29, 2), #短整数型, )
图像压缩 ＝ 取字节集数据 (取字节集中间 (位图, 31, 4), #整数型, )
.如果真 (图像压缩 ≠ 0 且 图像压缩 ≠ 3)
    返回 (0)
.如果真结束
.判断开始 (图像位数 ＝ 16 或 图像位数 ＝ 32)
    色板大小 ＝ 选择 (图像压缩 ＝ 0, 0, 12)
.判断 (图像位数 ＝ 24)
    色板大小 ＝ 0
.判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8)  ' 有调色板
    色板大小 ＝ 左移 (取字节集数据 (取字节集中间 (位图, 47, 4), #整数型, ), 2)  ' 实际使用色彩数 * 4
    .如果真 (色板大小 ＝ 0)
        色板大小 ＝ 左移 (4, 图像位数)
    .如果真结束
.默认
    返回 (0)
.判断结束
扫描行 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2)  ' 备用写法：右移 (位与 (图像宽度 × 图像位数 ＋ 31, 位取反 (31)), 3)
重定义数组 (颜色表, 假, 图像宽度, 图像高度)
.计次循环首 (图像宽度, x)
    .计次循环首 (图像高度, y)
        坐标偏移 ＝ (右移 (图像高度, 31) × (图像高度 ＋ 1) ＋ 图像高度 － 位或 (右移 (图像高度, 31), 1) × y) × 扫描行 ＋ 右移 ((x － 1) × 图像位数, 3) ＋ 1
        数据偏移 ＝ 14 ＋ 信息大小 ＋ 色板大小 ＋ 坐标偏移
        RGB ＝ { 0, 0, 0, 0 }
        .判断开始 (图像位数 ＝ 32)  ' 3 字节表示 1个像素颜色
            RGB ＝ 取字节集中间 (位图, 数据偏移, 4)
        .判断 (图像位数 ＝ 24)
            RGB [1] ＝ 位图 [数据偏移 ＋ 2]
            RGB [2] ＝ 位图 [数据偏移 ＋ 1]
            RGB [3] ＝ 位图 [数据偏移]
        .判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8)  ' 有调色板，1 字节表示 8/2/1 个像素颜色的调色板索引
            定点数据 ＝ 位图 [数据偏移]  ' 色彩索引字节
            字节位移 ＝ 位与 (x, 8 ÷ 图像位数 － 1)
            .如果真 (字节位移 ＞ 0)
                定点数据 ＝ 右移 (定点数据, 8 － 图像位数 × 字节位移)
            .如果真结束
            定点数据 ＝ 位与 (定点数据, 左移 (1, 图像位数) － 1)
            定点数据 ＝ 14 ＋ 信息大小 ＋ 左移 (定点数据, 2) ＋ 1  ' 指定色调色板偏移基址
            RGB [1] ＝ 位图 [定点数据 ＋ 2]
            RGB [2] ＝ 位图 [定点数据 ＋ 1]
            RGB [3] ＝ 位图 [定点数据]
        .默认
        .判断结束
        颜色表 [x] [y] ＝ 取字节集数据 (RGB, 3, )
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
返回 (图像位数)
.子程序 颜色表构建位图, 字节集, 公开, 如果颜色表是24位颜色表的话要构建8位位图 必须先把24位颜色表改成8位颜色表
.参数 颜色表, 整数型, 数组, 输进一个二维数组,分别表示宽和高,数组值为颜色值
.参数 位数, 整数型, 可空, 默认为24
.局部变量 w, 整数型
.局部变量 w1, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 i, 整数型
.局部变量 n, 整数型
.局部变量 位图, 字节集
.局部变量 调色板, 整数型, , "0"
.如果真 (取数组成员数 (颜色表) ＝ 0)
    返回 ({  })
.如果真结束
位数 ＝ 选择 (是否为空 (位数), 24, 位数)
w ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 8, 4), 3, )
h ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 4, 4), 3, )
.判断开始 (位数 ＝ 24)
    .计次循环首 (h, y)
        .计次循环首 (w, x)
            位图 ＝ 位图 ＋ 字节集反转 (取字节集左边 (到字节集 (颜色表 [x] [h ＋ 1 － y]), 3))
        .计次循环尾 ()
        .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
            位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (58 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 24, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 位图
.判断 (位数 ＝ 1)
    调色板 ＝ { #黑色, #白色 }
    w1 ＝ 到整数 (w ÷ 8)
    .如果真 (w1 ≠ w ÷ 8)
        w1 ＝ w1 ＋ 1
    .如果真结束
    .计次循环首 (h, y)
        .计次循环首 (w1, x)
            位图 ＝ 位图 ＋ { 0 }
            .计次循环首 (8, i)
                .如果真 ((x － 1) × 8 ＋ i ≤ w)
                    .如果真 (颜色表 [(x － 1) × 8 ＋ i] [h ＋ 1 － y] ＝ #白色)
                        位图 [取字节集长度 (位图)] ＝ 位图 [取字节集长度 (位图)] ＋ 求次方 (2, 8 － i)
                    .如果真结束
                .如果真结束
            .计次循环尾 ()
        .计次循环尾 ()
        .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
            位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (66 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 62, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 1, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 指针到字节集 (lstrcpynA_整数数组 (调色板, 调色板, 0), 取数组成员数 (调色板) × 4) ＋ 位图
.判断 (位数 ＝ 4)
    调色板 ＝ { 0, 8388608, 32768, 8421376, 128, 8388736, 32896, 8421504, 12632256, 16711680, 65280, 16776960, 255, 16711935, 65535, 16777215 }
    w1 ＝ 到整数 (w ÷ 2)
    .如果真 (w1 ≠ w ÷ 2)
        w1 ＝ w1 ＋ 1
    .如果真结束
    .计次循环首 (h, y)
        .计次循环首 (w1, x)
            位图 ＝ 位图 ＋ { 0 }
            .计次循环首 (2, i)
                .如果真 ((x － 1) × 2 ＋ i ≤ w)
                    .计次循环首 (取数组成员数 (调色板), n)
                        .如果真 (调色板 [n] ＝ 颜色表 [(x － 1) × 2 ＋ i] [h ＋ 1 － y])
                            跳出循环 ()
                        .如果真结束
                    .计次循环尾 ()
                    n ＝ 选择 (n ＝ 取数组成员数 (调色板) ＋ 1, n － 2, n － 1)
                    位图 [取字节集长度 (位图)] ＝ 位图 [取字节集长度 (位图)] ＋ n × 求次方 (16, 2 － i)
                .如果真结束
            .计次循环尾 ()
        .计次循环尾 ()
        .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
            位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (122 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 118, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 4, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 指针到字节集 (lstrcpynA_整数数组 (调色板, 调色板, 0), 取数组成员数 (调色板) × 4) ＋ 位图
.判断 (位数 ＝ 8)
    调色板 ＝ { 0, 65793, 131586, 197379, 263172, 328965, 394758, 460551, 526344, 592137, 657930, 723723, 789516, 855309, 921102, 986895, 1052688, 1118481, 1184274, 1250067, 1315860, 1381653, 1447446, 1513239, 1579032, 1644825, 1710618, 1776411, 1842204, 1907997, 1973790, 2039583, 2105376, 2171169, 2236962, 2302755, 2368548, 2434341, 2500134, 2565927, 2631720, 2697513, 2763306, 2829099, 2894892, 2960685, 3026478, 3092271, 3158064, 3223857, 3289650, 3355443, 3421236, 3487029, 3552822, 3618615, 3684408, 3750201, 3815994, 3881787, 3947580, 4013373, 4079166, 4144959, 4210752, 4276545, 4342338, 4408131, 4473924, 4539717, 4605510, 4671303, 4737096, 4802889, 4868682, 4934475, 5000268, 5066061, 5131854, 5197647, 5263440, 5329233, 5395026, 5460819, 5526612, 5592405, 5658198, 5723991, 5789784, 5855577, 5921370, 5987163, 6052956, 6118749, 6184542, 6250335, 6316128, 6381921, 6447714, 6513507, 6579300, 6645093, 6710886, 6776679, 6842472, 6908265, 6974058, 7039851, 7105644, 7171437, 7237230, 7303023, 7368816, 7434609, 7500402, 7566195, 7631988, 7697781, 7763574, 7829367, 7895160, 7960953, 8026746, 8092539, 8158332, 8224125, 8289918, 8355711, 8421504, 8487297, 8553090, 8618883, 8684676, 8750469, 8816262, 8882055, 8947848, 9013641, 9079434, 9145227, 9211020, 9276813, 9342606, 9408399, 9474192, 9539985, 9605778, 9671571, 9737364, 9803157, 9868950, 9934743, 10000536, 10066329, 10132122, 10197915, 10263708, 10329501, 10395294, 10461087, 10526880, 10592673, 10658466, 10724259, 10790052, 10855845, 10921638, 10987431, 11053224, 11119017, 11184810, 11250603, 11316396, 11382189, 11447982, 11513775, 11579568, 11645361, 11711154, 11776947, 11842740, 11908533, 11974326, 12040119, 12105912, 12171705, 12237498, 12303291, 12369084, 12434877, 12500670, 12566463, 12632256, 12698049, 12763842, 12829635, 12895428, 12961221, 13027014, 13092807, 13158600, 13224393, 13290186, 13355979, 13421772, 13487565, 13553358, 13619151, 13684944, 13750737, 13816530, 13882323, 13948116, 14013909, 14079702, 14145495, 14211288, 14277081, 14342874, 14408667, 14474460, 14540253, 14606046, 14671839, 14737632, 14803425, 14869218, 14935011, 15000804, 15066597, 15132390, 15198183, 15263976, 15329769, 15395562, 15461355, 15527148, 15592941, 15658734, 15724527, 15790320, 15856113, 15921906, 15987699, 16053492, 16119285, 16185078, 16250871, 16316664, 16382457, 16448250, 16514043, 16579836, 16645629, 16711422, 16777215 }
    .计次循环首 (h, y)
        .计次循环首 (w, x)
            位图 ＝ 位图 ＋ { 0 }
            .计次循环首 (取数组成员数 (调色板), n)
                .如果真 (调色板 [n] ＝ 颜色表 [x] [h ＋ 1 － y])
                    跳出循环 ()
                .如果真结束
            .计次循环尾 ()
            n ＝ 选择 (n ＝ 取数组成员数 (调色板) ＋ 1, n － 2, n － 1)
            位图 [取字节集长度 (位图)] ＝ n
        .计次循环尾 ()
        .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
            位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (2102 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 54, 4, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 8, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 指针到字节集 (lstrcpynA_整数数组 (调色板, 调色板, 0), 取数组成员数 (调色板) × 4) ＋ 位图
.判断 (位数 ＝ 32)
    .计次循环首 (h, y)
        .计次循环首 (w, x)
            位图 ＝ 位图 ＋ 字节集反转 (取字节集左边 (到字节集 (颜色表 [x] [h ＋ 1 － y]), 3)) ＋ { 0 }
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (58 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 32, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 位图
.默认
.判断结束
返回 (位图)
.子程序 位图去杂点, 字节集, 公开
.参数 位图, 字节集
.局部变量 颜色表, 整数型, , "0"
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 i, 整数型
.局部变量 孤立值, 整数型
.局部变量 点x, 整数型
.局部变量 点y, 整数型
.局部变量 点阵, 整数型, , "8,3"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
写到内存 ({ 1, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 2, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 4, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 8, 0, 0, 0, 1, 0, 0, 0, 255, 255, 255, 255, 16, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 128, 0, 0, 0, 255, 255, 255, 255, 1, 0, 0, 0 }, lstrcpynA_整数数组 (点阵, 点阵, 0), 96)
取位图颜色表 (位图, 颜色表)
.计次循环首 (h, y)
    .计次循环首 (w, x)
        点x ＝ -1
        点y ＝ -1
        孤立值 ＝ 点是否孤立 (位图, x － 1, y － 1)
        .如果真 (孤立值 ＝ -1)
            到循环尾 ()
        .如果真结束
        .如果真 (孤立值 ＝ 0)
            颜色表 [x] [y] ＝ #白色
            到循环尾 ()
        .如果真结束
        .计次循环首 (8, i)
            .如果真 (位与 (孤立值, 点阵 [i] [1]) ＝ 点阵 [i] [1])
                .如果 (点x ＝ -1 且 点y ＝ -1)
                    点x ＝ x ＋ 点阵 [i] [2]
                    点y ＝ y ＋ 点阵 [i] [3]
                .否则
                    跳出循环 ()
                .如果结束
            .如果真结束
        .计次循环尾 ()
        .如果真 (i ＝ 9)
            i ＝ 点是否孤立 (位图, 点x, 点y)
            .如果真 (i ＝ 孤立值)
                颜色表 [x] [y] ＝ #白色
                颜色表 [点x] [点y] ＝ #白色
            .如果真结束
        .如果真结束
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
位图 ＝ 颜色表构建位图 (颜色表)
返回 (位图)
.子程序 位图缩放, 字节集, 公开
.参数 位图, 字节集
.参数 缩放后宽, 整数型
.参数 缩放后高, 整数型
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 x0, 双精度小数型
.局部变量 y0, 双精度小数型
.局部变量 x1, 整数型
.局部变量 x2, 整数型
.局部变量 y1, 整数型
.局部变量 y2, 整数型
.局部变量 颜色1, 字节集
.局部变量 颜色2, 字节集
.局部变量 缩放颜色r1, 双精度小数型
.局部变量 缩放颜色g1, 双精度小数型
.局部变量 缩放颜色b1, 双精度小数型
.局部变量 缩放颜色r2, 双精度小数型
.局部变量 缩放颜色g2, 双精度小数型
.局部变量 缩放颜色b2, 双精度小数型
.局部变量 dt颜色r, 双精度小数型
.局部变量 dt颜色g, 双精度小数型
.局部变量 dt颜色b, 双精度小数型
.局部变量 缩放宽比, 双精度小数型
.局部变量 缩放高比, 双精度小数型
.局部变量 颜色表, 整数型, , "0"
.局部变量 缩放颜色表, 整数型, , "0"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
取位图颜色表 (位图, 颜色表)
重定义数组 (缩放颜色表, 假, 缩放后宽, 缩放后高)
缩放宽比 ＝ w ÷ 缩放后宽
缩放高比 ＝ h ÷ 缩放后高
.计次循环首 (缩放后宽, x)
    .计次循环首 (缩放后高, y)
        x0 ＝ x × 缩放宽比
        y0 ＝ y × 缩放高比
        .如果 (到整数 (x0) ≠ x0)
            x1 ＝ 选择 (到整数 (x0) ＜ 1, 1, 到整数 (x0))
            x2 ＝ 到整数 (x0) ＋ 1
        .否则
            x1 ＝ x0
            x2 ＝ x0
        .如果结束
        .如果 (到整数 (y0) ≠ y0)
            y1 ＝ 选择 (到整数 (y0) ＜ 1, 1, 到整数 (y0))
            y2 ＝ 到整数 (y0) ＋ 1
        .否则
            y1 ＝ y0
            y2 ＝ y0
        .如果结束
        颜色1 ＝ 到字节集 (颜色表 [x1] [y1])
        颜色2 ＝ 到字节集 (颜色表 [x1] [y2])
        缩放颜色r1 ＝ 颜色2 [1] － (颜色2 [1] － 颜色1 [1]) × (y2 － y0)
        缩放颜色g1 ＝ 颜色2 [2] － (颜色2 [2] － 颜色1 [2]) × (y2 － y0)
        缩放颜色b1 ＝ 颜色2 [3] － (颜色2 [3] － 颜色1 [3]) × (y2 － y0)
        颜色1 ＝ 到字节集 (颜色表 [x2] [y1])
        颜色2 ＝ 到字节集 (颜色表 [x2] [y2])
        缩放颜色r2 ＝ 颜色2 [1] － (颜色2 [1] － 颜色1 [1]) × (y2 － y0)
        缩放颜色g2 ＝ 颜色2 [2] － (颜色2 [2] － 颜色1 [2]) × (y2 － y0)
        缩放颜色b2 ＝ 颜色2 [3] － (颜色2 [3] － 颜色1 [3]) × (y2 － y0)
        dt颜色r ＝ 缩放颜色r2 － (缩放颜色r2 － 缩放颜色r1) × (x2 － x0)
        dt颜色g ＝ 缩放颜色g2 － (缩放颜色g2 － 缩放颜色g1) × (x2 － x0)
        dt颜色b ＝ 缩放颜色b2 － (缩放颜色b2 － 缩放颜色b1) × (x2 － x0)
        颜色1 [1] ＝ 四舍五入 (dt颜色r, )
        颜色1 [2] ＝ 四舍五入 (dt颜色g, )
        颜色1 [3] ＝ 四舍五入 (dt颜色b, )
        缩放颜色表 [x] [y] ＝ 取字节集数据 (颜色1, 3, )
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
返回 (颜色表构建位图 (缩放颜色表))
.子程序 位图转换位数, 字节集, 公开
.参数 位图, 字节集
.参数 位数, 整数型
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 i, 整数型
.局部变量 rgb1, 字节集
.局部变量 rgb2, 字节集
.局部变量 亮度值, 双精度小数型
.局部变量 颜色值, 整数型
.局部变量 颜色表, 整数型, , "0"
.局部变量 调色板, 整数型, , "0"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
取位图颜色表 (位图, 颜色表)
.如果真 (位数 ＝ 8 或 位数 ＝ 4 或 位数 ＝ 1)
    .计次循环首 (w, x)
        .计次循环首 (h, y)
            rgb1 ＝ 到字节集 (颜色表 [x] [y])
            亮度值 ＝ rgb1 [1] × 0.299 ＋ rgb1 [2] × 0.588 ＋ rgb1 [3] × 0.113
            连续赋值 (四舍五入 (亮度值, ), rgb1 [1], rgb1 [2], rgb1 [3])
            颜色表 [x] [y] ＝ 取字节集数据 (rgb1, 3, )
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    .如果真 (位数 ＝ 4 或 位数 ＝ 1)
        .如果 (位数 ＝ 4)
            调色板 ＝ { 0, 8388608, 32768, 8421376, 128, 8388736, 32896, 8421504, 12632256, 16711680, 65280, 16776960, 255, 16711935, 65535, 16777215 }
        .否则
            调色板 ＝ { #黑色, #白色 }
        .如果结束
        .计次循环首 (w, x)
            .计次循环首 (h, y)
                rgb1 ＝ 到字节集 (颜色表 [x] [y])
                亮度值 ＝ rgb1 [1]
                颜色值 ＝ -1
                .计次循环首 (取数组成员数 (调色板), i)
                    .如果 (颜色值 ＝ -1)
                        颜色值 ＝ 调色板 [i]
                    .否则
                        rgb1 ＝ 到字节集 (颜色值)
                        rgb2 ＝ 到字节集 (调色板 [i])
                        颜色值 ＝ 选择 (取绝对值 (rgb2 [1] × 0.113 ＋ rgb2 [2] × 0.588 ＋ rgb2 [3] × 0.299 － 亮度值) ＜ 取绝对值 (rgb1 [1] × 0.113 ＋ rgb1 [2] × 0.588 ＋ rgb1 [3] × 0.299 － 亮度值), 调色板 [i], 颜色值)
                    .如果结束
                .计次循环尾 ()
                颜色表 [x] [y] ＝ 颜色值
            .计次循环尾 ()
            处理事件 ()
        .计次循环尾 ()
    .如果真结束
.如果真结束
位图 ＝ 颜色表构建位图 (颜色表, 位数)
返回 (位图)
.子程序 位图二值化, 字节集, 公开
.参数 位图, 字节集
.参数 阀值, 整数型
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 rgb, 字节集
.局部变量 颜色表, 整数型, , "0"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
取位图颜色表 (位图, 颜色表)
.计次循环首 (w, x)
    .计次循环首 (h, y)
        rgb ＝ 到字节集 (颜色表 [x] [y])
        .如果 (rgb [1] ＜ 阀值 且 rgb [2] ＜ 阀值 且 rgb [3] ＜ 阀值)
            颜色表 [x] [y] ＝ #黑色
        .否则
            颜色表 [x] [y] ＝ #白色
        .如果结束
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
位图 ＝ 颜色表构建位图 (颜色表)
返回 (位图)
.子程序 位图反色, 字节集, 公开
.参数 位图, 字节集
.局部变量 颜色表, 整数型, , "0"
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 rgb, 整数型
.局部变量 bin, 字节集
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
取位图颜色表 (位图, 颜色表)
.计次循环首 (w, x)
    .计次循环首 (h, y)
        rgb ＝ 颜色表 [x] [y]
        bin ＝ 到字节集 (rgb)
        bin [1] ＝ 255 － bin [1]
        bin [2] ＝ 255 － bin [2]
        bin [3] ＝ 255 － bin [3]
        rgb ＝ 取字节集数据 (bin, 3, )
        颜色表 [x] [y] ＝ rgb
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
位图 ＝ 颜色表构建位图 (颜色表)
返回 (位图)
.子程序 取位图轮廓图, 字节集, 公开
.参数 位图, 字节集
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 i, 整数型
.局部变量 rgb, 整数型
.局部变量 颜色表, 整数型, , "0"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
取位图颜色表 (位图, 颜色表)
.计次循环首 (w, x)
    .计次循环首 (h, y)
        rgb ＝ 取位图颜色 (位图, x － 1, y － 1)
        .如果真 (rgb ≠ #白色)
            rgb ＝ 取位图颜色 (位图, x － 2, y － 1)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x － 1, y － 2)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x, y － 1)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x － 1, y)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x － 2, y － 2)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x, y － 2)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x － 2, y)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            rgb ＝ 取位图颜色 (位图, x, y)
            .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                到循环尾 ()
            .如果真结束
            颜色表 [x － 1] [y － 1] ＝ #白色
        .如果真结束
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
返回 (颜色表构建位图 (颜色表))
.子程序 位图细化, 字节集, 公开
.参数 位图, 字节集
.局部变量 表, 字节集
.局部变量 位图宽度, 整数型
.局部变量 位图高度, 整数型
.局部变量 Finished, 逻辑型
.局部变量 X, 整数型
.局部变量 Y, 整数型
.局部变量 w, 整数型
.局部变量 e, 整数型
.局部变量 nw, 整数型
.局部变量 n, 整数型
.局部变量 ne, 整数型
.局部变量 sw, 整数型
.局部变量 s, 整数型
.局部变量 se, 整数型
.局部变量 num, 整数型
表 ＝ { 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0 }
位图宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
位图高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
Finished ＝ 假
.判断循环首 (Finished ＝ 假)
    Finished ＝ 真
    .计次循环首 (位图高度 － 2, Y)
        X ＝ 1
        .判断循环首 (X ＜ 位图宽度 － 2)
            .如果真 (取位图颜色 (位图, X, Y) ≠ #白色)
                w ＝ 选择 (取位图颜色 (位图, X － 1, Y) ＝ #白色, 1, 0)
                e ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y) ＝ #白色, 1, 0)
                .如果真 (w ＝ 1 或 e ＝ 1)
                    nw ＝ 选择 (取位图颜色 (位图, X － 1, Y － 1) ＝ #白色, 1, 0)
                    n ＝ 选择 (取位图颜色 (位图, X, Y － 1) ＝ #白色, 1, 0)
                    ne ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y － 1) ＝ #白色, 1, 0)
                    sw ＝ 选择 (取位图颜色 (位图, X － 1, Y ＋ 1) ＝ #白色, 1, 0)
                    s ＝ 选择 (取位图颜色 (位图, X, Y ＋ 1) ＝ #白色, 1, 0)
                    se ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y ＋ 1) ＝ #白色, 1, 0)
                    num ＝ nw ＋ n × 2 ＋ ne × 4 ＋ w × 8 ＋ e × 16 ＋ sw × 32 ＋ s × 64 ＋ se × 128
                    .如果真 (表 [num ＋ 1] ＝ 1)
                        位图 ＝ 置位图颜色 (位图, X, Y, #白色)
                        Finished ＝ 假
                        X ＝ X ＋ 1
                    .如果真结束
                .如果真结束
            .如果真结束
            X ＝ X ＋ 1
        .判断循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    .计次循环首 (位图宽度 － 2, X)
        Y ＝ 1
        .判断循环首 (Y ＜ 位图高度 － 2)
            .如果真 (取位图颜色 (位图, X, Y) ≠ #白色)
                n ＝ 选择 (取位图颜色 (位图, X, Y － 1) ＝ #白色, 1, 0)
                s ＝ 选择 (取位图颜色 (位图, X, Y ＋ 1) ＝ #白色, 1, 0)
                .如果真 (n ＝ 1 或 s ＝ 1)
                    nw ＝ 选择 (取位图颜色 (位图, X － 1, Y － 1) ＝ #白色, 1, 0)
                    ne ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y － 1) ＝ #白色, 1, 0)
                    w ＝ 选择 (取位图颜色 (位图, X － 1, Y) ＝ #白色, 1, 0)
                    e ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y) ＝ #白色, 1, 0)
                    sw ＝ 选择 (取位图颜色 (位图, X － 1, Y ＋ 1) ＝ #白色, 1, 0)
                    se ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y ＋ 1) ＝ #白色, 1, 0)
                    num ＝ nw ＋ n × 2 ＋ ne × 4 ＋ w × 8 ＋ e × 16 ＋ sw × 32 ＋ s × 64 ＋ se × 128
                    .如果真 (表 [num ＋ 1] ＝ 1)
                        位图 ＝ 置位图颜色 (位图, X, Y, #白色)
                        Finished ＝ 假
                        Y ＝ Y ＋ 1
                    .如果真结束
                .如果真结束
            .如果真结束
            Y ＝ Y ＋ 1
        .判断循环尾 ()
        处理事件 ()
    .计次循环尾 ()
.判断循环尾 ()
返回 (位图)
.子程序 位图分割1, 整数型, 公开
.参数 位图, 字节集
.参数 范围数组, 精易_矩形, 参考 可空 数组
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 i, 整数型
.局部变量 rgb, 整数型
.局部变量 范围, 精易_矩形
.局部变量 有效, 逻辑型, , "2"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
清除数组 (范围数组)
.计次循环首 (w, x)
    有效 [2] ＝ 假
    .计次循环首 (h, y)
        rgb ＝ 取位图颜色 (位图, x － 1, y － 1)
        .如果真 (rgb ≠ #白色)
            .如果 (有效 [1])
                有效 [2] ＝ 真
                范围.顶边 ＝ 选择 (y ＜ 范围.顶边 ＋ 1, y － 1, 范围.顶边)
            .否则
                有效 [1] ＝ 真
                有效 [2] ＝ 真
                范围.左边 ＝ x － 1
                范围.顶边 ＝ y － 1
            .如果结束
            跳出循环 ()
        .如果真结束
    .计次循环尾 ()
    .如果真 (有效 [1])
        .如果真 (有效 [2] ＝ 假)
            有效 [1] ＝ 假
            范围.右边 ＝ x － 范围.左边
            范围.底边 ＝ h － 范围.顶边
            .计次循环首 (范围.底边, y)
                .计次循环首 (范围.右边, i)
                    rgb ＝ 取位图颜色 (位图, 范围.左边 ＋ i － 2, h － y)
                    .如果真 (rgb ≠ #白色)
                        跳出循环 ()
                    .如果真结束
                .计次循环尾 ()
                .如果真 (范围.右边 ＋ 1 ≠ i)
                    跳出循环 ()
                .如果真结束
            .计次循环尾 ()
            范围.底边 ＝ 范围.底边 ＋ 1 － y
            加入成员 (范围数组, 范围)
        .如果真结束
    .如果真结束
    处理事件 ()
.计次循环尾 ()
返回 (取数组成员数 (范围数组))
.子程序 位图分割2, 整数型, 公开
.参数 位图, 字节集
.参数 点阵数组, 点阵, 参考 可空 数组
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 i, 整数型
.局部变量 rgb, 整数型
.局部变量 颜色表, 整数型, , "0"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
清除数组 (点阵数组)
取位图颜色表 (位图, 颜色表)
.计次循环首 (w, x)
    .计次循环首 (h, y)
        rgb ＝ 颜色表 [x] [y]
        .如果真 (rgb ≠ #白色)
            加入成员 (点阵数组, 枚举连续点 (颜色表, x, y))
        .如果真结束
    .计次循环尾 ()
    处理事件 ()
.计次循环尾 ()
返回 (取数组成员数 (点阵数组))
.子程序 取位图有效范围, 精易_矩形, 公开
.参数 位图, 字节集
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 x, 整数型
.局部变量 y, 整数型
.局部变量 有效范围, 精易_矩形
.局部变量 是否有效, 整数型, , "2,3"
w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
.计次循环首 (w, x)
    是否有效 [1] [2] ＝ 0
    是否有效 [2] [2] ＝ 0
    是否有效 [1] [3] ＝ 是否有效 [1] [1]
    是否有效 [2] [3] ＝ 是否有效 [2] [1]
    .计次循环首 (h, y)
        .如果真 (是否有效 [1] [2] ＝ 0 且 有效范围.左边 ＝ 0)
            .如果真 (取位图颜色 (位图, x － 1, y － 1) ＝ #黑色)
                是否有效 [1] [1] ＝ 是否有效 [1] [1] ＋ 1
                是否有效 [1] [2] ＝ 1
            .如果真结束
        .如果真结束
        .如果真 (是否有效 [2] [2] ＝ 0 且 有效范围.右边 ＝ 0)
            .如果真 (取位图颜色 (位图, w － x, h － y) ＝ #黑色)
                是否有效 [2] [1] ＝ 是否有效 [2] [1] ＋ 1
                是否有效 [2] [2] ＝ 1
            .如果真结束
        .如果真结束
    .计次循环尾 ()
    是否有效 [1] [1] ＝ 选择 (是否有效 [1] [3] ＝ 是否有效 [1] [1], 0, 是否有效 [1] [1])
    是否有效 [2] [1] ＝ 选择 (是否有效 [2] [3] ＝ 是否有效 [2] [1], 0, 是否有效 [2] [1])
    .如果真 (是否有效 [1] [1] ＝ 2 且 有效范围.左边 ＝ 0)
        有效范围.左边 ＝ x － 2
    .如果真结束
    .如果真 (是否有效 [2] [1] ＝ 2 且 有效范围.右边 ＝ 0)
        有效范围.右边 ＝ x － 2
    .如果真结束
    处理事件 ()
.计次循环尾 ()
w ＝ w － 有效范围.左边 － 有效范围.右边
数组清零 (是否有效)
.计次循环首 (h, y)
    是否有效 [1] [2] ＝ 0
    是否有效 [2] [2] ＝ 0
    是否有效 [1] [3] ＝ 是否有效 [1] [1]
    是否有效 [2] [3] ＝ 是否有效 [2] [1]
    .计次循环首 (w, x)
        .如果真 (是否有效 [1] [2] ＝ 0 且 有效范围.顶边 ＝ 0)
            .如果真 (取位图颜色 (位图, 有效范围.左边 ＋ x － 1, y － 1) ＝ #黑色)
                是否有效 [1] [1] ＝ 是否有效 [1] [1] ＋ 1
                是否有效 [1] [2] ＝ 1
            .如果真结束
        .如果真结束
        .如果真 (是否有效 [2] [2] ＝ 0 且 有效范围.底边 ＝ 0)
            .如果真 (取位图颜色 (位图, 有效范围.左边 ＋ w － x, h － y) ＝ #黑色)
                是否有效 [2] [1] ＝ 是否有效 [2] [1] ＋ 1
                是否有效 [2] [2] ＝ 1
            .如果真结束
        .如果真结束
    .计次循环尾 ()
    是否有效 [1] [1] ＝ 选择 (是否有效 [1] [3] ＝ 是否有效 [1] [1], 0, 是否有效 [1] [1])
    是否有效 [2] [1] ＝ 选择 (是否有效 [2] [3] ＝ 是否有效 [2] [1], 0, 是否有效 [2] [1])
    .如果真 (是否有效 [1] [1] ＝ 2 且 有效范围.顶边 ＝ 0)
        有效范围.顶边 ＝ y － 2
    .如果真结束
    .如果真 (是否有效 [2] [1] ＝ 2 且 有效范围.底边 ＝ 0)
        有效范围.底边 ＝ y － 2
    .如果真结束
    处理事件 ()
.计次循环尾 ()
有效范围.右边 ＝ w
有效范围.底边 ＝ h － 有效范围.顶边 － 有效范围.底边
返回 (有效范围)
.子程序 点是否孤立, 整数型, , 0表示孤立,1表示左边,2表示左上,4表示上,8表示右上,16表示右,32表示右下,64表示下,128表示左下
.参数 位图, 字节集
.参数 x, 整数型
.参数 y, 整数型
.局部变量 相关点, 整数型
.局部变量 rgb, 整数型
rgb ＝ 取位图颜色 (位图, x, y)
.如果 (rgb ≠ #白色)
    rgb ＝ 取位图颜色 (位图, x － 1, y)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 1
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x － 1, y － 1)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 2
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x, y － 1)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 4
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x ＋ 1, y － 1)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 8
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x ＋ 1, y)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 16
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x ＋ 1, y ＋ 1)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 32
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x, y ＋ 1)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 64
    .如果真结束
    rgb ＝ 取位图颜色 (位图, x － 1, y ＋ 1)
    .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
        相关点 ＝ 相关点 ＋ 128
    .如果真结束
.否则
    相关点 ＝ -1
.如果结束
返回 (相关点)
.子程序 枚举连续点, 点阵
.参数 颜色表, 整数型, 参考 数组
.参数 x, 整数型
.参数 y, 整数型
.局部变量 点阵, 点阵
.局部变量 点组, 整数型, , "0"
.局部变量 颜色组, 整数型, , "0"
.局部变量 data, 字节集
.局部变量 i, 整数型
.局部变量 x0, 字节集
.局部变量 y0, 字节集
.局部变量 minx, 字节集
.局部变量 maxx, 字节集
.局部变量 miny, 字节集
.局部变量 maxy, 字节集
不重复加入点 (点组, 合并整数 (x, y))
加入成员 (颜色组, 颜色表 [x] [y])
子枚举 (颜色表, x, y, 点组, 颜色组)
data ＝ 指针到字节集 (lstrcpynA_整数数组 (点组, 点组, 0), 取数组成员数 (点组) × 4)
minx ＝ 取字节集左边 (data, 2)
maxx ＝ minx
miny ＝ 取字节集中间 (data, 3, 2)
maxy ＝ miny
.计次循环首 (取数组成员数 (点组), i)
    x0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 1, 2)
    y0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 3, 2)
    minx ＝ 比较字节数小 (minx, x0)
    maxx ＝ 比较字节数大 (maxx, x0)
    miny ＝ 比较字节数小 (miny, y0)
    maxy ＝ 比较字节数大 (maxy, y0)
.计次循环尾 ()
重定义数组 (点阵.点, 假, 取字节集数据 (maxx, 3, ) ＋ 1 － 取字节集数据 (minx, 3, ), 取字节集数据 (maxy, 3, ) ＋ 1 － 取字节集数据 (miny, 3, ))
写到内存 (取重复字节集 (取数组成员数 (点阵.点) × 4, { 255, 255, 255, 0 }), lstrcpynA_整数数组 (点阵.点, 点阵.点, 0), 取数组成员数 (点阵.点) × 4)
.计次循环首 (取数组成员数 (点组), i)
    x0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 1, 2)
    y0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 3, 2)
    x ＝ 取字节集数据 (x0, 3, ) ＋ 1 － 取字节集数据 (minx, 3, )
    y ＝ 取字节集数据 (y0, 3, ) ＋ 1 － 取字节集数据 (miny, 3, )
    点阵.点 [x] [y] ＝ 颜色组 [i]
.计次循环尾 ()
返回 (点阵)
.子程序 子枚举
.参数 颜色表, 整数型, 参考 数组
.参数 x, 整数型
.参数 y, 整数型
.参数 点组, 整数型, 参考 数组
.参数 颜色组, 整数型, 参考 数组
.局部变量 w, 整数型
.局部变量 h, 整数型
.局部变量 位图, 字节集
.局部变量 孤立值, 整数型
.局部变量 方位, 整数型, , "8,3"
.局部变量 i, 整数型
.局部变量 点x, 整数型
.局部变量 点y, 整数型
位图 ＝ 颜色表构建位图 (颜色表)
孤立值 ＝ 点是否孤立 (位图, x － 1, y － 1)
位图 ＝ {  }
颜色表 [x] [y] ＝ #白色
写到内存 ({ 1, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 2, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 4, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 8, 0, 0, 0, 1, 0, 0, 0, 255, 255, 255, 255, 16, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 128, 0, 0, 0, 255, 255, 255, 255, 1, 0, 0, 0 }, lstrcpynA_整数数组 (方位, 方位, 0), 96)
w ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 8, 4), 3, )
h ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 4, 4), 3, )
.计次循环首 (8, i)
    .如果真 (位与 (孤立值, 方位 [i] [1]) ＝ 方位 [i] [1])
        点x ＝ x ＋ 方位 [i] [2]
        点y ＝ y ＋ 方位 [i] [3]
        .如果真 (点x ＜ 1 或 点y ＜ 1 或 点x ＞ w 或 点y ＞ h)
            到循环尾 ()
        .如果真结束
        .如果真 (不重复加入点 (点组, 合并整数 (点x, 点y)))
            加入成员 (颜色组, 颜色表 [点x] [点y])
            子枚举 (颜色表, 点x, 点y, 点组, 颜色组)
        .如果真结束
    .如果真结束
    处理事件 ()
.计次循环尾 ()
.子程序 比较字节数大, 字节集, , 返回大数的字节
.参数 数1, 字节集
.参数 数2, 字节集
.局部变量 i1, 整数型
.局部变量 i2, 整数型
.局部变量 n, 整数型
i1 ＝ 取字节集长度 (数1)
i2 ＝ 取字节集长度 (数2)
.如果真 (i1 ≠ 4)
    数1 ＝ 数1 ＋ 取空白字节集 (4 － i1)
.如果真结束
.如果真 (i2 ≠ 4)
    数2 ＝ 数2 ＋ 取空白字节集 (4 － i2)
.如果真结束
.计次循环首 (4, n)
    .如果真 (数1 [5 － n] ≠ 数2 [5 － n])
        返回 (选择 (数1 [5 － n] ＞ 数2 [5 － n], 取字节集左边 (数1, i1), 取字节集左边 (数2, i2)))
    .如果真结束
.计次循环尾 ()
返回 (取字节集左边 (数1, i1))
.子程序 比较字节数小, 字节集, , 返回小数的字节
.参数 数1, 字节集
.参数 数2, 字节集
.局部变量 i1, 整数型
.局部变量 i2, 整数型
.局部变量 n, 整数型
i1 ＝ 取字节集长度 (数1)
i2 ＝ 取字节集长度 (数2)
.如果真 (i1 ≠ 4)
    数1 ＝ 数1 ＋ 取空白字节集 (4 － i1)
.如果真结束
.如果真 (i2 ≠ 4)
    数2 ＝ 数2 ＋ 取空白字节集 (4 － i2)
.如果真结束
.计次循环首 (4, n)
    .如果真 (数1 [5 － n] ≠ 数2 [5 － n])
        返回 (选择 (数1 [5 － n] ＜ 数2 [5 － n], 取字节集左边 (数1, i1), 取字节集左边 (数2, i2)))
    .如果真结束
.计次循环尾 ()
返回 (取字节集左边 (数1, i1))
.子程序 不重复加入点, 逻辑型
.参数 点组, 整数型, 参考 数组
.参数 点, 整数型, , 低16位X,高16位Y
.局部变量 data, 字节集
.局部变量 i, 整数型
data ＝ 指针到字节集 (lstrcpynA_整数数组 (点组, 点组, 0), 取数组成员数 (点组) × 4)
.循环判断首 ()
    i ＝ i ＋ 1
    i ＝ 寻找字节集 (data, 到字节集 (点), i)
    .如果真 (i ＝ -1)
        加入成员 (点组, 点)
        返回 (真)
    .如果真结束
    处理事件 ()
.循环判断尾 (到整数 ((i － 1) ÷ 4) ≠ (i － 1) ÷ 4)
返回 (假)
.子程序 字节集反转, 字节集
.参数 字节集, 字节集
.局部变量 i, 整数型
.局部变量 反转后字节集, 字节集
.局部变量 len, 整数型
len ＝ 取字节集长度 (字节集)
反转后字节集 ＝ 取空白字节集 (len)
.计次循环首 (len, i)
    反转后字节集 [len － i ＋ 1] ＝ 字节集 [i]
.计次循环尾 ()
返回 (反转后字节集)
.程序集 类_图片组操作类, , 公开
.程序集变量 集_图片组句柄, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 销毁图片组, 整数型, 公开, 成功返回非零,失败返回0
返回 (ImageList_Destroy (集_图片组句柄))
.子程序 创建图片组, 字节集, 公开, 创建一个空的图片组，成功返回所创建图片组的数据，失败返回空字节集
.参数 参_宽度, 整数型, 可空, 欲创建图片组的宽度,默认为32
.参数 参_高度, 整数型, 可空, 欲创建图片组的高度,默认为32
.参数 参_位深, 整数型, 可空, 默认为32
.参数 图片组背景颜色, 整数型, 可空, 默认为白色
.如果真 (是否为空 (参_宽度))
    参_宽度 ＝ 32
.如果真结束
.如果真 (是否为空 (参_高度))
    参_高度 ＝ 32
.如果真结束
.如果真 (是否为空 (参_位深))
    参_位深 ＝ 32
.如果真结束
集_图片组句柄 ＝ ImageList_Create (参_宽度, 参_高度, 参_位深, 0, 假)
.如果 (是否为空 (图片组背景颜色))
    置图片组背景颜色 (#白色)
.否则
    置图片组背景颜色 (图片组背景颜色)
.如果结束
返回 (导出图片组 ())
.子程序 删除图标, 逻辑型, 公开, 删除图片组中指定位置的图标,成功返回真,否则返回假
.参数 参_索引位置, 整数型, , 要删除的图标位置,索引从0开始
返回 (ImageList_Remove (集_图片组句柄, 参_索引位置))
.子程序 清空, 逻辑型, 公开, 成功返回真,否则返回假
返回 (ImageList_Remove (集_图片组句柄, -1))
.子程序 取图片组尺寸, 逻辑型, 公开, 取得图片组的图标尺寸,成功返回真,否则返回假
.参数 参_宽度, 整数型, 参考, 此变量用于存放图片组图标宽度
.参数 参_高度, 整数型, 参考, 此变量用于存放图片组图标高度
返回 (ImageList_GetIconSize (集_图片组句柄, 参_宽度, 参_高度))
.子程序 取图片组图标数, 整数型, 公开, 取出图片组的图标数
返回 (ImageList_GetImageCount (集_图片组句柄))
.子程序 置图片组图标尺寸, 逻辑型, 公开, 设置图片组的图标大小,成功返回真,否则返回假
.参数 参_宽度, 整数型, , 要设置的图标组图标宽度
.参数 参_高度, 整数型, , 要设置的图标组图标高度
返回 (ImageList_SetIconSize (集_图片组句柄, 参_宽度, 参_高度))
.子程序 置图片组图标数, 逻辑型, 公开, 成功返回真,否则返回假
.参数 图标数量, 整数型, , 要设置的图片组图标数量
返回 (ImageList_SetImageCount (集_图片组句柄, 图标数量))
.子程序 取图片组背景颜色, 整数型, 公开, 返回图片组的背景颜色
返回 (ImageList_GetBkColor (集_图片组句柄))
.子程序 置图片组背景颜色, 逻辑型, 公开, 成功返回真,否则返回假
.参数 背景颜色值, 整数型, , 要设置的图片组背景颜色值
返回 (ImageList_SetBkColor (集_图片组句柄, 背景颜色值))
.子程序 取图片组句柄, 整数型, 公开, 返回创建成功后的图片组句柄
返回 (集_图片组句柄)
.子程序 置图片组句柄, , 公开, 设置要操作的图片组句柄
.参数 句柄, 整数型, , 要设置要操作的图片组句柄
集_图片组句柄 ＝ 句柄
.子程序 替换图标, 逻辑型, 公开, 根据图标句柄替换指定索引的图标,成功返回真,失败返回假
.参数 图标句柄, 整数型, , 欲替换成的ico图标的句柄,可用命令 载入图标_ 返回的句柄
.参数 替换位置索引, 整数型, , 欲替换图片组的索引位置,0为第一位置,如果为空表示插入到尾部
返回 (ImageList_ReplaceIcon (集_图片组句柄, 替换位置索引, 图标句柄) ≠ -1)
.子程序 替换位图, 整数型, 公开, 成功返回非0失败返回0
.参数 位图句柄, 整数型, , 欲替换成的位图的句柄,可用命令 载入位图_ 返回的句柄
.参数 替换位置索引, 整数型, , 欲替换图片组的索引位置,0为第一位置
返回 (ImageList_Replace (集_图片组句柄, 替换位置索引, 位图句柄, 0))
.子程序 导出图片组_其它语言, 字节集, , 取回图片组的数据
.局部变量 字节流, 字节流
.局部变量 返回值, 逻辑型
.局部变量 图片组字节集, 字节集
字节流.创建字节流 ()
返回值 ＝ ImageList_Write (集_图片组句柄, 字节流.取字节流指针 ())
.如果真 (返回值)
    图片组字节集 ＝ 字节流.取出字节集 ()
.如果真结束
字节流.释放字节流 ()
返回 (图片组字节集)
.子程序 导出图片组, 字节集, 公开, 取出为易使用的图片组字节集 
.局部变量 字节流, 字节流
.局部变量 返回值, 逻辑型
.局部变量 图片组字节集, 字节集
字节流.创建字节流 ()
返回值 ＝ ImageList_Write (集_图片组句柄, 字节流.取字节流指针 ())
.如果 (返回值)
    图片组字节集 ＝ { 77, 73, 84, 76, 0, 0, 0, 255 } ＋ 字节流.取出字节集 ()
.否则
    信息框 (“取出失败”, 0, )
.如果结束
字节流.释放字节流 ()
返回 (图片组字节集)
.子程序 导入图片组_其它语言, 逻辑型, , 将图片组字节集数据读入到本类中操作使用,成功返回真,失败返回假
.参数 图片组字节集, 字节集, , 要读入的图片组数据
.局部变量 字节流, 字节流
字节流.创建字节流 (图片组字节集)
集_图片组句柄 ＝ ImageList_Read (字节流.取字节流指针 ())  ' 将图片组句柄赋值
字节流.释放字节流 ()
返回 (集_图片组句柄 ≠ 0)  ' 成功返回图片组句柄
.子程序 导入图片组, 逻辑型, 公开, 将易图片组读入为类图片组
.参数 图片组字节集, 字节集, , 要读入的图片组数据
.局部变量 字节流, 字节流
图片组字节集 ＝ 取字节集中间 (图片组字节集, 9, 取字节集长度 (图片组字节集) － 8)  ' 前面的八个字节为易图片组标志头  MITL.... 的字节集数据
字节流.创建字节流 (图片组字节集)
集_图片组句柄 ＝ ImageList_Read (字节流.取字节流指针 ())  ' 将图片组句柄赋值
字节流.释放字节流 ()
返回 (集_图片组句柄 ≠ 0)  ' 成功返回图片组句柄
.子程序 取图标句柄_从文件, 整数型, 公开, 载入指定图标,成功返回图标句柄,失败返回0
.参数 图标文件路径, 文本型, , 欲载入的图标文件全路径
返回 (LoadImage (0, 图标文件路径, 1, 0, 0, 16))
.子程序 取图片句柄_从文件, 整数型, 公开, 载入指定位图,成功返回位图句柄,失败返回0
.参数 位图文件路径, 文本型, , 欲载入的位图文件全路径,只能为BMP格式位图文件路径
返回 (LoadImage (0, 位图文件路径, 0, 0, 0, 16))
.子程序 取图片句柄_从字节集, 整数型, 公开, 载入指定图片,或者图标.成功返回位图句柄,失败返回0
.参数 图片字节集, 字节集, , 欲载入的bmp,jpg等图片资源或者ico图标字节集
.局部变量 图片对象, 对象, 静态
.局部变量 图片句柄, 整数型
CoInitialize (0)
图片对象.创建图片对象 (图片字节集)
图片句柄 ＝ 图片对象.读数值属性 (“Handle”, )
CoUninitialize ()
返回 (图片句柄)
.子程序 加入图标_从字节集, 逻辑型, 公开
.参数 图片字节集, 字节集, , 要加入的bmp,jpg等图片资源或者ico图标字节集
返回 (加入图标_从句柄 (取图片句柄_从字节集 (图片字节集)) ≠ -1)
.子程序 加入位图_从文件, 整数型, 公开, 成功返回添加位图后的图片索引,失败返回 -1
.参数 位图文件路径, 文本型, , 要添加的bmp位图文件路径,只能为bmp格式图片,如果这个位图尺寸大于了创建图片组的尺寸,将自动被分割成多个图片,自动添加到图片组中
.局部变量 位图句柄, 整数型
位图句柄 ＝ 取图片句柄_从文件 (位图文件路径)
返回 (ImageList_Add (集_图片组句柄, 位图句柄, 0))
.子程序 加入位图_从句柄, 整数型, 公开, 成功返回添加位图后的图片索引,失败返回 -1
.参数 位图句柄, 整数型, , 可用命令 载入位图_从字节集_ ,载入位图_从文件_ 返回的句柄,欲添加的bmp位图图片句柄,只能为bmp格式图片,如果这个位图尺寸大于了创建图片组的尺寸,将自动被分割成多个图片,自动添加到图片组中
返回 (ImageList_Add (集_图片组句柄, 位图句柄, 0))
.子程序 加入图标_从文件, 整数型, 公开, 成功返回添加图标后的图片索引,失败返回 -1
.参数 图标文件路径, 文本型, , 欲添加的ico图标文件路径
.局部变量 图标句柄, 整数型
图标句柄 ＝ 取图标句柄_从文件 (图标文件路径)
返回 (ImageList_AddIcon (集_图片组句柄, 图标句柄))
.子程序 加入图标_从句柄, 整数型, 公开, 成功返回添加图标后的图片索引,失败返回 -1
.参数 图标句柄, 整数型, , 欲添加的ico图标的句柄,可用命令 取图标句柄_从文件 返回的句柄
返回 (ImageList_AddIcon (集_图片组句柄, 图标句柄))
.程序集 类_像素组, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
' 命令收集地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14182970
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 位图_转_像素组, 逻辑型, 公开, 图片宽高小于1才会返回假
.参数 wt_, 类_位图操作
.参数 shuj_, 整数型, 数组
.局部变量 k_, 整数型
.局部变量 g_, 整数型
.局部变量 q1, 整数型
.局部变量 g_s1, 整数型
.局部变量 y_, 整数型
.局部变量 k_s1, 整数型
.局部变量 s1, 整数型
k_ ＝ wt_.取宽度 ()
g_ ＝ wt_.取高度 ()
.如果真 (k_ ＜ 1)
    返回 (假)
.如果真结束
.如果真 (g_ ＜ 1)
    返回 (假)
.如果真结束
q1 ＝ k_ × g_
重定义数组 (shuj_, 假, q1)
.计次循环首 (g_, g_s1)
    y_ ＝ g_s1 － 1
    .计次循环首 (k_, k_s1)
        s1 ＝ s1 ＋ 1  ' 优化
        shuj_ [s1] ＝ wt_.取某点颜色 (k_s1 － 1, y_)
    .计次循环尾 ()
.计次循环尾 ()
返回 (真)
.子程序 像素组_转_位图, 逻辑型, 公开
.参数 位图_, 类_位图操作, 参考
.参数 shuj_, 整数型, 数组
.参数 k_, 整数型
.参数 g_, 整数型
.局部变量 q1, 整数型
.局部变量 k_s1, 整数型
.局部变量 g_s1, 整数型
.局部变量 y_, 整数型
.局部变量 s1, 整数型
q1 ＝ k_ × g_
.如果真 (q1 ＜ 1)
    返回 (假)
.如果真结束
.如果真 (取数组成员数 (shuj_) ＜ q1)
    返回 (假)
.如果真结束
位图_.创建空白位图 (k_, g_, 24)
.计次循环首 (g_, g_s1)
    y_ ＝ g_s1 － 1
    .计次循环首 (k_, k_s1)
        s1 ＝ s1 ＋ 1  ' 优化
        位图_.置某点颜色 (k_s1 － 1, y_, shuj_ [s1])
    .计次循环尾 ()
.计次循环尾 ()
返回 (真)
.子程序 像素组_取_某点颜色, 整数型, 公开
.参数 shuj_, 整数型, 数组
.参数 k, 整数型
.参数 x, 整数型
.参数 y, 整数型
.局部变量 ls_d, 整数型
.局部变量 q1, 整数型
q1 ＝ 取数组成员数 (shuj_)
.如果真 (q1 ＜ 1)
    返回 (0)
.如果真结束
ls_d ＝ (y － 1) × k ＋ x
.如果真 (q1 ≥ ls_d)
    返回 (shuj_ [ls_d])
.如果真结束
返回 (0)
.子程序 像素组_置_某点颜色, , 公开
.参数 shuj_, 整数型, 数组
.参数 k, 整数型
.参数 x, 整数型
.参数 y, 整数型
.参数 置入颜色, 整数型
.局部变量 ls_d, 整数型
.局部变量 q1, 整数型
q1 ＝ 取数组成员数 (shuj_)
.如果真 (q1 ＜ 1)
    返回 ()
.如果真结束
ls_d ＝ (y － 1) × k ＋ x
.如果真 (q1 ≥ ls_d)
    shuj_ [ls_d] ＝ 置入颜色
.如果真结束
.子程序 像素组_缩放图片_快速, 逻辑型, 公开, 图片宽高小于1才会返回假
.参数 shuj_, 整数型, 数组
.参数 k_, 整数型
.参数 g_, 整数型
.参数 缩放后_k, 整数型
.参数 缩放后_g, 整数型
.参数 缩放后数据, 整数型, 数组
.局部变量 q1, 整数型
.局部变量 q2, 整数型
.局部变量 x_int, 整数型
.局部变量 y_int, 整数型
.局部变量 g_s1, 整数型
.局部变量 k_s1, 整数型
.局部变量 shu_1, 整数型
.局部变量 shu_2, 整数型
.局部变量 yt_d, 整数型
.局部变量 sf_d, 整数型
q1 ＝ k_ × g_
.如果真 (q1 ＜ 1)
    返回 (假)
.如果真结束
.如果真 (取数组成员数 (shuj_) ＜ q1)
    返回 (假)
.如果真结束
q2 ＝ 缩放后_k × 缩放后_g
.如果真 (q2 ＜ 1)
    返回 (假)
.如果真结束
重定义数组 (缩放后数据, 假, q2)
' ------------------------
x_int ＝ k_ × 1000 ÷ 缩放后_k
y_int ＝ g_ × 1000 ÷ 缩放后_g
.计次循环首 (缩放后_g, g_s1)
    .计次循环首 (缩放后_k, k_s1)
        shu_1 ＝ k_s1 × x_int ÷ 1000
        shu_2 ＝ g_s1 × y_int ÷ 1000
        .如果真 (shu_1 ＜ 1)
            shu_1 ＝ 1
        .如果真结束
        .如果真 (shu_2 ＜ 1)
            shu_2 ＝ 1
        .如果真结束
        yt_d ＝ (shu_2 － 1) × k_ ＋ shu_1
        sf_d ＝ (g_s1 － 1) × 缩放后_k ＋ k_s1
        缩放后数据 [sf_d] ＝ shuj_ [yt_d]
    .计次循环尾 ()
.计次循环尾 ()
返回 (真)
.子程序 像素组_缩放图片_无损, 逻辑型, 公开
.参数 shuj_, 整数型, 数组
.参数 k_, 整数型
.参数 g_, 整数型
.参数 缩放后_k, 整数型
.参数 缩放后_g, 整数型
.参数 缩放后数据, 整数型, 数组
.局部变量 q1, 整数型
.局部变量 q2, 整数型
.局部变量 x_int, 整数型
.局部变量 y_int, 整数型
.局部变量 xh_x, 整数型
.局部变量 xh_y, 整数型
.局部变量 g_s1, 整数型
.局部变量 k_s1, 整数型
.局部变量 shu_1, 整数型
.局部变量 shu_2, 整数型
.局部变量 N, 整数型
.局部变量 R, 整数型
.局部变量 G, 整数型
.局部变量 B, 整数型
.局部变量 临时_x, 整数型
.局部变量 临时_y, 整数型
.局部变量 临时_颜色, 整数型
.局部变量 临时_点, 整数型
q1 ＝ k_ × g_
.如果真 (q1 ＜ 1)
    返回 (假)
.如果真结束
.如果真 (取数组成员数 (shuj_) ＜ q1)
    返回 (假)
.如果真结束
q2 ＝ 缩放后_k × 缩放后_g
.如果真 (q2 ＜ 1)
    返回 (假)
.如果真结束
重定义数组 (缩放后数据, 假, q2)
x_int ＝ k_ × 1000 ÷ 缩放后_k
y_int ＝ g_ × 1000 ÷ 缩放后_g
' ---------------------------
xh_x ＝ x_int ÷ 1000
xh_y ＝ y_int ÷ 1000
' ----------------------------
.计次循环首 (缩放后_g, g_s1)
    .计次循环首 (缩放后_k, k_s1)
        shu_1 ＝ x_int × (k_s1 － 1)
        .如果真 (shu_1 ＞ 0)
            shu_1 ＝ shu_1 ÷ 1000
        .如果真结束
        .如果真 (shu_1 ＜ 1)
            shu_1 ＝ 0
        .如果真结束
        N ＝ 0
        R ＝ 0
        G ＝ 0
        B ＝ 0
        临时_颜色 ＝ 0
        .计次循环首 (xh_x, )
            shu_1 ＝ shu_1 ＋ 1
            .判断开始 (shu_1 ＜ 1)
                临时_x ＝ 1
            .默认
                临时_x ＝ shu_1
            .判断结束
            shu_2 ＝ y_int × (g_s1 － 1)
            .如果真 (shu_2 ＞ 0)
                shu_2 ＝ shu_2 ÷ 1000
            .如果真结束
            .如果真 (shu_2 ＜ 1)
                shu_2 ＝ 0
            .如果真结束
            .计次循环首 (xh_y, )
                shu_2 ＝ shu_2 ＋ 1
                .判断开始 (shu_2 ＜ 1)
                    临时_y ＝ 1
                .默认
                    临时_y ＝ shu_2
                .判断结束
                临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
                临时_颜色 ＝ shuj_ [临时_点]
                加入_RGB (临时_颜色, R, G, B, N)
            .计次循环尾 ()
            临时_y ＝ y_int × g_s1
            .如果真 (临时_y ＞ 0)
                临时_y ＝ 临时_y ÷ 1000
            .如果真结束
            .如果真 (临时_y ＜ 1)
                临时_y ＝ 1
            .如果真结束
            临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
            临时_颜色 ＝ shuj_ [临时_点]
            加入_RGB (临时_颜色, R, G, B, N)
        .计次循环尾 ()
        临时_x ＝ x_int × k_s1
        .如果真 (临时_x ＞ 0)
            临时_x ＝ 临时_x ÷ 1000
        .如果真结束
        .如果真 (临时_x ＜ 1)
            临时_x ＝ 1
        .如果真结束
        shu_2 ＝ y_int × (g_s1 － 1)
        .如果真 (shu_2 ＞ 0)
            shu_2 ＝ shu_2 ÷ 1000
        .如果真结束
        .如果真 (shu_2 ＜ 1)
            shu_2 ＝ 0
        .如果真结束
        .计次循环首 (xh_y, )
            shu_2 ＝ shu_2 ＋ 1
            .判断开始 (shu_2 ＜ 1)
                临时_y ＝ 1
            .默认
                临时_y ＝ shu_2
            .判断结束
            临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
            临时_颜色 ＝ shuj_ [临时_点]
            加入_RGB (临时_颜色, R, G, B, N)
        .计次循环尾 ()
        临时_y ＝ y_int × g_s1
        .如果真 (临时_y ＞ 0)
            临时_y ＝ 临时_y ÷ 1000
        .如果真结束
        .如果真 (临时_y ＜ 1)
            临时_y ＝ 1
        .如果真结束
        临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
        临时_颜色 ＝ shuj_ [临时_点]
        加入_RGB (临时_颜色, R, G, B, N)
        R ＝ R ÷ N
        G ＝ G ÷ N
        B ＝ B ÷ N
        临时_颜色 ＝ RGB_整数 (R, G, B)
        临时_点 ＝ (g_s1 － 1) × 缩放后_k ＋ k_s1
        缩放后数据 [临时_点] ＝ 临时_颜色
    .计次循环尾 ()
.计次循环尾 ()
返回 (真)
.程序集 类_图像格式转换类, , 公开, 作者：凌晨孤星；修改：邓学彬(泪闯天涯)
.程序集变量 m_hMem, 整数型
.程序集变量 m_Stream, 对象
.程序集变量 m_pBitmap, 整数型
.程序集变量 m_nWidth, 整数型, , , 图片宽度
.程序集变量 m_nHeight, 整数型, , , 图片高度
.程序集变量 m_pBrush, 整数型, , , 背景画刷
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.局部变量 GpInput, GdiplusStartupInput
GpInput.GdiplusVersion ＝ 1
GdiplusStartup (全_Token, GpInput, 0)  ' 启动 GDI+
' 模块命令收录自：http://bbs.eyuyan.com/read.php?tid=405365
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 ()
.如果真 (m_pBrush ≠ 0)
    GdipDeleteBrush (m_pBrush)
    m_pBrush ＝ 0
.如果真结束
.子程序 销毁, , 公开, 销毁载入的图像,释放内存
.如果真 (m_pBitmap ≠ 0)
    GdipDisposeImage (m_pBitmap)
    m_pBitmap ＝ 0
.如果真结束
.如果真 (m_Stream.是否为空 () ＝ 假)
    m_Stream.清除 ()
.如果真结束
.如果真 (m_hMem ≠ 0)
    GlobalFree (m_hMem)
    m_hMem ＝ 0
.如果真结束
m_nWidth ＝ 0
m_nHeight ＝ 0
.子程序 载入图像, 逻辑型, 公开
.参数 图像数据, 字节集
.局部变量 nLength, 整数型
.局部变量 lpvoid, 整数型
.局部变量 pStream1, 整数型
.局部变量 pStream2, 整数型
销毁 ()
nLength ＝ 取字节集长度 (图像数据)
.如果真 (nLength ＜ 5)
    返回 (假)
.如果真结束
m_hMem ＝ GlobalAlloc (#GMEM_MOVEABLE, nLength)
.如果真 (m_hMem ＝ 0)
    返回 (假)
.如果真结束
CreateStreamOnHGlobal_Object (m_hMem, 假, m_Stream)  ' 创建流对象。注意第2个参数！！！！！！！！！如果后面调用了 GlobalFree 进行释放的话，这里第2个参数设置为“假”
.如果真 (m_Stream.是否为空 ())
    返回 (假)
.如果真结束
lpvoid ＝ GlobalLock (m_hMem)  ' 锁定该区域，获得存放数据的地址
.如果真 (lpvoid ＝ 0)
    返回 (假)
.如果真结束
RtlMoveMemory_字节集 (lpvoid, 图像数据, nLength)  ' 把数据写到流里面
GlobalUnlock (m_hMem)  ' 取消锁定
pStream1 ＝ GetObjectPtr (m_Stream, m_Stream, 0)  ' 获得流对象指针
.如果真 (pStream1 ＝ 0)
    返回 (假)
.如果真结束
RtlMoveMemory_整数传址1 (pStream2, pStream1, 4)
.如果真 (pStream2 ＝ 0)
    返回 (假)
.如果真结束
GDIpCreateBitmapFromStream (pStream2, m_pBitmap)  ' 创建位图对象
.如果真 (m_pBitmap ＝ 0)
    返回 (假)
.如果真结束
返回 (m_pBitmap ≠ 0)
.子程序 载入文件, 逻辑型, 公开
.参数 文件名, 文本型, , 完整文件路径。
.局部变量 FileName, 字节集
销毁 ()
.如果真 (文件名 ＝ “”)
    返回 (假)
.如果真结束
FileName ＝ A2W (文件名)
GdipLoadImageFromFile (FileName, m_pBitmap)
返回 (m_pBitmap ≠ 0)
.子程序 转换到字节集, 字节集, 公开, 转换图片为新格式,操作成功返回新图片的字节集,失败返回空字节集.参数1为转换格式(1、bmp；2、jpg；3、gif；4、tiff；5、png),参数2为JPG图片质量(0-100)
.参数 转换格式, 整数型, , 转换后的图片格式。1、bmp；2、jpg；3、gif；4、tiff；5、png
.参数 JPG图片质量, 整数型, 可空, 只对JPG格式有效,0最差效果,100最好效果,留空默认为100
.局部变量 Clsid, 字节集
.局部变量 DataStream, 对象
.局部变量 hMemDataStream, 整数型
.局部变量 pDataStream, 整数型
.局部变量 nStreamSize, 整数型
.局部变量 bRet, 逻辑型
.局部变量 eps, EncoderParameters
.局部变量 quality, 整数型
.局部变量 新图像, 字节集
.局部变量 pStream2, 整数型
.局部变量 pStream1, 整数型
.如果真 (m_pBitmap ＝ 0)
    返回 (新图像)
.如果真结束
填充背景 ()
' //-----------------------------------------
.如果真 (是否为空 (JPG图片质量))
    JPG图片质量 ＝ 100
.如果真结束
.如果真 (JPG图片质量 ＜ 0)
    JPG图片质量 ＝ 0
.如果真结束
.如果真 (JPG图片质量 ＞ 100)
    JPG图片质量 ＝ 100
.如果真结束
' //-----------------------------------------
GetCLSID (转换格式, Clsid)
eps.Count ＝ 1
eps.Parameter [1].Type ＝ 4
eps.Parameter [1].NumberOfValues ＝ 1
.如果真 (转换格式 ＝ 2)  ' jpg
    quality ＝ JPG图片质量  ' 图片质量，0最差效果，100最好效果
    eps.Parameter [1].Value ＝ lstrcpynA_整数传址 (quality, quality, 0)
    CLSIDFromString_字节 (A2W (“{1d5be4b5-fa4a-452d-9cdd-5db35105e7eb}”, ), eps.Parameter [1].Guid)
.如果真结束
' //-----------------------------------------
hMemDataStream ＝ GlobalAlloc (#GMEM_MOVEABLE, 0)
CreateStreamOnHGlobal_Object (hMemDataStream, 假, DataStream)
pStream1 ＝ GetObjectPtr (DataStream, DataStream, 0)  ' 获得流对象指针
.如果真 (pStream1 ≠ 0)
    RtlMoveMemory_整数传址1 (pStream2, pStream1, 4)
    .如果真 (pStream2 ≠ 0)
        GdipSaveImageToStream (m_pBitmap, pStream2, Clsid, eps)
        pDataStream ＝ GlobalLock (hMemDataStream)
        nStreamSize ＝ GlobalSize (hMemDataStream)
        .如果真 (pDataStream ≠ 0)
            新图像 ＝ 取空白字节集 (nStreamSize)
            RtlMoveMemory_int2Bytes (新图像, pDataStream, nStreamSize)
            bRet ＝ 真
        .如果真结束
        GlobalUnlock (hMemDataStream)
    .如果真结束
.如果真结束
GlobalFree (hMemDataStream)
返回 (新图像)
.子程序 转换到文件, 逻辑型, 公开, 转换图片为新格式,操作成功返回真,失败返回假.参数1为转换格式(1、bmp；2、jpg；3、gif；4、tiff；5、png),参数2为JPG图片质量(0-100)
.参数 文件名, 文本型, , 完整文件路径,存放转换后的图片。
.参数 转换格式, 整数型, , 转换后的图片格式。1、bmp；2、jpg；3、gif；4、tiff；5、png
.参数 JPG图片质量, 整数型, 可空, 只对JPG格式有效,0最差效果,100最好效果,留空默认为100
.局部变量 Clsid, 字节集
.局部变量 FileName, 字节集
.局部变量 eps, EncoderParameters
.局部变量 quality, 整数型
.局部变量 r, 整数型
.如果真 (m_pBitmap ＝ 0)
    返回 (假)
.如果真结束
.如果真 (文件名 ＝ “”)
    返回 (假)
.如果真结束
填充背景 ()
' //-----------------------------------------
.如果真 (是否为空 (JPG图片质量))
    JPG图片质量 ＝ 100
.如果真结束
.如果真 (JPG图片质量 ＜ 0)
    JPG图片质量 ＝ 0
.如果真结束
.如果真 (JPG图片质量 ＞ 100)
    JPG图片质量 ＝ 100
.如果真结束
' //-----------------------------------------
GetCLSID (转换格式, Clsid)
eps.Count ＝ 1
eps.Parameter [1].Type ＝ 4
eps.Parameter [1].NumberOfValues ＝ 1
.如果真 (转换格式 ＝ 2)  ' jpg
    quality ＝ JPG图片质量  ' 图片质量，0最差效果，100最好效果
    eps.Parameter [1].Value ＝ lstrcpynA_整数传址 (quality, quality, 0)
    CLSIDFromString_字节 (A2W (“{1d5be4b5-fa4a-452d-9cdd-5db35105e7eb}”, ), eps.Parameter [1].Guid)
.如果真结束
' //-----------------------------------------
FileName ＝ A2W (文件名)
r ＝ GdipSaveImageToFile_EncoderParameters (m_pBitmap, FileName, Clsid, eps)
返回 (r ＝ 0)
.子程序 填充背景, , 公开
.局部变量 pNewBitmap, 整数型
.局部变量 pGraphics, 整数型
.如果真 (m_pBitmap ＝ 0)
    返回 ()
.如果真结束
.如果真 (m_pBrush ＝ 0)
    返回 ()
.如果真结束
' //-----------------------------------------------
.如果真 (m_nWidth ＝ 0 或 m_nHeight ＝ 0)
    GdipGetImageWidth (m_pBitmap, m_nWidth)
    GdipGetImageHeight (m_pBitmap, m_nHeight)
.如果真结束
GdipCreateBitmapFromScan0 (m_nWidth, m_nHeight, 0, #像素格式_32bppARGB, 0, pNewBitmap)
.如果真 (pNewBitmap ＝ 0)
    返回 ()
.如果真结束
GdipGetImageGraphicsContext (pNewBitmap, pGraphics)
GdipFillRectangle (pGraphics, m_pBrush, 0, 0, m_nWidth, m_nHeight)
GdipDrawImageRectRect_NULL (pGraphics, m_pBitmap, 0, 0, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight, #单位_像素, 0, 0, 0)
GdipDeleteGraphics (pGraphics)
' //-----------------------------------------------
销毁 ()
m_pBitmap ＝ pNewBitmap
.子程序 取图片宽度, 整数型, 公开
.如果真 (m_pBitmap ≠ 0 且 m_nWidth ＝ 0)
    取图片尺寸 (0, 0)
.如果真结束
返回 (m_nWidth)
.子程序 取图片高度, 整数型, 公开
.如果真 (m_pBitmap ≠ 0 且 m_nHeight ＝ 0)
    取图片尺寸 (0, 0)
.如果真结束
返回 (m_nHeight)
.子程序 取图片尺寸, , 公开
.参数 图片宽度, 整数型, 参考
.参数 图片高度, 整数型, 参考
.如果真 (m_pBitmap ≠ 0)
    .如果真 (m_nWidth ＝ 0)
        GdipGetImageWidth (m_pBitmap, m_nWidth)
    .如果真结束
    .如果真 (m_nHeight ＝ 0)
        GdipGetImageHeight (m_pBitmap, m_nHeight)
    .如果真结束
    .如果真 (m_nWidth ＝ 0 或 m_nHeight ＝ 0)
        销毁 ()
    .如果真结束
.如果真结束
图片宽度 ＝ m_nWidth
图片高度 ＝ m_nHeight
.子程序 取图片句柄, 整数型, 公开
返回 (m_pBitmap)
.子程序 置背景颜色, , 公开, 设置转换后图片的背景颜色
.参数 背景颜色, 整数型, , RGB颜色值，-1为透明(不填充背景)
.如果真 (m_pBrush ≠ 0)
    GdipDeleteBrush (m_pBrush)
    m_pBrush ＝ 0
.如果真结束
.如果真 (背景颜色 ≥ 0)
    GdipCreateSolidFill (RGB2ARGB (背景颜色), m_pBrush)
.如果真结束
.子程序 GetCLSID
.参数 转换格式, 整数型, , 转换后的图片格式。1、bmp；2、jpg；3、gif；4、tiff；5、png
.参数 Clsid, 字节集, 参考
.局部变量 pStr, 文本型
.判断开始 (转换格式 ＝ 1)  ' bmp
    pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
.判断 (转换格式 ＝ 2)  ' jpg
    pStr ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
.判断 (转换格式 ＝ 3)  ' gif
    pStr ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
.判断 (转换格式 ＝ 4)  ' tiff
    pStr ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
.判断 (转换格式 ＝ 5)  ' png
    pStr ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
.默认
    pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
.判断结束
Clsid ＝ 取空白字节集 (16)
CLSIDFromString_字节集传址2 (A2W (pStr, ), Clsid)  ' 获取图像格式对应的Clsid
.程序集 集_网页
.程序集变量 集_屏蔽信息框线程句柄, 整数型, , , 开始屏蔽信息框
.程序集变量 集_点击信息框标识文本, 文本型, , , 点击屏蔽信息框
.程序集变量 集_按钮的标题, 文本型, , , 点击屏蔽信息框
.子程序 网页_取IP地址, 精易_IP归属地, 公开
.局部变量 局_网址, 文本型
.局部变量 局_返回, 文本型
.局部变量 局_Json, 类_json
.局部变量 局_归属地, 精易_IP归属地
局_网址 ＝ “http://ip.taobao.com/service/getIpInfo2.php?ip=myip&accessKey=alibaba-inc”
局_返回 ＝ 编码_Utf8到Ansi (网页_访问 (局_网址))
局_返回 ＝ 子文本替换 (局_返回, 字符 (10), , , , 真)
局_Json.解析 (局_返回)
局_归属地.IP ＝ 局_Json.取通用属性 (“data.ip”)
局_归属地.国家 ＝ 局_Json.取通用属性 (“data.country”)
局_归属地.省份 ＝ 局_Json.取通用属性 (“data.region”)
局_归属地.城市 ＝ 局_Json.取通用属性 (“data.city”)
局_归属地.运营商 ＝ 局_Json.取通用属性 (“data.isp”)
返回 (局_归属地)
.子程序 网页_IE浏览器网页跳转静音, , 公开, 默认为真  真=静音
.参数 参_是否静音, 逻辑型, 可空
.如果真 (是否为空 (参_是否静音))
    参_是否静音 ＝ 真
.如果真结束
CoInternetSetFeatureEnabled (#FEATURE_DISABLE_NAVIGATION_SOUNDS, #SET_FEATURE_ON_PROCESS, 参_是否静音)  ' 21
.子程序 网页_协议头_取信息, 文本型, 公开, 取出协议头中的某个值 例如302跳转协议头中的 Location
.参数 参_源协议头, 文本型
.参数 参_键名, 文本型, , 例如：Location
.局部变量 局_数组, 文本型, , "0"
.局部变量 i, 整数型
.局部变量 局_数据, 文本型
.局部变量 局_长度, 整数型
局_数组 ＝ 分割文本 (参_源协议头, #换行符, )
局_长度 ＝ 取文本长度 (参_键名)
.计次循环首 (取数组成员数 (局_数组), i)
    .如果真 (取文本左边 (局_数组 [i], 局_长度) ＝ 参_键名)
        局_数据 ＝ 文本_取右边 (局_数组 [i], 参_键名 ＋ “: ”)
        返回 (局_数据)
    .如果真结束
.计次循环尾 ()
返回 (“”)
.子程序 网页_JS格式化_EX, 文本型, 公开
.参数 参数1, 文本型
.局部变量 JS命令, 类_脚本组件
.局部变量 结果, 文本型
JS命令.执行 (#JS格式化EX)
结果 ＝ JS命令.运行 (“FJsDecoder”, 参数1)
返回 (结果)
.子程序 网页_文字翻译, 文本型, 公开, 调用 有道翻译  支持中翻英  或  多语翻中
.参数 参_待翻译, 文本型
.局部变量 局_网址, 文本型
.局部变量 局_方式, 整数型
.局部变量 ADD_协议头, 类_POST数据类
.局部变量 局_提交协议头, 文本型
.局部变量 局_结果, 字节集
.局部变量 局_返回, 文本型
.局部变量 局_待翻译, 文本型
局_待翻译 ＝ 编码_URL编码 (参_待翻译, , 真)
局_网址 ＝ “http://fanyi.youdao.com//translate?i=” ＋ 局_待翻译 ＋ “&type=AUTO&doctype=text&xmlVersion=1.1&keyfrom=360se”
局_方式 ＝ 0
ADD_协议头.添加 (“Connection”, “ keep-alive”)
ADD_协议头.添加 (“Referer”, “ http://fanyi.youdao.com/translate”)
ADD_协议头.添加 (“User-Agent”, “ Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36”)
ADD_协议头.添加 (“Accept-Language”, “ zh-CN,zh;q=0.8”)
局_提交协议头 ＝ ADD_协议头.获取协议头数据 ()
局_结果 ＝ 网页_访问_对象 (局_网址, 局_方式, , , , 局_提交协议头, , , , , , , , , , , )
局_返回 ＝ 到文本 (编码_编码转换对象 (局_结果))
局_返回 ＝ 文本_取右边 (局_返回, “result=”)
返回 (局_返回)
.子程序 网页_更改IE版本, 逻辑型, 公开, 需要XP以上系统支持，且IE版本不低于8，写入后永久生效。多数情况需获取管理员权限，详情参阅：https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/general-info/ee330730(v=vs.85)#browser-emulation
.参数 类型, 整数型, 可空, 为空或0移除写入的版本  1=ie7  2=ie8   3=ie9   4=ie10   5=ie11
.参数 是否使用所有用户, 逻辑型, 可空, 默认为假！使用当前用户，为真则使用所有用户。
.局部变量 局_处理器, 文本型
.局部变量 参数, 整数型
' https://bbs.125.la/thread-14547669-1-1.html
局_处理器 ＝ 读环境变量 (“PROCESSOR_ARCHITECTURE”)
.如果真 (类型 ≤ 0 或 类型 ＞ 5)
    .如果真 (是否使用所有用户)
        .判断开始 (局_处理器 ＝ “x86”)
            返回 (删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 ()))
        .判断 (局_处理器 ＝ “AMD64”)
            返回 (删除注册项 (#本地机器, “SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 ()))
        .默认
        .判断结束
        返回 (假)
    .如果真结束
    返回 (删除注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 ()))
.如果真结束
.判断开始 (类型 ＝ 1)
    参数 ＝ 7000  ' IE 7
.判断 (类型 ＝ 2)
    参数 ＝ 8000  ' IE 8
.判断 (类型 ＝ 3)
    参数 ＝ 9000  ' IE 9
.判断 (类型 ＝ 4)
    参数 ＝ 10000  ' IE 10
.判断 (类型 ＝ 5)
    参数 ＝ 11000  ' IE 11
.默认
.判断结束
.如果真 (是否使用所有用户)
    .判断开始 (局_处理器 ＝ “x86”)
        返回 (写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 (), 参数))
    .判断 (局_处理器 ＝ “AMD64”)
        返回 (写注册项 (#本地机器, “SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 (), 参数))
    .默认
    .判断结束
    返回 (假)
.如果真结束
返回 (写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 (), 参数))
' 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_GPU_RENDERING\” ＋ 取执行文件名 (), 1)
.子程序 网页_eval解密, 文本型, 公开
.参数 原JS文本, 文本型, , 需要加密\解密的JS源文本
.局部变量 脚本, 类_脚本组件
.局部变量 结果, 文本型
结果 ＝ 脚本.计算表达式 (子文本替换 (原JS文本, “eval”, “”, , , 真))
返回 (结果)
.子程序 网页_eval加密, 文本型, 公开
.参数 原JS文本, 文本型, , 需要加密\解密的JS源文本
.局部变量 脚本, 类_脚本组件
.局部变量 结果, 文本型
脚本.执行 (#eval加密)
结果 ＝ 脚本.运行 (“encode”, 原JS文本)
返回 (结果)
.子程序 内部_协议头取值, 文本型
.参数 协议头, 文本型
.局部变量 位置, 整数型
.局部变量 结果, 文本型
位置 ＝ 寻找文本 (协议头, “:”, , 假)
.如果真 (位置 ≠ -1)
    结果 ＝ 取文本右边 (协议头, 取文本长度 (协议头) － 位置)
.如果真结束
返回 (删首尾空 (结果))
.子程序 内部_协议头取名, 文本型
.参数 协议头, 文本型
.局部变量 位置, 整数型
.局部变量 结果, 文本型
位置 ＝ 寻找文本 (协议头, “:”, , 假)
.如果真 (位置 ≠ -1)
    结果 ＝ 取文本左边 (协议头, 位置 － 1)
.如果真结束
返回 (删首尾空 (结果))
.子程序 内部_设Cookie, , , 设定前，请先清除
.参数 域名, 文本型, , 只接受域名
.参数 Cookie内容, 文本型, , 以“;”号结尾
.局部变量 网址, 文本型
.局部变量 计次, 整数型
.局部变量 Cookies, 文本型, , "0"
网址 ＝ “http://” ＋ 域名
Cookies ＝ 分割文本 (Cookie内容, “;”, )
.计次循环首 (取数组成员数 (Cookies), 计次)
    InternetSetCookieA (网址, 内部_Cookie取名 (Cookies [计次]), 内部_Cookie取值 (Cookies [计次]))
.计次循环尾 ()
.子程序 网页_Cookie合并更新ex, 文本型, 公开, 返回更新后的Cookie 感谢【小小n】提供
.参数 旧Cookie, 文本型, 参考, a=1; b=2
.参数 新Cookie, 文本型, , a=1; b=2
.局部变量 局_新Cookie组, 文本型, , "0"
.局部变量 局_合并Cookie组, 文本型, , "0"
.局部变量 局_计次, 整数型
.局部变量 初步合并, 文本型
.局部变量 已存在名称, 文本型, , "0"
.局部变量 C, 整数型
.局部变量 倒序索引, 整数型
.局部变量 i, 整数型
.局部变量 是否存在, 逻辑型
.局部变量 名称, 文本型
.局部变量 值, 文本型
.局部变量 局_合并cookie, 文本型
' 初步合并 顺序：旧→新
' 能处理单次http请求返回多个同名Cookie的情况,例如同时存在 Set-Cookie: a=1;  和 Set-Cookie: a=2; 这种情况以后者为新
初步合并 ＝ 旧Cookie ＋ 选择 (旧Cookie ≠ “” 且 新Cookie ≠ “”, “; ”, “”) ＋ 新Cookie
' 输出调试文本 (“初步合并: ” ＋ 初步合并)
局_合并Cookie组 ＝ 分割文本 (初步合并, “; ”, )
C ＝ 取数组成员数 (局_合并Cookie组)
.计次循环首 (C, 局_计次)
    ' 更新 倒序：新→旧，名称已记录的Cookie一定是更加新的Cookie
    倒序索引 ＝ C ＋ 1 － 局_计次
    名称 ＝ 内部_Cookie取名ex (删首尾空 (局_合并Cookie组 [倒序索引]))
    值 ＝ 内部_Cookie取值 (删首尾空 (局_合并Cookie组 [倒序索引]))
    .如果 (名称 ≠ “”)  ' 过滤
        是否存在 ＝ 假
        .计次循环首 (取数组成员数 (已存在名称), i)
            .如果真 (已存在名称 [i] ＝ 名称)
                是否存在 ＝ 真
                跳出循环 ()
            .如果真结束
        .计次循环尾 ()
        .如果 (是否存在 ＝ 假)
            .如果 (值 ≠ “” 且 到小写 (值) ≠ “deleted”)  ' 过滤
                ' 输出调试文本 (“有效[” ＋ 名称 ＋ “=” ＋ 值 ＋ “]”)
                加入成员 (局_新Cookie组, 局_合并Cookie组 [倒序索引])
            .否则
                ' 输出调试文本 (“名称[” ＋ 名称 ＋ “]过滤无效值”)
            .如果结束
            加入成员 (已存在名称, 名称)
        .否则
            ' 输出调试文本 (“名称[” ＋ 名称 ＋ “]已存在”)
        .如果结束
    .否则
        ' 输出调试文本 (“过滤无效名称[” ＋ 局_合并Cookie组 [倒序索引] ＋ “]”)
    .如果结束
.计次循环尾 ()
局_合并cookie ＝ “”
.计次循环首 (取数组成员数 (局_新Cookie组), i)
    .如果真 (局_合并cookie ≠ “”)
        局_合并cookie ＝ “; ” ＋ 局_合并cookie
    .如果真结束
    局_合并cookie ＝ 局_新Cookie组 [i] ＋ 局_合并cookie
.计次循环尾 ()
旧Cookie ＝ 局_合并cookie
返回 (局_合并cookie)
.子程序 内部_Cookie取名ex, 文本型
.参数 Cookie, 文本型
.局部变量 位置, 整数型
.局部变量 结果, 文本型
位置 ＝ 寻找文本 (Cookie, “=”, , 假)
.判断开始 (位置 ≠ -1)
    ' 输出调试文本 (Cookie, 位置)
    结果 ＝ 取文本左边 (Cookie, 位置 － 1)
.默认
    结果 ＝ “”  ' 无效名称应返回空
.判断结束
返回 (删首尾空 (结果))
.子程序 网页_Cookie合并更新, 文本型, 公开, 返回更新后的Cookie
.参数 旧Cookie, 文本型, 参考
.参数 新Cookie, 文本型
.局部变量 局_旧Cookie组, 文本型, , "0"
.局部变量 局_新Cookie组, 文本型, , "0"
.局部变量 局_计次, 整数型
' 初步格式化
旧Cookie ＝ 删首尾空 (旧Cookie)
.如果真 (取文本右边 (旧Cookie, 1) ＝ “;”)
    旧Cookie ＝ 旧Cookie ＋ 字符 (#空格键)
.如果真结束
新Cookie ＝ 删首尾空 (新Cookie)
.如果真 (取文本右边 (新Cookie, 1) ＝ “;”)
    新Cookie ＝ 新Cookie ＋ 字符 (#空格键)
.如果真结束
' 开始更新Cookie
局_旧Cookie组 ＝ 分割文本 (旧Cookie, “; ”, )
局_新Cookie组 ＝ 分割文本 (新Cookie, “; ”, )
.计次循环首 (取数组成员数 (局_旧Cookie组), 局_计次)
    .如果真 (内部_数组成员是否存在1 (局_新Cookie组, 内部_Cookie取名 (局_旧Cookie组 [局_计次])) ＝ 假)
        加入成员 (局_新Cookie组, 局_旧Cookie组 [局_计次])
    .如果真结束
.计次循环尾 ()
' 去除无效的Cookie
旧Cookie ＝ “”
.计次循环首 (取数组成员数 (局_新Cookie组), 局_计次)
    .如果真 (取文本右边 (局_新Cookie组 [局_计次], 8) ≠ “=deleted”)
        旧Cookie ＝ 旧Cookie ＋ 局_新Cookie组 [局_计次] ＋ “; ”
    .如果真结束
.计次循环尾 ()
旧Cookie ＝ 取文本左边 (旧Cookie, 取文本长度 (旧Cookie) － 2)
' 对重复的Cookie进行合并
旧Cookie ＝ 文本_去重复文本 (旧Cookie, “; ”)
返回 (旧Cookie)
.子程序 内部_数组成员是否存在1, 逻辑型, , Cookie处理专用
.参数 数组, 文本型, 数组
.参数 要判断值, 文本型
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (数组), 局_计次)
    .如果真 (内部_Cookie取名 (数组 [局_计次]) ＝ 要判断值)
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 内部_Cookie取值, 文本型
.参数 Cookie, 文本型
.局部变量 位置, 整数型
.局部变量 结果, 文本型
位置 ＝ 寻找文本 (Cookie, “=”, , 假)
.如果真 (位置 ≠ -1)
    结果 ＝ 取文本右边 (Cookie, 取文本长度 (Cookie) － 位置)
.如果真结束
返回 (结果)
.子程序 内部_Cookie取名, 文本型
.参数 Cookie, 文本型
.局部变量 位置, 整数型
.局部变量 结果, 文本型
位置 ＝ 寻找文本 (Cookie, “=”, , 假)
.判断开始 (位置 ≠ -1)
    结果 ＝ 取文本左边 (Cookie, 位置 － 1)
.默认
    结果 ＝ Cookie
.判断结束
返回 (删首尾空 (结果))
.子程序 网页_处理协议头, 文本型, 公开, 将协议头中的键名首字母处理为大写
.参数 参_原始协议头, 文本型
.局部变量 局_数组, 文本型, , "0"
.局部变量 i, 整数型
.局部变量 局_键名, 文本型
.局部变量 局_键名右, 文本型
.局部变量 局_键名左, 文本型
.局部变量 局_协议头, 文本型
.局部变量 局_键名拼接, 文本型
.局部变量 局_键名数组, 文本型, , "0"
.局部变量 局_总数, 整数型
.局部变量 x, 整数型
.局部变量 局_键值, 文本型
.局部变量 局_冒号位置, 整数型
局_数组 ＝ 分割文本 (参_原始协议头, #换行符, )
.计次循环首 (取数组成员数 (局_数组), i)
    局_冒号位置 ＝ 寻找文本 (局_数组 [i], “:”, , 假)
    .如果真 (局_冒号位置 ＝ -1)
        到循环尾 ()
    .如果真结束
    局_键名 ＝ 取文本中间 (局_数组 [i], 1, 局_冒号位置 － 1)
    .如果 (寻找文本 (局_键名, “-”, , 假) ≠ -1)
        局_键名拼接 ＝ “”
        局_键名数组 ＝ 分割文本 (局_键名, “-”, )
        局_总数 ＝ 取数组成员数 (局_键名数组)
        .计次循环首 (局_总数, x)
            .如果 (x ＝ 局_总数)
                局_键名拼接 ＝ 局_键名拼接 ＋ 文本_首字母改大写 (局_键名数组 [x])
            .否则
                局_键名拼接 ＝ 局_键名拼接 ＋ 文本_首字母改大写 (局_键名数组 [x]) ＋ “-”
            .如果结束
        .计次循环尾 ()
        局_键名 ＝ 局_键名拼接
    .否则
        局_键名 ＝ 文本_首字母改大写 (局_键名)
    .如果结束
    局_键值 ＝ 取文本右边 (局_数组 [i], 取文本长度 (局_数组 [i]) － 取文本长度 (局_键名))
    .如果真 (取代码 (取文本左边 (局_键值, 1), ) ＝ 32)
        局_键值 ＝ 取文本右边 (局_键值, 取文本长度 (局_键值) － 1)
    .如果真结束
    局_协议头 ＝ 局_协议头 ＋ 局_键名 ＋ 局_键值 ＋ #换行符
.计次循环尾 ()
局_协议头 ＝ 取文本左边 (局_协议头, 取文本长度 (局_协议头) － 取文本长度 (#换行符))
返回 (局_协议头)
.子程序 网页_处理协议头ex, 文本型, 公开, 将协议头中的键名首字母处理为大写
.参数 参_原始协yi头, 文本型
.局部变量 首分, 文本型, , "0"
.局部变量 次分, 文本型, , "0"
.局部变量 代码, 整数型
.局部变量 位置, 整数型
.局部变量 输出, 文本型
.局部变量 文件号, 整数型
.局部变量 i, 整数型
' 该命令出自：https://bbs.125.la/thread-14325247-1-1.html
文件号 ＝ 打开内存文件 ()
首分 ＝ 分割文本 (参_原始协yi头, #换行符, )
.计次循环首 (取数组成员数 (首分), i)
    次分 ＝ 分割文本 (首分 [i], “:”, )
    .如果真 (取数组成员数 (次分) ≥ 2)
        代码 ＝ 取代码 (次分 [1], 1)
        .如果真 (代码 ≥ 97 且 代码 ≤ 122)
            次分 [1] ＝ 文本替换 (次分 [1], 1, 1, 字符 (代码 － 32))
            位置 ＝ 寻找文本 (次分 [1], “-”, , 假)
            .判断循环首 (位置 ≠ -1)
                位置 ＝ 位置 ＋ 1
                代码 ＝ 取代码 (次分 [1], 位置)
                .如果真 (代码 ≥ 97 且 代码 ≤ 122)
                    次分 [1] ＝ 文本替换 (次分 [1], 位置, 1, 字符 (代码 － 32))
                .如果真结束
                位置 ＝ 寻找文本 (次分 [1], “-”, 位置, 假)
            .判断循环尾 ()
            首分 [i] ＝ 文本替换 (首分 [i], 1, 取文本长度 (次分 [1]), 次分 [1])
        .如果真结束
        代码 ＝ 取代码 (次分 [2], 1)
        .如果真 (代码 ≠ 32)
            首分 [i] ＝ 文本替换 (首分 [i], 取文本长度 (次分 [1]) ＋ 1, 1, “: ”)
        .如果真结束
    .如果真结束
    写文本行 (文件号, 首分 [i])
.计次循环尾 ()
移到文件首 (文件号)
输出 ＝ 读入文本 (文件号, )
关闭文件 (文件号)
返回 (输出)
.子程序 网页_访问_对象, 字节集, 公开, 使用WinHttp的对象方式访问网页
.参数 网址, 文本型, , 完整的网页地址,必须包含http://或者https://
.参数 访问方式, 整数型, 可空, 0=GET 1=POST 2=HEAD 3=PUT  4=OPTIONS  5=DELETE  6=TRACE  7=CONNECT
.参数 提交信息, 文本型, 可空, "POST"专用   自动UTF8编码
.参数 提交Cookies, 文本型, 参考 可空, 设置提交时的cookie
.参数 返回Cookies, 文本型, 参考 可空, 返回的Cookie
.参数 附加协议头, 文本型, 可空, 一行一个请用换行符隔开
.参数 返回协议头, 文本型, 参考 可空, 返回的协议头
.参数 返回状态代码, 整数型, 参考 可空, 网页返回的状态代码，例如：200；302；404等
.参数 禁止重定向, 逻辑型, 可空, 默认不禁止网页重定向
.参数 字节集提交, 字节集, 可空, 提交字节集数据
.参数 代理地址, 文本型, 可空, 代理地址，格式为 8.8.8.8:88
.参数 超时, 整数型, 可空, 秒|默认为15秒,-1为无限等待
.参数 代理用户名, 文本型, 可空, 用户名
.参数 代理密码, 文本型, 可空, 密码
.参数 代理标识, 整数型, 可空, 代理标识，默认为1，0为路由器
.参数 对象继承, 对象, 可空, 此处可自行提供对象，不再主动创建
.参数 是否自动合并更新Cookie, 逻辑型, 可空, 默认为真，自动合并更新
.参数 是否补全必要协议头, 逻辑型, 可空, 当附件协议头为空时自动添加必要的UA协议头 默认为真，假将不再添加非传入协议头
.参数 是否处理协议头大小写, 逻辑型, 可空, 将协议头中的键名首字母处理为大写  默认为真
.局部变量 局_访问方式, 文本型
.局部变量 局_WinHttp, 对象
.局部变量 局_发送协议头, 文本型, , "0"
.局部变量 局_返回协议头, 文本型, , "0"
.局部变量 局_计次, 整数型
.局部变量 局_网页数据, 字节集
.局部变量 局_变体提交, 变体型
.局部变量 局_附加协议头, 文本型
.如果真 (是否为空 (是否自动合并更新Cookie))
    是否自动合并更新Cookie ＝ 真
.如果真结束
.如果真 (是否为空 (是否补全必要协议头))
    是否补全必要协议头 ＝ 真
.如果真结束
.如果真 (是否为空 (是否处理协议头大小写))
    是否处理协议头大小写 ＝ 真
.如果真结束
线程_初始化COM库 ()
.如果真 (访问方式 ＜ 0 或 访问方式 ＞ 7)
    访问方式 ＝ 0
.如果真结束
局_访问方式 ＝ 多项选择 (访问方式 ＋ 1, “GET”, “POST”, “HEAD”, “PUT”, “OPTIONS”, “DELETE”, “TRACE”, “CONNECT”)
.判断开始 (是否为空 (对象继承))
    .如果真 (局_WinHttp.创建 (“WinHttp.WinHttpRequest.5.1”, ) ＝ 假)
        返回 ({  })
    .如果真结束
.默认
    局_WinHttp ＝ 对象继承
.判断结束
.如果真 (超时 ≠ -1)
    .如果 (超时 ＜ 1)
        超时 ＝ 15000
    .否则
        超时 ＝ 超时 × 1000
    .如果结束
    局_WinHttp.方法 (“SetTimeouts”, 超时, 超时, 超时, 超时)
.如果真结束
.如果真 (代理地址 ≠ “”)
    局_WinHttp.方法 (“SetProxy”, 2, 代理地址)
.如果真结束
局_WinHttp.方法 (“Open”, 局_访问方式, 网址, 假)
.如果真 (禁止重定向)
    局_WinHttp.写属性 (“Option”, 6, 0)
.如果真结束
局_WinHttp.写属性 (“Option”, 4, 13056)  ' 忽略错误标志
局_附加协议头 ＝ 附加协议头
.如果真 (是否补全必要协议头)
    .如果真 (寻找文本 (局_附加协议头, “Accept:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept: */*”
    .如果真结束
    .如果真 (寻找文本 (局_附加协议头, “Referer:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Referer: ” ＋ 网址
    .如果真结束
    .如果真 (寻找文本 (局_附加协议头, “Accept-Language:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept-Language: zh-cn”
    .如果真结束
    .如果真 (寻找文本 (局_附加协议头, “User-Agent:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “User-Agent: Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1)”
    .如果真结束
    .如果真 (访问方式 ＝ 1)
        .如果真 (寻找文本 (局_附加协议头, “Content-Type:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Content-Type: application/x-www-form-urlencoded”
        .如果真结束
    .如果真结束
.如果真结束
.如果真 (是否处理协议头大小写)
    局_附加协议头 ＝ 网页_处理协议头 (局_附加协议头)
.如果真结束
.如果真 (代理地址 ≠ “” 且 代理用户名 ≠ “”)
    .如果真 (是否为空 (代理标识))
        代理标识 ＝ 1
    .如果真结束
    局_WinHttp.方法 (“SetCredentials”, 代理用户名, 代理密码, 代理标识)
    .如果真 (代理标识 ＝ 1)
        局_WinHttp.方法 (“SetRequestHeader”, “Proxy-Authorization”, “Basic ” ＋ 编码_BASE64编码 (到字节集 (代理用户名 ＋ “:” ＋ 代理密码)))
    .如果真结束
.如果真结束
.如果真 (取反 (是否为空 (提交Cookies)))
    .如果真 (取文本长度 (提交Cookies) ＞ 0)
        .如果真 (寻找文本 (提交Cookies, “Cookie:”, , 真) ≠ -1)
            提交Cookies ＝ 子文本替换 (提交Cookies, “Cookie:”, “”, , , 假)
        .如果真结束
    .如果真结束
    局_WinHttp.方法 (“SetRequestHeader”, “Cookie”, 提交Cookies)
.如果真结束
.判断开始 (寻找文本 (局_附加协议头, #换行符, , 假) ＝ -1)
    局_WinHttp.方法 (“SetRequestHeader”, 内部_协议头取名 (局_附加协议头), 内部_协议头取值 (局_附加协议头))
.默认
    局_发送协议头 ＝ 分割文本 (局_附加协议头, #换行符, )
    .计次循环首 (取数组成员数 (局_发送协议头), 局_计次)
        .如果真 (局_发送协议头 [局_计次] ≠ “”)
            .如果真 (内部_协议头取名 (局_发送协议头 [局_计次]) ＝ “Connection”)
                .如果真 (内部_协议头取值 (局_发送协议头 [局_计次]) ＝ “keep-alive”)
                    到循环尾 ()  ' 筛选排除此参数 避免协议头有此参数 HTTP对象又自动添加此参数
                .如果真结束
            .如果真结束
            局_WinHttp.方法 (“SetRequestHeader”, 内部_协议头取名 (局_发送协议头 [局_计次]), 内部_协议头取值 (局_发送协议头 [局_计次]))
        .如果真结束
    .计次循环尾 ()
.判断结束
.判断开始 (字节集提交 ＝ {  })
    局_WinHttp.方法 (“Send”, 提交信息)
.默认
    局_变体提交.赋值 (字节集提交, )
    局_WinHttp.方法 (“Send”, 局_变体提交)
.判断结束
局_网页数据 ＝ 局_WinHttp.读属性 (“ResponseBody”, ).取字节集 ()
返回协议头 ＝ 局_WinHttp.读文本属性 (“GetAllResponseHeaders”, )
返回状态代码 ＝ 局_WinHttp.读数值属性 (“Status”, )
局_WinHttp.读文本属性 (“StatusText”, )
局_返回协议头 ＝ 分割文本 (返回协议头, #换行符, )
返回Cookies ＝ “”
.计次循环首 (取数组成员数 (局_返回协议头), 局_计次)
    .如果真 (文本_取左边 (局_返回协议头 [局_计次], “: ”) ＝ “Set-Cookie”)
        .判断开始 (寻找文本 (局_返回协议头 [局_计次], “;”, , 假) ≠ -1)
            返回Cookies ＝ 返回Cookies ＋ 删首尾空 (文本_取出中间文本 (局_返回协议头 [局_计次], “Set-Cookie:”, “;”)) ＋ “; ”
        .默认
            返回Cookies ＝ 返回Cookies ＋ 删首尾空 (子文本替换 (局_返回协议头 [局_计次], “Set-Cookie:”, , , , 假)) ＋ “; ”
        .判断结束
    .如果真结束
.计次循环尾 ()
.如果真 (取文本左边 (返回Cookies, 2) ＝ “; ”)
    返回Cookies ＝ 取文本左边 (返回Cookies, 取文本长度 (返回Cookies) － 2)
.如果真结束
.如果真 (是否自动合并更新Cookie)
    .如果真 (取反 (是否为空 (提交Cookies)))
        返回Cookies ＝ 网页_Cookie合并更新 (提交Cookies, 返回Cookies)
    .如果真结束
.如果真结束
局_WinHttp.清除 ()
线程_取消COM库 ()
返回 (局_网页数据)
.子程序 网页_访问, 字节集, 公开, 使用WinInet的API方式访问网页
.参数 网址, 文本型, , 完整的网页地址,必须包含http://或者https://
.参数 访问方式, 整数型, 可空, 0=GET 1=POST 2=HEAD 3=PUT  4=OPTIONS  5=DELETE  6=TRACE  7=CONNECT
.参数 提交信息, 文本型, 可空, POST专用
.参数 提交Cookies, 文本型, 参考 可空, 设置提交时的cookie
.参数 返回Cookies, 文本型, 可空, 返回的Cookie
.参数 附加协议头, 文本型, 可空, 一行一个请用换行符隔开,建议填写常量值或文本值,防止因传参引发错误
.参数 返回协议头, 文本型, 参考 可空, 返回的协议头
.参数 禁止重定向, 逻辑型, 可空, 默认不禁止网页重定向
.参数 字节集提交, 字节集, 可空, 提交字节集数据
.参数 代理地址, 文本型, 可空, 代理地址，格式为:ip:port,例如:8.8.8.8:88
.参数 是否自动合并更新Cookie, 逻辑型, 可空, 默认为真，自动合并更新
.参数 是否补全必要协议头, 逻辑型, 可空, 当附件协议头为空时自动添加必要的UA协议头 默认为真，假将不再添加非传入协议头
.参数 是否处理协议头大小写, 逻辑型, 可空, 将协议头中的键名首字母处理为大写  默认为真
.局部变量 局_Internet句柄, 整数型
.局部变量 局_Internet连接句柄, 整数型
.局部变量 局_HTTP请求句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_字节集, 字节集
.局部变量 局_访问方式, 文本型
.局部变量 局_User_Agent, 文本型
.局部变量 局_返回协议头, 文本型, , "0"
.局部变量 局_页面内容, 字节集
.局部变量 局_请求标记, 整数型
.局部变量 局_重定向地址, 文本型
.局部变量 局_HTTPS, 逻辑型
.局部变量 bAutoDecode, 整数型
.局部变量 局_附加协议头, 文本型
.如果真 (是否为空 (是否自动合并更新Cookie))
    是否自动合并更新Cookie ＝ 真
.如果真结束
.如果真 (是否为空 (是否补全必要协议头))
    是否补全必要协议头 ＝ 真
.如果真结束
.如果真 (是否为空 (是否处理协议头大小写))
    是否处理协议头大小写 ＝ 真
.如果真结束
局_附加协议头 ＝ 附加协议头
.如果真 (是否处理协议头大小写)
    局_附加协议头 ＝ 网页_处理协议头 (局_附加协议头)
.如果真结束
' 局_访问方式 ＝ 选择 (访问方式 ＝ 1, “POST”, “GET”)
.如果真 (访问方式 ＜ 0 或 访问方式 ＞ 7)
    访问方式 ＝ 0
.如果真结束
局_访问方式 ＝ 多项选择 (访问方式 ＋ 1, “GET”, “POST”, “HEAD”, “PUT”, “OPTIONS”, “DELETE”, “TRACE”, “CONNECT”)
.如果真 (到小写 (取文本左边 (网址, 8)) ＝ “https://”)
    局_HTTPS ＝ 真
.如果真结束
.判断开始 (寻找文本 (局_附加协议头, “User-Agent:”, , 真) ≠ -1)
    局_User_Agent ＝ 删首尾空 (文本_取出中间文本 (局_附加协议头 ＋ #换行符, “User-Agent:”, #换行符, , ))
    .如果真 (局_User_Agent ＝ “”)
        局_User_Agent ＝ 内部_协议头取值 (局_附加协议头)
    .如果真结束
.默认
    局_User_Agent ＝ “Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1)”
.判断结束
.判断开始 (代理地址 ＝ “”)
    局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 1, 字符 (0), 字符 (0), 0)
.默认
    .判断开始 (局_HTTPS)  ' 用于解决win7下https协议代理无效问题
        局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 3, 代理地址, “”, 0)
    .默认
        局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 3, “http=” ＋ 代理地址, “”, 0)
    .判断结束
.判断结束
.如果真 (局_Internet句柄 ＝ 0)
    ' InternetCloseHandle (局_Internet句柄)
    返回 ({  })
.如果真结束
局_Internet连接句柄 ＝ InternetConnectA (局_Internet句柄, 网页_取域名 (网址), 网页_取端口 (网址), 字符 (0), 字符 (0), 3, 0, 0)
.如果真 (局_Internet连接句柄 ＝ 0)
    ' InternetCloseHandle (局_Internet连接句柄)
    InternetCloseHandle (局_Internet句柄)
    返回 ({  })
.如果真结束
局_请求标记 ＝ 位或 (#INTERNET_FLAG_RELOAD, #INTERNET_COOKIE_THIRD_PARTY)
.如果真 (取反 (是否为空 (提交Cookies)))
    局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_NO_COOKIES)
.如果真结束
.如果真 (禁止重定向)
    局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_NO_AUTO_REDIRECT)
.如果真结束
.判断开始 (局_HTTPS)
    局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_SECURE)
.默认
    局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS)
.判断结束
局_HTTP请求句柄 ＝ HttpOpenRequestA (局_Internet连接句柄, 局_访问方式, 网页_取页面地址 (网址), “HTTP/1.1”, 字符 (0), 字符 (0), 局_请求标记, 0)
.如果真 (局_HTTP请求句柄 ＝ 0)
    ' InternetCloseHandle (局_HTTP请求句柄)
    InternetCloseHandle (局_Internet连接句柄)
    InternetCloseHandle (局_Internet句柄)
    返回 ({  })
.如果真结束
InternetSetOption (局_HTTP请求句柄, #INTERNET_OPTION_SECURITY_FLAGS, 127872, 4)
.如果真 (是否补全必要协议头)
    .如果真 (局_附加协议头 ＝ “”)
        局_附加协议头 ＝ “Accept: */*”
    .如果真结束
    .如果真 (寻找文本 (局_附加协议头, “Accept:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept: */*”
    .如果真结束
    .如果真 (寻找文本 (局_附加协议头, “Referer:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Referer: ” ＋ 网址
    .如果真结束
    .如果真 (寻找文本 (局_附加协议头, “Accept-Language:”, , 真) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept-Language: zh-cn”
    .如果真结束
    .如果真 (访问方式 ＝ 1)
        .如果真 (寻找文本 (局_附加协议头, “Content-Type:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Content-Type: application/x-www-form-urlencoded”
        .如果真结束
    .如果真结束
.如果真结束
.如果真 (提交Cookies ≠ “”)
    .判断开始 (寻找文本 (提交Cookies, “Cookie:”, , 假) ＝ -1)
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Cookie: ” ＋ 提交Cookies
    .默认
        局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ 提交Cookies
    .判断结束
.如果真结束
' 在Vista之后  可以自动解压Gzip
' bAutoDecode ＝ 1
' InternetSetOptionA_传址 (局_HTTP请求句柄, #INTERNET_OPTION_HTTP_DECODING, bAutoDecode, 4)
.判断开始 (访问方式 ＝ 0)
    HttpSendRequestA (局_HTTP请求句柄, 局_附加协议头, 取文本长度 (局_附加协议头), 0, 0)
.默认
    .如果真 (字节集提交 ＝ {  })
        字节集提交 ＝ 到字节集 (提交信息)
    .如果真结束
    HttpSendRequestA (局_HTTP请求句柄, 局_附加协议头, 取文本长度 (局_附加协议头), 取指针字节集_ (字节集提交), 取字节集长度 (字节集提交))
.判断结束
局_计次 ＝ 0
局_字节集 ＝ 取空白字节集 (1024)
.循环判断首 ()
    InternetReadFile (局_HTTP请求句柄, 局_字节集, 1024, 局_计次)
    局_页面内容 ＝ 局_页面内容 ＋ 取字节集左边 (局_字节集, 局_计次)
.循环判断尾 (局_计次 ≠ 0)
返回协议头 ＝ 取空白文本 (5000)
HttpQueryInfoA (局_HTTP请求句柄, 22, 返回协议头, 5000, 0)
' 返回协议头 ＝ 子文本替换 (返回协议头, “Set-Cookie”, “Set-Cookie”, , , 假)
InternetCloseHandle (局_HTTP请求句柄)
InternetCloseHandle (局_Internet连接句柄)
InternetCloseHandle (局_Internet句柄)
局_返回协议头 ＝ 分割文本 (返回协议头, #换行符, )
返回Cookies ＝ “”
.计次循环首 (取数组成员数 (局_返回协议头), 局_计次)
    .如果真 (文本_取左边 (局_返回协议头 [局_计次], “: ”) ＝ “Set-Cookie”)
        .判断开始 (寻找文本 (局_返回协议头 [局_计次], “;”, , 假) ≠ -1)
            返回Cookies ＝ 返回Cookies ＋ 删首尾空 (文本_取出中间文本 (局_返回协议头 [局_计次], “Set-Cookie:”, “;”)) ＋ “; ”
        .默认
            返回Cookies ＝ 返回Cookies ＋ 删首尾空 (子文本替换 (局_返回协议头 [局_计次], “Set-Cookie:”, , , , 假)) ＋ “; ”
        .判断结束
    .如果真结束
.计次循环尾 ()
返回Cookies ＝ 取文本左边 (返回Cookies, 取文本长度 (返回Cookies) － 2)
.如果真 (是否自动合并更新Cookie)
    .如果真 (取反 (是否为空 (提交Cookies)))
        返回Cookies ＝ 网页_Cookie合并更新 (提交Cookies, 返回Cookies)
    .如果真结束
.如果真结束
返回 (局_页面内容)
.子程序 网页_访问S, 文本型, 公开, 源码由[洫蜘蛛]提供,使用WinHttp的 API方式访问网页,如果返回是“?”请查询返回协议头是否有“Content-Encoding: gzip“表示gzip压缩过网页，可用 网页_GZIP解压()命令解压，如果返回是乱码，则返回原始文本，请自行转换编码，失败返回空文本，请取出状态文本。
.参数 网址, 文本型, , 完整的网页地址,必须包含http://或者https://
.参数 访问方式, 整数型, 可空, 0=GET 1=POST 2=HEAD  3=PUT  4=OPTIONS  5=DELETE  6=TRACE  7=CONNECT
.参数 提交信息, 文本型, 可空, POST专用
.参数 提交Cookies, 文本型, 参考 可空, 设置提交时的cookie
.参数 返回Cookies, 文本型, 参考 可空, 返回的Cookie
.参数 附加协议头, 文本型, 可空, 一行一个请用换行符隔开,建议填写常量值或文本值,防止因传参引发错误
.参数 返回协议头, 文本型, 参考 可空, 返回的协议头
.参数 禁止重定向, 逻辑型, 可空, 默认不禁止网页重定向
.参数 网站登录用户名, 文本型, 可空, 自动登录网页用户名 如路由器
.参数 网站登录密码, 文本型, 可空
.参数 代理地址, 文本型, 可空, 代理地址，格式为 8.8.8.8:88
.参数 代理帐号, 文本型, 可空
.参数 代理密码, 文本型, 可空
.参数 超时时间, 整数型, 可空, 可以被省略，单位：秒，默认30秒，如果提供大于0的数值，则修改操作超时时间。
.参数 返回重定向, 文本型, 参考 可空, 可以被省略，提供参数时只能提供文本型变量，用于当发生重定向时取回页面重定向的地址。
.参数 返回状态文本, 文本型, 参考 可空
.参数 返回原始数据, 字节集, 参考 可空, 可以被省略，返回原始网页编码
.参数 是否自动合并更新Cookie, 逻辑型, 可空, 默认为真，自动合并更新
.参数 是否补全必要协议头, 逻辑型, 可空, 当附件协议头为空时自动添加必要的UA协议头 默认为真，假将不再添加非传入协议头
.参数 字节集提交, 字节集, 可空, 提交字节集数据
.参数 是否处理协议头大小写, 逻辑型, 可空, 将协议头中的键名首字母处理为大写  默认为真
.局部变量 局_URL结构, URL_COMPONENTS
.局部变量 局_网页地址, 字节集
.局部变量 局_域名, 文本型
.局部变量 局_端口, 整数型
.局部变量 局_重定向地址, 文本型
.局部变量 局_HTTPS, 逻辑型
.局部变量 局_会话句柄, 整数型
.局部变量 局_User_Agent, 文本型
.局部变量 局_代理名称, 字节集
.局部变量 局_会话类型, 整数型
.局部变量 局_连接句柄, 整数型
.局部变量 局_请求句柄, 整数型
.局部变量 局_访问方式, 文本型
.局部变量 局_页面地址, 字节集
.局部变量 局_设置超时, 整数型
.局部变量 局_请求标记, 整数型
.局部变量 局_请求协议, 文本型
.局部变量 局_请求报头, 字节集
.局部变量 局_数据长度, 整数型
.局部变量 局_提交数据, 字节集
.局部变量 局_可读长度, 整数型
.局部变量 局_缓存数据, 字节集
.局部变量 局_网页数据, 字节集
.局部变量 局_网页内容, 文本型
.局部变量 局_文本数组, 文本型, , "0"
.局部变量 局_编码类型, 文本型
.局部变量 局_解码对象, 对象
.局部变量 局_变体型, 变体型
.局部变量 局_计次, 整数型
.局部变量 局_正则, 正则表达式类
.如果真 (是否为空 (是否自动合并更新Cookie))
    是否自动合并更新Cookie ＝ 真
.如果真结束
.如果真 (是否为空 (是否补全必要协议头))
    是否补全必要协议头 ＝ 真
.如果真结束
.如果真 (是否为空 (是否处理协议头大小写))
    是否处理协议头大小写 ＝ 真
.如果真结束
.如果 (WinHttpCheckPlatform ())
    局_URL结构.dwStructSize ＝ 60
    连续赋值 (-1, 局_URL结构.dwSchemeLength, 局_URL结构.dwHostNameLength, 局_URL结构.dwUrlPathLength, 局_URL结构.dwExtraInfoLength)
    局_网页地址 ＝ 编码_Ansi到Unicode (网址)
    .如果 (WinHttpCrackUrl (局_网页地址, 取字节集长度 (局_网页地址), 0, 局_URL结构))
        局_域名 ＝ 编码_Unicode到Ansi (指针到字节集 (局_URL结构.lpszHostName, 局_URL结构.dwHostNameLength × 2))
        局_页面地址 ＝ 选择 (局_URL结构.dwUrlPathLength ＜ 1, 编码_Ansi到Unicode (“/”), 指针到字节集 (局_URL结构.lpszUrlPath, 局_URL结构.dwUrlPathLength × 2) ＋ 指针到字节集 (局_URL结构.lpszExtraInfo, 局_URL结构.dwExtraInfoLength × 2) ＋ { 0, 0 })
        局_端口 ＝ 局_URL结构.nPort
        局_HTTPS ＝ #INTERNET_SCHEME_HTTPS ＝ 局_URL结构.nScheme
        局_会话类型 ＝ 选择 (取文本长度 (代理地址) ＞ 0, #WINHTTP_ACCESS_TYPE_NAMED_PROXY, #WINHTTP_ACCESS_TYPE_NO_PROXY)
        局_代理名称 ＝ 选择 (取文本长度 (代理地址) ＝ 0, { 0, 0 }, 选择 (局_HTTPS, 编码_Ansi到Unicode (代理地址), 编码_Ansi到Unicode (“http=” ＋ 代理地址)))
        局_会话句柄 ＝ WinHttpOpen (0, 局_会话类型, 局_代理名称, 0, 0)
        .如果 (局_会话句柄 ≠ 0)
            局_设置超时 ＝ 选择 (超时时间 ＞ 0, 超时时间 × 1000, 30000)
            .如果 (WinHttpSetTimeouts (局_会话句柄, 局_设置超时, 局_设置超时, 局_设置超时, 局_设置超时))
                局_连接句柄 ＝ WinHttpConnect (局_会话句柄, 编码_Ansi到Unicode (局_域名, ), 局_端口, 0)
                .如果 (局_连接句柄 ≠ 0)
                    局_访问方式 ＝ 选择 (访问方式 ＜ 0 或 访问方式 ＞ 7, “GET”, 多项选择 (访问方式 ＋ 1, “GET”, “POST”, “HEAD”, “PUT”, “OPTIONS”, “DELETE”, “TRACE”, “CONNECT”))
                    局_请求句柄 ＝ WinHttpOpenRequest (局_连接句柄, 编码_Ansi到Unicode (局_访问方式, ), 局_页面地址, 0, #WINHTTP_NO_REFERER, #WINHTTP_DEFAULT_ACCEPT_TYPES, 选择 (局_HTTPS, #WINHTTP_FLAG_SECURE, 0))
                    .如果 (局_请求句柄 ≠ 0)
                        .如果真 (取文本长度 (网站登录用户名) ＞ 0 且 取文本长度 (网站登录密码) ＞ 0)
                            .如果真 (WinHttpSetCredentials (局_请求句柄, #WINHTTP_AUTH_TARGET_SERVER, #WINHTTP_AUTH_SCHEME_BASIC, 编码_Ansi到Unicode (网站登录用户名, ), 编码_Ansi到Unicode (网站登录密码, ), 0) ＝ 假)
                                返回状态文本 ＝ “707 设置代理凭证失败!”
                                WinHttpCloseHandle (局_请求句柄)
                                WinHttpCloseHandle (局_连接句柄)
                                WinHttpCloseHandle (局_会话句柄)
                                返回 (“”)
                            .如果真结束
                        .如果真结束
                        .如果真 (取文本长度 (代理帐号) ＞ 0 且 取文本长度 (代理密码) ＞ 0)
                            .如果真 (WinHttpSetCredentials (局_请求句柄, #WINHTTP_AUTH_TARGET_PROXY, #WINHTTP_AUTH_SCHEME_BASIC, 编码_Ansi到Unicode (代理帐号, ), 编码_Ansi到Unicode (代理密码, ), 0) ＝ 假)
                                WinHttpCloseHandle (局_请求句柄)
                                WinHttpCloseHandle (局_连接句柄)
                                WinHttpCloseHandle (局_会话句柄)
                                返回状态文本 ＝ “707 设置代理凭证失败!”
                                返回 (“”)
                            .如果真结束
                        .如果真结束
                        .如果真 (WinHttpSetOption (局_请求句柄, #WINHTTP_OPTION_SECURITY_FLAGS, 13056, 4) ＝ 假)
                            返回状态文本 ＝ “忽略错误/证书错误  失败！”
                            WinHttpCloseHandle (局_请求句柄)
                            WinHttpCloseHandle (局_连接句柄)
                            WinHttpCloseHandle (局_会话句柄)
                            返回 (“”)
                        .如果真结束
                        .判断开始 (提交Cookies ＝ “”)
                            局_请求标记 ＝ #WINHTTP_OPTION_DISABLE_FEATURE
                        .默认
                            局_请求标记 ＝ #WINHTTP_OPTION_ENABLE_FEATURE
                        .判断结束
                        .如果真 (WinHttpSetOption (局_请求句柄, 局_请求标记, #WINHTTP_DISABLE_COOKIES, 4) ＝ 假)
                            返回状态文本 ＝ “708 禁止自动设置Cookies失败!”
                            WinHttpCloseHandle (局_请求句柄)
                            WinHttpCloseHandle (局_连接句柄)
                            WinHttpCloseHandle (局_会话句柄)
                            返回 (“”)
                        .如果真结束
                        .如果真 (禁止重定向)
                            .如果真 (WinHttpSetOption (局_请求句柄, #WINHTTP_OPTION_DISABLE_FEATURE, #WINHTTP_DISABLE_REDIRECTS, 4) ＝ 假)
                                返回状态文本 ＝ “709 重定向设置失败!”
                                WinHttpCloseHandle (局_请求句柄)
                                WinHttpCloseHandle (局_连接句柄)
                                WinHttpCloseHandle (局_会话句柄)
                                返回 (“”)
                            .如果真结束
                        .如果真结束
                        .如果真 (取文本长度 (附加协议头) ＞ 0)  ' 先加载用户设置的协议头，后面再进行补充。
                            局_请求协议 ＝ 附加协议头 ＋ #换行符
                        .如果真结束
                        .如果真 (是否补全必要协议头)
                            .如果真 (寻找文本 (局_请求协议, “User-Agent: ”, 1, 真) ＝ -1)
                                局_请求协议 ＝ 局_请求协议 ＋ “User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)” ＋ #换行符
                            .如果真结束
                            .如果真 (寻找文本 (局_请求协议, “Accept: ”, 1, 真) ＝ -1)
                                局_请求协议 ＝ 局_请求协议 ＋ “Accept: text/html, application/xhtml+xml, */*” ＋ #换行符
                            .如果真结束
                            .如果真 (寻找文本 (局_请求协议, “Accept-Encoding: ”, 1, 真) ＝ -1)
                                局_请求协议 ＝ 局_请求协议 ＋ “Accept-Encoding: gbk, GB2312” ＋ #换行符
                            .如果真结束
                            .如果真 (寻找文本 (局_请求协议, “Accept-Language: ”, 1, 真) ＝ -1)
                                局_请求协议 ＝ 局_请求协议 ＋ “Accept-Language: zh-cn” ＋ #换行符
                            .如果真结束
                            .如果真 (访问方式 ＝ 1)
                                .如果真 (寻找文本 (局_请求协议, “Content-Type:”, , 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ “Content-Type: application/x-www-form-urlencoded” ＋ #换行符
                                .如果真结束
                            .如果真结束
                            .如果真 (寻找文本 (局_请求协议, “Cache-Control: ”, , 真) ＝ -1)
                                局_请求协议 ＝ 局_请求协议 ＋ “Cache-Control: no-cache” ＋ #换行符
                            .如果真结束
                        .如果真结束
                        .如果真 (是否处理协议头大小写)
                            局_请求协议 ＝ 网页_处理协议头 (局_请求协议)
                        .如果真结束
                        .如果真 (寻找文本 (局_请求协议, “Connection”, , 假) ≠ -1)
                            .如果真 (网页_协议头_取信息 (局_请求协议, “Connection”) ＝ “keep-alive”)
                                局_请求协议 ＝ 子文本替换 (局_请求协议, “Connection: keep-alive” ＋ #换行符, “”, , , 真)  ' 筛选排除此参数 避免协议头有此参数 HTTP对象又自动添加此参数
                            .如果真结束
                        .如果真结束
                        .如果真 (寻找文本 (局_请求协议, “Cookie:”, , 真) ＝ -1)
                            .如果真 (取文本长度 (提交Cookies) ＞ 0)
                                .判断开始 (寻找文本 (提交Cookies, “Cookie:”, , 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ #换行符 ＋ “Cookie: ” ＋ 提交Cookies ＋ #换行符
                                .默认
                                    局_请求协议 ＝ 局_请求协议 ＋ #换行符 ＋ 提交Cookies ＋ #换行符
                                .判断结束
                            .如果真结束
                        .如果真结束
                        局_请求报头 ＝ 编码_Ansi到Unicode (局_请求协议, )
                        局_数据长度 ＝ 取字节集长度 (局_请求报头) ÷ 2 － 1
                        .如果 (WinHttpAddRequestHeaders (局_请求句柄, 局_请求报头, 局_数据长度, #WINHTTP_ADDREQ_FLAG_ADD))
                            .如果 (字节集提交 ＝ {  })
                                局_提交数据 ＝ 到字节集 (提交信息)
                            .否则
                                局_提交数据 ＝ 字节集提交
                            .如果结束
                            局_数据长度 ＝ 取字节集长度 (局_提交数据)
                            .如果 (WinHttpSendRequest (局_请求句柄, 0, 0, 局_提交数据, 局_数据长度, 局_数据长度, 0))
                                .如果 (WinHttpReceiveResponse (局_请求句柄, 0))
                                    局_缓存数据 ＝ {  }
                                    局_网页数据 ＝ {  }
                                    .判断循环首 (WinHttpQueryDataAvailable (局_请求句柄, 局_可读长度))
                                        .如果真 (局_可读长度 ＜ 1)
                                            跳出循环 ()
                                        .如果真结束
                                        局_缓存数据 ＝ 取空白字节集 (局_可读长度)
                                        .如果真 (WinHttpReadData (局_请求句柄, 局_缓存数据, 局_可读长度, 局_数据长度) ＝ 假)
                                            返回状态文本 ＝ “713 读取数据失败!”
                                            跳出循环 ()
                                        .如果真结束
                                        局_网页数据 ＝ 局_网页数据 ＋ 取字节集左边 (局_缓存数据, 局_数据长度)
                                    .判断循环尾 ()
                                    局_缓存数据 ＝ {  }
                                    局_数据长度 ＝ 0
                                    WinHttpQueryHeaders (局_请求句柄, #WINHTTP_QUERY_RAW_HEADERS_CRLF, 0, 局_缓存数据, 局_数据长度, #WINHTTP_NO_HEADER_INDEX)
                                    局_缓存数据 ＝ 取空白字节集 (局_数据长度)
                                    .如果真 (WinHttpQueryHeaders (局_请求句柄, #WINHTTP_QUERY_RAW_HEADERS_CRLF, 0, 局_缓存数据, 局_数据长度, #WINHTTP_NO_HEADER_INDEX))
                                        返回协议头 ＝ 编码_Unicode到Ansi (局_缓存数据)
                                        返回状态文本 ＝ 取文本中间 (返回协议头, 10, 寻找文本 (返回协议头, #换行符, 10, 假) － 9)
                                        局_文本数组 ＝ 分割文本 (返回协议头, #换行符, )
                                        .计次循环首 (取数组成员数 (局_文本数组), 局_计次)
                                            .如果真 (文本_取左边 (局_文本数组 [局_计次], “: ”, , ) ＝ “Set-Cookie”)
                                                .判断开始 (寻找文本 (局_文本数组 [局_计次], “;”, , 假) ≠ -1)
                                                    返回Cookies ＝ 返回Cookies ＋ 删首尾空 (文本_取出中间文本 (局_文本数组 [局_计次], “Set-Cookie:”, “;”, , )) ＋ “; ”
                                                .默认
                                                    返回Cookies ＝ 返回Cookies ＋ 删首尾空 (子文本替换 (局_文本数组 [局_计次], “Set-Cookie:”, , , , 假)) ＋ “; ”
                                                .判断结束
                                            .如果真结束
                                            .如果真 (文本比较 (取文本左边 (局_文本数组 [局_计次], 10), “Location: ”, 假) ＝ 0)
                                                返回重定向 ＝ 取文本中间 (局_文本数组 [局_计次], 11, 取文本长度 (局_文本数组 [局_计次]) － 10)
                                            .如果真结束
                                            处理事件 ()
                                        .计次循环尾 ()
                                        返回Cookies ＝ 取文本左边 (返回Cookies, 取文本长度 (返回Cookies))
                                        .如果真 (取文本左边 (返回Cookies, 2) ＝ “; ”)
                                            返回Cookies ＝ 取文本左边 (返回Cookies, 取文本长度 (返回Cookies) － 2)
                                        .如果真结束
                                        .如果真 (是否自动合并更新Cookie)
                                            .如果真 (取反 (提交Cookies ＝ “”))
                                                返回Cookies ＝ 网页_Cookie合并更新 (提交Cookies, 返回Cookies)
                                            .如果真结束
                                        .如果真结束
                                        ' -------------------提取网页编码，并转码
                                        返回原始数据 ＝ 局_网页数据
                                        局_网页内容 ＝ 到文本 (返回原始数据)
                                        CoInitialize (0)
                                        .如果真 (局_正则.创建 (“<meta.+?charset=[^\w]?([-\w]+)”, 取文本左边 (局_网页内容, 1024), , , , ))
                                            局_编码类型 ＝ 局_正则.取子匹配文本 (1, 1, )
                                            .如果真 (取文本长度 (局_编码类型) ＞ 0)
                                                .如果真 (局_编码类型 ≠ “gbk” 或 局_编码类型 ≠ “gb2312”)  ' 如果为中文就不处理
                                                    .如果真 (局_解码对象.创建 (“Adodb.Stream”, ))
                                                        局_变体型.赋值 (局_网页数据, )
                                                        局_解码对象.写属性 (“Type”, 1)
                                                        局_解码对象.写属性 (“Mode”, 3)
                                                        局_解码对象.方法 (“Open”, )
                                                        局_解码对象.方法 (“Write”, 局_变体型)
                                                        局_解码对象.写属性 (“Position”, 0)
                                                        局_解码对象.写属性 (“Type”, 2)
                                                        局_解码对象.写属性 (“Charset”, 局_编码类型)
                                                        局_网页内容 ＝ 局_解码对象.文本方法 (“ReadText”, )
                                                        局_解码对象.方法 (“Close”, )
                                                        局_解码对象.清除 ()
                                                        局_变体型.清除 ()
                                                    .如果真结束
                                                .如果真结束
                                            .如果真结束
                                            处理事件 ()
                                        .如果真结束
                                        CoUninitialize ()
                                    .如果真结束
                                    处理事件 ()
                                .否则
                                    返回状态文本 ＝ “712 服务器未响应!”
                                .如果结束
                                处理事件 ()
                            .否则
                                返回状态文本 ＝ “711 发送请求失败!”
                            .如果结束
                            处理事件 ()
                        .否则
                            返回状态文本 ＝ “710 设置协议头失败!”
                        .如果结束
                        处理事件 ()
                    .否则
                        返回状态文本 ＝ “704 创建WinHttp请求失败!”
                    .如果结束
                    处理事件 ()
                .否则
                    返回状态文本 ＝ “703 创建WinHttp连接失败!”
                .如果结束
                处理事件 ()
            .否则
                返回状态文本 ＝ “705 设置超时时间失败!”
            .如果结束
            处理事件 ()
        .否则
            返回状态文本 ＝ “702 创建WinHttp会话失败!”
        .如果结束
        处理事件 ()
    .否则
        返回状态文本 ＝ “701 解析URL地址失败!”
    .如果结束
    处理事件 ()
.否则
    返回状态文本 ＝ “700 当前系统不支持WinHttp服务!”
.如果结束
WinHttpCloseHandle (局_请求句柄)
WinHttpCloseHandle (局_连接句柄)
WinHttpCloseHandle (局_会话句柄)
返回 (局_网页内容)
.子程序 网页_URL取本地地址, 文本型, 公开, 通过文件的URL地址，获取缓存在本地的文件地址，成功返回本地文件地址，失败或不存在返回空文本。目前知道不支持搜狗浏览器。
.参数 文件地址, 文本型, , 如：http://bbs.125.la/static/image/common/logo.png
.局部变量 缓存信息, INTERNET_CACHE_ENTRY_INFO
.局部变量 dwbuffer, 整数型
.局部变量 memaddr, 整数型
GetUrlCacheEntryInfo (文件地址, 0, dwbuffer)  ' 获取dwbuffer大小
.判断开始 (GetLastError () ＝ 2)  ' 指定的缓存条目在缓存中没有找到。
    输出调试文本 (“指定的缓存条目在缓存中没有找到。”)
    返回 (“”)
.判断 (GetLastError () ＝ 122)  ' 有缓存文件
    memaddr ＝ LocalAlloc (0, dwbuffer)  ' 申请内存
    GetUrlCacheEntryInfo (文件地址, memaddr, dwbuffer)
    RtlMoveMemory_GetUrlCache (缓存信息, memaddr, 80)
    LocalFree (memaddr)  ' 释放内存
    返回 (缓存信息.lpszLocalFileName)
.默认
.判断结束
返回 (“”)
.子程序 网页_GZIP压缩_文本, 文本型, 公开, 返回 Base64编码 感谢【@surplus 】提供源码
.参数 Text, 文本型
.参数 是否线程, 逻辑型, 可空
.局部变量 对象, 对象
.局部变量 eval, 变体型
.局部变量 ret, 文本型
.如果真 (是否线程)
    线程_初始化COM库 ()
.如果真结束
Text ＝ 编码_URL编码 (Text, 真, 真)
对象.创建 (“ScriptControl”, )
对象.写属性 (“Language”, “JScript”)
对象.逻辑方法 (“AddCode”, #Gzip)
eval ＝ 对象.通用方法 (“Eval”, “Gzip_Encrypt('” ＋ Text ＋ “')”)  ' 这里要填写单引号， 也就是 Gzip_Encrypt('1233')  否则遇到 易语言的引号 会冲突 导致 压缩失败
ret ＝ eval.取文本 ()
对象.清除 ()
.如果真 (是否线程)
    线程_取消COM库 ()
.如果真结束
返回 (到文本 (编码_BASE64编码A (字节集_文本转字节集 (“{” ＋ ret ＋ “}”))))
.子程序 网页_GZIP解压_文本, 文本型, 公开, 传递 Base64编码 感谢【@surplus 】提供源码
.参数 Text, 文本型
.参数 是否线程, 逻辑型, 可空
.局部变量 对象, 对象
.局部变量 eval, 变体型
.局部变量 ret, 文本型
.局部变量 局_转码内容, 字节集
.如果真 (是否线程)
    线程_初始化COM库 ()
.如果真结束
Text ＝ 字节集_字节集转文本ex (编码_BASE64解码A (到字节集 (Text)))
Text ＝ 取文本左边 (取文本右边 (Text, 取文本长度 (Text) － 1), 取文本长度 (Text) － 2)
对象.创建 (“ScriptControl”, )
对象.写属性 (“Language”, “JScript”)
对象.逻辑方法 (“AddCode”, #Gzip)
eval ＝ 对象.通用方法 (“Eval”, “Gzip_Decrypt('” ＋ Text ＋ “')”)  ' 这里要填写单引号， 也就是 Gzip_Decrypt('1233')  否则遇到 易语言的引号 会冲突 导致 压缩失败
ret ＝ eval.取文本 ()
对象.清除 ()
.如果真 (是否线程)
    线程_取消COM库 ()
.如果真结束
局_转码内容 ＝ 字节集_文本转字节集ex (“{” ＋ ret ＋ “}”)
返回 (编码_URL解码_快速 (编码_Utf8到Ansi (局_转码内容), ))
.子程序 网页_GZIP压缩, 字节集, 公开, 感谢小磊提供，gzip.dll文件请自行到这里来下载并放到程序根目录下即可。http://pan.baidu.com/share/link?shareid=222122&uk=2013335237
.参数 inData, 字节集
.局部变量 context, 整数型
.局部变量 inData2, 字节集
.局部变量 inLength, 整数型
.局部变量 buffer, 字节集
.局部变量 inUsed, 整数型
.局部变量 outUsed, 整数型
.局部变量 hResult, 整数型
.局部变量 retBytes, 字节集
.局部变量 upRetByts, 字节集
.局部变量 压缩位置, 整数型
buffer ＝ 取空白字节集 (8192)  ' #MAX_BUF
InitCompression ()
CreateCompression (context, 3)  ' #GZIP_LVL
.循环判断首 ()
    inData2 ＝ 取字节集中间 (inData, 压缩位置 ＋ 1, 8192)  ' #MAX_BUF
    inLength ＝ 取字节集长度 (inData2)
    hResult ＝ Compress (context, inData2, inLength, buffer, 8192, inUsed, outUsed, 3)
    .如果真 (0 ≠ outUsed)
        upRetByts ＝ upRetByts ＋ 取字节集左边 (buffer, outUsed)
        压缩位置 ＝ 压缩位置 ＋ inUsed
    .如果真结束
.循环判断尾 (hResult ＝ 0)
DestroyCompression (context)
返回 (upRetByts)
.子程序 网页_GZIP解压, 字节集, 公开, 感谢小磊提供，gzip.dll文件请自行到这里来下载并放到程序根目录下即可。http://pan.baidu.com/share/link?shareid=222122&uk=2013335237
.参数 inData, 字节集
.局部变量 context, 整数型
.局部变量 inData2, 字节集
.局部变量 inLength, 整数型
.局部变量 buffer, 字节集
.局部变量 inUsed, 整数型
.局部变量 outUsed, 整数型
.局部变量 hResult, 整数型
.局部变量 retBytes, 字节集
.局部变量 upRetByts, 字节集
.局部变量 解压位置, 整数型
buffer ＝ 取空白字节集 (8192)
InitDecompression ()
CreateDecompression (context, 3)
.循环判断首 ()
    inData2 ＝ 取字节集中间 (inData, 解压位置 ＋ 1, 8192)
    inLength ＝ 取字节集长度 (inData2)
    hResult ＝ Decompress (context, inData2, inLength, buffer, 8192, inUsed, outUsed)
    .如果真 (0 ≠ outUsed)
        upRetByts ＝ upRetByts ＋ 取字节集左边 (buffer, outUsed)
        解压位置 ＝ 解压位置 ＋ inUsed
    .如果真结束
.循环判断尾 (hResult ＝ 0)
DestroyDecompression (context)
返回 (upRetByts)
.子程序 网页_JS格式化, 文本型, 公开, 感谢小磊提供，格式化未处理的JS文本
.参数 js代码, 文本型, , 需要加密\解密的源码
.参数 压缩模式, 逻辑型, 可空, 假为格式化代码,真为压缩代码
.局部变量 js, 类_脚本组件
.局部变量 str, 文本型
js.执行 (#JS格式化)
.判断开始 (压缩模式)
    返回 (js.运行 (“ysjs”, js代码))
.默认
    返回 (js.运行 (“js_beautify”, js代码))
.判断结束
.子程序 网页_置浏览器代理, , 公开, 设置当前程序中浏览器的代理,不影响外部浏览器使用
.参数 代理IP, 文本型, 可空, 格式ip地址+端口，例如【192.168.1.10:80】,留空为取消代理
.局部变量 op, INTERNET_PROXY_INFO
.如果 (是否为空 (代理IP) ＝ 假)
    op.dwAccessType ＝ #INTERNET_OPEN_TYPE_PROXY
    op.lpszProxy ＝ “ftp= ” ＋ 代理IP ＋ “;http= ” ＋ 代理IP ＋ “;socks= ” ＋ 代理IP
    op.lpszProxyBypass ＝ “”
    InternetSetOptionA2 (0, #INTERNET_OPTION_PROXY, op, 12)
    InternetSetOptionA_传址 (0, #INTERNET_OPTION_SETTINGS_CHANGED, 0, 0)
.否则
    op.dwAccessType ＝ #INTERNET_OPEN_TYPE_DIRECT
    op.lpszProxy ＝ “”
    op.lpszProxyBypass ＝ “”
    InternetSetOptionA2 (0, #INTERNET_OPTION_PROXY, op, 12)
    InternetSetOptionA_传址 (0, #INTERNET_OPTION_SETTINGS_CHANGED, 0, 0)
.如果结束
.子程序 网页_置浏览器UA, 逻辑型, 公开, 设置当前程序中浏览器的UserAgent,不影响外部浏览器使用
.参数 UserAgent, 文本型
返回 (UrlMkSetSessionOption (#URLMON_OPTION_USERAGENT, UserAgent, 取文本长度 (UserAgent), 0) ＝ 0)
.子程序 网页_取网页源码, 文本型, 公开, 获取指定网址的网页源码文本
.参数 网址, 文本型, , 请提供要取源码的网址
返回 (到文本 (网页_访问 (网址)))
.子程序 网页_取文本_reg, 文本型, 公开, 去掉网页源码中的HTML标签，保留纯文本(正则方式)
.参数 网页源码, 文本型, , 网页源码如果含中文且乱码的,请先解码
.局部变量 正则, 正则表达式类
.局部变量 局_源码, 文本型
局_源码 ＝ 网页源码
正则.创建 (“<script[\s\S]*?</script>|<style[\s\S]*?</style>|<[^>]+>|&.{1,8};”, 局_源码)
局_源码 ＝ 正则.替换 ()
返回 (局_源码)
.子程序 网页_取文本_dom, 文本型, 公开, 去掉网页源码中的HTML标签，保留纯文本(DOM方式)
.参数 网页源码, 文本型, , 网页源码如果含中文且乱码的,请先解码
.局部变量 dom, 对象
.局部变量 局_源码, 文本型
局_源码 ＝ 网页源码
CoInitialize (0)
dom.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
dom.方法 (“write”, “<HTML><BODY><div></div></BODY></HTML>”)
dom.对象型方法 (“body”, ).写属性 (“innerHTML”, 局_源码)
dom.方法 (“close”, )
局_源码 ＝ dom.对象型方法 (“body”, ).读文本属性 (“outerText”, )
CoUninitialize ()
返回 (局_源码)
.子程序 网页_取端口, 整数型, 公开, 取出网站服务器的默认端口
.参数 网址, 文本型
.局部变量 端口, 文本型
.局部变量 位置, 整数型
端口 ＝ 网页_取域名 (网址, , 真)
位置 ＝ 倒找文本 (端口, “:”, , 假)
.判断开始 (位置 ≠ -1)
    返回 (到整数 (取文本右边 (端口, 取文本长度 (端口) － 位置)))
.判断 (取文本左边 (到小写 (网址), 5) ＝ “https”)
    返回 (443)
.默认
    返回 (80)
.判断结束
.子程序 网页_取域名, 文本型, 公开, 通过“/”或者“.”来获取网址中的域名，默认使用“/”方式
.参数 网址, 文本型
.参数 去除二级域名, 逻辑型, 可空
.参数 不过滤端口, 逻辑型, 可空
.参数 后缀点数量, 整数型, 可空, 不留空表示通过“.”的方式取域名 。如：.com后缀点数量为1 ,.com.cn后缀点数量为2
.局部变量 域名, 文本型
.局部变量 位置, 整数型
.局部变量 二级, 文本型, , "0"
.局部变量 域名长度, 整数型
.局部变量 前点开始, 整数型, , , 如www.bbs.125.la   www后面.的位置
.局部变量 前点结束, 整数型, , , 如www.bbs.125.la   bbs后面.的位置
.局部变量 后点开始, 整数型, , , 如www.bbs.125.la   125后面.的位置
域名 ＝ 到小写 (网址)
.判断开始 (是否为空 (后缀点数量))  ' 使用“/”方式获取域名，网页_访问() 内部 必须使用这个
    .如果真 (取文本右边 (域名, 1) ≠ “/”)
        域名 ＝ 域名 ＋ “/”
    .如果真结束
    .判断开始 (取文本左边 (域名, 8) ＝ “https://”)
        域名 ＝ 文本_取出中间文本 (域名, “https://”, “/”)
    .默认
        .如果真 (寻找文本 (域名, “http://”, , 假) ＝ -1)
            域名 ＝ “http://” ＋ 域名
        .如果真结束
        域名 ＝ 文本_取出中间文本 (域名, “http://”, “/”)
    .判断结束
    .如果真 (去除二级域名)
        二级 ＝ 分割文本 (域名, “.”, )
        位置 ＝ 取数组成员数 (二级)
        .如果真 (位置 ＞ 1)
            域名 ＝ 二级 [位置 － 1] ＋ “.” ＋ 二级 [位置]
        .如果真结束
    .如果真结束
.默认
    ' 通过“.”的方式取域名，支持任何后缀域名
    域名 ＝ 子文本替换 (域名, “http://”, “”, , , 真)
    域名 ＝ 子文本替换 (域名, “https://”, “”, , , 真)
    位置 ＝ 寻找文本 (域名, “/”, , 假)  ' 一撇位置
    .如果真 (位置 ≠ -1)
        域名 ＝ 取文本左边 (域名, 位置 － 1)
    .如果真结束
    连续赋值 (取文本长度 (域名), 域名长度, 后点开始)
    .计次循环首 (后缀点数量, )
        后点开始 ＝ 倒找文本 (域名, “.”, 后点开始, 假)
    .计次循环尾 ()
    前点结束 ＝ 倒找文本 (域名, “.”, 后点开始, 假)
    .判断开始 (去除二级域名)
        域名 ＝ 取文本右边 (域名, 域名长度 － 前点结束)
    .默认
        ' 保留二级域名---------------------------------------
        .如果真 (前点结束 ≠ -1)  ' 至少是二级域名
            前点开始 ＝ 倒找文本 (域名, “.”, 前点结束, 假)
            .如果真 (前点开始 ≠ -1)  ' 至少是三级域名
                域名 ＝ 取文本右边 (域名, 域名长度 － 前点开始)
            .如果真结束
        .如果真结束
    .判断结束
.判断结束
' 端口过滤处理--------------------------------------------------------
.判断开始 (不过滤端口)
    返回 (域名)
.默认
    位置 ＝ 寻找文本 (域名, “:”, , 假)  ' 冒号位置
    .判断开始 (位置 ≠ -1)
        返回 (取文本左边 (域名, 位置 － 1))
    .默认
        返回 (域名)
    .判断结束
.判断结束
.子程序 网页_取外网IP, 文本型, 公开, 取本机的外网IP
.参数 所在省市, 文本型, 可空, 可空。请提供一个文本变量，用于存放您所在的省市，注：有些接口无法取出城市
.参数 接口, 整数型, 可空, 可空。0、ip138；1、sohu；2、ttt.sh；3、ip.cn；4、taobao；5、uc；6、ip.sb；7、ipinfo
.局部变量 局_结果, 字节集
.局部变量 局_网址, 文本型
.局部变量 局_返回, 文本型
.局部变量 局_IP, 文本型
.判断开始 (接口 ＝ 1)
    局_网址 ＝ “http://pv.sohu.com/cityjson”
    局_返回 ＝ 到文本 (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
    局_IP ＝ 文本_取出中间文本 (局_返回, “cip” ＋ #引号 ＋ “: ” ＋ #引号, #引号 ＋ “, ” ＋ #引号 ＋ “cid”, , )
    所在省市 ＝ 文本_取出中间文本 (局_返回, “cname” ＋ #引号 ＋ “: ” ＋ #引号, #引号 ＋ “};”, , )
.判断 (接口 ＝ 2)
    局_网址 ＝ “https://api.ttt.sh/ip/qqwry/”
    局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
    局_返回 ＝ 编码_usc2到ansi (局_返回)
    局_IP ＝ 文本_取出中间文本 (局_返回, “ip” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
    所在省市 ＝ 文本_取出中间文本 (局_返回, “address” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
.判断 (接口 ＝ 3)
    局_网址 ＝ “https://ip.cn/api/index?ip=&type=0”
    局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , “User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36 Core/1.47.277.400 QQBrowser/9.4.7658.400”, , , , , , , , , , , , , ))
    局_IP ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “ip” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
    所在省市 ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “address” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
.判断 (接口 ＝ 4)
    局_网址 ＝ “http://ip.taobao.com/service/getIpInfo2.php?ip=myip&accessKey=alibaba-inc”  ' 较慢且不一定可以取出
    局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
    局_IP ＝ 文本_取出中间文本 (局_返回, “ip” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
    所在省市 ＝ 文本_取出中间文本 (局_返回, “region” ＋ #引号 ＋ “:” ＋ #引号, #引号, , ) ＋ “ ” ＋ 文本_取出中间文本 (局_返回, “city” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
.判断 (接口 ＝ 5)
    局_网址 ＝ “https://www.uc.cn/ip”
    局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
    局_IP ＝ 文本_取右边 (局_返回, “IP:”, , )
    所在省市 ＝ “”  ' 返回无省市
.判断 (接口 ＝ 6)
    局_网址 ＝ “https://api.ip.sb/ip”
    局_返回 ＝ 到文本 (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
    局_IP ＝ 文本_取左边 (局_返回, 字符 (10), , )
    所在省市 ＝ “”  ' 返回无省市
.判断 (接口 ＝ 7)
    局_网址 ＝ “https://ipinfo.io/json”
    局_返回 ＝ 网页_访问S (局_网址, , , , , , , , , , , , , , , , , , , , )
    局_IP ＝ 文本_取出中间文本 (局_返回, “ip” ＋ #引号 ＋ “: ” ＋ #引号, #引号, , )
    所在省市 ＝ “”  ' 返回无省市
.默认
    局_网址 ＝ “http://www.ip138.com”
    局_结果 ＝ 网页_访问_对象 (局_网址, , , , , “User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36”, , , , , , , , , , , , , )
    局_网址 ＝ 到文本 (字节集_取中间 (局_结果, 到字节集 (“<iframe src=”) ＋ { 34 }, { 34 }, ))  ' 引号
    .如果真 (局_网址 ≈ “http” ＝ 假)
        局_网址 ＝ “http:” ＋ 局_网址
    .如果真结束
    局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
    局_IP ＝ 文本_取出中间文本 (局_返回, “您的IP地址是：”, “</title>”, , )
    所在省市 ＝ 文本_取出中间文本 (局_返回, “来自：”, 字符 (10) ＋ “</p>”, , )
.判断结束
返回 (局_IP)
.子程序 网页_置Cookie, 逻辑型, 公开, 设置本地IE的cookie
.参数 网址, 文本型
.参数 Cookie名称, 文本型, 可空, 为空清除所有
.参数 Cookie内容, 文本型, 可空, 为空清除
.参数 有效期, 日期时间型, 可空, 为空不保存
.局部变量 域名, 文本型
.局部变量 GMT时间, 文本型
.局部变量 现有Cookie, 文本型
.局部变量 整数容器, 整数型
.局部变量 名称, 文本型
.局部变量 CookieStr, 文本型
域名 ＝ 网页_取域名 (网址)
CookieStr ＝ Cookie内容
.如果 (Cookie名称 ≠ “”)
    .如果真 (Cookie内容 ＝ “”)
        CookieStr ＝ “delete”
        有效期 ＝ 指定时间 (1999, 1, 1, 1, 1, 1)
    .如果真结束
    .如果真 (有效期 ≠ 指定时间 (1899, 12, 30, 0, 0, 0))
        GMT时间 ＝ 时间_转为GMT格式 (有效期)
        CookieStr ＝ CookieStr ＋ “; expires=” ＋ GMT时间
    .如果真结束
    CookieStr ＝ CookieStr ＋ “; path=/”
    InternetSetCookieA (“http://” ＋ 域名, Cookie名称, CookieStr)
    CookieStr ＝ CookieStr ＋ “; domain=.” ＋ 网页_取域名 (域名, 真, )
    返回 (InternetSetCookieA (“http://” ＋ 域名, Cookie名称, CookieStr))
.否则
    现有Cookie ＝ 网页_取Cookie (“http://” ＋ 域名)
    .如果真 (现有Cookie ≠ “”)
        整数容器 ＝ 寻找文本 (现有Cookie, “=”, 1, 真)
        .如果真 (整数容器 ＞ 0)
            名称 ＝ 取文本左边 (现有Cookie, 整数容器 － 1)
            网页_置Cookie (“http://” ＋ 域名, 名称)
            网页_置Cookie (“http://” ＋ 域名)
        .如果真结束
    .如果真结束
    返回 (真)
.如果结束
.子程序 网页_置Cookie1, , 公开
.参数 网站域名, 文本型
.参数 Cookie值, 文本型, , 整个Cookie值
.参数 有效期, 日期时间型, 可空, 可空。默认为2088年8月8日8时
.局部变量 局_数组, 文本型, , "0"
.局部变量 i, 整数型
.局部变量 局_C名称, 文本型
.局部变量 局_C内容, 文本型
.局部变量 局_位置, 整数型
.如果真 (是否为空 (有效期))
    有效期 ＝ [2088年8月8日8时]
.如果真结束
局_数组 ＝ 分割文本 (Cookie值, “;”, )
.计次循环首 (取数组成员数 (局_数组), i)
    局_位置 ＝ 寻找文本 (局_数组 [i], “=”, , 假)
    .如果真 (局_位置 ＝ -1)
        到循环尾 ()
    .如果真结束
    局_C名称 ＝ 删首尾空 (取文本左边 (局_数组 [i], 局_位置 － 1))
    局_C内容 ＝ 删首尾空 (取文本右边 (局_数组 [i], 取文本长度 (局_数组 [i]) － 局_位置))
    网页_置Cookie (网站域名, 局_C名称, 局_C内容, 有效期)
.计次循环尾 ()
.子程序 网页_取Cookie, 文本型, 公开, 取出指定域名在本机的cookie
.参数 域名, 文本型, , 只接受域名
.参数 Cookie名称, 文本型, 可空, 为空返回全部Cookie
.局部变量 网址, 文本型
.局部变量 读取内容, 文本型
.局部变量 读取内容1, 文本型
网址 ＝ “http://” ＋ 域名
连续赋值 (取空白文本 (3000), 读取内容, 读取内容1)
InternetGetCookieA (网址, 字符 (0), 读取内容, 3000)
InternetGetCookieExA (网址, 字符 (0), 读取内容1, 3000, 8192, 0)
读取内容 ＝ 网页_Cookie合并更新 (读取内容, 读取内容1)
.如果真 (Cookie名称 ≠ “”)
    读取内容 ＝ 网页_取单条Cookie (读取内容, Cookie名称)
.如果真结束
返回 (读取内容)
.子程序 网页_取Cookie2, 文本型, 公开, [Mr.Yang]
.参数 域名, 文本型, , 欲取出cookie域名 例:<a href="http://baidu.com或baidu.com" target="_blank">http://baidu.com或baidu.com</a>
.参数 Path, 文本型, 可空, 取出存放在path的cookie
.参数 Cookie名称, 文本型, 可空, 为空返回全部Cookie
.局部变量 _域名, 文本型
.局部变量 _Path, 文本型
.局部变量 读取内容, 文本型
.局部变量 读取内容1, 文本型
.如果 (寻找文本 (域名, “://”, , 假) ＝ -1)
    _域名 ＝ “http://” ＋ 域名
.否则
    _域名 ＝ 域名
.如果结束
.如果真 (取文本右边 (_域名, 1) ＝ “/”)
    _域名 ＝ 文本_删右边 (_域名, 1)
.如果真结束
.如果真 (Path ≠ “”)
    _Path ＝ Path
    .如果真 (取文本左边 (_Path, 1) ≠ “/”)
        _Path ＝ “/” ＋ _Path
    .如果真结束
    .如果真 (取文本右边 (_Path, 1) ≠ “/”)
        _Path ＝ _Path ＋ “/”
    .如果真结束
    _域名 ＝ _域名 ＋ _Path
.如果真结束
连续赋值 (取空白文本 (3000), 读取内容, 读取内容1)
InternetGetCookieA (_域名, 字符 (0), 读取内容, 3000)
InternetGetCookieExA (_域名, 字符 (0), 读取内容1, 3000, 8192, 0)
网页_Cookie合并更新 (读取内容, 读取内容1)
.如果真 (Cookie名称 ≠ “”)
    读取内容 ＝ 网页_取单条Cookie (读取内容, Cookie名称)
.如果真结束
返回 (读取内容)
.子程序 网页_取单条Cookie, 文本型, 公开, 从左往右获取
.参数 Cookie, 文本型
.参数 名称, 文本型
.参数 不附带名称, 逻辑型, 可空
.局部变量 t, 文本型
Cookie ＝ 删首尾空 (Cookie)
.如果真 (取文本右边 (Cookie, 1) ≠ “;”)
    Cookie ＝ Cookie ＋ “; ”
.如果真结束
t ＝ 取单条Cookie (Cookie, 名称)
.判断开始 (不附带名称 或 t ＝ “”)
    返回 (t)
.默认
    返回 (名称 ＋ “=” ＋ t)
.判断结束
.子程序 取单条Cookie, 文本型
.参数 原Cookies, 文本型
.参数 单条Cookie名称, 文本型
.局部变量 Cookies, 文本型, , "0"
.局部变量 i, 整数型
.局部变量 Name, 文本型
Cookies ＝ 分割文本 (原Cookies, “;”, )
.计次循环首 (取数组成员数 (Cookies), i)
    Name ＝ 文本_取左边 (删首尾空 (Cookies [i]), “=”, , )
    .如果真 (到小写 (Name) ＝ 到小写 (单条Cookie名称))
        .如果真 (寻找文本 (删首尾空 (Cookies [i]), “:”, , 假) ≠ -1)
            返回 (文本_取出中间文本 (删首尾空 (Cookies [i]), “=”, “:”, , ))
        .如果真结束
        返回 (文本_取右边 (删首尾空 (Cookies [i]), “=”, -1, ))
    .如果真结束
.计次循环尾 ()
返回 (“”)
.子程序 网页_清除Cookie, , 公开, 清除本机IE里的cookie
.参数 域名, 文本型, , 只接受域名
.局部变量 Cookie值1, 文本型
.局部变量 Cookie值2, 文本型
.局部变量 Cookie, 文本型, , "0"
.局部变量 计次, 整数型
.局部变量 最终Cookie, 文本型
.局部变量 Cookie名, 文本型
Cookie值1 ＝ “deleted; expires=Fri, 1-Jan-1999 1:1:1 GMT; path=/;”
Cookie值2 ＝ Cookie值1 ＋ “ domain=” ＋ 网页_取域名 (域名, 真)
最终Cookie ＝ 网页_取Cookie (域名)
Cookie ＝ 分割文本 (最终Cookie, “;”, )
.计次循环首 (取数组成员数 (Cookie), 计次)
    Cookie名 ＝ 内部_Cookie取名 (Cookie [计次])
    InternetSetCookieA (“http://” ＋ 域名, Cookie名, Cookie值1)
    InternetSetCookieA (“http://” ＋ 域名, Cookie名, Cookie值2)
.计次循环尾 ()
.子程序 网页_清除Cookie文件, 逻辑型, 公开, 【此命令由小磊提供】，删除本地IE缓存的cookie文件
.参数 关键字, 文本型, 可空, 输入Cookie文件的关键字即可,空则清除全部
.参数 Cookie路径, 文本型, 参考 可空, 传递Cookie路径
.局部变量 文件名, 文本型
.局部变量 已删除, 逻辑型
Cookie路径 ＝ 取文本注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Cookies”, )
文件名 ＝ 寻找文件 (Cookie路径 ＋ “\*.txt”, )
.判断循环首 (文件名 ≠ “”)
    .如果真 (寻找文本 (文件名, 关键字, 1, 假) ≠ -1 或 关键字 ＝ “”)
        .如果真 (删除文件 (Cookie路径 ＋ “\” ＋ 文件名))
            已删除 ＝ 真
        .如果真结束
    .如果真结束
    文件名 ＝ 寻找文件 (, )
.判断循环尾 ()
返回 (已删除)
.子程序 网页_删除IE缓存文件, 逻辑型, 公开, 【此命令由小磊提供】，删除本地IE的缓存文件
.参数 缓存文件路径, 文本型, 参考 可空, 传递缓存文件路径
.局部变量 文件名, 文本型
.局部变量 已删除, 逻辑型
缓存文件路径 ＝ 取文本注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Cache”, )
文件名 ＝ 寻找文件 (缓存文件路径 ＋ “\*.*”, )
.判断循环首 (文件名 ≠ “”)
    .如果真 (删除文件 (缓存文件路径 ＋ “\” ＋ 文件名))
        已删除 ＝ 真
    .如果真结束
    文件名 ＝ 寻找文件 (, )
.判断循环尾 ()
返回 (已删除)
.子程序 网页_保存, , 公开, 保存网页
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 258)
.子程序 网页_打印, , 公开, 打印
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 260)  ' #define ID_IE_FILE_PRINT 260
.子程序 网页_全选, , 公开, 全选
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 31)
.子程序 网页_打印预览, , 公开, 打印预览
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 93)
.子程序 网页_查找关键字, , , 查找关键字
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 67)
.子程序 网页_保存html文档, , 公开, 保存html文档
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 71)
.子程序 网页_查看网页属性, , 公开, 查看网页属性
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 28)
.子程序 网页_设置网页字体, , 公开, 设置网页字体
.参数 浏览器句柄, 整数型
网页_发送命令 (浏览器句柄, 0, 90)
.子程序 网页_发送命令, , , 发送IE命令
.参数 窗口句柄, 整数型, , 网页框句柄
.参数 命令类型, 整数型, , 命令类型
.参数 命令ID, 整数型, , 命令ID
.局部变量 hwndSDV, 整数型, , , Shell DocObject View
.局部变量 hwndIES, 整数型, , , Internet Explorer_Server
窗口_查找网页句柄 (窗口句柄, hwndSDV, hwndIES)
.如果真 (hwndSDV ≠ 0 且 hwndIES ≠ 0)
    .判断开始 (命令类型 ＝ 1)
        发送消息整数 (hwndIES, 273, 命令ID, 0)
    .默认
        发送消息整数 (hwndSDV, 273, 命令ID, 0)
    .判断结束
.如果真结束
.子程序 窗口_查找网页句柄, , , 取网页框(WebBrowser)的子窗口句柄
.参数 Hwnd, 整数型
.参数 hwndSDV, 整数型, 参考, Shell DocObject View
.参数 hwndIES, 整数型, 参考, Internet Explorer_Server
.局部变量 窗口句柄, 整数型
.局部变量 窗口类名, 文本型
窗口句柄 ＝ FindWindowExA (Hwnd, 0, 0, 0)
.判断循环首 (窗口句柄 ≠ 0)
    窗口类名 ＝ 窗口_取类名 (窗口句柄)
    .如果 (窗口类名 ＝ “Shell DocObject View”)
        hwndSDV ＝ 窗口句柄
        跳出循环 ()
    .否则
        窗口_查找网页句柄 (窗口句柄, hwndSDV, hwndIES)
    .如果结束
    窗口句柄 ＝ FindWindowExA (Hwnd, 窗口句柄, 0, 0)
.判断循环尾 ()
.如果真 (hwndSDV ≠ 0)
    窗口类名 ＝ 窗口_取类名 (窗口句柄)
    .如果真 (窗口类名 ＝ “Shell DocObject View”)
        hwndIES ＝ FindWindowExA (hwndSDV, 0, 0, 0)
    .如果真结束
.如果真结束
.子程序 网页_取网址引用, 文本型, 公开, 返回指定网址的引用信息
.参数 网址, 文本型
.局部变量 pwszUrl1, 字节集
.局部变量 urlComp, URL_COMPONENTS
.局部变量 bool, 逻辑型
.局部变量 lpszScheme, 文本型
.局部变量 lpszHostName, 文本型
.局部变量 Agreement, 文本型
urlComp.dwStructSize ＝ 60
urlComp.dwSchemeLength ＝ -1
urlComp.dwHostNameLength ＝ -1
urlComp.dwUrlPathLength ＝ -1
urlComp.dwExtraInfoLength ＝ -1
Agreement ＝ 文本_取左边 (网址, “//”)
.如果真 (Agreement ＝ “mms:”)
    网址 ＝ 子文本替换 (网址, Agreement, “http:”, , , 真)
.如果真结束
pwszUrl1 ＝ 编码_Ansi到Unicode (网址)
bool ＝ WinHttpCrackUrl (pwszUrl1, 取字节集长度 (pwszUrl1), 0, urlComp)
.如果真 (bool)
    lpszScheme ＝ 编码_Unicode到Ansi (指针到字节集 (urlComp.lpszScheme, urlComp.dwSchemeLength × 2))
    lpszHostName ＝ 编码_Unicode到Ansi (指针到字节集 (urlComp.lpszHostName, urlComp.dwHostNameLength × 2))
    .如果真 (Agreement ＝ “mms:”)
        返回 (Agreement ＋ “//” ＋ lpszHostName)
    .如果真结束
    返回 (lpszScheme ＋ “://” ＋ lpszHostName)
.如果真结束
返回 (“”)
.子程序 网页_取页面地址, 文本型, 公开, 返回指定网址的页面地址
.参数 网址, 文本型
.局部变量 页面地址, 文本型
.局部变量 符号位置, 整数型
.局部变量 域名, 文本型
域名 ＝ 网页_取域名 (网址)
符号位置 ＝ 寻找文本 (网址, “/”, 寻找文本 (网址, 域名, 1, 真), 真)
.如果 (符号位置 ＞ 0)
    页面地址 ＝ 取文本右边 (网址, 取文本长度 (网址) － 符号位置 ＋ 1)
.否则
    页面地址 ＝ “/”
.如果结束
返回 (页面地址)
.子程序 网页_取网址文件名, 文本型, 公开, 取一个网站地址中的文件名
.参数 网址, 文本型
.局部变量 分隔块, 文本型, , "0"
.局部变量 块数, 整数型
.局部变量 文件名, 文本型
分隔块 ＝ 分割文本 (网址, “/”, )
块数 ＝ 取数组成员数 (分隔块)
.如果真 (块数 ＝ 0)
    返回 (“”)
.如果真结束
返回 (分隔块 [块数])
.子程序 网页_取网络文件名, 文本型, 公开, 取特殊网络文件名，如{35419830/13139680144000128.mp3?xcode=91d07544}，取出文件名为“我可以抱你吗.mp3”
.参数 网址, 文本型
.局部变量 name, 文本型
.局部变量 hOpen, 整数型
.局部变量 hOpenUrl
.局部变量 Length
.局部变量 bool, 逻辑型
.局部变量 sBuffer, 文本型
hOpen ＝ InternetOpenA (“”, 0, 字符 (0), 字符 (0), 0)
.如果真 (hOpen ≠ 0)
    hOpenUrl ＝ InternetOpenUrlA (hOpen, 网址, 字符 (0), 0, 2147483648, 0)
    .如果真 (hOpenUrl ≠ 0)
        bool ＝ HttpQueryInfoA (hOpenUrl, 22, “”, Length, 0)  ' #HTTP_QUERY_RAW_HEADERS_CRLF
        sBuffer ＝ 取空白文本 (Length)
        bool ＝ HttpQueryInfoA (hOpenUrl, 22, sBuffer, Length, 0)
        .如果真 (bool)
            name ＝ 文本_取出中间文本 (sBuffer, “filename=” ＋ #引号, #引号)
        .如果真结束
        InternetCloseHandle (hOpenUrl)
    .如果真结束
    InternetCloseHandle (hOpen)
.如果真结束
返回 (name)
.子程序 网页_是否为网页, 逻辑型, 公开, 判断输入的地址是否为URL地址。
.参数 网页地址, 文本型
返回 (PathIsURL (网页地址))
.子程序 网页_还原网页颜色, 文本型, 公开, 转换颜色值到网页颜色的代码
.参数 颜色值, 整数型
.局部变量 结果文本, 文本型
结果文本 ＝ 取十六进制文本 (颜色值)
结果文本 ＝ 取文本中间 (结果文本, 5, 2) ＋ 取文本中间 (结果文本, 3, 2) ＋ 取文本左边 (结果文本, 2)
.如果 (取文本长度 (结果文本) ＜ 6)
    结果文本 ＝ 取文本左边 (“#” ＋ 结果文本 ＋ “000000”, 7)
.否则
    结果文本 ＝ “#” ＋ 结果文本
.如果结束
返回 (结果文本)
.子程序 网页_转换为HTML色, 文本型, 公开, 将RGB色转换为HTML色
.参数 RGB颜色值, 整数型
.局部变量 HTML颜色值, 文本型
.局部变量 字节集, 字节集
.局部变量 局_文本, 文本型
字节集 ＝ 到字节集 (RGB颜色值)
局_文本 ＝ 取十六进制文本 (字节集 [1])
HTML颜色值 ＝ HTML颜色值 ＋ 选择 (取文本长度 (局_文本) ＝ 1, 局_文本 ＋ “0”, 局_文本)
局_文本 ＝ 取十六进制文本 (字节集 [3])
HTML颜色值 ＝ HTML颜色值 ＋ 选择 (取文本长度 (局_文本) ＝ 1, 局_文本 ＋ “0”, 局_文本)
局_文本 ＝ 取十六进制文本 (字节集 [2])
HTML颜色值 ＝ HTML颜色值 ＋ 选择 (取文本长度 (局_文本) ＝ 1, 局_文本 ＋ “0”, 局_文本)
返回 (HTML颜色值)
.子程序 网页_取十进制颜色值, 整数型, 公开, 把十六进制的网页颜色值转换成十进制的颜色值    
.参数 十六进制的颜色值, 文本型, , 234A97
.局部变量 字节集, 字节集
.局部变量 str, 文本型
str ＝ 子文本替换 (十六进制的颜色值, “#”, “”, , , 真)
字节集 ＝ 取空白字节集 (4)
字节集 [1] ＝ 进制_十六到十 (取文本中间 (str, 1, 2))
字节集 [2] ＝ 进制_十六到十 (取文本中间 (str, 3, 2))
字节集 [3] ＝ 进制_十六到十 (取文本中间 (str, 5, 2))
返回 (取字节集数据 (字节集, #整数型, ))
.子程序 网页_打开指定网址, , 公开, 使用系统默认的浏览器打开一个网址
.参数 网页地址, 文本型, , 要打开的网页地址
ShellExecuteA (0, “open”, 网页地址, “”, “”, 1)
.子程序 网页_创建快捷方式, 逻辑型, 公开, 创建网页快捷方式
.参数 快捷方式文件名, 文本型, , 扩展名为.url全路径
.参数 网页地址, 文本型
.参数 ico图标, 文本型, 可空
.参数 快捷键, 文本型, 可空, 如"CTRL+SHIFT+F"
.局部变量 Wshom, 对象
.局部变量 oUrlLink, 对象
CoInitialize (0)
.如果真 (Wshom.创建 (“{F935DC22-1CF0-11d0-ADB9-00C04FD58A0B}”, ))
    快捷方式文件名 ＝ 选择 (文件_取扩展名 (快捷方式文件名) ≠ “.url”, 快捷方式文件名 ＋ “.url”, 快捷方式文件名)
    oUrlLink ＝ Wshom.对象型方法 (“CreateShortcut”, 快捷方式文件名)
    oUrlLink.写属性 (“TargetPath”, 网页地址)
    oUrlLink.写属性 (“WindowStyle”, 2)
    oUrlLink.写属性 (“IconLocation”, ico图标)
    写配置项 (快捷方式文件名, “InternetShortcut”, “IconFile”, ico图标)
    写配置项 (快捷方式文件名, “InternetShortcut”, “IconIndex”, “0”)
    oUrlLink.写属性 (“Hotkey”, 快捷键)
    oUrlLink.数值方法 (“Save”, )
    Wshom.清除 ()
.如果真结束
CoUninitialize ()
返回 (文件_是否存在 (快捷方式文件名))
.子程序 网页_取快捷方式地址, 文本型, 公开, 取网页快捷方式的地址；
.参数 文件路径, 文本型
返回 (读配置项 (文件路径, “InternetShortcut”, “URL”, ))
.子程序 网页_网络文件是否存在, 逻辑型, 公开, 判断网络上的文件是否存在，存在返回真，否则返回假；
.参数 网络文件名, 文本型
.局部变量 IXMLHTTP, 对象
.局部变量 局_返回, 逻辑型
CoInitialize (0)
IXMLHTTP.创建 (“msxml2.XMLHTTP”, )
IXMLHTTP.方法 (“open”, “HEAD”, 网络文件名, 假)
IXMLHTTP.方法 (“send”, )
局_返回 ＝ IXMLHTTP.读数值属性 (“Status”, ) ＝ 200
IXMLHTTP.清除 ()
CoUninitialize ()
返回 (局_返回)
.子程序 网页_开始屏蔽信息框, 逻辑型, 公开, 屏蔽掉电脑上把有页页信息框，成功开始屏蔽返回真，失败返回假；
.如果真 (集_屏蔽信息框线程句柄 ＝ 0)
    集_屏蔽信息框线程句柄 ＝ 线程_启动 (&内部_屏蔽网页信息框)
    返回 (真)
.如果真结束
.如果真 (集_屏蔽信息框线程句柄 ≠ 0)
    输出调试文本 (“已经开始了屏蔽网页信息框，请不要重复使用！”)
.如果真结束
返回 (假)
.子程序 网页_停止屏蔽信息框, , 公开, 停止屏蔽掉电脑上把有页页信息框
线程_销毁 (集_屏蔽信息框线程句柄)
线程_关闭句柄 (集_屏蔽信息框线程句柄)
集_屏蔽信息框线程句柄 ＝ 0
.子程序 内部_屏蔽网页信息框, 整数型
.参数 整数, 整数型
.局部变量 窗口句柄, 整数型
.局部变量 窗口标题, 文本型
.局部变量 静态, 整数型
.局部变量 子窗口数组, 整数型, , "0"
.局部变量 i, 整数型
静态 ＝ 1
.判断循环首 (静态 ＝ 1)  ' 构造死循环.又不让编译器不通过
    .计次循环首 (窗口_枚举所有子窗口 (, 子窗口数组, “#32770”), i)
        窗口标题 ＝ 窗口_取标题 (子窗口数组 [i])
        .如果真 (窗口标题 ＝ “来自网页的消息”)  ' WIN7是IE9+提示这个
            发送消息整数 (子窗口数组 [i], 16, 0, 0)
        .如果真结束
        .如果真 (窗口标题 ＝ “Microsoft Internet Explorer”)  ' ie6
            发送消息整数 (子窗口数组 [i], 16, 0, 0)
        .如果真结束
    .计次循环尾 ()
    延时 (500)
.判断循环尾 ()
返回 (0)
.子程序 网页_自动点击网页信息框, , 公开, 自动点击网页上弹出的消息框
.参数 窗口句柄, 整数型, , 程序本身的窗口句柄,直接用 取窗口句柄() 命令即可
.参数 网页信息框的标题, 文本型, 可空, 可空，网页信息框的标题,默认为【Microsoft Internet Explorer】
.参数 按钮的标题, 文本型, 可空, 可空，消息框上要点击的按钮标题,默认为【确定】
.参数 停止, 逻辑型, 可空, 可空，如果将此参数设置为真，将停止自动点击信息框
.参数 监控间隔, 整数型, 可空, 可空，默认为300毫秒。
.如果真 (停止)
    时钟_销毁 (窗口句柄, 100)
    返回 ()
.如果真结束
.如果真 (是否为空 (监控间隔) 或 监控间隔 ＜ 50)
    监控间隔 ＝ 300
.如果真结束
.如果真 (是否为空 (网页信息框的标题))
    网页信息框的标题 ＝ “Microsoft Internet Explorer”
.如果真结束
.如果真 (是否为空 (按钮的标题))
    按钮的标题 ＝ “确定”
.如果真结束
集_按钮的标题 ＝ 网页信息框的标题 ＋ “|” ＋ 按钮的标题
时钟_创建 (窗口句柄, 100, 监控间隔, &开始自动点击网页信息框)
.子程序 开始自动点击网页信息框
.局部变量 窗口句柄, 整数型
.局部变量 子窗口句柄, 整数型
窗口句柄 ＝ 窗口_取句柄 (, , “#32770”, 文本_取左边 (集_按钮的标题, “|”))
子窗口句柄 ＝ 窗口_取句柄 (窗口句柄, , “Button”, 文本_取右边 (集_按钮的标题, “|”))
.如果真 (子窗口句柄 ＞ 0)
    鼠标_消息 (子窗口句柄, 5, 5)
.如果真结束
.子程序 网页_自动点击网页信息框_带返回值, 逻辑型, 公开, 成功返回真，失败返回假。
.参数 网页信息框的标题, 文本型, 可空, 网页信息框的标题,默认为【Microsoft Internet Explorer】
.参数 按钮的标题, 文本型, 可空, 消息框上要点击的按钮标题,默认为【确定】
.参数 超时返回, 整数型, 可空, 可空，单位为毫秒，默认为5000毫秒。
.参数 监控间隔, 整数型, 可空, 可空，默认为300毫秒。
.局部变量 窗口句柄, 整数型
.局部变量 子窗口句柄, 整数型
.局部变量 局_超时, 整数型
.局部变量 局_线程句柄, 整数型
.局部变量 局_返回值, 整数型
.局部变量 局_时间, 整数型
.如果真 (是否为空 (网页信息框的标题))
    网页信息框的标题 ＝ “Microsoft Internet Explorer”
.如果真结束
.如果真 (是否为空 (按钮的标题))
    按钮的标题 ＝ “确定”
.如果真结束
.如果真 (是否为空 (超时返回) 或 超时返回 ＜ 1000)
    超时返回 ＝ 5000
.如果真结束
.如果真 (是否为空 (监控间隔) 或 监控间隔 ＜ 50)
    监控间隔 ＝ 300
.如果真结束
集_按钮的标题 ＝ 网页信息框的标题 ＋ “|” ＋ 按钮的标题
局_线程句柄 ＝ 线程_启动 (&开始自动点击网页信息框_带返回值, 监控间隔)
局_时间 ＝ 取启动时间 ()
.循环判断首 ()
    局_返回值 ＝ MsgWaitForMultipleObjects (1, 局_线程句柄, 假, 超时返回, 1215)
    .如果真 (取启动时间 () － 局_时间 ≥ 超时返回)
        局_返回值 ＝ 258
    .如果真结束
    程序_延时 (300)
.循环判断尾 (局_返回值 ≠ 0 且 局_返回值 ≠ 258)  ' 258=已超时,0=线程正常结束
.如果真 (局_返回值 ＝ 258)  ' 线程_销毁 (局_线程句柄)
    线程_销毁 (局_线程句柄)
    CloseHandle (局_线程句柄)
.如果真结束
返回 (局_返回值 ≠ 258)  ' 如果不是超时,则为真
.子程序 开始自动点击网页信息框_带返回值
.参数 监控间隔, 整数型
.局部变量 窗口句柄, 整数型
.局部变量 子窗口句柄, 整数型
.判断循环首 (真)
    窗口句柄 ＝ 窗口_取句柄 (, , “#32770”, 文本_取左边 (集_按钮的标题, “|”))
    子窗口句柄 ＝ 窗口_取句柄 (窗口句柄, , “Button”, 文本_取右边 (集_按钮的标题, “|”))
    .如果真 (子窗口句柄 ＞ 0)
        鼠标_消息 (子窗口句柄, 5, 5)
        鼠标_消息 (子窗口句柄, 5, 5)
        返回 ()
    .如果真结束
    程序_延时 (监控间隔)
.判断循环尾 ()
.子程序 立即刷新注册表
发送消息整数 (GetDesktopWindow (), 26, 0, 0)
.子程序 网页_屏蔽网页复制提示, , 公开, 目前只测试了IE8
.参数 是否屏蔽, 逻辑型, 可空, 默认为真，允许网页复制，假为不允许。
.局部变量 注册表, 注册表操作
.如果 (是否为空 (是否屏蔽) 或 是否屏蔽 ＝ 真)
    注册表.写DWORD值 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3”, “1407”, 0)
.否则
    注册表.写DWORD值 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3”, “1407”, 1)
.如果结束
立即刷新注册表 ()
.子程序 网页_禁止允许一键操作, , 公开, 一键操作所有设置（写注册项，影响全局，不仅仅是软件的自带浏览器）
.参数 禁止允许gif图片, 逻辑型, 可空, 禁止或允许 播放GIF动画图片，可以加快网页的显示速度。默认为假，允许。
.参数 禁止允许显示图片, 逻辑型, 可空, 禁止或允许 显示网页中的图片，可以加快网页的显示速度。默认为假，允许。
.参数 禁止允许背景声音, 逻辑型, 可空, 禁止或允许 播放网页背景声音，如：mid、mp3等等。默认为假，允许。
.参数 禁止允许点击声音, 逻辑型, 可空, 禁止或允许 在点击网页链接或网页跳转时,会有一个点击的声音,用此命令可以禁止或恢复它。默认为假，允许。
.参数 禁止允许播放网页视频, 逻辑型, 可空, 禁止或允许 播放网页中的视频，可以加快网页的显示速度。默认为假，允许。
网页_禁止允许gif图片 (禁止允许gif图片)
网页_禁止允许显示图片 (禁止允许显示图片)
网页_禁止允许背景声音 (禁止允许背景声音)
网页_禁止允许点击声音 (禁止允许点击声音)
网页_禁止允许播放网页视频 (禁止允许播放网页视频)
.子程序 网页_禁止允许gif图片, 逻辑型, 公开, 禁止或允许 播放GIF动画图片，可以加快网页的显示速度。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
.参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
.局部变量 局_文本, 文本型
局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Play_Animations”, 局_文本)
立即刷新注册表 ()
返回 (禁止或允许)
.子程序 网页_禁止允许背景声音, 逻辑型, 公开, 禁止或允许 播放网页背景声音，如：mid、mp3等等。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
.参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
.局部变量 局_文本, 文本型
局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Play_Background_Sounds”, 局_文本)
立即刷新注册表 ()
返回 (禁止或允许)
.子程序 网页_禁止允许显示图片, 逻辑型, 公开, 禁止或允许 显示网页中的图片，可以加快网页的显示速度。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
.参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
.局部变量 局_文本, 文本型
局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Display Inline Images”, 局_文本)
立即刷新注册表 ()
返回 (禁止或允许)
.子程序 网页_禁止允许点击声音, 逻辑型, 公开, 禁止或允许 在点击网页链接或网页跳转时,会有一个点击的声音,用此命令可以禁止或恢复它。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
.参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
.局部变量 局_声音路径, 文本型
.局部变量 局_REG路径, 文本型
.局部变量 注册表, 注册表操作
局_REG路径 ＝ “HKEY_CURRENT_USER\AppEvents\Schemes\Apps\Explorer\Navigating\.Current”
局_声音路径 ＝ 到文本 (注册表.取字节集 (局_REG路径, “”, 到数值 (文本_取右边 (注册表.取键名类型 (局_REG路径), “：”))))
.如果真 (删首尾空 (局_声音路径) ＝ “”)
    返回 (假)
.如果真结束
.判断开始 (禁止或允许)
    .如果真 (取文本右边 (局_声音路径, 1) ＝ “1”)
        返回 (真)
    .如果真结束
    返回 (注册表.写字节集 (局_REG路径, “”, 到字节集 (局_声音路径 ＋ “1”), 到数值 (文本_取右边 (注册表.取键名类型 (局_REG路径), “：”))))
.判断 (禁止或允许 ＝ 假)
    .如果真 (取文本右边 (局_声音路径, 1) ≠ “1”)
        返回 (真)
    .如果真结束
    局_声音路径 ＝ 取文本左边 (局_声音路径, 取文本长度 (局_声音路径) － 1)
    返回 (注册表.写字节集 (局_REG路径, “”, 到字节集 (局_声音路径), 到数值 (文本_取右边 (注册表.取键名类型 (局_REG路径), “：”))))
.默认
.判断结束
返回 (假)
.子程序 网页_禁止允许播放网页视频, 逻辑型, , 禁止或允许 播放网页中的视频，可以加快网页的显示速度。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
.参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
.局部变量 局_文本, 文本型
局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Display Inline Videos”, 局_文本)
立即刷新注册表 ()
返回 (禁止或允许)
.子程序 网页_取编码, 文本型, 公开, 用于取出指定网页地址的编码
.参数 网页地址, 文本型
.局部变量 局_网页内容, 文本型
.局部变量 局_正则, 正则表达式类
.局部变量 局_编码类型, 文本型
局_网页内容 ＝ 到文本 (网页_访问 (网页地址))
.如果真 (取文本长度 (局_网页内容) ＞ 0)
    .如果真 (局_正则.创建 (“<meta.+?charset=[^\w]?([-\w]+)”, 取文本左边 (局_网页内容, 1024)))
        局_编码类型 ＝ 局_正则.取子匹配文本 (1, 1)
    .如果真结束
    返回 (局_编码类型)
.如果真结束
返回 (“”)
.子程序 网页_取网络文件尺寸, 长整数型, 公开
.参数 欲取网络文件地址, 文本型
.局部变量 hOpen
.局部变量 hOpenUrl
.局部变量 sbuffer, 文本型
.局部变量 Length, 整数型
hOpen ＝ InternetOpenA (“”, 0, 字符 (0), 字符 (0), 0)
.如果真 (hOpen ≠ 0)
    hOpenUrl ＝ InternetOpenUrlA (hOpen, 欲取网络文件地址, 字符 (0), 0, 2147483648, 0)
    .如果真 (hOpenUrl ≠ 0)
        HttpQueryInfoA (hOpenUrl, 5, “”, Length, 0)
        sbuffer ＝ 取空白文本 (Length)
        HttpQueryInfoA (hOpenUrl, 5, sbuffer, Length, 0)
        InternetCloseHandle (hOpenUrl)
    .如果真结束
    InternetCloseHandle (hOpen)
.如果真结束
返回 (到长整数 (sbuffer))
.子程序 网络_取网络文件大小_对象版, 长整数型, 公开
.参数 url, 文本型
.参数 代理IP, 文本型, 可空
.局部变量 局_http, 对象
.局部变量 局_结果, 变体型
.局部变量 局_返回, 长整数型
' 该例程收录自：https://bbs.125.la/thread-14380851-1-1.html
CoInitialize (0)
.如果 (局_http.创建 (“WinHttp.WinHttpRequest.5.1”, ))
    局_http.方法 (“SetTimeouts”, 5000, 5000, 10000, 5000)
    局_http.方法 (“open”, “HEAD”, url, 假)
    局_http.方法 (“setRequestHeader”, “User-Agent”, “Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)”)
    局_http.方法 (“setRequestHeader”, “Accept-Language”, “zh-cn”)
    局_http.方法 (“setRequestHeader”, “Connection”, “Keep-Alive”)
    .如果真 (是否为空 (代理IP) ＝ 假)
        局_http.方法 (“SetProxy”, 代理IP)
    .如果真结束
    局_http.方法 (“send”, )
    局_结果 ＝ 局_http.读属性 (“status”, )
    .如果 (到整数 (局_结果.取数值 ()) ＝ 200)
        局_结果 ＝ 局_http.读属性 (“GetResponseHeader”, “Content-Length”)
        局_返回 ＝ 到长整数 (局_结果.取数值 ())
        CoUninitialize ()
        返回 (局_返回)
    .否则
        CoUninitialize ()
        返回 (-1)
    .如果结束
.否则
    CoUninitialize ()
    返回 (-2)
.如果结束
.子程序 网址_取所有参数, 整数型, 公开, 取出指定网址中所有的键名和键值，返回取到的数量。
.参数 参_网址, 文本型
.参数 参_名称, 文本型, 参考 可空, 返回名称；如：http://www.baidu.com/nihao?id=123456&name=hello，其中nihao就是名称
.参数 参_键名数组, 文本型, 参考 可空 数组
.参数 参_键值数组, 文本型, 参考 可空 数组
.局部变量 局_临时url, 文本型
.局部变量 局_最后位置, 整数型
.局部变量 局_参数文本, 文本型
.局部变量 局_返回位置1, 整数型
.局部变量 局_起始位置1, 整数型
.局部变量 局_返回位置2, 整数型
.局部变量 局_参数名, 文本型
.局部变量 局_返回位置3, 整数型
.局部变量 局_参数值, 文本型
' https://bbs.125.la/thread-14496162-1-1.html
局_临时url ＝ 参_网址
局_最后位置 ＝ 寻找文本 (局_临时url, “?”, , 假)  ' 针对url中参数部分包含url，会导致解析最后一个url，所以要从第一个?位置开始寻找
.判断开始 (局_最后位置 ＝ -1)
    局_最后位置 ＝ 倒找文本 (局_临时url, “/”, , 假)
.默认
    局_最后位置 ＝ 倒找文本 (局_临时url, “/”, 局_最后位置, 假)  ' 通常url参数部分都是从最后一个/符号开始的
.判断结束
局_参数文本 ＝ 取文本右边 (局_临时url, 取文本长度 (局_临时url) － 局_最后位置)
局_返回位置1 ＝ 寻找文本 (局_参数文本, “?”, , 假)
.判断开始 (局_返回位置1 ≠ -1)
    参_名称 ＝ 取文本左边 (局_参数文本, 局_返回位置1 － 1)
.默认
    参_名称 ＝ “”
.判断结束
' 替换掉第一次出现的?符号，部分url第一个参数是用?号开始的
局_参数文本 ＝ 子文本替换 (局_参数文本, “?”, “&”, , 1, 真)
清除数组 (参_键名数组)
清除数组 (参_键值数组)
.判断循环首 (真)
    ' 寻找参数名，&和=直接的就是参数名
    局_返回位置1 ＝ 寻找文本 (局_参数文本, “&”, 局_起始位置1, 假)
    .如果真 (局_返回位置1 ＝ -1)
        跳出循环 ()
    .如果真结束
    局_返回位置2 ＝ 寻找文本 (局_参数文本, “=”, 局_返回位置1, 假)
    .如果真 (局_返回位置2 ＝ -1)
        跳出循环 ()
    .如果真结束
    ' 如果寻找到&和?就取出两个符号之间的参数名
    局_参数名 ＝ 取文本中间 (局_参数文本, 局_返回位置1 ＋ 1, 局_返回位置2 － 局_返回位置1 － 1)
    加入成员 (参_键名数组, 局_参数名)
    ' 寻找参数值，从上一次的=号位置开始寻找&号，中间的内容就是参数值了
    局_返回位置3 ＝ 寻找文本 (局_参数文本, “&”, 局_返回位置2, 假)
    .判断开始 (局_返回位置3 ＝ -1)  ' 如果找不到&符号，表示到url尾部了，取出尾部所有内容即可
        局_参数值 ＝ 取文本右边 (局_参数文本, 取文本长度 (局_参数文本) － 局_返回位置2)
    .默认
        局_参数值 ＝ 取文本中间 (局_参数文本, 局_返回位置2 ＋ 1, 局_返回位置3 － 局_返回位置2 － 1)
    .判断结束
    加入成员 (参_键值数组, 局_参数值)
    ' 最后一次找到的=符号的位置要赋值给起始位置
    局_起始位置1 ＝ 局_返回位置2
.判断循环尾 ()
返回 (取数组成员数 (参_键名数组))
.子程序 网页_参数Ascii排序, 文本型, 公开, 对传入的请求参数按参数名的字典序（ASCII码)排序
.参数 请求参数, 文本型, , url键值对格式(即key1=value1&key2=value2)
.参数 排序方式, 整数型, 可空, 0.升序排序 1.降序排序  留空默认 0.升序
.局部变量 局_参数名, 文本型, , "0"
.局部变量 局_字符串, 文本型
.局部变量 len, 整数型
.局部变量 i, 整数型
' https://bbs.125.la/forum.php?mod=viewthread&tid=14511499
.如果真 (排序方式 ＜ 0 或 排序方式 ＞ 1)
    排序方式 ＝ 0
.如果真结束
局_参数名 ＝ 分割文本 (请求参数, “&”, )
数组_排序 (局_参数名, 排序方式, 真)
len ＝ 取数组成员数 (局_参数名)
.计次循环首 (len, i)
    局_字符串 ＝ 局_字符串 ＋ 局_参数名 [i]
    .如果真 (i ＜ len)
        局_字符串 ＝ 局_字符串 ＋ “&”
    .如果真结束
.计次循环尾 ()
返回 (局_字符串)
.子程序 网址_取指定参数值, 文本型, 公开, 成功返回键值，失败返回空。
.参数 网址, 文本型
.参数 参数名, 文本型
.局部变量 len, 整数型
.局部变量 局_键名, 文本型, , "0"
.局部变量 局_键值, 文本型, , "0"
.局部变量 i, 整数型
len ＝ 网址_取所有参数 (网址, , 局_键名, 局_键值)
.计次循环首 (len, i)
    .如果真 (局_键名 [i] ＝ 参数名)
        返回 (局_键值 [i])
    .如果真结束
.计次循环尾 ()
返回 (“”)
.子程序 网页_掩码计算, 整数型, 公开, 例：起始IP：121.224.0.0   结束IP：121.239.255.255   返回12
.参数 起始IP, 文本型
.参数 结束IP, 文本型
.局部变量 L_起始IP, 文本型, , "0"
.局部变量 L_结束IP, 文本型, , "0"
.局部变量 L_起始IP_二进制, 文本型
.局部变量 L_结束IP_二进制, 文本型
.局部变量 L_01, 整数型
.局部变量 L_起始IP_二进制_Arr, 文本型, , "0"
.局部变量 L_结束IP_二进制_Arr, 文本型, , "0"
' https://bbs.125.la/forum.php?mod=viewthread&tid=14634957
L_起始IP ＝ 分割文本 (起始IP, “.”, )
L_结束IP ＝ 分割文本 (结束IP, “.”, )
.计次循环首 (4, L_01)
    L_起始IP_二进制 ＝ L_起始IP_二进制 ＋ 取文本右边 (进制_十到二 (到整数 (L_起始IP [L_01])), 8)
    L_结束IP_二进制 ＝ L_结束IP_二进制 ＋ 取文本右边 (进制_十到二 (到整数 (L_结束IP [L_01])), 8)
.计次循环尾 ()
.计次循环首 (32, L_01)
    .如果真 (取文本中间 (L_起始IP_二进制, L_01, 1) ≠ 取文本中间 (L_结束IP_二进制, L_01, 1))
        返回 (L_01 － 1)
    .如果真结束
.计次循环尾 ()
返回 (0)
.子程序 网页_掩码取结束IP, 文本型, 公开, 例：121.224.0.0/12   起始IP：121.224.0.0 掩码：12     返回结束IP：121.239.255.255
.参数 起始IP, 文本型, , 例：121.224.0.0
.参数 掩码, 整数型, , 例：12
.局部变量 L_起始IP, 文本型, , "0"
.局部变量 L_结束IP, 文本型
.局部变量 L_起始IP_二进制, 文本型
.局部变量 L_结束IP_二进制, 文本型
.局部变量 L_01, 整数型
.局部变量 L_02, 整数型
' https://bbs.125.la/forum.php?mod=viewthread&tid=14634957
L_起始IP ＝ 分割文本 (起始IP, “.”, )
.计次循环首 (4, L_01)
    L_起始IP_二进制 ＝ L_起始IP_二进制 ＋ 取文本右边 (进制_十到二 (到整数 (L_起始IP [L_01])), 8)
.计次循环尾 ()
L_结束IP_二进制 ＝ 取文本左边 (L_起始IP_二进制, 掩码) ＋ 取文本右边 (“11111111111111111111111111111111”, 32 － 掩码)
.计次循环首 (4, L_02)
    L_结束IP ＝ L_结束IP ＋ 到文本 (进制_二到十 (取文本中间 (L_结束IP_二进制, (L_02 － 1) × 8 ＋ 1, 8))) ＋ “.”
.计次循环尾 ()
返回 (取文本左边 (L_结束IP, 取文本长度 (L_结束IP) － 1))
.程序集 集_时间
.程序集变量 时间标记, 文本型, , "0"
.子程序 时间_秒到时分秒格式, 文本型, 公开, 返回指定格式的时间文本
.参数 秒, 整数型
.参数 格式, 文本型, 可空, 默认:d天h小时m分s秒
.参数 自动补零, 逻辑型, 可空, 不足2位数自动前面补0
.局部变量 局_天, 整数型
.局部变量 局_小时, 整数型
.局部变量 局_分, 整数型
.局部变量 局_秒, 整数型
.局部变量 局_位置, 整数型
.局部变量 局_Time, 文本型
局_秒 ＝ 秒
.如果真 (是否为空 (格式) 或 格式 ＝ “”)
    格式 ＝ “d天h小时m分s秒”
.如果真结束
局_天 ＝ 局_秒 ÷ 86400
局_小时 ＝ (局_秒 ％ 86400) ÷ 3600
局_分 ＝ (局_秒 ％ 86400 ％ 3600) ÷ 60
局_秒 ＝ 局_秒 ％ 86400 ％ 3600 ％ 60
局_位置 ＝ 倒找文本 (格式, “d”, , 假)
.如果真 (局_位置 ≠ -1)
    局_Time ＝ 到文本 (局_天)
    .如果真 (自动补零)
        局_Time ＝ 文本_自动补零 (局_Time, 2)
    .如果真结束
    格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
.如果真结束
局_位置 ＝ 倒找文本 (格式, “h”, , 假)
.如果真 (局_位置 ≠ -1)
    局_Time ＝ 到文本 (局_小时)
    .如果真 (自动补零)
        局_Time ＝ 文本_自动补零 (局_Time, 2)
    .如果真结束
    格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
.如果真结束
局_位置 ＝ 倒找文本 (格式, “m”, , 假)
.如果真 (局_位置 ≠ -1)
    局_Time ＝ 到文本 (局_分)
    .如果真 (自动补零)
        局_Time ＝ 文本_自动补零 (局_Time, 2)
    .如果真结束
    格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
.如果真结束
局_位置 ＝ 倒找文本 (格式, “s”, , 假)
.如果真 (局_位置 ≠ -1)
    局_Time ＝ 到文本 (局_秒)
    .如果真 (自动补零)
        局_Time ＝ 文本_自动补零 (局_Time, 2)
    .如果真结束
    格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
.如果真结束
返回 (格式)
.子程序 时间_十八位时间戳转北京, 日期时间型, 公开, 将【18位的时间戳】转换成【北京标准时间】
.参数 十八位时间戳, 文本型, , 要转换的18位时间时间戳
.局部变量 十三位时间戳, 长整数型
' 例程来自：https://bbs.125.la/thread-14319889-1-1.html
十三位时间戳 ＝ (到长整数 (十八位时间戳) － 到长整数 (“621355968000000000”)) ÷ 10000
返回 (时间_格林威治转北京 (十三位时间戳))
.子程序 时间_北京转十八位时间戳, 文本型, 公开, 将【北京标准时间】转换成【18位的时间戳】
.参数 时间, 日期时间型, , 要转换的时间
.局部变量 十三位时间戳, 长整数型
.局部变量 十八位时间戳, 长整数型
' 例程来自：https://bbs.125.la/thread-14319889-1-1.html
十三位时间戳 ＝ 到长整数 (时间_到时间戳 (时间, 假, ))
十八位时间戳 ＝ 十三位时间戳 × 10000 ＋ 到长整数 (“621355968000000000”)
返回 (到文本 (十八位时间戳))
.子程序 时间_取时间间隔, 文本型, 公开, 返回一个文本，表示“时间1”减去“时间2”之后间隔的天，时，分，秒。返回示例：3天13时56分27秒
.参数 时间1, 日期时间型
.参数 时间2, 日期时间型
.局部变量 剩余秒数A, 整数型
.局部变量 剩余秒数B, 整数型
.局部变量 剩余天, 整数型
.局部变量 剩余小时, 整数型
.局部变量 剩余分钟, 整数型
.局部变量 剩余秒, 整数型
.局部变量 返回时间, 文本型
' 源码出处：https://bbs.125.la/thread-14315424-1-1.html
剩余秒数A ＝ 取时间间隔 (时间1, 时间2, 8)
.如果真 (剩余秒数A ＜ 0)
    剩余秒数A ＝ 剩余秒数A × -1
.如果真结束
剩余秒数B ＝ 剩余秒数A ％ 86400
剩余天 ＝ (剩余秒数A － 剩余秒数B) ÷ 86400
剩余秒数A ＝ 剩余秒数B
剩余秒数B ＝ 剩余秒数A ％ 3600
剩余小时 ＝ (剩余秒数A － 剩余秒数B) ÷ 3600
剩余秒数A ＝ 剩余秒数B
剩余秒数B ＝ 剩余秒数A ％ 60
剩余分钟 ＝ (剩余秒数A － 剩余秒数B) ÷ 60
剩余秒 ＝ 剩余秒数B
.如果真 (剩余天 ≠ 0)
    返回时间 ＝ 到文本 (剩余天) ＋ “天”
.如果真结束
.如果真 (剩余小时 ≠ 0)
    返回时间 ＝ 返回时间 ＋ 到文本 (剩余小时) ＋ “时”
.如果真结束
.如果真 (剩余分钟 ≠ 0)
    返回时间 ＝ 返回时间 ＋ 到文本 (剩余分钟) ＋ “分”
.如果真结束
.如果真 (剩余秒 ≠ 0)
    返回时间 ＝ 返回时间 ＋ 到文本 (剩余秒) ＋ “秒”
.如果真结束
返回 (返回时间)
.子程序 时间_转为GMT格式, 文本型, 公开, 将日期时间型数据转换为GMT格式 Greenwich Mean Time
.参数 待转换时间, 日期时间型
.局部变量 整数容器, 整数型
.局部变量 GMT时间, 文本型
整数容器 ＝ 取星期几 (待转换时间)
.判断开始 (整数容器 ＝ 1)
    GMT时间 ＝ “Sun, ”
.判断 (整数容器 ＝ 2)
    GMT时间 ＝ “Mon, ”
.判断 (整数容器 ＝ 3)
    GMT时间 ＝ “Tue, ”
.判断 (整数容器 ＝ 4)
    GMT时间 ＝ “Wed, ”
.判断 (整数容器 ＝ 5)
    GMT时间 ＝ “Thu, ”
.判断 (整数容器 ＝ 6)
    GMT时间 ＝ “Fri, ”
.判断 (整数容器 ＝ 7)
    GMT时间 ＝ “Sat, ”
.默认
.判断结束
GMT时间 ＝ GMT时间 ＋ 到文本 (取日 (待转换时间)) ＋ “-”
整数容器 ＝ 取月份 (待转换时间)
.判断开始 (整数容器 ＝ 1)
    GMT时间 ＝ GMT时间 ＋ “Jan” ＋ “-”
.判断 (整数容器 ＝ 2)
    GMT时间 ＝ GMT时间 ＋ “Feb” ＋ “-”
.判断 (整数容器 ＝ 3)
    GMT时间 ＝ GMT时间 ＋ “Mar” ＋ “-”
.判断 (整数容器 ＝ 4)
    GMT时间 ＝ GMT时间 ＋ “Apr” ＋ “-”
.判断 (整数容器 ＝ 5)
    GMT时间 ＝ GMT时间 ＋ “May” ＋ “-”
.判断 (整数容器 ＝ 6)
    GMT时间 ＝ GMT时间 ＋ “Jun” ＋ “-”
.判断 (整数容器 ＝ 7)
    GMT时间 ＝ GMT时间 ＋ “Jul” ＋ “-”
.判断 (整数容器 ＝ 8)
    GMT时间 ＝ GMT时间 ＋ “Aug” ＋ “-”
.判断 (整数容器 ＝ 9)
    GMT时间 ＝ GMT时间 ＋ “Sep” ＋ “-”
.判断 (整数容器 ＝ 10)
    GMT时间 ＝ GMT时间 ＋ “Oct” ＋ “-”
.判断 (整数容器 ＝ 11)
    GMT时间 ＝ GMT时间 ＋ “Nov” ＋ “-”
.判断 (整数容器 ＝ 12)
    GMT时间 ＝ GMT时间 ＋ “Dec” ＋ “-”
.默认
.判断结束
GMT时间 ＝ GMT时间 ＋ 到文本 (取年份 (待转换时间)) ＋ “ ” ＋ 到文本 (内部_补全 (取小时 (待转换时间))) ＋ “:” ＋ 到文本 (内部_补全 (取分钟 (待转换时间))) ＋ “:” ＋ 到文本 (内部_补全 (取秒 (待转换时间))) ＋ “ GMT”
返回 (GMT时间)
.子程序 内部_补全, 文本型
.参数 参_原数据, 整数型
.局部变量 局_新数据, 文本型
.如果真 (参_原数据 ＜ 10)
    局_新数据 ＝ “0” ＋ 到文本 (参_原数据)
    返回 (局_新数据)
.如果真结束
返回 (到文本 (参_原数据))
.子程序 时间_转为GMT格式1, 文本型, 公开, 感谢会员shituo提供代码，将日期时间型数据转换为GMT格式 Greenwich Mean Time
.参数 待转换时间, 日期时间型, 可空, 可为空，默认即现行时间。
.局部变量 GMT时间, 文本型
.局部变量 time, 精易_时间
.局部变量 Success, 逻辑型
.如果 (是否为空 (待转换时间))
    ' GetLocalTime (time)
    GetSystemTime (time)
.否则
    time.年 ＝ 取年份 (待转换时间)
    time.月 ＝ 取月份 (待转换时间)
    time.日 ＝ 取日 (待转换时间)
    time.时 ＝ 取小时 (待转换时间)
    time.分 ＝ 取分钟 (待转换时间)
    time.秒 ＝ 取秒 (待转换时间)
.如果结束
GMT时间 ＝ 取空白文本 (128)
Success ＝ InternetTimeFromSystemTime (time, 0, GMT时间, 128)
返回 (选择 (Success, GMT时间, “”))
.子程序 时间_转为GMT格式2, 文本型, 公开, 将日期时间型数据转换为GMT格式 Greenwich Mean Time
.参数 Time, 日期时间型, 可空, 可空，默认即现行时间。
.局部变量 Success, 逻辑型
.局部变量 pwszTimeStr, 字节集
.局部变量 sTime, 精易_时间
.局部变量 Retrun, 文本型
.如果 (是否为空 (Time))
    ' GetLocalTime (sTime)
    GetSystemTime (sTime)
.否则
    sTime.年 ＝ 取年份 (Time)
    sTime.月 ＝ 取月份 (Time)
    sTime.日 ＝ 取日 (Time)
    sTime.时 ＝ 取小时 (Time)
    sTime.分 ＝ 取分钟 (Time)
    sTime.秒 ＝ 取秒 (Time)
    sTime.星期 ＝ 取星期几 (Time)
.如果结束
pwszTimeStr ＝ 取空白字节集 (100)
Success ＝ WinHttpTimeFromSystemTime (sTime, pwszTimeStr)
Retrun ＝ 编码_Unicode到Ansi (pwszTimeStr)
返回 (Retrun)
.子程序 时间_转为GMT格式3, 文本型, 公开, 将日期时间型数据转换为GMT格式 Greenwich Mean Time
.参数 lpDateTime, 日期时间型, 可空
.局部变量 time, 精易_时间
.局部变量 lpDateStr, 文本型
.局部变量 lpTimeStr, 文本型
' 例程收录自：https://bbs.125.la/thread-14396648-1-1.html
.判断开始 (是否为空 (lpDateTime))
    GetSystemTime (time)
.判断 (VariantTimeToSystemTime (lpDateTime, time) ≠ 1)
    返回 (“”)
.默认
.判断结束
' Fri, 21 Jun 2019 09:18:38 GMT
lpDateStr ＝ 取空白文本 (50)
lpTimeStr ＝ 取空白文本 (24)
GetDateFormatA (#en_US, 0, time, “ddd, dd MMM yyyy”, lpDateStr, 50)
GetTimeFormatA (#en_US, 0, time, “HH:mm:ss GMT”, lpTimeStr, 24)
返回 (lpDateStr ＋ “ ” ＋ lpTimeStr)
.子程序 时间_GMT转为时间, 日期时间型, 公开, 感谢会员shituo提供代码，将GMT文本时间 转换成日期时间型
.参数 GMT时间, 文本型
.局部变量 stime, 精易_时间
.局部变量 DateFormat, 日期时间型
InternetTimeToSystemTime (GMT时间, stime, 0)
DateFormat ＝ 指定时间 (stime.年, stime.月, stime.日, stime.时, stime.分, stime.秒)
DateFormat ＝ 增减时间 (DateFormat, #小时, 8)
返回 (DateFormat)
.子程序 时间_GMT转为时间1, 日期时间型, 公开, 将GMT文本时间 转换成日期时间型
.参数 GMT时间, 文本型
.局部变量 Success, 逻辑型
.局部变量 pwszTimeStr, 字节集
.局部变量 sTime, 精易_时间
.局部变量 DateFormat, 日期时间型
pwszTimeStr ＝ 编码_Ansi到Unicode (GMT时间)
Success ＝ WinHttpTimeToSystemTime (pwszTimeStr, sTime)
DateFormat ＝ 指定时间 (sTime.年, sTime.月, sTime.日, sTime.时, sTime.分, sTime.秒)
DateFormat ＝ 增减时间 (DateFormat, #小时, 8)
返回 (DateFormat)
.子程序 时间_取现行时间戳, 文本型, 公开, 生成一个13位或者10位的现行时间戳，默认生成13位时间戳。13位：1325252169718，10位：1325252169
.参数 是否取十位时间戳, 逻辑型, 可空, 本参数为真时，将生成10位时间戳返回
.局部变量 时间b, 精易_时间
.局部变量 返回值, 文本型
.局部变量 毫秒数, 文本型
.局部变量 时间a, 文本型
GetLocalTime (时间b)
毫秒数 ＝ 取重复文本 (3 － 取文本长度 (到文本 (时间b.毫)), “0”) ＋ 到文本 (时间b.毫)
时间a ＝ 到文本 (取时间间隔 (取现行时间 (), 到时间 (“1970-01-01 08:00:00”), #秒))
返回值 ＝ 时间a ＋ 毫秒数
' 返回值 ＝ 选择 (是否取十位时间戳, 取文本左边 (时间a ＋ 毫秒数, 10), 时间a ＋ 毫秒数)
.判断开始 (是否取十位时间戳)
    返回值 ＝ 取文本左边 (返回值, 10)
    .判断循环首 (取文本长度 (返回值) ＜ 10)
        返回值 ＝ 返回值 ＋ “0”
    .判断循环尾 ()
    返回 (返回值)
.默认
    .判断循环首 (取文本长度 (返回值) ＜ 13)
        返回值 ＝ 返回值 ＋ “0”
    .判断循环尾 ()
    返回 (返回值)
.判断结束
.子程序 时间_取现行时间戳1, 长整数型, 公开, 生成一个10位或者13位的现行时间戳
.参数 精确到毫秒, 逻辑型, 可空, 默认为假 精确到秒10位数 精确到毫秒13位数
.局部变量 ret, 长整数型
' https://bbs.125.la/forum.php?mod=viewthread&tid=14649396
GetSystemTimeAsFileTime (取指针地址_长整数型 (ret))
ret ＝ FileTimeToUnixTime (ret)
.如果 (精确到毫秒)
    ret ＝ ret ÷ 10000
.否则
    ret ＝ ret ÷ 10000000
.如果结束
返回 (ret)
.子程序 时间_取北京时间戳, 文本型, 公开, 生成一个13位或者10位的北京时间戳，默认生成13位时间戳。13位：1325252169718，10位：1325252169。使用网站：【http://www.114time.com/】接口。
.参数 是否取十位时间戳, 逻辑型, 可空, 本参数为真时，将生成10位时间戳返回
.局部变量 局_时间, 日期时间型
局_时间 ＝ 时间_取北京时间 ()
返回 (时间_到时间戳 (局_时间, 是否取十位时间戳, ))
.子程序 时间_取北京时间, 日期时间型, 公开, 获取北京时间，超稳定，长久不失效，代码提供者：aqwvwv
.参数 参_网址, 文本型, 可空
.局部变量 局_返回协议头, 文本型
.局部变量 局_时间, 日期时间型
.如果真 (是否为空 (参_网址))
    参_网址 ＝ “http://www.baidu.com/”
.如果真结束
网页_访问_对象 (参_网址, 2, , , , , 局_返回协议头, , , , , , , , , , , , )
局_返回协议头 ＝ 文本_取出中间文本 (局_返回协议头, “Date:”, #换行符)
局_时间 ＝ 时间_GMT转为时间 (局_返回协议头)
返回 (局_时间)
.子程序 时间_到时间戳, 文本型, 公开, 把指定日期时间转换为10位或13位时间戳,默认生成13位时间戳。13位：1325252169718，10位：1325252169
.参数 参_时间, 日期时间型, 可空, 可为空，默认为现行时间
.参数 参_十位时间戳, 逻辑型, 可空, 本参数为真时，将生成10位时间戳返回
.参数 参_是否取满10位, 逻辑型, 可空, 如果参数为真，则保证一定取出至少10位，如果不足10位，在前面补0. 如果为假，则直接取出
.局部变量 局_时间, 精易_时间
.局部变量 返回值, 文本型
.局部变量 毫秒数, 文本型
.局部变量 时间a, 文本型
参_时间 ＝ 选择 (是否为空 (参_时间), 取现行时间 (), 参_时间)
VariantTimeToSystemTime (参_时间, 局_时间)
毫秒数 ＝ 取重复文本 (3 － 取文本长度 (到文本 (局_时间.毫)), “0”) ＋ 到文本 (局_时间.毫)
时间a ＝ 到文本 (取时间间隔 (参_时间, 到时间 (“1970-01-01 08:00:00”), #秒))
.如果真 (参_是否取满10位)
    .如果真 (取文本长度 (时间a) ＜ 10)
        时间a ＝ 取重复文本 (10 － 取文本长度 (时间a), “0”) ＋ 时间a
    .如果真结束
.如果真结束
返回 (选择 (参_十位时间戳, 取文本左边 (时间a, 10), 时间a ＋ 毫秒数))
.子程序 时间_取随机时间戳, 文本型, 公开, 生成一个随机的时间戳。如：0.842703761170252
.局部变量 VBscript, 对象
.局部变量 局_文本, 文本型
线程_初始化COM库 ()
VBscript.创建 (“ScriptControl”, )
VBscript.写属性 (“Language”, “JScript”)
VBscript.数值方法 (“ExecuteStatement”, “function time(){return Math.random()}”)
.判断循环首 (取文本长度 (局_文本) ≠ 17)
    局_文本 ＝ VBscript.通用方法 (“Run”, “time”, ).取文本 ()
    .如果真 (取文本左边 (局_文本, 1) ≠ “0”)
        局_文本 ＝ “0” ＋ 局_文本
    .如果真结束
    系统_处理事件 ()
.判断循环尾 ()
VBscript.清除 ()
线程_取消COM库 ()
返回 (局_文本)
.子程序 时间_时间戳转文本, 文本型, 公开, 把一个13位的时间戳，如：1325252169718 转成 2011-12-30 21:36:09
.参数 时间戳, 文本型
.局部变量 VBscript, 对象
.局部变量 局_文本, 文本型
.局部变量 局_数组, 文本型, , "0"
.局部变量 局_时间, 日期时间型
CoInitialize (0)
.如果 (取文本长度 (时间戳) ＝ 10)
    局_时间 ＝ 增减时间 (到时间 (“1970.01.01 08:00:00”), #秒, 到整数 (时间戳))
    返回 (选择 (时间_取制式 () ＝ 0, 时间_格式化 (局_时间, “yyyy-MM-dd ”, “hh:mm:ss”, ), 时间_格式化 (局_时间, “yyyy-MM-dd ”, “HH:mm:ss”, )))
.否则
    .如果真 (VBscript.创建 (“ScriptControl”, ))
        VBscript.写属性 (“Language”, “JScript”)
        VBscript.数值方法 (“ExecuteStatement”, “function timea(){var d,s;d=new Date();d.setTime('” ＋ 时间戳 ＋ “');return(d);}”)
        局_文本 ＝ VBscript.通用方法 (“Run”, “timea”, ).取文本 ()
        VBscript.清除 ()
        CoUninitialize ()
        .如果真 (取文本长度 (局_文本) ＞ 0)
            局_数组 ＝ 分割文本 (局_文本, “ ”, )
            .如果真 (取数组成员数 (局_数组) ≥ 6)
                .判断开始 (局_数组 [2] ＝ “Jan”)
                    局_数组 [2] ＝ “1”
                .判断 (局_数组 [2] ＝ “Feb”)
                    局_数组 [2] ＝ “2”
                .判断 (局_数组 [2] ＝ “Mar”)
                    局_数组 [2] ＝ “3”
                .判断 (局_数组 [2] ＝ “Apr”)
                    局_数组 [2] ＝ “4”
                .判断 (局_数组 [2] ＝ “May”)
                    局_数组 [2] ＝ “5”
                .判断 (局_数组 [2] ＝ “Jun”)
                    局_数组 [2] ＝ “6”
                .判断 (局_数组 [2] ＝ “Jul”)
                    局_数组 [2] ＝ “7”
                .判断 (局_数组 [2] ＝ “Aug”)
                    局_数组 [2] ＝ “8”
                .判断 (局_数组 [2] ＝ “Sep”)
                    局_数组 [2] ＝ “9”
                .判断 (局_数组 [2] ＝ “Oct”)
                    局_数组 [2] ＝ “10”
                .判断 (局_数组 [2] ＝ “Nov”)
                    局_数组 [2] ＝ “11”
                .判断 (局_数组 [2] ＝ “Dec”)
                    局_数组 [2] ＝ “12”
                .默认
                .判断结束
                返回 (局_数组 [6] ＋ “-” ＋ 局_数组 [2] ＋ “-” ＋ 局_数组 [3] ＋ “ ” ＋ 局_数组 [4])
            .如果真结束
        .如果真结束
    .如果真结束
.如果结束
返回 (“”)
.子程序 时间_取公历节日, 文本型, 公开, 根据公历年月日,返回公历的节日,某些节日需要有年代才能确定是星期几.
.参数 公历年, 整数型, 可空
.参数 公历月, 整数型, 可空
.参数 公历日, 整数型, 可空
.局部变量 节日文本, 文本型
.局部变量 星期几, 整数型
星期几 ＝ 取星期几 (到时间 (到文本 (公历年) ＋ “年” ＋ 到文本 (公历月) ＋ “月” ＋ 到文本 (公历日) ＋ “日”))
节日文本 ＝ “”
.如果真 (公历月 ＝ 1 且 公历日 ＝ 1)
    节日文本 ＝ “元旦”
.如果真结束
.如果真 (公历月 ＝ 2 且 公历日 ＝ 14)
    节日文本 ＝ “情人节”
.如果真结束
.如果真 (公历月 ＝ 3 且 公历日 ＝ 5)
    节日文本 ＝ “雷峰纪念日”
.如果真结束
.如果真 (公历月 ＝ 3 且 公历日 ＝ 8)
    节日文本 ＝ “国际劳动妇女节”
.如果真结束
.如果真 (公历月 ＝ 3 且 公历日 ＝ 12)
    节日文本 ＝ “植树节”
.如果真结束
.如果真 (公历月 ＝ 3 且 公历日 ＝ 15)
    节日文本 ＝ “国际消费者权益日”
.如果真结束
.如果真 (公历月 ＝ 3 且 公历日 ＝ 23)
    节日文本 ＝ “国际气象日”
.如果真结束
.如果真 (公历月 ＝ 3 且 公历日 ＝ 31)
    节日文本 ＝ “安全教育日”
.如果真结束
.如果真 (公历月 ＝ 4 且 公历日 ＝ 1)
    节日文本 ＝ “愚人节”
.如果真结束
.如果真 (公历月 ＝ 4 且 公历日 ＝ 7)
    节日文本 ＝ “世界卫生日”
.如果真结束
.如果真 (公历月 ＝ 4 且 公历日 ＝ 22)
    节日文本 ＝ “世界地球日”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 1)
    节日文本 ＝ “国际劳动节”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 4)
    节日文本 ＝ “青年节”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 8)
    节日文本 ＝ “世界红十字日”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 12)
    节日文本 ＝ “国际护士节”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 15)
    节日文本 ＝ “国际家庭日”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 16)
    节日文本 ＝ “全国助残日”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 17)
    节日文本 ＝ “国际电信日”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＝ 31)
    节日文本 ＝ “世界无烟日”
.如果真结束
.如果真 (公历月 ＝ 6 且 公历日 ＝ 1)
    节日文本 ＝ “国际儿童节”
.如果真结束
.如果真 (公历月 ＝ 6 且 公历日 ＝ 5)
    节日文本 ＝ “国际环境保护日”
.如果真结束
.如果真 (公历月 ＝ 6 且 公历日 ＝ 6)
    节日文本 ＝ “全国爱眼日”
.如果真结束
.如果真 (公历月 ＝ 6 且 公历日 ＝ 25)
    节日文本 ＝ “全国土地日”
.如果真结束
.如果真 (公历月 ＝ 6 且 公历日 ＝ 26)
    节日文本 ＝ “国际禁毒日”
.如果真结束
.如果真 (公历月 ＝ 7 且 公历日 ＝ 1)
    节日文本 ＝ “党的生日、香港回归日”
.如果真结束
.如果真 (公历月 ＝ 7 且 公历日 ＝ 7)
    节日文本 ＝ “抗日战争胜利日”
.如果真结束
.如果真 (公历月 ＝ 7 且 公历日 ＝ 11)
    节日文本 ＝ “世界人口日”
.如果真结束
.如果真 (公历月 ＝ 8 且 公历日 ＝ 1)
    节日文本 ＝ “中国建军节”
.如果真结束
.如果真 (公历月 ＝ 8 且 公历日 ＝ 8)
    节日文本 ＝ “父亲节”
.如果真结束
.如果真 (公历月 ＝ 9 且 公历日 ＝ 8)
    节日文本 ＝ “国际扫盲日”
.如果真结束
.如果真 (公历月 ＝ 9 且 公历日 ＝ 9)
    节日文本 ＝ “毛泽东逝世”
.如果真结束
.如果真 (公历月 ＝ 9 且 公历日 ＝ 10)
    节日文本 ＝ “中国教师节”
.如果真结束
.如果真 (公历月 ＝ 9 且 公历日 ＝ 20)
    节日文本 ＝ “中国爱牙日”
.如果真结束
.如果真 (公历月 ＝ 9 且 公历日 ＝ 27)
    节日文本 ＝ “世界旅游日”
.如果真结束
.如果真 (公历月 ＝ 9 且 公历日 ＝ 28)
    节日文本 ＝ “世界聋人日、孔子诞辰”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 1)
    节日文本 ＝ “世界音乐日、国庆节”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 4)
    节日文本 ＝ “世界动物日”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 6)
    节日文本 ＝ “老人节”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 8)
    节日文本 ＝ “全国高血压日”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 9)
    节日文本 ＝ “世界邮政日”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 14)
    节日文本 ＝ “世界标准日”
.如果真结束
.如果真 (公历月 ＝ 10 且 公历日 ＝ 24)
    节日文本 ＝ “联合国日”
.如果真结束
.如果真 (公历月 ＝ 11 且 公历日 ＝ 1)
    节日文本 ＝ “万圣节”
.如果真结束
.如果真 (公历月 ＝ 11 且 公历日 ＝ 2)
    节日文本 ＝ “万灵节”
.如果真结束
.如果真 (公历月 ＝ 11 且 公历日 ＝ 12)
    节日文本 ＝ “孙中山诞辰”
.如果真结束
.如果真 (公历月 ＝ 11 且 公历日 ＝ 17)
    节日文本 ＝ “国际学生日”
.如果真结束
.如果真 (公历月 ＝ 12 且 公历日 ＝ 5)
    节日文本 ＝ “国际志愿人员日”
.如果真结束
.如果真 (公历月 ＝ 12 且 公历日 ＝ 20)
    节日文本 ＝ “澳门回归”
.如果真结束
.如果真 (公历月 ＝ 12 且 公历日 ＝ 25)
    节日文本 ＝ “圣诞节”
.如果真结束
.如果真 (公历月 ＝ 12 且 公历日 ＝ 26)
    节日文本 ＝ “毛泽东诞辰”
.如果真结束
.如果真 (公历月 ＝ 5 且 公历日 ＞ 7 且 公历日 ＜ 15 且 星期几 ＝ 1)
    节日文本 ＝ “母亲节”
.如果真结束
.如果真 (公历月 ＝ 6 且 公历日 ＞ 14 且 公历日 ＜ 22 且 星期几 ＝ 1)
    节日文本 ＝ “父亲节”
.如果真结束
.如果真 (公历月 ＝ 11 且 公历日 ＞ 21 且 星期几 ＝ 1)
    节日文本 ＝ “感恩节”
.如果真结束
返回 (节日文本)
.子程序 时间_取节气文本, 文本型, 公开, 立春,雨水,惊蛰,春分,清明,谷雨；立夏,小满,芒种,夏至,小暑,大暑；立秋,处暑,白露,秋分,寒露,霜降；立冬,小雪,大雪,冬至,小寒,大寒
.参数 节气顺序, 整数型, , 根据24个节气返回节气名称.
.判断开始 (节气顺序 ＝ 1)
    返回 (“立春”)
.判断 (节气顺序 ＝ 2)
    返回 (“雨水”)
.判断 (节气顺序 ＝ 3)
    返回 (“惊蛰”)
.判断 (节气顺序 ＝ 4)
    返回 (“春分”)
.判断 (节气顺序 ＝ 5)
    返回 (“清明”)
.判断 (节气顺序 ＝ 6)
    返回 (“谷雨”)
.判断 (节气顺序 ＝ 7)
    返回 (“立夏”)
.判断 (节气顺序 ＝ 8)
    返回 (“小满”)
.判断 (节气顺序 ＝ 9)
    返回 (“芒种”)
.判断 (节气顺序 ＝ 10)
    返回 (“夏至”)
.判断 (节气顺序 ＝ 11)
    返回 (“小暑”)
.判断 (节气顺序 ＝ 12)
    返回 (“大暑”)
.判断 (节气顺序 ＝ 13)
    返回 (“立秋”)
.判断 (节气顺序 ＝ 14)
    返回 (“处暑”)
.判断 (节气顺序 ＝ 15)
    返回 (“白露”)
.判断 (节气顺序 ＝ 16)
    返回 (“秋分”)
.判断 (节气顺序 ＝ 17)
    返回 (“寒露”)
.判断 (节气顺序 ＝ 18)
    返回 (“霜降”)
.判断 (节气顺序 ＝ 19)
    返回 (“立冬”)
.判断 (节气顺序 ＝ 20)
    返回 (“小雪”)
.判断 (节气顺序 ＝ 21)
    返回 (“大雪”)
.判断 (节气顺序 ＝ 22)
    返回 (“冬至”)
.判断 (节气顺序 ＝ 23)
    返回 (“小寒”)
.判断 (节气顺序 ＝ 24)
    返回 (“大寒”)
.默认
    返回 (“”)
.判断结束
.子程序 时间_取美式日期, 文本型, 公开, 转换日期时间表达为美式表达方式
.参数 日期时间, 日期时间型
.局部变量 日期, 日期时间型
.局部变量 美式日期, 文本型
日期 ＝ 日期时间
美式日期 ＝ 到文本 (取年份 (日期))
美式日期 ＝ 美式日期 ＋ “/” ＋ 到文本 (取月份 (日期))
美式日期 ＝ 美式日期 ＋ “/” ＋ 到文本 (取日 (日期))
返回 (美式日期)
.子程序 时间_取农历节日, 文本型, 公开, 取农历所对应该的节日，需要事先知道农历日期的月份，与日子，
.参数 农历月份, 整数型
.参数 农历天数, 整数型
.局部变量 节日文本, 文本型
节日文本 ＝ “”
.如果真 (农历月份 ＝ 1 且 农历天数 ＝ 1)
    节日文本 ＝ “春节”
.如果真结束
.如果真 (农历月份 ＝ 1 且 农历天数 ＝ 15)
    节日文本 ＝ “元宵节”
.如果真结束
.如果真 (农历月份 ＝ 2 且 农历天数 ＝ 2)
    节日文本 ＝ “中和节”
.如果真结束
.如果真 (农历月份 ＝ 5 且 农历天数 ＝ 5)
    节日文本 ＝ “端午节”
.如果真结束
.如果真 (农历月份 ＝ 7 且 农历天数 ＝ 7)
    节日文本 ＝ “七巧节”
.如果真结束
.如果真 (农历月份 ＝ 8 且 农历天数 ＝ 15)
    节日文本 ＝ “中秋节”
.如果真结束
.如果真 (农历月份 ＝ 9 且 农历天数 ＝ 9)
    节日文本 ＝ “重阳节”
.如果真结束
.如果真 (农历月份 ＝ 12 且 农历天数 ＝ 8)
    节日文本 ＝ “腊八节”
.如果真结束
.如果真 (农历月份 ＝ 12 且 农历天数 ＝ 24)
    节日文本 ＝ “小年”
.如果真结束
返回 (节日文本)
.子程序 时间_取身份证比较, 逻辑型, 公开, 对身份证号和一个日期进行比较,看两者是否一致
.参数 身份证号, 文本型
.参数 比较日期, 日期时间型
.局部变量 长度, 整数型
长度 ＝ 取文本长度 (身份证号)
.如果真 (长度 ＝ 15)
    .如果 (到数值 (“19” ＋ 取文本中间 (身份证号, 7, 2)) ＝ 取年份 (比较日期) 且 到数值 (取文本中间 (身份证号, 9, 2)) ＝ 取月份 (比较日期) 且 到数值 (取文本中间 (身份证号, 11, 2)) ＝ 取日 (比较日期))
        返回 (真)
    .否则
        返回 (假)
    .如果结束
.如果真结束
.如果真 (长度 ＝ 18)
    .如果 (到数值 (取文本中间 (身份证号, 7, 4)) ＝ 取年份 (比较日期) 且 到数值 (取文本中间 (身份证号, 11, 2)) ＝ 取月份 (比较日期) 且 到数值 (取文本中间 (身份证号, 13, 2)) ＝ 取日 (比较日期))
        返回 (真)
    .否则
        返回 (假)
    .如果结束
.如果真结束
返回 (假)
.子程序 时间_取中国星期几, 文本型, 公开, 返回一个星期文本
.参数 目标时间, 日期时间型, 可空, 如果星期数不为零,本参数不处理,否则将本参数内的时间进行处理.
.局部变量 星期数, 整数型, , , 如果空或为零时取下面时间的返回星期几
目标时间 ＝ 选择 (是否为空 (目标时间), 取现行时间 (), 目标时间)
星期数 ＝ 取星期几 (目标时间)
返回 (多项选择 (星期数, “星期日”, “星期一”, “星期二”, “星期三”, “星期四”, “星期五”, “星期六”))
.子程序 时间_取身份证日期, 文本型, 公开, 取一个身份证号中的出生日期,在本程序前对身份证是否正确进行简单判断,应该用真正的判断程序进行判断
.参数 身份证号, 文本型
.局部变量 长度, 整数型
长度 ＝ 取文本长度 (身份证号)
.如果真 (长度 ＝ 15)
    返回 (“19” ＋ 取文本中间 (身份证号, 7, 6))
.如果真结束
.如果真 (长度 ＝ 18)
    返回 (取文本中间 (身份证号, 7, 8))
.如果真结束
返回 (“”)
.子程序 时间_取身份证性别, 文本型, 公开, 判断身份证的性别
.参数 身份证号, 文本型
.局部变量 长度, 整数型
长度 ＝ 取文本长度 (身份证号)
.如果真 (长度 ＝ 15)
    .如果 (到数值 (取文本中间 (身份证号, 15, 1)) ％ 2 ＝ 1)
        返回 (“男”)
    .否则
        返回 (“女”)
    .如果结束
.如果真结束
.如果真 (长度 ＝ 18)
    .如果 (到数值 (取文本中间 (身份证号, 17, 1)) ％ 2 ＝ 1)
        返回 (“男”)
    .否则
        返回 (“女”)
    .如果结束
.如果真结束
返回 (“身份证有误”)
.子程序 时间_取身份证判断, 逻辑型, 公开, 判断身份证号是否正确，检测1900年到2030年中15位或18位身份证，正确返回真，错误返回假。
.参数 身份证号, 文本型
.局部变量 长度, 整数型
.局部变量 局_年
.局部变量 局_月
.局部变量 局_日
.局部变量 局_乘数, 整数型, , "0"
.局部变量 局_计次
.局部变量 和, 整数型
长度 ＝ 取文本长度 (身份证号)
.如果真 (长度 ＝ 15 或 长度 ＝ 18)
    .如果真 (长度 ＝ 15)
        .如果真 (到数值 (取文本中间 (身份证号, 9, 2)) ≥ 13 或 到数值 (取文本中间 (身份证号, 9, 2)) ＝ 0)
            ' 输出调试文本 (取文本中间 (身份证号, 9, 2))
            返回 (假)  ' 月份大于12个月3201057302
        .如果真结束
        .如果真 (到数值 (取文本中间 (身份证号, 11, 2)) ≥ 32 或 到数值 (取文本中间 (身份证号, 11, 2)) ＝ 0)
            ' 输出调试文本 (取文本中间 (身份证号, 11, 2))
            返回 (假)  ' 日子大于32天
        .如果真结束
        返回 (真)
    .如果真结束
    .如果真 (长度 ＝ 18)
        局_年 ＝ 到数值 (取文本中间 (身份证号, 7, 4))
        .如果真 (局_年 ≤ 1900 或 局_年 ≥ 2030)
            ' 输出调试文本 (取文本中间 (身份证号, 9, 2))
            返回 (假)  ' 年份小于1900年,大于2030年
        .如果真结束
        局_月 ＝ 到数值 (取文本中间 (身份证号, 11, 2))
        .如果真 (局_月 ≥ 13 或 局_月 ＝ 0)
            ' 输出调试文本 (取文本中间 (身份证号, 11, 2))
            返回 (假)  ' 月份大于12个月
        .如果真结束
        局_日 ＝ 到数值 (取文本中间 (身份证号, 13, 2))
        .如果真 (局_日 ≥ 32 或 局_日 ＝ 0)
            ' 输出调试文本 (取文本中间 (身份证号, 13, 2))
            返回 (假)  ' 日子大于32天
        .如果真结束
        ' 校验码计算公式 由易友【小爬虫】提供。
        局_乘数 ＝ { 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 }
        .计次循环首 (17, 局_计次)
            和 ＝ 和 ＋ 到整数 (取文本中间 (身份证号, 局_计次, 1)) × 局_乘数 [局_计次]
        .计次循环尾 ()
        和 ＝ 和 ％ 11
        返回 (多项选择 (和 ＋ 1, “1”, “0”, “x”, “9”, “8”, “7”, “6”, “5”, “4”, “3”, “2”) ＝ 到小写 (取文本右边 (身份证号, 1)))
    .如果真结束
.如果真结束
返回 (假)
.子程序 时间_身份证号转换, 文本型, 公开, 从15位转换到18位身份证号
.参数 身份证号, 文本型
.局部变量 加权因子, 整数型, , "17"
.局部变量 校验码串, 文本型, , "11"
.局部变量 位, 文本型
.局部变量 累加, 整数型
.局部变量 校验码, 文本型
.局部变量 计数, 整数型
.局部变量 长度, 整数型
加权因子 ＝ { 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 }
校验码串 ＝ { “1”, “0”, “X”, “9”, “8”, “7”, “6”, “5”, “4”, “3”, “2” }
长度 ＝ 取文本长度 (身份证号)
.如果真 (长度 ≠ 18)
    .如果真 (长度 ≠ 15)
        返回 (“”)  ' 信息框 (“身份证号码长度非法！”, #错误图标, )
    .如果真结束
.如果真结束
.如果真 (长度 ＝ 15)
    身份证号 ＝ 取文本左边 (身份证号, 6) ＋ “19” ＋ 取文本右边 (身份证号, 9)
.如果真结束
.计次循环首 (17, 计数)
    位 ＝ 取文本中间 (身份证号, 计数, 1)
    累加 ＝ 累加 ＋ 到数值 (位) × 加权因子 [计数]
.计次循环尾 ()
校验码 ＝ 校验码串 [累加 ％ 11 ＋ 1]
身份证号 ＝ 取文本左边 (身份证号, 17) ＋ 校验码
返回 (身份证号)
.子程序 时间_到文本, 文本型, 公开, 返回文本格式的现行时间，如：2005053107123
.参数 操作时间, 日期时间型, 可空, 可空。留空为现行时间
.参数 输出格式, 整数型, 可空, 可空。0=N年N月N日 N时N分N秒  1=年-月-日 时:分:秒  2=年/月/日 时/分/秒  3=年月日时分秒
.参数 取出类型, 整数型, 可空, 可空。留空为全部，1=只取年月日，2=取月日，3=只取时分秒，4=时分，5=分秒
.局部变量 局_日期格式, 文本型
.局部变量 局_时间格式, 文本型
.局部变量 局_格式, 文本型
.局部变量 局_制式, 整数型
操作时间 ＝ 选择 (是否为空 (操作时间), 取现行时间 (), 操作时间)
输出格式 ＝ 选择 (输出格式 ≥ 0 且 输出格式 ≤ 3, 输出格式, 0)
局_日期格式 ＝ 多项选择 (输出格式 ＋ 1, “yyyy年MM月dd日 ”, “yyyy-MM-dd ”, “yyyy/MM/dd ”, “yyyyMMdd”)
局_日期格式 ＝ 选择 (取出类型 ≥ 3 且 取出类型 ≤ 5, “”, 局_日期格式)
局_时间格式 ＝ 多项选择 (输出格式 ＋ 1, “hh时mm分ss秒”, “hh:mm:ss”, “hh/mm/ss”, “hhmmss”)
局_时间格式 ＝ 选择 (取出类型 ≥ 1 且 取出类型 ≤ 2, “”, 局_时间格式)
.如果真 (取出类型 ＝ 1)
    局_日期格式 ＝ 删首尾空 (局_日期格式)
.如果真结束
.如果真 (取出类型 ＝ 2)
    局_日期格式 ＝ 多项选择 (输出格式 ＋ 1, “MM月dd日”, “MM-dd”, “MM/dd”, “MMdd”)
.如果真结束
.如果真 (取出类型 ＝ 4)
    局_时间格式 ＝ 多项选择 (输出格式 ＋ 1, “hh时mm分”, “hh:mm”, “hh/mm”, “hhmm”)
.如果真结束
.如果真 (取出类型 ＝ 5)
    局_时间格式 ＝ 多项选择 (输出格式 ＋ 1, “mm分ss秒”, “mm:ss”, “mm/ss”, “mmss”)
.如果真结束
局_制式 ＝ 时间_取制式 ()
局_时间格式 ＝ 选择 (局_制式 ＝ 1, 子文本替换 (局_时间格式, “hh”, “HH”, , , 真), 局_时间格式)
局_格式 ＝ 时间_格式化 (操作时间, 局_日期格式, 局_时间格式)
返回 (局_格式)
.子程序 时间_身份证号15到18, 文本型, 公开, 将15位身份证转换为18位
.参数 身份证号15, 文本型
.局部变量 计数, 整数型
.局部变量 加权因子, 整数型
.局部变量 加权码, 文本型
.局部变量 转换后号, 文本型
转换后号 ＝ 取文本左边 (身份证号15, 6) ＋ “19” ＋ 取文本右边 (身份证号15, 9)
.变量循环首 (18, 2, -1, 计数)
    加权因子 ＝ 加权因子 ＋ (求次方 (2, 计数 － 1) ％ 11) × 到数值 (取文本中间 (转换后号, 19 － 计数, 1))
.变量循环尾 ()
加权因子 ＝ 加权因子 ％ 11
.判断开始 (加权因子 ＝ 0)
    加权码 ＝ “1”
.判断 (加权因子 ＝ 1)
    加权码 ＝ “0”
.判断 (加权因子 ＝ 2)
    加权码 ＝ “X”
.默认
    加权码 ＝ 删首尾空 (到文本 (12 － 加权因子))
.判断结束
返回 (转换后号 ＋ 加权码)
.子程序 时间_北京转格林威治, 长整数型, 公开, 将【北京标准时间】转换成【格林威治的标准时间】，13位的时间戳可用“时间_取现行时间戳（）”获得
.参数 欲转换的时间, 日期时间型, 可空, 如果为空则取当前时间，如: 1970-01-01 08:00:00 或 2009年2月9日12时36分36秒
.如果真 (是否为空 (欲转换的时间))
    欲转换的时间 ＝ 取现行时间 ()
.如果真结束
返回 (取时间间隔 (欲转换的时间, [1970年1月1日8时], #秒))
.子程序 时间_格林威治转北京, 日期时间型, 公开, 将【格林威治的标准时间】转换成【北京标准时间】,源码修改至官方用户
.参数 要转换的格林威治时间, 长整数型, , 要转换的格林威治时间
.局部变量 time, 日期时间型
.局部变量 待转数据, 整数型
.局部变量 局_时间, 整数型
time ＝ 指定时间 (1970, 1, 1, 8, 0, 0)
局_时间 ＝ 取文本长度 (到文本 (要转换的格林威治时间))
.如果 (局_时间 ≠ 10)
    待转数据 ＝ 到整数 (取文本左边 (到文本 (要转换的格林威治时间), 10))
.否则
    待转数据 ＝ 要转换的格林威治时间
.如果结束
返回 (增减时间 (time, #秒, 待转数据))
.子程序 FileTimeToUnixTime, 长整数型
.参数 FlieTime, 长整数型
.局部变量 ll, 长整数型
ll ＝ FlieTime － 1.16444736e+017
返回 (ll)
.子程序 UnixTimeToFileTime, 长整数型
.参数 UnixTime, 长整数型
.局部变量 ll, 长整数型
.局部变量 位数, 整数型
.局部变量 乘数, 整数型
位数 ＝ 取整数位数 (UnixTime)
乘数 ＝ 1
.计次循环首 (17 － 位数, )
    乘数 ＝ 乘数 × 10
.计次循环尾 ()
ll ＝ UnixTime × 乘数 ＋ 1.16444736e+017
返回 (ll)
.子程序 取整数位数, 整数型
.参数 长整数, 长整数型
.局部变量 n, 整数型
.局部变量 l, 长整数型
l ＝ 长整数
n ＝ 1
.循环判断首 ()
    l ＝ l ÷ 10
    .如果 (l ≥ 1)
        n ＝ n ＋ 1
    .否则
        跳出循环 ()
    .如果结束
.循环判断尾 (l ≥ 1)
返回 (n)
.子程序 时间_WMI时间转日期, 日期时间型, 公开, 失败返回  [100年1月1日]
.参数 WMI数据时间, 文本型, , 如“20140926001639.000000+480”
.局部变量 局_时间对象, 对象
.局部变量 局_返回时间, 日期时间型
CoInitialize (0)
.如果 (局_时间对象.创建 (“WbemScripting.SWbemDateTime”, ))
    局_时间对象.写属性 (“Value”, WMI数据时间)
    局_返回时间 ＝ 局_时间对象.日期方法 (“GetVarDate”, )
    局_时间对象.清除 ()
.否则
    局_返回时间 ＝ 到时间 (0)
.如果结束
CoUninitialize ()
返回 (局_返回时间)
.子程序 时间_格式化, 文本型, 公开, 格式化指定日期与时间，失败返回空文本   GetTimeFormatA 该函数支持的最早时间是1600.1.1
.参数 参_欲格式化时间, 日期时间型
.参数 参_日期格式, 文本型, 可空, 可以为空，格式：yyyy [年]，M [月],d [日],dddd [星期]，如;yyyy/M/d dddd(年/月/日 星期几)
.参数 参_时间格式, 文本型, 可空, 可以为空，格式：tt [上午或下午],h [小时],m [分钟], s [秒] 。如;hh:mm:ss(小时:分钟:秒),tt hh:mm:ss(上午或下午 小时:分钟:秒)
.参数 参_是否为24小时制, 逻辑型, 可空
.局部变量 局_系统时间, 精易_时间
.局部变量 局_整数返回, 整数型
.局部变量 局_日期, 文本型
.局部变量 局_时间, 文本型
.局部变量 局_Flags, 整数型
.如果真 (是否为空 (参_日期格式) 且 是否为空 (参_时间格式))
    输出调试文本 (“日期格式和时间格式不能同时为空！请至少提供一个参数。”)
    返回 (“”)
.如果真结束
局_整数返回 ＝ VariantTimeToSystemTime (参_欲格式化时间, 局_系统时间)
.如果真 (1 ＝ 局_整数返回)
    .如果真 (取文本长度 (参_日期格式) ＞ 2)
        局_日期 ＝ 取空白文本 (50)
        GetDateFormatA (0, 0, 局_系统时间, 参_日期格式, 局_日期, 50)
    .如果真结束
    .如果真 (取文本长度 (参_时间格式) ＞ 2)
        局_时间 ＝ 取空白文本 (50)
        .如果真 (参_是否为24小时制 ＝ 真)
            局_Flags ＝ #TIME_FORCE24HOURFORMAT
        .如果真结束
        GetTimeFormatA (0, 局_Flags, 局_系统时间, 参_时间格式, 局_时间, 50)
    .如果真结束
    返回 (局_日期 ＋ 局_时间)
.如果真结束
返回 (“”)
.子程序 时间_格式化EX, 文本型, 公开, 将易语言中默认获取到的含有汉字的时间格式化为不含汉字的时间，源码由雪山凌狐提供
.参数 未格式化时间, 日期时间型, , 使用易语言自带命令：取现行时间()等获取到的含汉字的时间
.参数 日期间间隔, 文本型, 可空, 默认为“-”
.参数 时间间间隔, 文本型, 可空, 默认为“:”
.参数 返回模式, 整数型, 可空, 模式1为只返回时间（时分秒），模式为2为只返回日期（年月日），模式3为两者都返回，模式4为都返回，但日期与时间之间没有空格。如果为空，默认为1，如果不符合要求，返回为空
.局部变量 格式化后时间, 文本型
.局部变量 年份, 文本型
.局部变量 月份, 文本型
.局部变量 日, 文本型
.局部变量 小时, 文本型
.局部变量 分钟, 文本型
.局部变量 秒, 文本型
.如果真 (是否为空 (日期间间隔))
    日期间间隔 ＝ “-”
.如果真结束
.如果真 (是否为空 (时间间间隔))
    时间间间隔 ＝ “:”
.如果真结束
.如果真 (是否为空 (返回模式))
    返回模式 ＝ 1
.如果真结束
年份 ＝ 到文本 (取年份 (未格式化时间))
月份 ＝ 到文本 (取月份 (未格式化时间))
.如果真 (取文本长度 (月份) ＝ 1)
    月份 ＝ “0” ＋ 月份
.如果真结束
日 ＝ 到文本 (取日 (未格式化时间))
.如果真 (取文本长度 (日) ＝ 1)
    日 ＝ “0” ＋ 日
.如果真结束
小时 ＝ 到文本 (取小时 (未格式化时间))
.如果真 (取文本长度 (小时) ＝ 1)
    小时 ＝ “0” ＋ 小时
.如果真结束
分钟 ＝ 到文本 (取分钟 (未格式化时间))
.如果真 (取文本长度 (分钟) ＝ 1)
    分钟 ＝ “0” ＋ 分钟
.如果真结束
秒 ＝ 到文本 (取秒 (未格式化时间))
.如果真 (取文本长度 (秒) ＝ 1)
    秒 ＝ “0” ＋ 秒
.如果真结束
.判断开始 (返回模式 ＝ 1)
    格式化后时间 ＝ 小时 ＋ 时间间间隔 ＋ 分钟 ＋ 时间间间隔 ＋ 秒
.判断 (返回模式 ＝ 2)
    格式化后时间 ＝ 年份 ＋ 日期间间隔 ＋ 月份 ＋ 日期间间隔 ＋ 日
.判断 (返回模式 ＝ 3)
    格式化后时间 ＝ 年份 ＋ 日期间间隔 ＋ 月份 ＋ 日期间间隔 ＋ 日 ＋ “ ” ＋ 小时 ＋ 时间间间隔 ＋ 分钟 ＋ 时间间间隔 ＋ 秒
.判断 (返回模式 ＝ 4)
    格式化后时间 ＝ 年份 ＋ 日期间间隔 ＋ 月份 ＋ 日期间间隔 ＋ 日 ＋ 小时 ＋ 时间间间隔 ＋ 分钟 ＋ 时间间间隔 ＋ 秒
.默认
.判断结束
返回 (格式化后时间)
.子程序 时间_取制式, 整数型, 公开, 取当前系统时间制式，返回值；0表示12小时制，1表示24小时制
.局部变量 局_缓冲区, 文本型
局_缓冲区 ＝ 取空白文本 (4)
GetLocaleInfo (0, 35, 局_缓冲区, 4)
返回 (到整数 (局_缓冲区))
.子程序 时间_同步校时, 日期时间型, 公开, 调用http://www.baidu.com网址接口,win8以上系统需要管理员权限
.参数 参_是否同步, 逻辑型, 可空, 是否同步到北京时间，为空默认不同步
.局部变量 返回文本, 文本型
.局部变量 取出的时间, 文本型
.局部变量 时间, 日期时间型
网页_访问S (“https://www.baidu.com”, 2, , , , , 返回文本)
取出的时间 ＝ 删首尾空 (文本_取出中间文本 (返回文本, “Date:”, #换行符))
时间 ＝ 时间_GMT转为时间 (取出的时间)
.如果真 (参_是否同步)
    置现行时间 (时间)
.如果真结束
返回 (时间)
.子程序 时间_取月初, 日期时间型, 公开, 源码由论坛用户【ds9660】雕哥提供。
.参数 参_指定时间, 日期时间型, 可空
.如果真 (是否为空 (参_指定时间))
    参_指定时间 ＝ 取现行时间 ()
.如果真结束
返回 (增减时间 (取日期 (参_指定时间), #日, 1 － 取日 (参_指定时间)))
.子程序 时间_取月末, 日期时间型, 公开, 源码由论坛用户【ds9660】雕哥提供。
.参数 参_指定时间, 日期时间型, 可空
.局部变量 局_下月, 日期时间型
.如果真 (是否为空 (参_指定时间))
    参_指定时间 ＝ 取现行时间 ()
.如果真结束
局_下月 ＝ 取日期 (增减时间 (参_指定时间, #月份, 1))
返回 (增减时间 (局_下月, #日, －取日 (局_下月)))
.子程序 时间_取某年天数, 整数型, 公开, 阳历。
.参数 某时间, 日期时间型
返回 (选择 (取年份 (某时间) ％ 4 ＝ 0, 366, 365))
.子程序 时间_取月总天数, 整数型, 公开, 阳历。
.参数 输入_年
.参数 输入_月
.局部变量 datestr, 日期时间型
.局部变量 sday
.局部变量 eday, 日期时间型
datestr ＝ 到时间 (到文本 (输入_年) ＋ “-” ＋ 到文本 (输入_月) ＋ “-” ＋ “1”)
eday ＝ 增减时间 (datestr, #月份, 1)
eday ＝ 增减时间 (eday, #日, -1)
返回 (取日 (eday))
.子程序 时间_取第几周, , 公开, 查询指定日期是第几周
.参数 参_指定日期, 日期时间型, 可空
.参数 参_当月第几周, 整数型, 参考 可空
.参数 参_当年第几周, 整数型, 参考 可空
.局部变量 局_时间, 日期时间型
局_时间 ＝ 选择 (是否为空 (参_指定日期), 取现行时间 (), 参_指定日期)
参_当月第几周 ＝ 到整数 (编码_运行JS代码 (#时间取周数, “getMonthWeek”, 到文本 (取年份 (局_时间)), 到文本 (取月份 (局_时间)), 到文本 (取日 (局_时间)), ))
参_当年第几周 ＝ 到整数 (编码_运行JS代码 (#时间取周数, “getYearWeek”, 到文本 (取年份 (局_时间)), 到文本 (取月份 (局_时间)), 到文本 (取日 (局_时间)), ))
.子程序 时间_取月份, 文本型, 公开, 返回一个月份,源码由论坛用户【shandmail 】提供
.参数 目标时间, 日期时间型, 可空, 如果空或为零时取下面时间的返回月份
.参数 是否英文, 逻辑型, 可空
.局部变量 月数, 整数型
' 命令出自：https://bbs.125.la/forum.php?mod=viewthread&tid=13928859
目标时间 ＝ 选择 (是否为空 (目标时间), 取现行时间 (), 目标时间)
月数 ＝ 取月份 (目标时间)
.如果 (是否英文)
    返回 (多项选择 (月数, “January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November”, “December”))
.否则
    返回 (多项选择 (月数, “一月”, “二月”, “三月”, “四月”, “五月”, “六月”, “七月”, “八月”, “九月”, “十月”, “十一月”, “十二月”))
.如果结束
.子程序 时间_JSON转为时间, 日期时间型, 公开, 把JSON数据格式的日期（YYYY-MM-DDTHH:mm:ss.sssZ）转北京时间
.参数 JSON时间, 文本型, , JSON数据格式的日期（YYYY-MM-DDTHH:mm:ss.sssZ）
.局部变量 局_UTC, 文本型
.局部变量 局_时间, 日期时间型
局_UTC ＝ JSON时间
局_UTC ＝ 文本_取左边 (局_UTC, “.”, , )  ' 2019-08-19T01:41:38.000Z
局_UTC ＝ 子文本替换 (局_UTC, “T”, 字符 (32), , , 真)
局_时间 ＝ 到时间 (局_UTC)
局_时间 ＝ 增减时间 (局_时间, #小时, 8)  ' 东八区
返回 (局_时间)
.子程序 时间_时间转为JSON, 文本型, 公开, 格式化为JSON数据格式（YYYY-MM-DDTHH:mm:ss.sssZ）
.参数 时间, 日期时间型, 可空, 留空时间默认取系统UTC时间格式。不为空请先减8个小时（东8区）。
.局部变量 局_系统时间, 精易_时间
.局部变量 局_年, 文本型
.局部变量 局_月, 文本型
.局部变量 局_日, 文本型
.局部变量 局_时, 文本型
.局部变量 局_分, 文本型
.局部变量 局_秒, 文本型
.局部变量 局_毫, 文本型
.如果 (是否为空 (时间))
    GetSystemTime (局_系统时间)  ' 系统时间以协调世界时（UTC）表示
.否则
    VariantTimeToSystemTime (时间, 局_系统时间)
.如果结束
局_年 ＝ 文本_自动补零 (到文本 (局_系统时间.年), 4)
局_月 ＝ 文本_自动补零 (到文本 (局_系统时间.月), 2)
局_日 ＝ 文本_自动补零 (到文本 (局_系统时间.日), 2)
局_时 ＝ 文本_自动补零 (到文本 (局_系统时间.时), 2)
局_分 ＝ 文本_自动补零 (到文本 (局_系统时间.分), 2)
局_秒 ＝ 文本_自动补零 (到文本 (局_系统时间.秒), 2)
局_毫 ＝ 文本_自动补零 (到文本 (局_系统时间.毫), 3)
返回 (局_年 ＋ “-” ＋ 局_月 ＋ “-” ＋ 局_日 ＋ “T” ＋ 局_时 ＋ “:” ＋ 局_分 ＋ “:” ＋ 局_秒 ＋ “.” ＋ 局_毫 ＋ “Z”)  ' toJSON
.子程序 时间_判断二十四节气, 文本型, 公开, 返回文本型：若节气日，返回节气名称；不是节气日返回空。注：判断日期范围为1901年1月1日—2099年12月31日
.参数 日期, 日期时间型
.局部变量 年, 整数型
.局部变量 月, 整数型
.局部变量 日, 整数型
.局部变量 节气判断, 文本型
' https://bbs.125.la/thread-14459286-1-1.html
节气判断 ＝ “”
年 ＝ 取年份 (日期)
月 ＝ 取月份 (日期)
日 ＝ 取日 (日期)
.如果真 (年 ≥ 2000 且 年 ＜ 2100)  ' 21世纪判断
    年 ＝ 年 － 2000
    .如果真 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 3.87) － 取整 (年 ÷ 4))
        节气判断 ＝ “立春”
    .如果真结束
    .如果真 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 18.73) － 取整 (年 ÷ 4) 且 年 ≠ 26)
        节气判断 ＝ “雨水”
    .如果真结束
    .如果真 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.63) － 取整 (年 ÷ 4))
        节气判断 ＝ “惊蛰”
    .如果真结束
    .如果真 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.646) － 取整 (年 ÷ 4) 且 年 ≠ 84)
        节气判断 ＝ “春分”
    .如果真结束
    .如果真 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 4.81) － 取整 (年 ÷ 4))
        节气判断 ＝ “清明”
    .如果真结束
    .如果真 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.1) － 取整 (年 ÷ 4))
        节气判断 ＝ “谷雨”
    .如果真结束
    .如果真 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.52) － 取整 (年 ÷ 4))
        节气判断 ＝ “立夏”
    .如果真结束
    .如果真 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.04) － 取整 (年 ÷ 4) 且 年 ≠ 8)
        节气判断 ＝ “小满”
    .如果真结束
    .如果真 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.678) － 取整 (年 ÷ 4))
        节气判断 ＝ “芒种”
    .如果真结束
    .如果真 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.37) － 取整 (年 ÷ 4))
        节气判断 ＝ “夏至”
    .如果真结束
    .如果真 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.108) － 取整 (年 ÷ 4) 且 年 ≠ 16)
        节气判断 ＝ “小暑”
    .如果真结束
    .如果真 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.83) － 取整 (年 ÷ 4))
        节气判断 ＝ “大暑”
    .如果真结束
    .如果真 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.5) － 取整 (年 ÷ 4) 且 年 ≠ 2)
        节气判断 ＝ “立秋”
    .如果真结束
    .如果真 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.13) － 取整 (年 ÷ 4))
        节气判断 ＝ “处暑”
    .如果真结束
    .如果真 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.646) － 取整 (年 ÷ 4))
        节气判断 ＝ “白露”
    .如果真结束
    .如果真 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.042) － 取整 (年 ÷ 4))
        节气判断 ＝ “秋分”
    .如果真结束
    .如果真 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 8.318) － 取整 (年 ÷ 4))
        节气判断 ＝ “寒露”
    .如果真结束
    .如果真 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.438) － 取整 (年 ÷ 4) 且 年 ≠ 89)
        节气判断 ＝ “霜降”
    .如果真结束
    .如果真 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.438) － 取整 (年 ÷ 4) 且 年 ≠ 89)
        节气判断 ＝ “立冬”
    .如果真结束
    .如果真 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.36) － 取整 (年 ÷ 4))
        节气判断 ＝ “小雪”
    .如果真结束
    .如果真 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.18) － 取整 (年 ÷ 4))
        节气判断 ＝ “大雪”
    .如果真结束
    .如果真 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.94) － 取整 (年 ÷ 4) 且 年 ≠ 21)
        节气判断 ＝ “冬至”
    .如果真结束
    .如果真 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.4055) － 取整 (年 ÷ 4) 且 年 ≠ 19)
        节气判断 ＝ “小寒”
    .如果真结束
    .如果真 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.12) － 取整 (年 ÷ 4) 且 年 ≠ 82)
        节气判断 ＝ “大寒”
    .如果真结束
    ' 以下为21世纪特殊年份判断
    .如果真 (年 ＝ 26 且 月 ＝ 2 且 日 ＋ 1 ＝ 取整 (年 × 0.2422 ＋ 18.73) － 取整 (年 ÷ 4))
        节气判断 ＝ “雨水”
    .如果真结束
    .如果真 (年 ＝ 84 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 20.64) － 取整 (年 ÷ 4))
        节气判断 ＝ “春风”
    .如果真结束
    .如果真 (年 ＝ 8 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 21.04) － 取整 (年 ÷ 4))
        节气判断 ＝ “小满”
    .如果真结束
    .如果真 (年 ＝ 16 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 7.108) － 取整 (年 ÷ 4))
        节气判断 ＝ “小暑”
    .如果真结束
    .如果真 (年 ＝ 2 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 7.5) － 取整 (年 ÷ 4))
        节气判断 ＝ “立秋”
    .如果真结束
    .如果真 (年 ＝ 89 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 23.438) － 取整 (年 ÷ 4))
        节气判断 ＝ “霜降”
    .如果真结束
    .如果真 (年 ＝ 89 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 7.438) － 取整 (年 ÷ 4))
        节气判断 ＝ “立冬”
    .如果真结束
    .如果真 (年 ＝ 21 且 月 ＝ 2 且 日 ＋ 1 ＝ 取整 (年 × 0.2422 ＋ 21.94) － 取整 (年 ÷ 4))
        节气判断 ＝ “冬至”
    .如果真结束
    .如果真 (年 ＝ 19 且 月 ＝ 2 且 日 ＋ 1 ＝ 取整 (年 × 0.2422 ＋ 5.4055) － 取整 (年 ÷ 4))
        节气判断 ＝ “小寒”
    .如果真结束
    .如果真 (年 ＝ 82 且 月 ＝ 2 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 20.12) － 取整 (年 ÷ 4))
        节气判断 ＝ “大寒”
    .如果真结束
.如果真结束
.如果真 (年 ＞ 1900 且 年 ＜ 2000)  ' 20世纪判断
    年 ＝ 年 － 1900
    .如果真 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 4.6295) － 取整 (年 ÷ 4))
        节气判断 ＝ “立春”
    .如果真结束
    .如果真 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 19.4599) － 取整 (年 ÷ 4))
        节气判断 ＝ “雨水”
    .如果真结束
    .如果真 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.3826) － 取整 (年 ÷ 4))
        节气判断 ＝ “惊蛰”
    .如果真结束
    .如果真 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.4155) － 取整 (年 ÷ 4))
        节气判断 ＝ “春分”
    .如果真结束
    .如果真 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.59) － 取整 (年 ÷ 4))
        节气判断 ＝ “清明”
    .如果真结束
    .如果真 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.888) － 取整 (年 ÷ 4))
        节气判断 ＝ “谷雨”
    .如果真结束
    .如果真 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.318) － 取整 (年 ÷ 4) 且 年 ≠ 11)
        节气判断 ＝ “立夏”
    .如果真结束
    .如果真 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.86) － 取整 (年 ÷ 4))
        节气判断 ＝ “小满”
    .如果真结束
    .如果真 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.5) － 取整 (年 ÷ 4) 且 年 ≠ 2)
        节气判断 ＝ “芒种”
    .如果真结束
    .如果真 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.2) － 取整 (年 ÷ 4) 且 年 ≠ 28)
        节气判断 ＝ “夏至”
    .如果真结束
    .如果真 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.928) － 取整 (年 ÷ 4) 且 年 ≠ 25)
        节气判断 ＝ “小暑”
    .如果真结束
    .如果真 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.65) － 取整 (年 ÷ 4) 且 年 ≠ 22)
        节气判断 ＝ “大暑”
    .如果真结束
    .如果真 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.5) － 取整 (年 ÷ 4))
        节气判断 ＝ “立秋”
    .如果真结束
    .如果真 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.95) － 取整 (年 ÷ 4))
        节气判断 ＝ “处暑”
    .如果真结束
    .如果真 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 8.44) － 取整 (年 ÷ 4) 且 年 ≠ 27)
        节气判断 ＝ “白露”
    .如果真结束
    .如果真 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.822) － 取整 (年 ÷ 4) 且 年 ≠ 42)
        节气判断 ＝ “秋分”
    .如果真结束
    .如果真 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 9.098) － 取整 (年 ÷ 4))
        节气判断 ＝ “寒露”
    .如果真结束
    .如果真 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 24.218) － 取整 (年 ÷ 4))
        节气判断 ＝ “霜降”
    .如果真结束
    .如果真 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 8.218) － 取整 (年 ÷ 4))
        节气判断 ＝ “立冬”
    .如果真结束
    .如果真 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.08) － 取整 (年 ÷ 4) 且 年 ≠ 78)
        节气判断 ＝ “小雪”
    .如果真结束
    .如果真 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.9) － 取整 (年 ÷ 4) 且 年 ≠ 54)
        节气判断 ＝ “大雪”
    .如果真结束
    .如果真 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.6) － 取整 (年 ÷ 4) 且 年 ≠ 18)
        节气判断 ＝ “冬至”
    .如果真结束
    .如果真 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.11) － 取整 (年 ÷ 4) 且 年 ≠ 82)
        节气判断 ＝ “小寒”
    .如果真结束
    .如果真 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.84) － 取整 (年 ÷ 4))
        节气判断 ＝ “大寒”
    .如果真结束
    ' 以下为20世纪特殊年份判断
    .如果真 (月 ＝ 5 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 6.318) － 取整 (年 ÷ 4) 且 年 ≠ 11)
        节气判断 ＝ “立夏”
    .如果真结束
    .如果真 (月 ＝ 6 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 6.5) － 取整 (年 ÷ 4) 且 年 ≠ 2)
        节气判断 ＝ “芒种”
    .如果真结束
    .如果真 (月 ＝ 6 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 22.2) － 取整 (年 ÷ 4) 且 年 ≠ 28)
        节气判断 ＝ “夏至”
    .如果真结束
    .如果真 (月 ＝ 7 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 7.928) － 取整 (年 ÷ 4) 且 年 ≠ 25)
        节气判断 ＝ “小暑”
    .如果真结束
    .如果真 (月 ＝ 7 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 23.65) － 取整 (年 ÷ 4) 且 年 ≠ 22)
        节气判断 ＝ “大暑”
    .如果真结束
    .如果真 (月 ＝ 9 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 8.44) － 取整 (年 ÷ 4) 且 年 ≠ 27)
        节气判断 ＝ “白露”
    .如果真结束
    .如果真 (月 ＝ 9 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 23.822) － 取整 (年 ÷ 4) 且 年 ≠ 42)
        节气判断 ＝ “秋分”
    .如果真结束
    .如果真 (月 ＝ 11 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 23.08) － 取整 (年 ÷ 4) 且 年 ≠ 78)
        节气判断 ＝ “小雪”
    .如果真结束
    .如果真 (月 ＝ 12 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 7.9) － 取整 (年 ÷ 4) 且 年 ≠ 54)
        节气判断 ＝ “大雪”
    .如果真结束
    .如果真 (月 ＝ 12 且 日 ＋ 1 ＝ 取整 (年 × 0.2422 ＋ 22.6) － 取整 (年 ÷ 4) 且 年 ≠ 18)
        节气判断 ＝ “冬至”
    .如果真结束
    .如果真 (月 ＝ 1 且 日 － 1 ＝ 取整 (年 × 0.2422 ＋ 6.11) － 取整 (年 ÷ 4) 且 年 ≠ 82)
        节气判断 ＝ “小寒”
    .如果真结束
.如果真结束
返回 (节气判断)
.子程序 时间_星期几取日期, 日期时间型, 公开, 返回指定时间段里指定星期几的日期
.参数 参_时间, 日期时间型, 可空, 留空默认取当前时间
.参数 参_星期几, 整数型, , 1-7，分别代表星期一到星期日
.局部变量 局_星期几, 整数型
.局部变量 局_天差, 整数型
.局部变量 局_返回日期, 日期时间型
' https://bbs.125.la/thread-14479245-1-1.html
.如果真 (是否为空 (参_时间))
    参_时间 ＝ 取现行时间 ()
.如果真结束
局_星期几 ＝ 取星期几 (参_时间)
.判断开始 (局_星期几 ＝ 1)
    局_星期几 ＝ 7
.默认
    局_星期几 ＝ 局_星期几 － 1
.判断结束
局_天差 ＝ 局_星期几 － 参_星期几
局_返回日期 ＝ 增减时间 (参_时间, #日, －局_天差)
返回 (局_返回日期)
.子程序 时间_取间隔_开始, , 公开, 取微秒级时间间隔.[Mr.Yang提供]
.参数 标记, 文本型, 可空, 用于区分不同的时间.与"时间_取间隔_结束"对应.
.局部变量 Count, 长整数型
.局部变量 a, 整数型
.局部变量 i, 整数型
' https://bbs.125.la/thread-14545116-1-1.html
标记 ＝ 选择 (标记 ＝ “”, “耗时”, 标记)
.计次循环首 (取数组下标 (时间标记, 1), i)
    .如果真 (时间标记 [i] [1] ＝ 标记)  ' 标记已存在
        a ＝ i
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
.如果真 (a ＝ 0)  ' 标记未创建
    重定义数组 (时间标记, 真, 取数组下标 (时间标记, 1) ＋ 1, 2)  ' 创建标记
    a ＝ 取数组下标 (时间标记, 1)
    时间标记 [a] [1] ＝ 标记
.如果真结束
QueryPerformanceCounter (Count)
时间标记 [a] [2] ＝ 到文本 (Count)
.子程序 时间_取间隔_结束, 文本型, 公开, 取微秒级时间间隔.返回间隔时间.[Mr.Yang提供]
.参数 标记, 文本型, 可空, 用于区分不同的时间.与"时间_取间隔_开始"对应.
.局部变量 Count, 长整数型
.局部变量 a, 整数型
.局部变量 i, 整数型
.局部变量 频率, 长整数型
.局部变量 间隔时间, 双精度小数型
.局部变量 局_时, 整数型
.局部变量 局_分, 整数型
.局部变量 局_秒, 整数型
.局部变量 局_毫秒, 双精度小数型
.局部变量 返回文本, 文本型
.如果真 (频率 ＝ 0)  ' 获取HPET频率
    QueryPerformanceFrequency (Count)
    频率 ＝ Count
.如果真结束
QueryPerformanceCounter (Count)
标记 ＝ 选择 (标记 ＝ “”, “耗时”, 标记)
.计次循环首 (取数组下标 (时间标记, 1), i)
    .如果真 (时间标记 [i] [1] ＝ 标记)  ' 标记已存在
        a ＝ i
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
.如果真 (a ＝ 0)
    输出调试文本 (#引号 ＋ “时间_取间隔” ＋ #引号 ＋ “ 标记不存在!”)
    返回 (“”)
.如果真结束
间隔时间 ＝ (Count － 到数值 (时间标记 [a] [2])) ÷ 频率 × 1000
局_时 ＝ (间隔时间 ％ 86400000) ÷ 3600000
局_分 ＝ (间隔时间 ％ 86400000 ％ 3600000) ÷ 60000
局_秒 ＝ (间隔时间 ％ 86400000 ％ 3600000 ％ 60000) ÷ 1000
局_毫秒 ＝ 四舍五入 (间隔时间 ％ 86400000 ％ 3600000 ％ 60000 ％ 1000, 4)
.如果真 (局_时 ≠ 0)
    返回文本 ＝ 返回文本 ＋ 到文本 (局_时) ＋ “时”
.如果真结束
.如果真 (局_分 ≠ 0)
    返回文本 ＝ 返回文本 ＋ 到文本 (局_分) ＋ “分”
.如果真结束
.如果真 (局_秒 ≠ 0)
    返回文本 ＝ 返回文本 ＋ 到文本 (局_秒) ＋ “秒”
.如果真结束
.如果真 (局_毫秒 ≠ 0)
    返回文本 ＝ 返回文本 ＋ 到文本 (局_毫秒) ＋ “毫秒”
.如果真结束
输出调试文本 (标记 ＋ “:” ＋ 返回文本)
返回 (返回文本)
.程序集 类_POST数据类, , 公开
.程序集变量 _keys, 文本型, , "0"
.程序集变量 _values, 文本型, , "0"
.子程序 添加, , 公开, 添加指定键名与键值
.参数 key, 文本型
.参数 value, 文本型, , 当前值会进行utf-8的编码
.参数 转码, 逻辑型, 可空, 可空，是否对[值]进行进行utf-8编码，默认为 假=不转码，真=转码
.如果 (转码)
    加入成员 (_keys, 编码_gb2312到utf8 (key))
    加入成员 (_values, 编码_gb2312到utf8 (value))
.否则
    加入成员 (_keys, key)
    加入成员 (_values, value)
.如果结束
.子程序 添加_批量, , 公开, 批量加入[带转码]
.参数 文本, 文本型, , 如：a=123&b=456
.参数 转码, 逻辑型, 可空, 可空，是否对[值]进行进行utf-8编码，默认为 假=不转码，真=转码
.局部变量 Arr, 文本型, , "0"
.局部变量 i, 整数型
Arr ＝ 分割文本 (文本, “&”, )
.计次循环首 (取数组成员数 (Arr), i)
    添加 (文本_取左边 (Arr [i], “=”, , ), 文本_取右边 (Arr [i], “=”, , ), 转码)
.计次循环尾 ()
.子程序 取值, 文本型, 公开, 取指定键名的值
.参数 key, 文本型
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (_keys), i)
    .如果真 (_keys [i] ＝ key)
        返回 (_values [i])
    .如果真结束
.计次循环尾 ()
返回 (“”)
.子程序 置值, , 公开, 置指定键名的键值
.参数 key, 文本型
.参数 value, 文本型
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (_keys), i)
    .如果真 (_keys [i] ＝ key)
        _values [i] ＝ value
        返回 ()
    .如果真结束
.计次循环尾 ()
添加 (key, value)
.子程序 获取Post数据, 文本型, 公开, 将添加的数据以数据包格式返回  键名=键值&键名=键值
.参数 是否URL编码, 逻辑型, 可空, 默认为假=不编码，真=URL编码
.局部变量 i, 整数型
.局部变量 value, 文本型
.局部变量 str, 文本型
.计次循环首 (取数组成员数 (_keys), i)
    .如果 (是否URL编码)
        str ＝ str ＋ 编码_URL编码 (_keys [i], 真, ) ＋ “=” ＋ 编码_URL编码 (_values [i], 真, ) ＋ “&”
    .否则
        str ＝ str ＋ _keys [i] ＋ “=” ＋ _values [i] ＋ “&”
    .如果结束
.计次循环尾 ()
str ＝ 取文本左边 (str, 取文本长度 (str) － 1)
返回 (str)
.子程序 获取协议头数据, 文本型, 公开, 将添加的数据以协议头格式返回  键名:键值
.参数 是否URL编码, 逻辑型, 可空, 默认为假=不编码，真=URL编码
.局部变量 i, 整数型
.局部变量 value, 文本型
.局部变量 str, 文本型
.计次循环首 (取数组成员数 (_keys), i)
    .如果 (是否URL编码)
        str ＝ str ＋ _keys [i] ＋ “: ” ＋ 编码_URL编码 (_values [i], 真, ) ＋ 字符 (13) ＋ 字符 (10)
    .否则
        str ＝ str ＋ _keys [i] ＋ “: ” ＋ _values [i] ＋ 字符 (13) ＋ 字符 (10)
    .如果结束
.计次循环尾 ()
str ＝ 取文本左边 (str, 取文本长度 (str) － 1)
返回 (str)
.子程序 获取Key数组, , 公开
.参数 arr, 文本型, 参考 数组
arr ＝ _keys
.子程序 获取Value数组, , 公开
.参数 arr, 文本型, 参考 数组
arr ＝ _values
.子程序 清空, , 公开
清除数组 (_keys)
清除数组 (_values)
.子程序 删除, , 公开, 删除键值队  删除一个
.参数 key, 文本型
.局部变量 局_键名, 整数型
.计次循环首 (取数组成员数 (_keys), 局_键名)
    .如果真 (_keys [局_键名] ＝ key)
        删除成员 (_keys, 局_键名, 1)
        删除成员 (_values, 局_键名, 1)
        返回 ()
    .如果真结束
.计次循环尾 ()
.子程序 获取JSON文本, 文本型, 公开, 将添加的数据以JSON格式返回    ｛键名:键值｝
.局部变量 i, 整数型
.局部变量 Str, 文本型
Str ＝ “{”
.计次循环首 (取数组成员数 (_keys), i)
    Str ＝ Str ＋ #引号 ＋ _keys [i] ＋ #引号 ＋ “:” ＋ #引号 ＋ 处理元字符 (_values [i]) ＋ #引号 ＋ “,”
.计次循环尾 ()
Str ＝ rtrim (Str, “,”) ＋ “}”
返回 (Str)
.子程序 处理元字符, 文本型
.参数 文本, 文本型
.局部变量 Str, 文本型
Str ＝ 文本_替换 (文本, , , , #引号, “\” ＋ #引号, , , , , , , , )
返回 (Str)
.子程序 rtrim, 文本型, , 函数从字符串的末端开始删除空白字符或其他预定义字符
.参数 str, 文本型, , 规定要转换的字符串
.参数 charlist, 文本型, , 可空，规定从字符串中删除哪些字符
.如果真 (取文本右边 (str, 取文本长度 (charlist)) ＝ charlist)
    str ＝ 取文本左边 (str, 取文本长度 (str) － 取文本长度 (charlist))
.如果真结束
.如果真 (取文本左边 (str, 取文本长度 (charlist)) ＝ charlist)
    str ＝ 取文本右边 (str, 取文本长度 (str) － 取文本长度 (charlist))
.如果真结束
返回 (str)
.程序集 类_POST数据类_字节集, , 公开
.程序集变量 _keys, 文本型, , "0"
.程序集变量 _values, 字节集, , "0"
.程序集变量 _filename, 文本型, , "0"
.程序集变量 _types, 文本型, , "0"
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 清空, , 公开
清除数组 (_keys)
清除数组 (_values)
清除数组 (_types)
清除数组 (_filename)
.子程序 添加, , 公开
.参数 key, 文本型
.参数 value, 字节集
.参数 types, 文本型, 可空, 如： Content-Type: audio/mp3，请填写【audio/mp3】
.参数 filename, 文本型, 可空, 如： Content-Type: audio/mp3，请填写【audio/mp3】
加入成员 (_keys, key)
加入成员 (_values, value)
加入成员 (_types, types)
加入成员 (_filename, filename)
.子程序 取值, 字节集, 公开
.参数 key, 文本型
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (_keys), i)
    .如果真 (_keys [i] ＝ key)
        返回 (_values [i])
    .如果真结束
.计次循环尾 ()
返回 ({  })
.子程序 置值, , 公开
.参数 key, 文本型
.参数 value, 字节集
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (_keys), i)
    .如果真 (_keys [i] ＝ key)
        _values [i] ＝ value
        返回 ()
    .如果真结束
.计次循环尾 ()
添加 (key, value)
.子程序 ______获取Post数据, 字节集
.参数 boundary, 文本型
.参数 分割符数量, 整数型, 可空, 默认为2，如：--WebKitFormBoundaryPPRO2xsdBWf1T1h4
.局部变量 i, 整数型
.局部变量 head, 文本型
.局部变量 t, 文本型
.局部变量 bin, 字节集
.局部变量 keys, 文本型, , "0"
.局部变量 values, 文本型, , "0"
.如果真 (分割符数量 ＝ 0)
    分割符数量 ＝ 2
.如果真结束
head ＝ 取重复文本 (分割符数量, “-”) ＋ boundary ＋ #换行符
.计次循环首 (取数组成员数 (_keys), i)
    t ＝ head ＋ “Content-Disposition: form-data; name=” ＋ #引号 ＋ _keys [i] ＋ #引号 ＋ “; filename=” ＋ #引号 ＋ _keys [i] ＋ #引号 ＋ #换行符
    .如果真 (_types [i] ≠ “”)
        t ＝ t ＋ “Content-Type: ” ＋ _types [i] ＋ #换行符
    .如果真结束
    t ＝ t ＋ #换行符
    bin ＝ bin ＋ 到字节集 (t) ＋ _values [i] ＋ { 13, 10 }
.计次循环尾 ()
置入代码 ({ 255, 117, 236, 255, 117, 232, 139, 69, 8, 139, 0, 139, 88, 4, 137, 93, 236, 139, 88, 8, 137, 93, 232 })
.计次循环首 (取数组成员数 (keys), i)
    t ＝ head ＋ “Content-Disposition: form-data; name=” ＋ #引号 ＋ keys [i] ＋ #引号 ＋ #换行符 ＋ #换行符
    t ＝ t ＋ values [i] ＋ #换行符
    bin ＝ bin ＋ 到字节集 (t)
.计次循环尾 ()
置入代码 ({ 143, 69, 236, 143, 69, 232 })
bin ＝ bin ＋ 到字节集 (取重复文本 (分割符数量, “-”) ＋ boundary ＋ “--” ＋ #换行符)
返回 (bin)
.子程序 获取Post数据, 字节集, 公开
.参数 boundary, 文本型
.参数 分割符数量, 整数型, 可空, 默认为2，如：--WebKitFormBoundaryPPRO2xsdBWf1T1h4
.局部变量 i, 整数型
.局部变量 head, 文本型
.局部变量 t, 文本型
.局部变量 bin, 字节集
.局部变量 keys, 文本型, , "0"
.局部变量 values, 文本型, , "0"
' 修复代码来自;https://bbs.125.la/forum.php?mod=viewthread&tid=14285660
.如果真 (分割符数量 ＝ 0)
    分割符数量 ＝ 2
.如果真结束
head ＝ 取重复文本 (分割符数量, “-”) ＋ boundary ＋ #换行符
.计次循环首 (取数组成员数 (_keys), i)
    t ＝ head ＋ “Content-Disposition: form-data; name=” ＋ #引号 ＋ _keys [i] ＋ #引号
    .如果 (_filename [i] ≠ “”)
        t ＝ t ＋ “; filename=” ＋ #引号 ＋ _filename [i] ＋ #引号 ＋ #换行符
    .否则
        t ＝ t ＋ #换行符
    .如果结束
    .如果真 (_types [i] ≠ “”)
        t ＝ t ＋ “Content-Type: ” ＋ _types [i] ＋ #换行符
    .如果真结束
    t ＝ t ＋ #换行符
    bin ＝ bin ＋ 到字节集 (t) ＋ _values [i] ＋ { 13, 10 }
.计次循环尾 ()
bin ＝ bin ＋ 到字节集 (取重复文本 (分割符数量, “-”) ＋ boundary ＋ “--” ＋ #换行符)
返回 (bin)
.子程序 获取Key数组, , 公开
.参数 arr, 文本型, 参考 数组
.局部变量 keys, 文本型, , "0"
.局部变量 len, 整数型
.局部变量 i, 整数型
置入代码 ({ 255, 117, 252, 139, 69, 8, 139, 0, 139, 64, 4, 137, 69, 252 })
arr ＝ _keys
重定义数组 (arr, 真, 取数组成员数 (_keys) ＋ 取数组成员数 (keys))
.计次循环首 (取数组成员数 (keys), i)
    arr [取数组成员数 (_keys) ＋ i] ＝ keys [i]
.计次循环尾 ()
置入代码 ({ 143, 69, 252 })
.子程序 获取Value数组, , 公开
.参数 arr, 字节集, 参考 数组
.局部变量 values, 文本型, , "0"
.局部变量 i, 整数型
置入代码 ({ 255, 117, 252, 139, 69, 8, 139, 0, 139, 64, 8, 137, 69, 252 })
arr ＝ _values
重定义数组 (arr, 真, 取数组成员数 (_values) ＋ 取数组成员数 (values))
.计次循环首 (取数组成员数 (values), i)
    arr [取数组成员数 (_values) ＋ i] ＝ 到字节集 (values [i])
.计次循环尾 ()
置入代码 ({ 143, 69, 252 })
.程序集 类_脚本组件, , 公开
.程序集变量 脚本对象, 对象
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
线程_初始化COM库 ()
脚本对象.创建 (“ScriptControl”, )
脚本对象.写属性 (“Language”, “JScript”)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
脚本对象.清除 ()
线程_取消COM库 ()
.子程序 执行, 逻辑型, 公开, 执行指定的代码文本。返回真为执行正常，返回假为出错，错误信息可以从“错误信息”属性中取得。
.参数 脚本代码, 文本型
.局部变量 脚本代码_变体型, 变体型
' 脚本代码_变体型.赋值 (编码_Ansi到Unicode (脚本代码), )
' 脚本对象.数值方法 (“ExecuteStatement”, 脚本代码_变体型)
脚本对象.数值方法 (“ExecuteStatement”, 脚本代码)
返回 (脚本对象.取错误 () ＝ “”)
.子程序 计算表达式, 文本型, 公开, 计算表达式并返回结果。
.参数 表达式, 文本型
返回 (脚本对象.文本方法 (“Eval”, 表达式))
.子程序 清除, , 公开
脚本对象.数值方法 (“Reset”, )
.子程序 取错误, 文本型, 公开, 返回错误信息
返回 (脚本对象.取错误 ())
.子程序 取脚本对象, 对象, 公开
返回 (脚本对象)
.子程序 运行, 文本型, 公开, 在添加的代码中运行指定的过程，如有返回值返回相应文本，否则返回空文本。
.参数 过程或函数名, 文本型
.参数 参数1, 文本型, 可空
.参数 参数2, 文本型, 可空
.参数 参数3, 文本型, 可空
.参数 参数4, 文本型, 可空
.参数 参数5, 文本型, 可空
.参数 参数6, 文本型, 可空
.判断开始 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假 且 是否为空 (参数4) ＝ 假 且 是否为空 (参数5) ＝ 假 且 是否为空 (参数6) ＝ 假)
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3, 参数4, 参数5, 参数6))
.判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假 且 是否为空 (参数4) ＝ 假 且 是否为空 (参数5) ＝ 假)
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3, 参数4, 参数5))
.判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假 且 是否为空 (参数4) ＝ 假)
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3, 参数4))
.判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假)
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3))
.判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假)
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2))
.判断 (是否为空 (参数1) ＝ 假)
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1))
.默认
    返回 (脚本对象.文本方法 (“Run”, 过程或函数名))
.判断结束
.子程序 属性_语言, 文本型, 公开, 设置或返回正在使用的脚本语言名称。
.参数 新语言属性, 整数型, 可空, 默认为为 JScript   0. JScript   1. VBScript
.判断开始 (新语言属性 ＝ 0)
    脚本对象.写属性 (“Language”, “JScript”)
.判断 (新语言属性 ＝ 1)
    脚本对象.写属性 (“Language”, “vbs”)
.默认
.判断结束
返回 (脚本对象.读文本属性 (“Language”, ))
.子程序 属性_超时, 整数型, 公开, 设置或返回时间（毫秒），此时间后用户可选择中止脚本代码的执行或允许代码继续执行。
.参数 新超时属性值, 整数型, 可空, 默认为-1，执行无超时
.如果真 (是否为空 (新超时属性值))
    新超时属性值 ＝ -1
.如果真结束
脚本对象.写属性 (“Timeout”, 新超时属性值)
返回 (脚本对象.读数值属性 (“Timeout”, ))
.子程序 属性_状态, 整数型
.参数 新状态值, 整数型, 可空, 参数值为以下值之一： 0、Initialized； 1、Connected
.如果真 (是否为空 (新状态值) ＝ 假)
    脚本对象.写属性 (“State”, 新状态值)
.如果真结束
返回 (脚本对象.读数值属性 (“State”, ))
.子程序 属性_是否使用图形界面, 逻辑型
.参数 新是否使用图形界面属性, 逻辑型, 可空
.如果真 (是否为空 (新是否使用图形界面属性) ＝ 假)
    脚本对象.写属性 (“AllowUI”, 新是否使用图形界面属性)
.如果真结束
返回 (脚本对象.读逻辑属性 (“AllowUI”, ))
.子程序 属性_图形界面父窗口句柄, 整数型
.参数 新父窗口句柄, 整数型, 可空
.如果真 (是否为空 (新父窗口句柄) ＝ 假)
    脚本对象.写属性 (“SitehWnd”, 新父窗口句柄)
.如果真结束
返回 (脚本对象.读数值属性 (“SitehWnd”, ))
.子程序 添加代码
.参数 代码文本, 文本型
脚本对象.数值方法 (“AddCode”, 代码文本)
.子程序 未封装的属性及方法
' 类型: IScriptControl  10个属性，6个方法，标记: {0E59F1D3-1FBE-11D0-8FF2-00A0D10038BC}
' -------------------------------- 属性列表 --------------------------------
' 属性读取格式： 〈逻辑型〉 对象．读逻辑属性 （"UseSafeSubset"）
' 属性写入格式： 〈逻辑型〉 对象．写属性 （"UseSafeSubset"，欲写入属性值）
' 参数<1>的名称为“欲写入属性值”，类型为“逻辑型”。
' 解释：Force script to execute in safe mode and disallow potentially harmful actions
' 属性读取格式： 〈对象(IScriptModuleCollection)〉 对象．读对象型属性 （"Modules"）
' 解释：Collection of modules for the ScriptControl
' 属性读取格式： 〈对象〉 对象．读对象型属性 （"CodeObject"）
' 解释：Object exposed by the scripting engine that contains methods and properties defined in the code added to the global module
' 属性读取格式： 〈对象(IScriptProcedureCollection)〉 对象．读对象型属性 （"Procedures"）
' 解释：Collection of procedures that are defined in the global module
' -------------------------------- 方法列表 --------------------------------
' 方法调用格式： 〈整数型〉 对象．数值方法 （"AddObject"，Name，Object，AddMembers）
' 参数<1>的名称为“Name”，类型为“文本型”。
' 参数<2>的名称为“Object”，类型为“对象”。
' 参数<3>的名称为“AddMembers”，类型为“逻辑型”，参数默认值为“假”。
' 解释：Add an object to the global namespace of the scripting engine
.程序集 类_XMLHTTP, , 公开
.程序集变量 对象, 对象
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
CoInitialize (0)
创建 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
CoUninitialize ()
.子程序 创建, 逻辑型, , 把这个方法放到类“_初始化”命令里就不用自己创建了
.如果真 (对象.创建 (“MSXML2.XMLHTTP”, ) ＝ 假)
    返回 (假)
.如果真结束
返回 (真)
.子程序 打开, 逻辑型, 公开, 打开HTTP连接
.参数 模式, 文本型, , 模式为POST GET PUT PROPFIND之一
.参数 地址, 文本型, , 地址
.参数 异步方式, 逻辑型, 可空, 是否为异步方式
.参数 用户名, 文本型, 可空, 用户名
.参数 密码, 文本型, 可空, 密码
对象.方法 (“open”, 模式, 地址, 异步方式, 用户名, 密码)
返回 (真)
.子程序 指定请求头数据, , 公开, 单独指定请求的http头
.参数 头名称, 文本型, , 头名称
.参数 值, 文本型, , 值
对象.方法 (“setRequestHeader”, 头名称, 值)
.子程序 取响应头数据, 文本型, 公开, 从响应信息中获取指定的http头
.参数 头标志, 文本型, , 头标志
返回 (对象.文本方法 (“getResponseHeader”, 头标志))
.子程序 取所有头数据, 文本型, 公开, 获取响应的所有http头
返回 (对象.文本方法 (“getAllResponseHeaders”, ))
.子程序 发送请求, , 公开, 发送请求
.参数 发送数据, 文本型, 可空, 发送的数据
对象.方法 (“send”, 发送数据)
.子程序 取消当前请求, , 公开, 取消当前请求
对象.方法 (“abort”, )
.子程序 取状态码, 整数型, 公开, 返回当前请求的http状态码
返回 (对象.读数值属性 (“status”, ))
.子程序 取状态文本, 文本型, 公开, 返回当前请求的状态文本
返回 (对象.读文本属性 (“statusText”, ))
.子程序 取responseXML, 对象, 公开, 将响应信息格式化为 Xml 文档对象并返回
返回 (对象.读对象型属性 (“responseXML”, ))
.子程序 取responseText, 文本型, 公开, 将响应信息作为字符串返回
返回 (对象.读文本属性 (“responseText”, ))
.子程序 取响应数据, 变体型, 公开, 返回服务器响应数据
返回 (对象.读属性 (“responseBody”, ))
.子程序 取responseStream, 变体型, 公开, 以Ado Stream对象的形式返回响应信息
返回 (对象.读属性 (“responseStream”, ))
.子程序 取readyState, 整数型, 公开, 返回请求的当前状态
返回 (对象.读数值属性 (“readyState”, ))
.子程序 置onreadystatechange, , 公开, 指定当readyState属性改变时的子程序指针
.参数 参数值, 子程序指针
对象.写属性 (“onreadystatechange”, 参数值)
.程序集 类_json, , 公开
.程序集变量 dataName, 文本型
.程序集变量 JsonStr, 对象
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
dataName ＝ “da”
初始化 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
JsonStr.清除 ()
CoUninitialize ()
.子程序 初始化
CoInitialize (#NULL)
.如果真 (JsonStr.创建 (“MSScriptControl.ScriptControl”, ) ＝ 假)
    输出调试文本 (“创建指定类型的 COM 对象失败！”)
    返回 ()
.如果真结束
JsonStr.写属性 (“Language”, “JavaScript”)
JsonStr.逻辑方法 (“AddCode”, #js2)
JsonStr.逻辑方法 (“Eval”, “var ” ＋ dataName ＋ “ = {}, str_Code = String.fromCharCode(9216), str_reg = new RegExp(str_Code, 'g')”)
.子程序 解析, 逻辑型, 公开, 如果返回假，请检查Json文本是否为标准格式，如果确定，请检查 Windows 里 System 和 SysWOW64 是否需要权限
.参数 JSON文本, 文本型, , 必须是标准的JSON格式
.参数 为对象, 逻辑型, 可空
.局部变量 局_JSON文本, 文本型
' 暂时无法通过替换换行的方式来纠正JSON格式，原因是如果JSON是格式化的，替换了换行格式就会错误！
.如果真 (JsonStr.是否为空 () ＝ 假)
    JsonStr.清除 ()
    初始化 ()
.如果真结束
.如果真 (JsonStr.是否为空 ())
    返回 (假)
.如果真结束
JsonStr.逻辑方法 (“Eval”, “var ” ＋ dataName ＋ “ = null”)
局_JSON文本 ＝ JSON文本
.如果 (为对象)
    JsonStr.逻辑方法 (“AddCode”, “var ” ＋ dataName ＋ “ = ” ＋ 局_JSON文本)
.否则
    JsonStr.逻辑方法 (“AddCode”, “var ” ＋ dataName ＋ “ = eval(” ＋ 局_JSON文本 ＋ “)”)
.如果结束
返回 (JsonStr.逻辑方法 (“Eval”, dataName ＋ “ != null”))
.子程序 清除, 逻辑型, 公开
返回 (JsonStr.逻辑方法 (“Eval”, dataName ＋ “ = {}”))
.子程序 取数据文本, 文本型, 公开
返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ dataName ＋ “).replace(str_reg, '\\')”))
.子程序 置属性, 逻辑型, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 值, 文本型, 可空
.参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
.局部变量 局_属性名, 文本型
.局部变量 局_值, 文本型
.局部变量 局_是否存在, 逻辑型
.局部变量 局_类型, 文本型
局_属性名 ＝ 属性名
局_值 ＝ 值
局_是否存在 ＝ Property_exists (局_属性名)
.如果真 (为对象)
    .如果真 (局_值 ＝ “”)
        局_值 ＝ “{}”
    .如果真结束
    局_类型 ＝ JsonStr.文本方法 (“Eval”, “Object.prototype.toString.call(” ＋ 局_属性名 ＋ “)”)
    .如果真 (局_是否存在 且 局_类型 ＝ “[object Object]”)
        返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = get__extend(” ＋ 局_属性名 ＋ “, ” ＋ 局_值 ＋ “)”))
    .如果真结束
    返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = eval(” ＋ 值 ＋ “)”))
.如果真结束
局_值 ＝ 子文本替换 (局_值, “\”, “\\”, , , 真)
局_值 ＝ 子文本替换 (局_值, “'”, “\'”, , , 真)
局_值 ＝ 子文本替换 (局_值, #引号, “\” ＋ #引号, , , 真)
局_值 ＝ 子文本替换 (局_值, 字符 (13), “\r”, , , 真)
局_值 ＝ 子文本替换 (局_值, 字符 (10), “\n”, , , 真)
返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = '” ＋ 局_值 ＋ “'.replace(/\\/g, str_Code)”))
.子程序 置属性对象, 逻辑型, 公开, 属性解析为json对象或数组
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 值, 文本型, 可空
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = eval(” ＋ 值 ＋ “)”))
.子程序 Property_exists, 逻辑型
.参数 属性名, 文本型, 参考 可空, 请勿用变量
.判断开始 (属性名 ≈ dataName 且 JsonStr.逻辑方法 (“Eval”, 属性名 ＋ “ != null”))
    返回 (真)
.判断 (属性名 ＝ “”)
    属性名 ＝ dataName
.判断 (属性名 ≈ “[”)
    属性名 ＝ dataName ＋ 属性名
.默认
    属性名 ＝ dataName ＋ “.” ＋ 属性名
.判断结束
返回 (JsonStr.逻辑方法 (“Eval”, 属性名 ＋ “ != null”))
.子程序 属性是否存在, 逻辑型, 公开
.参数 属性名, 文本型, 可空
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
返回 (Property_exists (局_属性名))
.子程序 取类型, 整数型, 公开, -1、未知；0、未定义；1、布尔值；2、数值；4、对象；5、数组；6、字符串
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
.局部变量 局_类型, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
.如果真 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ == null”))
    返回 (0)  ' 未定义
.如果真结束
局_类型 ＝ JsonStr.文本方法 (“Eval”, “Object.prototype.toString.call(” ＋ 局_属性名 ＋ “)”)
.判断开始 (局_类型 ＝ “[object String]”)
    返回 (6)  ' 字符串
.判断 (局_类型 ＝ “[object Array]”)
    返回 (5)  ' 数组
.判断 (局_类型 ＝ “[object Object]”)
    返回 (4)  ' 对象
.判断 (局_类型 ＝ “[object Number]”)
    返回 (2)  ' 数值
.判断 (局_类型 ＝ “[object Boolean]”)
    返回 (1)  ' 布尔值
.默认
    返回 (-1)  ' 未知
.判断结束
.子程序 取通用属性, 文本型, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
.如果真 (为对象)
    返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “).replace(str_reg, '\\')”))
.如果真结束
返回 (JsonStr.文本方法 (“Eval”, 局_属性名 ＋ “.toString().replace(str_reg, '\\')”))
.子程序 取所有属性名, 整数型, 公开, 属性名指向JSON类型必须为对象
.参数 属性名数组, 文本型, 参考 可空 数组
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
.局部变量 局_值, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
局_值 ＝ JsonStr.文本方法 (“Eval”, “get__name_All(” ＋ 局_属性名 ＋ “)”)
属性名数组 ＝ 分割文本 (局_值, #换行符, )
返回 (取数组成员数 (属性名数组))
.子程序 成员数, 整数型, 公开, 属性名指向JSON类型必须为数组
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
返回 (到整数 (JsonStr.数值方法 (“Eval”, “get__count(” ＋ 局_属性名 ＋ “)”)))
.子程序 取属性, 类_json, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
.局部变量 局_json, 类_json
局_属性名 ＝ 属性名
Property_exists (局_属性名)
局_json.解析 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “).replace(str_reg, '\\')”))
返回 (局_json)
.子程序 加成员, 逻辑型, 公开
.参数 值, 文本型, 可空
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
.参数 开头添加, 逻辑型, 可空, 留空默认为末尾添加
.局部变量 局_属性名, 文本型
.局部变量 局_值, 文本型
局_属性名 ＝ 属性名
局_值 ＝ 值
Property_exists (局_属性名)
.如果真 (为对象 ＝ 假)
    局_值 ＝ “'” ＋ 局_值 ＋ “'”
.如果真结束
.如果真 (开头添加)
    返回 (JsonStr.逻辑方法 (“Eval”, “if (Object.prototype.toString.call(” ＋ 局_属性名 ＋ “) != '[object Array]') { ” ＋ 局_属性名 ＋ “ = new Array() } ” ＋ 局_属性名 ＋ “.unshift(” ＋ 局_值 ＋ “)”))
.如果真结束
返回 (JsonStr.逻辑方法 (“Eval”, “if (Object.prototype.toString.call(” ＋ 局_属性名 ＋ “) != '[object Array]') { ” ＋ 局_属性名 ＋ “ = new Array() } ” ＋ 局_属性名 ＋ “.push(” ＋ 局_值 ＋ “)”))
.子程序 取成员, 类_json, 公开
.参数 成员索引, 整数型, 可空, 成员索引从0开始
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
.局部变量 局_json, 类_json
局_属性名 ＝ 属性名
Property_exists (局_属性名)
局_json.解析 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “]).replace(str_reg, '\\')”))
返回 (局_json)
.子程序 取成员文本, 文本型, 公开
.参数 成员索引, 整数型, 可空, 成员索引从0开始
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
.如果真 (为对象)
    返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “]).replace(str_reg, '\\')”))
.如果真结束
返回 (JsonStr.文本方法 (“Eval”, 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “].replace(str_reg, '\\')”))
.子程序 置成员, 逻辑型, 公开
.参数 成员索引, 整数型, 可空, 成员索引从0开始
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 值, 文本型, 可空
.参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
.局部变量 局_属性名, 文本型
.局部变量 局_值, 文本型
局_属性名 ＝ 属性名
局_值 ＝ 值
Property_exists (局_属性名)
.如果真 (为对象 ＝ 假)
    局_值 ＝ “'” ＋ 局_值 ＋ “'”
.如果真结束
返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “] = ” ＋ 局_值))
.子程序 删成员, 逻辑型, 公开
.参数 成员索引, 整数型, 可空, 成员索引从0开始
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “.splice(” ＋ 到文本 (成员索引) ＋ “, 1)”))
.子程序 删属性, 逻辑型, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
返回 (JsonStr.逻辑方法 (“Eval”, “delete ” ＋ 局_属性名))
.子程序 置属性数值, 逻辑型, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.参数 值, 双精度小数型, 可空
.局部变量 局_属性名, 文本型
.局部变量 局_值, 文本型
局_属性名 ＝ 属性名
局_值 ＝ 到文本 (值)
Property_exists (局_属性名)
返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = ” ＋ 局_值))
.子程序 取属性数值, 双精度小数型, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
返回 (JsonStr.数值方法 (“Eval”, 局_属性名))
.子程序 取属性对象, 文本型, 公开
.参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
.局部变量 局_属性名, 文本型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “).replace(str_reg, '\\')”))
.子程序 取回对象, 对象, 公开
返回 (JsonStr)
.子程序 取所有属性值, 整数型, 公开, 取指定路径下所有属性的值
.参数 属性值数组, 文本型, 参考 可空 数组
.参数 属性名, 文本型, 可空, 属性名指向JSON类型必须为对象
.参数 向下递归, 逻辑型, 可空
.局部变量 局_属性名, 文本型
.局部变量 局_值, 文本型
.局部变量 len, 整数型
局_属性名 ＝ 属性名
Property_exists (局_属性名)
JsonStr.方法 (“Eval”, “var str_all = new Array()”)
JsonStr.方法 (“Eval”, “get__nodeValue(” ＋ 局_属性名 ＋ “, ” ＋ 选择 (向下递归, “true”, “false”) ＋ “)”)
局_值 ＝ JsonStr.文本方法 (“Eval”, “str_all.join('[2020年7月20日20时0分0秒]')”)
属性值数组 ＝ 分割文本 (局_值, “[2020年7月20日20时0分0秒]”, )
len ＝ 取数组成员数 (属性值数组)
返回 (len)
.程序集 类_FTP, , 公开
.程序集变量 初始句柄, 整数型
.程序集变量 连接句柄, 整数型
.子程序 是否已连接, 逻辑型, 公开, 判断FTP是否已连接服务器；
返回 (连接句柄 ≠ 0)
.子程序 连接FTP服务器, 逻辑型, 公开, 连接FTP服务器；
.参数 FTP服务器地址, 文本型
.参数 用户名, 文本型, 可空
.参数 密码, 文本型, 可空
.参数 端口号, 整数型, 可空
.参数 是否被动模式, 逻辑型, 可空
.局部变量 Flags, 整数型
.如果真 (是否为空 (用户名))
    用户名 ＝ “anonymous”
.如果真结束
.如果真 (是否为空 (密码))
    密码 ＝ 字符 (0)
.如果真结束
.如果真 (是否为空 (端口号))
    端口号 ＝ 21
.如果真结束
初始句柄 ＝ InternetOpenA (字符 (0), 1, 字符 (0), 字符 (0), 0)
Flags ＝ 0
.如果真 (是否被动模式)
    Flags ＝ 位或 (Flags, #INTERNET_FLAG_PASSIVE)
.如果真结束
连接句柄 ＝ InternetConnectA (初始句柄, FTP服务器地址, 端口号, 用户名, 密码, 1, Flags, 0)
.如果真 (连接句柄 ≠ 0)
    返回 (真)
.如果真结束
断开FTP服务器 ()
返回 (假)
.子程序 断开FTP服务器, 逻辑型, 公开, 断开FTP服务器；
.局部变量 局_结果, 逻辑型
局_结果 ＝ InternetCloseHandle (连接句柄)
.如果真 (局_结果)
    连接句柄 ＝ 0
.如果真结束
局_结果 ＝ InternetCloseHandle (初始句柄)
返回 (局_结果)
.子程序 目录创建, 逻辑型, 公开, 在FTP上创建目录；
.参数 欲创建的目录名, 文本型, , 欲创建的目录名；
.如果真 (连接句柄 ≠ 0)
    返回 (FtpCreateDirectoryA (连接句柄, 欲创建的目录名))
.如果真结束
返回 (假)
.子程序 目录删除, 逻辑型, 公开, 删除FTP上指定的目录；
.参数 欲删除的目录名, 文本型, , 欲删除的目录名；
.如果真 (连接句柄 ≠ 0)
    返回 (FtpRemoveDirectoryA (连接句柄, 欲删除的目录名))
.如果真结束
返回 (假)
.子程序 目录下载, 逻辑型, 公开, 下载FTP上指定的目录；
.参数 欲下载的FTP目录, 文本型, , 欲下载的FTP目录名；
.参数 本地目录, 文本型, , 注意，本地目录必须存在；
.参数 是否使用ASCII码方式, 逻辑型, 可空
.参数 错误信息, 文本型, 参考 数组, 返回下载
.局部变量 文件, 文本型, , "0"
.局部变量 属性, 整数型, , "0"
.局部变量 计次, 整数型
.如果真 (目录_是否存在 (本地目录) ＝ 假)
    目录_创建 (本地目录)
.如果真结束
.如果真 (连接句柄 ＝ 0 或 PathIsDirectoryA (本地目录) ≠ 16)
    返回 (假)
.如果真结束
.计次循环首 (目录列表 (欲下载的FTP目录, , 文件, 属性, , ), 计次)
    .如果真 (位与 (属性 [计次], 16) ＝ 0)
        .如果真 (文件下载 (欲下载的FTP目录 ＋ “/” ＋ 文件 [计次], 本地目录 ＋ “\” ＋ 文件 [计次], 是否使用ASCII码方式) ＝ 假)
            加入成员 (错误信息, 欲下载的FTP目录 ＋ “/” ＋ 文件 [计次])
        .如果真结束
        到循环尾 ()
    .如果真结束
    .如果真 (文件 [计次] ＝ “.” 或 文件 [计次] ＝ “..”)
        到循环尾 ()
    .如果真结束
    .如果真 (目录下载 (欲下载的FTP目录 ＋ “/” ＋ 文件 [计次], 本地目录 ＋ “\” ＋ 文件 [计次], 是否使用ASCII码方式, 错误信息) ＝ 假)
        加入成员 (错误信息, 欲下载的FTP目录 ＋ “/” ＋ 文件 [计次])
    .如果真结束
    处理事件 ()
.计次循环尾 ()
返回 (计次 ≠ 0 且 取数组成员数 (文件) ＝ 计次 － 1)
.子程序 目录上传, 逻辑型, 公开, 上传指定目录到FTP上；
.参数 欲上传的本地目录, 文本型
.参数 FTP目录路径, 文本型, , 目录要存在。
.参数 是否使用ASCII码方式, 逻辑型, 可空
.局部变量 文本, 文本型
.局部变量 文件, 文本型, , "0"
.局部变量 计次, 整数型
.如果真 (目录是否存在 (FTP目录路径) ＝ 假)
    .如果真 (目录创建 (FTP目录路径) ＝ 假)
        返回 (假)
    .如果真结束
.如果真结束
.如果真 (连接句柄 ＝ 0 或 PathIsDirectoryA (欲上传的本地目录) ≠ 16)
    返回 (假)
.如果真结束
文本 ＝ 寻找文件 (欲上传的本地目录 ＋ “\*”, )
.判断循环首 (文本 ≠ “”)
    .如果真 (文本 ≠ “.” 且 文本 ≠ “..”)
        加入成员 (文件, 文本)
    .如果真结束
    文本 ＝ 寻找文件 (, )
.判断循环尾 ()
.计次循环首 (取数组成员数 (文件), 计次)
    .如果真 (文件上传 (欲上传的本地目录 ＋ “\” ＋ 文件 [计次], FTP目录路径 ＋ “\” ＋ 文件 [计次], 到数值 (是否使用ASCII码方式)) ＝ 假)
        返回 (假)
    .如果真结束
.计次循环尾 ()
文本 ＝ “”
清除数组 (文件)
文本 ＝ 寻找文件 (欲上传的本地目录 ＋ “\*”, 16)
.判断循环首 (文本 ≠ “”)
    .如果真 (文本 ≠ “.” 且 文本 ≠ “..”)
        加入成员 (文件, 文本)
    .如果真结束
    文本 ＝ 寻找文件 (, 16)
.判断循环尾 ()
.计次循环首 (取数组成员数 (文件), 计次)
    FtpCreateDirectoryA (连接句柄, FTP目录路径 ＋ “\” ＋ 文件 [计次])
    .如果真 (目录上传 (欲上传的本地目录 ＋ “\” ＋ 文件 [计次], FTP目录路径 ＋ “\” ＋ 文件 [计次], 是否使用ASCII码方式) ＝ 假)
        返回 (假)
    .如果真结束
.计次循环尾 ()
返回 (真)
.子程序 目录列表, 整数型, 公开, 枚举FTP指定目录里的所有文件；返回找到的文件个数；
.参数 欲列出的文件类型, 文本型, 可空, 可空；留空取所有文件；或是指定文件类型，如："*.txt"；
.参数 欲列出的文件属性, 整数型, 可空, 欲列出的文件属性:1、#只读文件； 2、#隐藏文件； 4、#系统文件； 16、#子目录； 32、#存档文件。通过将这些常量值加起来可以一次设置多个文件属性。如果省略本参数，默认为搜寻所有文件。
.参数 存放文件名的数组, 文本型, 参考 可空 数组, 用于存放文件名的数组；
.参数 存放文件属性数组, 整数型, 参考 可空 数组, 用于存放文件属性数组；
.参数 存放文件尺寸数组, 长整数型, 参考 可空 数组, 用于存放文件尺寸数组；
.参数 存放文件时间数组, 日期时间型, 参考 可空 数组, 用于存放文件时间数组；
.局部变量 hFind, 整数型
.局部变量 文件信息, 查找的文件信息
.局部变量 局_目录名, 文本型
.局部变量 nFileSizeLow, 长整数型
.局部变量 nFileSizeHigh, 长整数型
.如果真 (欲列出的文件类型 ＝ “”)
    欲列出的文件类型 ＝ “*.*”
.如果真结束
清除数组 (存放文件名的数组)
清除数组 (存放文件属性数组)
清除数组 (存放文件尺寸数组)
清除数组 (存放文件时间数组)
.如果真 (连接句柄 ＝ 0)
    返回 (0)
.如果真结束
.如果真 (是否为空 (欲列出的文件属性))
    欲列出的文件属性 ＝ 1 ＋ 2 ＋ 4 ＋ 16 ＋ 32
.如果真结束
欲列出的文件属性 ＝ 欲列出的文件属性 ＋ 128
hFind ＝ FtpFindFirstFileA (连接句柄, 欲列出的文件类型, 文件信息, #INTERNET_FLAG_RELOAD, 0)
.如果真 (hFind ＝ 0)
    返回 (0)
.如果真结束
.循环判断首 ()
    局_目录名 ＝ 字节数组_到文本 (文件信息.cFileName)
    .判断开始 (位与 (文件信息.dwFileAttributes, 欲列出的文件属性) ＝ 0)
        到循环尾 ()
    .判断 (取文本左边 (局_目录名, 1) ＝ “.”)
        到循环尾 ()
    .默认
    .判断结束
    加入成员 (存放文件名的数组, 局_目录名)
    加入成员 (存放文件属性数组, 文件信息.dwFileAttributes)
    nFileSizeLow ＝ 取字节集数据 (到字节集 (文件信息.nFileSizeLow), #长整数型, )
    nFileSizeHigh ＝ 取字节集数据 (到字节集 (文件信息.nFileSizeHigh), #长整数型, )
    加入成员 (存放文件尺寸数组, nFileSizeLow ＋ nFileSizeHigh × 4294967296)
    加入成员 (存放文件时间数组, 系统_时间变时间 (文件信息.ftLastWriteTime))
    处理事件 ()
.循环判断尾 (InternetFindNextFileA (hFind, 文件信息) ≠ 0)
InternetCloseHandle (hFind)
返回 (取数组成员数 (存放文件名的数组))
.子程序 置现行目录, 逻辑型, 公开, 置现行目录；
.参数 FTP目录路径, 文本型, , FTP目录路径；
.如果真 (连接句柄 ≠ 0)
    返回 (FtpSetCurrentDirectoryA (连接句柄, FTP目录路径))
.如果真结束
返回 (假)
.子程序 取现行目录, 文本型, 公开, 取现行目录；
.局部变量 目录, 文本型
.局部变量 长度, 整数型
.如果真 (连接句柄 ≠ 0)
    长度 ＝ 0
    FtpGetCurrentDirectoryA (连接句柄, 目录, 长度)
    目录 ＝ 取空白文本 (长度)
    FtpGetCurrentDirectoryA (连接句柄, 目录, 长度)
    返回 (目录)
.如果真结束
返回 (“”)
.子程序 文件删除, 逻辑型, 公开, 删除FTP上指定的文件；
.参数 欲删除的FTP文件名, 文本型, , 欲删除的FTP文件名；
.如果真 (连接句柄 ≠ 0)
    返回 (FtpDeleteFileA (连接句柄, 欲删除的FTP文件名))
.如果真结束
返回 (假)
.子程序 文件更名, 逻辑型, 公开, 更改FTP上指定文件的名字；
.参数 欲改名的FTP文件名, 文本型, , 欲改名的FTP文件；
.参数 新文件名称, 文本型, , 新文件名称；
.如果真 (连接句柄 ≠ 0)
    返回 (FtpRenameFileA (连接句柄, 欲改名的FTP文件名, 新文件名称))
.如果真结束
返回 (假)
.子程序 文件下载, 逻辑型, 公开, 下载FTP上指定的文件；
.参数 欲下载的FTP文件, 文本型, , ‘/1.txt 注意这里需要使用/
.参数 本地文件名_绝对路径, 文本型, , 要保存到本地的路径，带文件名
.参数 是否使用ASCII码方式, 逻辑型, 可空
.局部变量 方式, 整数型
.如果真 (连接句柄 ≠ 0)
    .如果真 (是否为空 (是否使用ASCII码方式))
        是否使用ASCII码方式 ＝ 假
        方式 ＝ 2
    .如果真结束
    .如果 (是否使用ASCII码方式)
        方式 ＝ 位或 (1, #INTERNET_FLAG_RELOAD)  ' Forces a download of the requested file, object, or directory listing from the origin server, not from the cache.
    .否则
        方式 ＝ 位或 (2, #INTERNET_FLAG_RELOAD)  ' #INTERNET_FLAG_RELOAD 防止下载缓存文件
    .如果结束
    返回 (FtpGetFileA (连接句柄, 欲下载的FTP文件, 本地文件名_绝对路径, 0, 0, 方式, 0))
.如果真结束
返回 (假)
.子程序 文件上传, 逻辑型, 公开, 上传指定文件到FTP上；
.参数 欲上传的本地文件, 文本型, , 如：C:\012.txt
.参数 FTP文件路径, 文本型, , 如：/www/012.txt   请注意/，别用成\了。
.参数 文件上传方式, 整数型, 可空, 可空。默认为2  1=ASCII方式 2=二进制方式
.如果真 (是否为空 (文件上传方式) 或 文件上传方式 ＝ 0)
    文件上传方式 ＝ 2
.如果真结束
.如果真 (连接句柄 ≠ 0)
    返回 (FtpPutFileA (连接句柄, 欲上传的本地文件, FTP文件路径, 文件上传方式, 0))
.如果真结束
返回 (假)
.子程序 文件取大小, 长整数型, 公开, 取出FTP上指定文件的大小；
.参数 FTP文件路径, 文本型
.局部变量 句柄, 整数型
.局部变量 大小, , , "2"
.局部变量 nFileSizeLow, 长整数型
.局部变量 nFileSizeHigh, 长整数型
.如果真 (连接句柄 ＝ 0)
    返回 (0)
.如果真结束
句柄 ＝ FtpOpenFileA (连接句柄, FTP文件路径, 2147483648, 2, 0)
.如果真 (句柄 ＝ 0)
    返回 (0)
.如果真结束
大小 [1] ＝ FtpGetFileSize (句柄, 大小 [2])
nFileSizeLow ＝ 取字节集数据 (到字节集 (大小 [1]), #长整数型, )
nFileSizeHigh ＝ 取字节集数据 (到字节集 (大小 [2]), #长整数型, )
InternetCloseHandle (句柄)
返回 (nFileSizeLow ＋ nFileSizeHigh × 4294967296)
.子程序 目录取大小, 长整数型, 公开, 取出FTP上指定目录的大小；
.参数 FTP目录路径, 文本型
.局部变量 文件, 文本型, , "0"
.局部变量 大小, 长整数型, , "0"
.局部变量 属性, 整数型, , "0"
.局部变量 结果, 长整数型
.局部变量 计次, 整数型
.如果真 (连接句柄 ＝ 0)
    返回 (0)
.如果真结束
.计次循环首 (目录列表 (FTP目录路径, , 文件, 属性, 大小), 计次)
    .如果真 (文件 [计次] ＝ “.” 或 文件 [计次] ＝ “..”)
        到循环尾 ()
    .如果真结束
    .如果真 (位与 (属性 [计次], 16) ＝ 0)
        结果 ＝ 结果 ＋ 大小 [计次]
        到循环尾 ()
    .如果真结束
    结果 ＝ 结果 ＋ 目录取大小 (FTP目录路径 ＋ “\” ＋ 文件 [计次])
.计次循环尾 ()
返回 (结果)
.子程序 文件取属性, 整数型, 公开, 取出FTP上指定文件的属性；
.参数 FTP文件路径, 文本型
.参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
.局部变量 计次, 整数型
.局部变量 文本, 文本型
.局部变量 查找的文件信息, 查找的文件信息
.局部变量 寻找结果, 整数型
.局部变量 文件属性, 整数型
.如果真 (连接句柄 ＝ 0)
    返回 (-1)
.如果真结束
.如果 (区分大小写 ＝ 假)
    文本 ＝ 文本_到小写 (FTP文件路径)
.否则
    文本 ＝ FTP文件路径
.如果结束
寻找结果 ＝ FtpFindFirstFileA (连接句柄, 文本, 查找的文件信息, #INTERNET_FLAG_RELOAD, 0)
.如果真 (寻找结果 ＝ 0)
    返回 (-1)
.如果真结束
文件属性 ＝ 查找的文件信息.dwFileAttributes
InternetCloseHandle (寻找结果)
返回 (文件属性)
.子程序 目录取属性, 整数型, 公开, 取出FTP上指定目录的属性；
.参数 FTP目录路径, 文本型
.参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
.局部变量 文本, 文本型
.局部变量 目录, 文本型, , "0"
.局部变量 属性, 整数型, , "0"
.局部变量 计次, 整数型
.如果真 (连接句柄 ＝ 0)
    返回 (0)
.如果真结束
文本 ＝ 文本_去斜杠 (PathFindFileNameA (FTP目录路径))
.如果真 (区分大小写 ＝ 假)
    文本 ＝ 文本_到小写 (文本)
.如果真结束
.计次循环首 (目录列表 (FTP目录路径 ＋ “/../*”, 16, 目录, 属性), 计次)
    .如果真 (文本_到小写 (目录 [计次]) ＝ 文本)
        返回 (属性 [计次])
    .如果真结束
.计次循环尾 ()
返回 (0)
.子程序 文件取时间, 日期时间型, 公开, 返回文件最后修改时间。失败返回100年1月1日
.参数 FTP文件路径, 文本型
.参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
.局部变量 计次, 整数型
.局部变量 文本, 文本型
.局部变量 查找的文件信息, 查找的文件信息
.局部变量 寻找结果, 整数型
.局部变量 文件时间, 日期时间型
.局部变量 系统时间, 精易_时间
.如果真 (连接句柄 ＝ 0)
    返回 ([100年1月1日])
.如果真结束
.如果 (区分大小写 ＝ 假)
    文本 ＝ 文本_到小写 (FTP文件路径)
.否则
    文本 ＝ FTP文件路径
.如果结束
寻找结果 ＝ FtpFindFirstFileA (连接句柄, 文本, 查找的文件信息, #INTERNET_FLAG_RELOAD, 0)
.如果真 (寻找结果 ＝ 0)
    返回 ([100年1月1日])
.如果真结束
InternetCloseHandle (寻找结果)
返回 (系统_时间变时间 (查找的文件信息.ftLastWriteTime))
.子程序 目录取时间, 日期时间型, 公开, 返回目录最后修改时间。
.参数 FTP目录路径, 文本型
.参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
.局部变量 文本, 文本型
.局部变量 目录, 文本型, , "0"
.局部变量 时间, 日期时间型, , "0"
.局部变量 计次, 整数型
.局部变量 null, 日期时间型
.如果真 (连接句柄 ＝ 0)
    返回 (null)
.如果真结束
文本 ＝ 文本_去斜杠 (PathFindFileNameA (FTP目录路径))
.如果真 (区分大小写 ＝ 假)
    文本 ＝ 文本_到小写 (文本)
.如果真结束
.计次循环首 (目录列表 (FTP目录路径 ＋ “\..\*”, 16, 目录, , , 时间), 计次)
    .如果真 (文本_到小写 (目录 [计次]) ＝ 文本)
        返回 (时间 [计次])
    .如果真结束
.计次循环尾 ()
返回 (null)
.子程序 文件是否存在, 逻辑型, 公开, 判断FTP指定的文件是否存在；存在返回真，不存在返回假；
.参数 FTP文件路径, 文本型
.参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
.局部变量 文本, 文本型
.局部变量 查找的文件信息, 查找的文件信息
.局部变量 寻找结果, 整数型
.局部变量 返回值, 逻辑型
返回值 ＝ 假
.如果真 (连接句柄 ＝ 0)
    返回 (假)
.如果真结束
.如果 (区分大小写 ＝ 假)
    文本 ＝ 文本_到小写 (FTP文件路径)
.否则
    文本 ＝ FTP文件路径
.如果结束
寻找结果 ＝ FtpFindFirstFileA (连接句柄, 文本, 查找的文件信息, #INTERNET_FLAG_RELOAD, 0)
.如果真 (寻找结果 ≠ 0)
    返回值 ＝ 真
.如果真结束
InternetCloseHandle (寻找结果)
返回 (返回值)
.子程序 目录是否存在, 逻辑型, 公开, 判断FTP指定的目录是否存在；存在返回真，不存在返回假；
.参数 FTP目录路径, 文本型
.参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
.局部变量 文本, 文本型
.局部变量 目录, 文本型, , "0"
.局部变量 计次, 整数型
.如果真 (连接句柄 ＝ 0)
    返回 (假)
.如果真结束
文本 ＝ 文本_去斜杠 (PathFindFileNameA (FTP目录路径))
.如果真 (区分大小写 ＝ 假)
    文本 ＝ 文本_到小写 (文本)
.如果真结束
.计次循环首 (目录列表 (FTP目录路径 ＋ “/../*”, 16, 目录, , , ), 计次)
    .如果真 (文本_到小写 (目录 [计次]) ＝ 文本)
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 进度下载, 逻辑型, 公开
.参数 网络文件, 文本型
.参数 本地文件, 文本型
.参数 下载回调, 子程序指针, 可空, 3个参数；1＝已下载，长整数型指针。2=速度，整数型。3＝百分比，整数型。
.局部变量 hOpen
.局部变量 hOpenUrl
.局部变量 bool, 逻辑型
.局部变量 sReadBuffer, 字节型, , "0"
.局部变量 lNumberOfBytesRead
.局部变量 lCount, 长整数型
.局部变量 hHttpQueryInfo
.局部变量 sBuffer, 文本型
.局部变量 FileSize
.局部变量 handle
.局部变量 StartTime
.局部变量 TotalReadSize
.局部变量 TimeConsuming, 整数型
.局部变量 lSpeed, 整数型
.局部变量 进度, , , , 单位：百分比。
FileSize ＝ 文件取大小 (网络文件)
.如果真 (FileSize ＝ 0)
    返回 (假)
.如果真结束
hOpenUrl ＝ FtpOpenFileA (连接句柄, 网络文件, -2147483648, 2, 0)
.如果真 (hOpenUrl ＝ 0)
    返回 (假)
.如果真结束
handle ＝ 打开文件 (本地文件, 6, 1)
StartTime ＝ GetTickCount ()
.循环判断首 ()
    重定义数组 (sReadBuffer, 假, 2048)
    bool ＝ InternetReadFile_Byte (hOpenUrl, sReadBuffer, 2048, lNumberOfBytesRead)
    .如果 (lNumberOfBytesRead ＞ 0 且 bool)
        重定义数组 (sReadBuffer, 真, lNumberOfBytesRead)
        ' sReadBuffer ＝ 取空白字节集 (lNumberOfBytesRead)
        lCount ＝ lCount ＋ lNumberOfBytesRead  ' 已下载
        写出数据 (handle, sReadBuffer)
        TotalReadSize ＝ TotalReadSize ＋ lNumberOfBytesRead
        TimeConsuming ＝ GetTickCount () － StartTime
        .如果真 (TimeConsuming ＞ 0)
            lSpeed ＝ TotalReadSize ÷ TimeConsuming  ' 速度
        .如果真结束
        进度 ＝ 取整 (lCount ÷ FileSize × 100)  ' 百分比
        .如果真 (是否为空 (下载回调) ＝ 假 或 到整数 (下载回调) ≠ 0)
            程序_Call (到整数 (下载回调), 取指针地址_长整数型 (lCount), lSpeed, 进度, , )
        .如果真结束
        处理事件 ()
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.循环判断尾 (lNumberOfBytesRead ≠ 0)
关闭文件 (handle)
InternetCloseHandle (hOpen)
InternetCloseHandle (hOpenUrl)
返回 (真)
.子程序 系统_时间变时间, 日期时间型
.参数 文件时间, 文件时间
.局部变量 系统时间, 精易_时间
.局部变量 时间, 日期时间型
FileTimeToSystemTime (文件时间, 系统时间)
SystemTimeToVariantTime (系统时间, 时间)
返回 (时间)
.子程序 字节数组_到文本, 文本型
.参数 字节数组, 字节型, 数组
.局部变量 数组, 字节型, , "0"
.如果真 (取数组成员数 (字节数组) ＝ 0)
    返回 (“”)
.如果真结束
数组 ＝ 字节数组
加入成员 (数组, 0)
返回 (lstrcpynA_字节型 (数组, 0, 0))
.子程序 文本_去斜杠, 文本型
.参数 文本, 文本型
.局部变量 长度, 整数型
.局部变量 临时文本, 文本型
临时文本 ＝ 文本
.循环判断首 ()
    长度 ＝ lstrlenA (取指针文本_ (临时文本))
    StrTrimA (临时文本, “\”)
    StrTrimA (临时文本, “/”)
.循环判断尾 (lstrlenA (取指针文本_ (临时文本)) ≠ 长度)
返回 (临时文本)
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
断开FTP服务器 ()
.程序集 正则表达式类, , 公开
.程序集变量 正则, 对象
.程序集变量 集_过度对象, 对象
.程序集变量 集_被搜索的文本, 变体型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
线程_初始化COM库 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
正则.清除 ()
集_过度对象.清除 ()
集_被搜索的文本.清除 ()
线程_取消COM库 ()
.子程序 创建, 逻辑型, 公开, 根据指定的正则表达式文本创建一个正则表达式对象。本对象中的原有内容将被释放
.参数 正则表达式文本, 文本型, , 比如“易语言4\.0(模块|支持库)?”
.参数 被搜索的文本, 文本型
.参数 是否区分大小写, 逻辑型, 可空, 可以留空,默认为假,不区分大小写; 真为区分大小写;本参数指定这个正则表达式在创建成功后进行匹配、搜索、替换时，是否区分大小写;
.参数 是否匹配多行, 逻辑型, 可空, 可以留空,默认为真,允许匹配多行; 如果本成员值为真，字符“^”不仅匹配目标文本的开头，而且匹配目标文本中换行符（字符(10)，字符(13)或 #换行符）的后面；字符“$”不仅匹配目标文本的结尾，而且匹配目标文本中换行符的前面。否则字符“^”仅仅匹配目标文本的开头，“$”也仅仅匹配目标文本的结尾。
.参数 是否全局匹配, 逻辑型, 可空, 可以留空，默认为真，全局匹配
.参数 自动替换引号, 逻辑型, 可空, 可空。默认为不替换。说明：正则表达式文本为【formhash" value="7b4aa6c5】，这里面的引号处理起来很麻烦，直接把此参数设置为真，把"换成 #引号 再传进来就可以了，如：【formhash#引号 value=#引号7b4aa6c5】
.局部变量 局_正则文本, 文本型
是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
正则.清除 ()
集_过度对象.清除 ()
正则.创建 (“VBScript.RegExp”, )
正则.写属性 (“IgnoreCase”, 是否区分大小写)  ' 匹配时不区分大小写
正则.写属性 (“Multiline”, 是否匹配多行)  ' 是否匹配多行
正则.写属性 (“Singleline”, 真)  ' Singleline(单行模式)
正则.写属性 (“Global”, 是否全局匹配)  ' 是否全局匹配
.判断开始 (自动替换引号)
    局_正则文本 ＝ 子文本替换 (正则表达式文本, “#引号”, #引号, , , 真)
.默认
    局_正则文本 ＝ 正则表达式文本
.判断结束
正则.写属性 (“Pattern”, 局_正则文本)
' -----------------
集_被搜索的文本.赋值 (被搜索的文本, )
集_过度对象 ＝ 正则.对象型方法 (“Execute”, 集_被搜索的文本)
.' 如果真 (取文本长度 (被搜索的文本) ＞ 510000)
    ' 输出调试文本 (“友情提醒：正则类 → 创建() 命令的参数二 → 被搜索的文本 的长度过长，可以会导致程序直接结束。”)
.如果真结束
' 集_过度对象 ＝ 正则.对象型方法 (“Execute”, 被搜索的文本)
' 集_被搜索的文本 ＝ 被搜索的文本
返回 (集_过度对象.是否为空 () ＝ 假)
.子程序 查看, , 公开,  
正则.查看 ()
.子程序 取正则文本, 文本型, 公开, 返回以文本形式表示的正则表达式。如果该对象尚未创建，则返回空文本。本命令为高级对象成员命令
返回 (选择 (正则.是否为空 (), “”, 正则.读文本属性 (“Pattern”, )))
.子程序 替换, 文本型, 公开, 替换在正则表达式查找中找到的文本
.参数 用作替换的文本, 文本型, 可空, 用作替换的文本
.局部变量 用作替换的文本_变体型, 变体型
用作替换的文本_变体型.赋值 (用作替换的文本, )
' 返回 (编码_Unicode到Ansi (正则.通用方法 (“Replace”, 集_被搜索的文本, 用作替换的文本_变体型).取字节集 ()))
返回 (正则.文本方法 (“Replace”, 集_被搜索的文本, 用作替换的文本_变体型))
.子程序 取匹配数量, 整数型, 公开, 取出该正则匹配到的数量
返回 (集_过度对象.读数值属性 (“Count”, ))
.子程序 取匹配文本, 文本型, 公开, 取出该正则匹配到的文本
.参数 匹配索引, 整数型, , 索引值从1开始
.参数 起始位置, 整数型, 参考 可空, 可以被省略，提供参数数据时只能提供变量。该命令调用成功后，本参数存放取得的子文本在整个被搜索文本中的起始位置
.局部变量 Match, 对象
.局部变量 Value, 文本型
Match ＝ 集_过度对象.读对象型属性 (“Item”, 匹配索引 － 1)
' ----------------------
Value ＝ Match.读属性 (“Value”, ).取文本 ()
.如果真 (是否为空 (起始位置) ＝ 假)
    起始位置 ＝ 寻找文本 (集_被搜索的文本.取文本 (), Value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读属性 (“IgnoreCase”, ).取文本 () ＝ “0”, 真, 假)) － 1
.如果真结束
返回 (Value)
' Value ＝ Match.读文本属性 (“Value”, )
.' 如果真 (是否为空 (起始位置) ＝ 假)
    ' 起始位置 ＝ 寻找文本 (集_被搜索的文本, Value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读文本属性 (“IgnoreCase”, ) ＝ “0”, 真, 假)) － 1
.如果真结束
' 返回 (Value)
.子程序 取子匹配文本, 文本型, 公开, 取出该正则的子表达式匹配到的文本
.参数 匹配索引, 整数型, , 索引值从1开始
.参数 子表达式索引, 整数型, , 欲取其值的子表达式,该参数对应与正则表达式中的一个子表达式以圆括号"( )"为标记,索引从1开始
.参数 起始位置, 整数型, 参考 可空, 可以被省略，提供参数数据时只能提供变量。该命令调用成功后，本参数存放取得的子文本在整个被搜索文本中的起始位置
.局部变量 Match, 对象
.局部变量 SubMatches, 对象
.局部变量 value, 文本型
Match ＝ 集_过度对象.读对象型属性 (“Item”, 匹配索引 － 1)
SubMatches ＝ Match.读对象型属性 (“SubMatches”, )
value ＝ SubMatches.读属性 (“Item”, 子表达式索引 － 1).取文本 ()
.如果真 (是否为空 (起始位置) ＝ 假)
    起始位置 ＝ 寻找文本 (集_被搜索的文本.取文本 (), value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读属性 (“IgnoreCase”, ).取文本 () ＝ “0”, 真, 假)) － 1
    ' 起始位置 ＝ 寻找文本 (集_被搜索的文本, value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读文本属性 (“IgnoreCase”, ) ＝ “0”, 真, 假)) － 1
.如果真结束
返回 (value)
.子程序 取子匹配数量, 整数型, 公开, 取出该正则的子表达式匹配到的数量
返回 (集_过度对象.读对象型属性 (“Item”, 0).读对象型属性 (“SubMatches”, ).读数值属性 (“Count”, ))
.程序集 类_Cookie, , 公开, Cookie操作类   感谢【@bj2757 】提供源码
.程序集变量 cookie_s, Cookie, , "0", cookie数组
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 加入Cookie, , 公开, 加入单个cookie
.参数 cookie, Cookie, , 需要加入的cookie
加入成员 (cookie_s, cookie)
.子程序 加入Cookie2, , 公开, 加入单个cookie
.参数 健, 文本型, , Cookie的名字
.参数 值, 文本型, , Cookie的值
.局部变量 co, Cookie
co.健 ＝ 健
co.值 ＝ 值
加入成员 (cookie_s, co)
.子程序 加入Cookie文本, 逻辑型, 公开, 自动解析cookie文本并加入当前cookie对象
.参数 cookie字串, 文本型, , 需要加入的文本字串
.局部变量 局_cookie数组, Cookie, , "0"
Cookie解析 (cookie字串, 局_cookie数组)
.如果真 (取数组成员数 (局_cookie数组) ＞ 0)
    加入Cookie数组 (局_cookie数组)
.如果真结束
返回 (假)
.子程序 加入Cookie数组, , 公开
.参数 Cookie_数组, Cookie, 数组
加入成员 (cookie_s, Cookie_数组)
.子程序 Cookie解析, , 公开, 根据cookie文本解析cookie并加入返回数组中
.参数 Cookie文本, 文本型, , 需要解析的cookie文本字符串
.参数 Cookie集合, Cookie, 参考 数组, 返回cookie集合
.参数 删收尾引号, 逻辑型, 可空, 默认为真
.局部变量 局_数组1, 文本型, , "0"
.局部变量 局_index, 整数型
.局部变量 i, 整数型
.局部变量 cookie_i, Cookie
局_数组1 ＝ 分割文本 (Cookie文本, “;”, )
.如果真 (是否为空 (删收尾引号))
    删收尾引号 ＝ 真
.如果真结束
.计次循环首 (取数组成员数 (局_数组1), i)
    局_index ＝ 寻找文本 (局_数组1 [i], “=”, , 假)
    .如果真 (局_index ≠ -1)
        cookie_i.健 ＝ 删首尾空 (取文本左边 (局_数组1 [i], 局_index － 1))
        cookie_i.值 ＝ 删首尾空 (取文本右边 (局_数组1 [i], 取文本长度 (局_数组1 [i]) － 局_index))
        .如果真 (删收尾引号)
            .如果真 (取文本左边 (cookie_i.健, 1) ＝ #引号)
                cookie_i.健 ＝ 取文本右边 (cookie_i.健, 取文本长度 (cookie_i.健) － 1)
            .如果真结束
            .如果真 (取文本右边 (cookie_i.健, 1) ＝ #引号)
                cookie_i.健 ＝ 取文本左边 (cookie_i.健, 取文本长度 (cookie_i.健) － 1)
            .如果真结束
            .如果真 (取文本左边 (cookie_i.值, 1) ＝ #引号)
                cookie_i.值 ＝ 取文本右边 (cookie_i.值, 取文本长度 (cookie_i.值) － 1)
            .如果真结束
            .如果真 (取文本右边 (cookie_i.值, 1) ＝ #引号)
                cookie_i.值 ＝ 取文本左边 (cookie_i.值, 取文本长度 (cookie_i.值) － 1)
            .如果真结束
        .如果真结束
        加入成员 (Cookie集合, cookie_i)
    .如果真结束
.计次循环尾 ()
.子程序 删除Cookie, 逻辑型, 公开, 根据cookie的键删除cookie
.参数 cookieKey, 文本型, , 需要删除cookie的健
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (cookie_s), i)
    .如果真 (cookie_s [i].健 ＝ cookieKey)
        删除成员 (cookie_s, i, )
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 删除全部, , 公开, 删除当前对象中所有的cookie
清除数组 (cookie_s)
.子程序 取Cookie文本, 文本型, 公开, 返回当前集合中所有的cookie组成的字符串
.局部变量 i, 整数型
.局部变量 返回, 文本型
返回 ＝ “”
.计次循环首 (取数组成员数 (cookie_s), i)
    返回 ＝ 返回 ＋ cookie_s [i].健 ＋ “=” ＋ cookie_s [i].值 ＋ “; ”
.计次循环尾 ()
返回 ＝ 取文本左边 (返回, 取文本长度 (返回) － 2)
返回 (返回)
.子程序 取全部Cookie, 逻辑型, 公开, 如果当前对象没有Cookie则返回假
.参数 Cookie数组, Cookie, 参考 数组, 返回的cookie所存放的数组
.如果真 (取数组成员数 (cookie_s) ≤ 0)
    返回 (假)
.如果真结束
加入成员 (Cookie数组, cookie_s)
返回 (真)
.子程序 取Cookie值, 文本型, 公开, 根据键取值 成功返回对应的值 失败返回空
.参数 CookieKey, 文本型, , cookie健
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (cookie_s), i)
    .如果真 (cookie_s [i].健 ＝ CookieKey)
        返回 (cookie_s [i].值)
    .如果真结束
.计次循环尾 ()
返回 (“”)
.子程序 取Cookie组, 文本型, 公开, 返回一组cookie
.参数 CookieKey, 文本型, , cookie健
.如果真 (取Cookie值 (CookieKey) ＝ “”)
    返回 (“”)
.如果真结束
返回 (CookieKey ＋ “=” ＋ 取Cookie值 (CookieKey))
.子程序 取Cookie组对象, Cookie, 公开, 返回一组cookie对象
.参数 CookieKey, 文本型, , cookie健，也就是cookie名称
.局部变量 i, 整数型
.局部变量 f, Cookie
.计次循环首 (取数组成员数 (cookie_s), i)
    .如果真 (cookie_s [i].健 ＝ CookieKey)
        f ＝ cookie_s [i]
    .如果真结束
.计次循环尾 ()
返回 (f)
.子程序 Cookie是否存在, 逻辑型, 公开, 根据key判断cookie中是否存在
.参数 cookieKey, 文本型, , 需要判断的cookie的key
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (cookie_s), i)
    .如果真 (cookie_s [i].健 ＝ cookieKey)
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 Cookie是否存在数组中, 逻辑型, 公开, 根据key判断指定的cookie数组中是否存在
.参数 CookieKey, 文本型, , 需要判断的cookie的key
.参数 Cookie数组, Cookie, 数组, Cookie数组
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (Cookie数组), i)
    .如果真 (Cookie数组 [i].健 ＝ CookieKey)
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 Cookie是否存在文本中, 逻辑型, 公开, 根据key判断指定的cookie字符串文本中是否存在
.参数 CookieKey, 文本型, , 需要判断的cookie的key
.参数 Cookie文本, 文本型, , Cookie文本
.局部变量 Cookie数组, Cookie, , "0", Cookie数组
.局部变量 i, 整数型
Cookie解析 (Cookie文本, Cookie数组)
.如果真 (取数组成员数 (Cookie数组) ＞ 0)
    .计次循环首 (取数组成员数 (Cookie数组), i)
        .如果真 (Cookie数组 [i].健 ＝ CookieKey)
            返回 (真)
        .如果真结束
    .计次循环尾 ()
.如果真结束
返回 (假)
.程序集 HashMap_StrInt, , 公开, 源码收录自【https://bbs.125.la/forum.php?mod=viewthread&tid=14088175】
.程序集变量 成员_散列表, HashMap_Str_Str_节点型, , "0"
.程序集变量 成员_扩容因数, 双精度小数型
.程序集变量 成员_扩容阈值, 整数型
.程序集变量 成员_已用数据表链总数, 整数型
.程序集变量 成员_键总数量, 整数型
.程序集变量 成员_重新索引次数, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
初始化 ()
.子程序 初始化, , 公开
初始设置 (16, 0.75)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 初始设置, 逻辑型, 公开, 默认初始容量为16,扩容因数为0.75
.参数 初始容量大小, 整数型, 可空, 留空表示不改变,注意 改变初始容量大小会清除已有数据
.参数 扩容因数, 双精度小数型, 可空, 留空表示不改变,注意 必须小于1且大于0
.局部变量 初始容量, 整数型
.如果真 (是否为空 (初始容量大小) ＝ 假)
    .如果真 (初始容量大小 ＜ 0)
        返回 (假)
    .如果真结束
    初始容量 ＝ 1
    .判断循环首 (初始容量 ＜ 初始容量大小)
        初始容量 ＝ 左移 (初始容量, 1)
    .判断循环尾 ()
    重定义数组 (成员_散列表, 假, 初始容量)
    成员_已用数据表链总数 ＝ 0
    成员_键总数量 ＝ 0
    成员_重新索引次数 ＝ 0
    更新阈值 ()
.如果真结束
.如果真 (是否为空 (扩容因数) ＝ 假)
    .如果真 (扩容因数 ≤ 0 或 扩容因数 ＞ 1)
        返回 (假)
    .如果真结束
    成员_扩容因数 ＝ 扩容因数
    更新阈值 ()
.如果真结束
返回 (真)
.子程序 加入, 逻辑型, 公开, 添加一个键值对
.参数 键, 文本型, 可空
.参数 值, 整数型, 可空
.参数 禁止覆盖相同键, 逻辑型, 可空, 默认为假,如果为真,则已存在该键时不覆盖原值并返回假,否则覆盖原键值
.局部变量 节点索引, 整数型
.局部变量 新的键值, HashMap_Str_Str_键值型
.局部变量 i, 整数型
新的键值.键 ＝ 键
新的键值.值 ＝ 值
新的键值.散列值 ＝ 计算散列值 (键)
.如果真 (成员_已用数据表链总数 ＋ 1 ≥ 成员_扩容阈值)
    重新索引 (取数组成员数 (成员_散列表) × 2)
.如果真结束
.如果真 (取数组成员数 (成员_散列表) ＝ 0)
    初始设置 (16, )
.如果真结束
节点索引 ＝ 计算索引 (新的键值.散列值, 取数组成员数 (成员_散列表))
.变量循环首 (2, 取数组成员数 (成员_散列表 [节点索引].键值链数组), 1, i)
    .如果真 (成员_散列表 [节点索引].键值链数组 [i].键 ＝ 新的键值.键)
        .如果真 (禁止覆盖相同键)
            返回 (假)
        .如果真结束
        成员_散列表 [节点索引].键值链数组 [i].值 ＝ 新的键值.值
        返回 (真)
    .如果真结束
.变量循环尾 ()
成员_键总数量 ＝ 成员_键总数量 ＋ 1
加入成员 (成员_散列表 [节点索引].键值链数组, 新的键值)
成员_已用数据表链总数 ＝ 成员_已用数据表链总数 ＋ 1
返回 (真)
.子程序 取值, 整数型, 公开, 取指定键的值
.参数 键, 文本型
.参数 返回_键是否存在, 逻辑型, 参考 可空
.局部变量 节点索引, 整数型
.局部变量 i, 整数型
.局部变量 len, 整数型
返回_键是否存在 ＝ 假
len ＝ 取数组成员数 (成员_散列表)
.如果真 (len ＝ 0)
    返回_键是否存在 ＝ 假
    返回 (0)
.如果真结束
节点索引 ＝ 计算索引 (计算散列值 (键), len)
.变量循环首 (2, 取数组成员数 (成员_散列表 [节点索引].键值链数组), 1, i)
    .如果真 (成员_散列表 [节点索引].键值链数组 [i].键 ＝ 键)
        返回_键是否存在 ＝ 真
        返回 (成员_散列表 [节点索引].键值链数组 [i].值)
    .如果真结束
.变量循环尾 ()
返回 (0)
.子程序 删除, 逻辑型, 公开, 删除指定键的键值对
.参数 键, 文本型
.局部变量 节点索引, 整数型
.局部变量 i, 整数型
节点索引 ＝ 计算索引 (计算散列值 (键), 取数组成员数 (成员_散列表))
.变量循环首 (2, 取数组成员数 (成员_散列表 [节点索引].键值链数组), 1, i)
    .如果真 (成员_散列表 [节点索引].键值链数组 [i].键 ＝ 键)
        删除成员 (成员_散列表 [节点索引].键值链数组, i, )
        成员_键总数量 ＝ 成员_键总数量 － 1
        .如果真 (取数组成员数 (成员_散列表 [节点索引].键值链数组) ＝ 1)
            成员_已用数据表链总数 ＝ 成员_已用数据表链总数 － 1
        .如果真结束
        返回 (真)
    .如果真结束
.变量循环尾 ()
返回 (假)
.子程序 计算散列值, 整数型, , java HashCode算法
.参数 文本数据, 文本型
.局部变量 i, 整数型
.局部变量 h, 整数型
.局部变量 文本字节集, 字节集
文本字节集 ＝ 到字节集 (文本数据)
.变量循环首 (1, 取字节集长度 (文本字节集), 1, i)
    h ＝ 31 × h ＋ 文本字节集 [i]
.变量循环尾 ()
返回 (h)
' 1.可以节省内存，因为hash值在相邻，这样hash的数组可以比较小。比如当用HashMap，以String为key时。
' 2.hash值相邻，如果存放在容器，比好HashSet，HashMap中时，实际存放的内存的位置也相邻，则存取的效率也高。（程序局部性原理）
' 以31为倍数，原因了31的二进制全是1，则可以有效地离散数据。
.子程序 更新阈值
成员_扩容阈值 ＝ 成员_扩容因数 × 取数组成员数 (成员_散列表)
.子程序 计算索引, 整数型
.参数 h, 整数型
.参数 length, 整数型
返回 (取绝对值 (h ％ length) ＋ 1)
.子程序 重新索引
.参数 新表尺寸, 整数型
.局部变量 原数据表, HashMap_Str_Str_节点型, , "0"
.局部变量 新索引值, 整数型
.局部变量 i, 整数型
.局部变量 i2, 整数型
.局部变量 x, 整数型
.局部变量 t1, 整数型
复制数组 (原数据表, 成员_散列表)
重定义数组 (成员_散列表, 假, 新表尺寸)
更新阈值 ()
.变量循环首 (1, 取数组成员数 (原数据表), 1, i)
    .变量循环首 (2, 取数组成员数 (原数据表 [i].键值链数组), 1, i2)
        新索引值 ＝ 计算索引 (原数据表 [i].键值链数组 [i2].散列值, 新表尺寸)
        .如果真 (取数组成员数 (成员_散列表 [新索引值].键值链数组) ＝ 1)
            x ＝ x ＋ 1
        .如果真结束
        加入成员 (成员_散列表 [新索引值].键值链数组, 原数据表 [i].键值链数组 [i2])
    .变量循环尾 ()
.变量循环尾 ()
成员_已用数据表链总数 ＝ x
成员_重新索引次数 ＝ 成员_重新索引次数 ＋ 1
.程序集 类_HTML实体, , 公开, 源码收录自【https://bbs.125.la/forum.php?mod=viewthread&tid=14088175】
.程序集变量 m_HashTable, HashMap_StrInt, , , 这里用到了网络上的 hashmap，我觉得很轻量，内部用的是数组，所以特点是加入稍慢，但是查询速度非常好，很符合这里的应用场景
.程序集变量 m_UTF8, 字节集
.程序集变量 m_UTF8Len, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
Init ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 Init, , , 初始化，解码前必须主动调用
.局部变量 arr, 文本型, , "0"
.局部变量 i, 整数型
.局部变量 arr2, 文本型, , "0"
.局部变量 temp, 文本型
m_HashTable.初始化 ()
arr ＝ 分割文本 (#HtmlEntitiesTable, #换行符, )
temp ＝ 字符 (9)
.计次循环首 (取数组成员数 (arr), i)
    arr2 ＝ 分割文本 (arr [i], temp, )
    .如果真 (取数组成员数 (arr2) ＝ 2)
        m_HashTable.加入 (arr2 [1], 到整数 (arr2 [2]))  ' 覆盖了两个 html4 中的规范
    .如果真结束
.计次循环尾 ()
' 输出调试文本 (m_HashTable.取数量 () ＝ 1448)
' 输出调试文本 (m_HashTable.取值 (“lang”))
.子程序 解码_ANSI, , 公开, 反转义 ANSI 文本
.参数 ANSI, 文本型
解码_UTF8 (编码_Ansi到Utf8 (ANSI))
.子程序 解码_UTF8, , 公开, 反转义 UTF8 文本，内码最终选择了 UTF8，大部分网页的编码也都是 UTF8，而且可以囊括目前世界上所有的字符
.参数 UTF8, 字节集
.局部变量 Pos, 整数型, , , ebp-4
.局部变量 pUTF8, 长整数型
.局部变量 remain, 整数型
.局部变量 prejudge, 整数型
.局部变量 prejudge_Byte, 字节型
.局部变量 semicolon, 长整数型
.局部变量 semicolon_Byte, 字节型
.局部变量 i, 整数型
.局部变量 tempBool, 逻辑型
.局部变量 UnicodePoint, 整数型
.局部变量 _4BytesLen, 整数型
.局部变量 reduce, 整数型
.局部变量 temp, 长整数型
.局部变量 pAnd, 长整数型
' 1、防止传入的 UTF8 尾部不带\0
' 2、牺牲空间但是确保不改变原始数据，而且方便 Get 时的不同编码选择
m_UTF8 ＝ 取空白字节集 (取字节集长度 (UTF8) ＋ 1)
RtlMoveMemory (取指针字节集_ (m_UTF8), 取指针字节集_ (UTF8), 取字节集长度 (UTF8))
' 指针和数组(字节集)下标的配合使用是我的独门秘术，虽说指针很快，但是易里面对指针 read 和 write 都需要调用别的代码，反而不会比数组寻址快，配合使用有奇效
pUTF8 ＝ 取指针字节集_ (m_UTF8)
' 记住这里的长度为到第一个\0为止的 UTF8 长度
m_UTF8Len ＝ lstrlenA (pUTF8)
.判断循环首 (Pos ＜ m_UTF8Len)
    ' 查找 & 位置  找不到说明可以结束了
    pAnd ＝ strchr (pUTF8 ＋ Pos, 38)  ' &
    .如果真 (pAnd ＝ 0)
        跳出循环 ()
    .如果真结束
    Pos ＝ pAnd － pUTF8 ＋ 1
    remain ＝ m_UTF8Len － Pos
    .如果真 (remain ＜ 3)  ' 最短也是类似 &#9; 至少 4 字节
        跳出循环 ()
    .如果真结束
    ' 最长的是 &CapitalDifferentialD; 和 &EmptyVerySmallSquare; 有 22 字节
    ' 这个操作算是这个代码的亮点：为了限定 strchr 范围，因为这是个很慢的函数。试想如果全文都是 & 却一个 ; 也没有，每次都会搜索到字符串的结尾，将极大地干扰解码速度
    .如果 (remain ＜ 21)
        ' 此处其实有个 "BUG"   例如 &#000000000000000000000000000009; 将不会被解码，但是这种奇葩并不去考虑，因为不会有哪个转义库会生成这种
        prejudge ＝ m_UTF8Len ＋ 1  ' 尾部0
    .否则
        prejudge ＝ Pos ＋ 22
    .如果结束
    ' 交换变量 (prejudge_Byte, m_UTF8 [prejudge])'交换变量是按照 4 字节来对齐的
    prejudge_Byte ＝ m_UTF8 [prejudge]
    m_UTF8 [prejudge] ＝ 0
    ' 查找分号位置
    semicolon ＝ strchr (pUTF8 ＋ Pos － 1, 59)  ' ;
    ' 为什么这里的分支这么多：
    ' 代码可读性，尤其是易的代码可读性，有的时候和效率是不能兼得的。
    ' 如果在这里判断反条件然后 到循环尾()，编译后势必多一条指令
    ' 而这里的判断在多数情况下都会走的是那条反条件的分支，权衡之下的选择。
    .如果 (semicolon ≠ 0)  ' 指针是否会小于0
        ' 返回的是指针，算出数组下标
        semicolon ＝ semicolon － pUTF8 ＋ 1
        .如果 (semicolon － Pos ≥ 3)  ' & 和 分号 之间至少有两个字节
            ' 交换变量 (semicolon_Byte, m_UTF8 [semicolon])
            semicolon_Byte ＝ m_UTF8 [semicolon]  ' 同上面一样的技巧，这里的截止符是为了 StrToIntEx，继续往下看
            m_UTF8 [semicolon] ＝ 0
            tempBool ＝ 真
            .如果 (m_UTF8 [Pos ＋ 1] ＝ 35)  ' #  则可能是十进制或者十六进制
                .判断开始 (m_UTF8 [Pos ＋ 2] ＝ 120 或 m_UTF8 [Pos ＋ 2] ＝ 88)  ' x X
                    .变量循环首 (Pos ＋ 3, semicolon － 1, 1, i)
                        .如果真 (m_UTF8 [i] ＜ 48 或 m_UTF8 [i] ＞ 57)  ' 0-9
                            .如果真 (m_UTF8 [i] ＜ 65 或 m_UTF8 [i] ＞ 70)  ' A-F
                                .如果真 (m_UTF8 [i] ＜ 97 或 m_UTF8 [i] ＞ 102)  ' a-f
                                    tempBool ＝ 假
                                    跳出循环 ()
                                .如果真结束
                            .如果真结束
                        .如果真结束
                    .变量循环尾 ()
                    .如果真 (tempBool)  ' 确定是十六进制了
                        m_UTF8 [Pos ＋ 1] ＝ 48  ' 0 构造 0x 结构
                        StrToIntExA_整数 (pUTF8 ＋ Pos, #STIF_SUPPORT_HEX, UnicodePoint)
                    .如果真结束
                .判断 (48 ≤ m_UTF8 [Pos ＋ 2] 且 m_UTF8 [Pos ＋ 2] ≤ 57)  ' 0-9
                    .变量循环首 (Pos ＋ 3, semicolon － 1, 1, i)
                        .如果真 (m_UTF8 [i] ＜ 48 或 m_UTF8 [i] ＞ 57)  ' 0-9
                            tempBool ＝ 假
                            跳出循环 ()
                        .如果真结束
                    .变量循环尾 ()
                    .如果真 (tempBool)  ' 确定是十进制了
                        StrToIntExA_整数 (pUTF8 ＋ Pos ＋ 1, #STIF_DEFAULT, UnicodePoint)
                    .如果真结束
                .默认
                    tempBool ＝ 假
                .判断结束
            .否则
                UnicodePoint ＝ m_HashTable.取值 (指针到文本 (pUTF8 ＋ Pos))  ' 可能是关键字
                .如果真 (UnicodePoint ＝ 0)  ' 并非关键字
                    tempBool ＝ 假
                .如果真结束
            .如果结束
            .如果 (tempBool)
                ' 关于这个函数（UNICODE到UTF8）：
                ' 初学 asm，在朋友的指导下完成了一个 asm 的版本，速度肯定快了很多，压测了还行，不知道有没有坑，自行测试。
                ' 此处发布用的是 no-asm 版本的，其实就是编码知识。
                ' 关于速度：其实正常的 html 页面中并不会有太多的 HTML Entity，所以这里一般不会是瓶颈。
                _4BytesLen ＝ UNICODE到UTF8_no_asm (UnicodePoint, m_UTF8 [Pos], m_UTF8 [Pos ＋ 1], m_UTF8 [Pos ＋ 2], m_UTF8 [Pos ＋ 3])
                ' 需要改变 prejudge Pos m_UTF8 UTF8Len
                ' 其实只要关注 \0 的位置
                ' 分号后面的包括\0移过来
                RtlMoveMemory (pUTF8 ＋ Pos － 1 ＋ _4BytesLen, pUTF8 ＋ semicolon, m_UTF8Len － semicolon ＋ 1)
                reduce ＝ semicolon － Pos ＋ 1 － _4BytesLen  ' 变短的长度
                m_UTF8Len ＝ m_UTF8Len － reduce  ' 文本的长度需要改变了
                Pos ＝ Pos ＋ _4BytesLen － 1
                prejudge ＝ prejudge － reduce
            .否则
                m_UTF8 [Pos] ＝ 0  ' 同样增加分界  这样这个指针就只包含 m_UTF8[Pos+1] 到 m_UTF8[semicolon-1] 这么多字节
                temp ＝ strrchr (pUTF8 ＋ Pos, 38)  ' &  倒找
                m_UTF8 [Pos] ＝ 38  ' &
                .如果 (temp ＝ 0)
                    Pos ＝ semicolon
                .否则
                    Pos ＝ temp － pUTF8
                .如果结束
                ' 交换变量 (semicolon_Byte, m_UTF8 [semicolon])  ' 分号还得换回去
                m_UTF8 [semicolon] ＝ semicolon_Byte
                semicolon_Byte ＝ 0
            .如果结束
        .否则
            Pos ＝ semicolon
        .如果结束
    .否则
        m_UTF8 [Pos] ＝ 0
        temp ＝ strrchr (pUTF8 ＋ Pos, 38)  ' &  倒找
        m_UTF8 [Pos] ＝ 38  ' &
        .如果 (temp ＝ 0)
            Pos ＝ prejudge － 1
        .否则
            Pos ＝ temp － pUTF8
        .如果结束
    .如果结束
    ' 交换变量 (prejudge_Byte, m_UTF8 [prejudge])  ' 交换回去
    m_UTF8 [prejudge] ＝ prejudge_Byte
    prejudge_Byte ＝ 0
.判断循环尾 ()
.子程序 取值_UTF8, 字节集, 公开, 返回反转义的结果，带尾部\0的 UTF8 文本
返回 (取字节集左边 (m_UTF8, m_UTF8Len ＋ 1))
.子程序 取值_UNICODE, 字节集, 公开, 返回反转义的结果，带尾部\0\0的 UNICODE 文本
返回 (编码_Utf8到Unicode (m_UTF8))
.子程序 取值_ANSI, 文本型, 公开, 返回反转义的结果，ANSI 文本 !!! 用到了 HTML Entity 的很多都是无法用 ANSI 表达的字符，很可能乱码
返回 (编码_Utf8到Ansi (m_UTF8))
.子程序 UNICODE到UTF8_no_asm, 整数型, , 0x24B62  转  F0 A4 AD A2
.参数 NUM, 整数型, , 8
.参数 b1, 字节型, 参考, c
.参数 b2, 字节型, 参考, 10
.参数 b3, 字节型, 参考, 14
.参数 b4, 字节型, 参考, 18
.判断开始 (进制_十六到十 (“10000”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“10FFFF”))
    b4 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), NUM))
    b3 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), 右移 (NUM, 6)))
    b2 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), 右移 (NUM, 12)))
    b1 ＝ 位或 (进制_十六到十 (“F0”), 右移 (NUM, 18))
    返回 (4)
.判断 (进制_十六到十 (“0800”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“FFFF”))
    b3 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), NUM))
    b2 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), 右移 (NUM, 6)))
    b1 ＝ 位或 (进制_十六到十 (“E0”), 右移 (NUM, 12))
    返回 (3)
.判断 (进制_十六到十 (“0080”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“07FF”))
    b2 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), NUM))
    b1 ＝ 位或 (进制_十六到十 (“C0”), 右移 (NUM, 6))
    返回 (2)
.判断 (进制_十六到十 (“0000”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“007F”))
    b1 ＝ NUM
    返回 (1)
.默认
    返回 (0)
.判断结束
.程序集 类_RegExp, , 公开, 线程内请先调用 _COM初始化(0)
.程序集变量 m_RegExp, 对象
.程序集变量 m_Matches, 对象
.程序集变量 m_Match, 对象
.程序集变量 m_SubMatches, 对象
.程序集变量 m_Search, 变体型
.程序集变量 m_Null, 逻辑型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
m_Null ＝ 真
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
m_RegExp.清除 ()
m_Matches.清除 ()
m_Search.清除 ()
CoUninitialize ()
.子程序 继承, , 公开, 内部使用
.参数 RegExpClass, 类_RegExp, 参考 可空
.参数 RegExp, 变体型, 可空
.参数 Matches, 变体型, 可空
.参数 Match, 变体型, 可空
.参数 SubMatches, 变体型, 可空
.参数 Search, 变体型, 可空
.参数 Null, 逻辑型, 可空
.局部变量 l_RegExp, 变体型
.局部变量 l_Matches, 变体型
.局部变量 l_Match, 变体型
.局部变量 l_SubMatches, 变体型
.局部变量 l_Search, 变体型
.局部变量 l_Null, 逻辑型
.如果 (是否为空 (RegExpClass) ＝ 假)
    l_RegExp.赋值 (m_RegExp, )
    l_Matches.赋值 (m_Matches, )
    l_Match.赋值 (m_Match, )
    l_SubMatches.赋值 (m_SubMatches, )
    l_Search ＝ m_Search
    l_Null ＝ m_Null
    RegExpClass.继承 (, l_RegExp, l_Matches, l_Match, l_SubMatches, l_Search, l_Null)
.否则
    m_RegExp ＝ RegExp.取对象 ()
    m_Matches ＝ Matches.取对象 ()
    m_Match ＝ Match.取对象 ()
    m_SubMatches ＝ SubMatches.取对象 ()
    m_Search ＝ Search
    m_Null ＝ Null
.如果结束
.子程序 创建, 逻辑型, 公开, 根据指定的正则表达式文本创建一个正则表达式对象。本对象中的原有内容将被释放
.参数 正则表达式文本, 文本型
.参数 被搜索的文本, 文本型
.参数 是否区分大小写, 逻辑型, 可空
.参数 是否匹配多行, 逻辑型, 可空
.参数 是否全局匹配, 逻辑型, 可空
.局部变量 局_正则文本, 文本型
是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
m_RegExp.清除 ()
m_Matches.清除 ()
CoInitialize (0)
m_RegExp.创建 (“VBScript.RegExp”, )
m_RegExp.写属性 (“IgnoreCase”, 是否区分大小写)  ' 匹配时不区分大小写
m_RegExp.写属性 (“Multiline”, 是否匹配多行)  ' 是否匹配多行
m_RegExp.写属性 (“Singleline”, 真)  ' Singleline(单行模式)
m_RegExp.写属性 (“Global”, 是否全局匹配)  ' 是否全局匹配
局_正则文本 ＝ 正则表达式文本
m_RegExp.写属性 (“Pattern”, 局_正则文本)
' -----------------
m_Search.赋值 (被搜索的文本, )
m_Matches ＝ m_RegExp.对象型方法 (“Execute”, m_Search)
m_Null ＝ m_Matches.是否为空 ()
返回 (m_Null ＝ 假)
.子程序 创建类, 类_RegExp, 公开, 根据指定的正则表达式文本创建一个正则表达式对象。本对象中的原有内容将被释放
.参数 正则表达式文本, 文本型
.参数 被搜索的文本, 文本型
.参数 是否区分大小写, 逻辑型, 可空
.参数 是否匹配多行, 逻辑型, 可空
.参数 是否全局匹配, 逻辑型, 可空
.局部变量 局_RegExp, 类_RegExp
是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
创建 (正则表达式文本, 被搜索的文本, 是否区分大小写, 是否匹配多行, 是否全局匹配)
继承 (局_RegExp)
返回 (局_RegExp)
.子程序 是否空, 逻辑型, 公开
返回 (m_Null)
.子程序 取匹配, 文本型, 公开, 取出该正则匹配到的文本
.参数 匹配索引, 整数型, 可空, 索引值从1开始,留空默认1
.局部变量 Match, 对象
.局部变量 Value, 文本型
.局部变量 Item, 整数型
Item ＝ 选择 (是否为空 (匹配索引), 1, 匹配索引 － 1)
Match ＝ m_Matches.读对象型属性 (“Item”, Item)
Value ＝ Match.读属性 (“Value”, ).取文本 ()
m_Match ＝ Match
返回 (Value)
.子程序 创建自匹配, 类_RegExp, 公开, 根据指定匹配文本创建一个正则表达式对象。本对象中的原有内容将被释放
.参数 正则表达式文本, 文本型
.参数 匹配索引, 整数型, , 索引值从1开始,留空默认1
.参数 是否区分大小写, 逻辑型, 可空
.参数 是否匹配多行, 逻辑型, 可空
.参数 是否全局匹配, 逻辑型, 可空
是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
返回 (创建类 (正则表达式文本, 取匹配 (匹配索引), 是否区分大小写, 是否匹配多行, 是否全局匹配))
.子程序 替换, 文本型, 公开, 替换在正则表达式查找中找到的文本
.参数 用作替换的文本, 文本型, 可空, 用作替换的文本
.局部变量 局_用作替换的文本, 变体型
局_用作替换的文本.赋值 (用作替换的文本, )
返回 (m_RegExp.文本方法 (“Replace”, m_Search, 局_用作替换的文本))
.子程序 创建自替换, 类_RegExp, 公开, 根据指定匹配文本创建一个正则表达式对象。本对象中的原有内容将被释放
.参数 正则表达式文本, 文本型
.参数 用作替换的文本, 文本型, , 索引值从1开始,留空默认1
.参数 是否区分大小写, 逻辑型, 可空
.参数 是否匹配多行, 逻辑型, 可空
.参数 是否全局匹配, 逻辑型, 可空
是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
返回 (创建类 (正则表达式文本, 替换 (用作替换的文本), 是否区分大小写, 是否匹配多行, 是否全局匹配))
.子程序 取子匹配, 文本型, 公开, 取出该正则的子表达式匹配到的文本
.参数 匹配索引, 整数型, 可空, 索引值从1开始
.参数 子表达式索引, 整数型, 可空, 欲取其值的子表达式,该参数对应与正则表达式中的一个子表达式以圆括号"( )"为标记,索引从1开始
.局部变量 Match, 对象
.局部变量 SubMatches, 对象
.局部变量 value, 文本型
.局部变量 Item, 整数型
Item ＝ 选择 (是否为空 (匹配索引), 1, 匹配索引 － 1)
Match ＝ m_Matches.读对象型属性 (“Item”, Item)
SubMatches ＝ Match.读对象型属性 (“SubMatches”, )
Item ＝ 选择 (是否为空 (子表达式索引), 1, 子表达式索引 － 1)
value ＝ SubMatches.读属性 (“Item”, Item).取文本 ()
m_Match ＝ Match
m_SubMatches ＝ SubMatches
返回 (value)
.子程序 创建自子匹配, 类_RegExp, 公开, 根据指定匹配文本创建一个正则表达式对象。本对象中的原有内容将被释放
.参数 正则表达式文本, 文本型
.参数 匹配索引, 整数型, , 索引值从1开始
.参数 子表达式索引, 整数型, , 欲取其值的子表达式,该参数对应与正则表达式中的一个子表达式以圆括号"( )"为标记,索引从1开始
.参数 是否区分大小写, 逻辑型, 可空
.参数 是否匹配多行, 逻辑型, 可空
.参数 是否全局匹配, 逻辑型, 可空
是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
返回 (创建类 (正则表达式文本, 取子匹配 (匹配索引, 子表达式索引), 是否区分大小写, 是否匹配多行, 是否全局匹配))
.子程序 取匹配数, 整数型, 公开, 取出该正则匹配到的数量
返回 (m_Matches.读数值属性 (“Count”, ))
.子程序 取子匹配数, 整数型, 公开, 取出该正则的子表达式匹配到的数量
返回 (m_Matches.读对象型属性 (“Item”, 0).读对象型属性 (“SubMatches”, ).读数值属性 (“Count”, ))
.子程序 取位置, 整数型, 公开, 取匹配起始位置
.参数 匹配索引, 整数型, 可空
.局部变量 l_FirstIndex, 整数型
.局部变量 l_Bytes, 字节集
.局部变量 l_Len, 整数型
.局部变量 l_Width, 整数型
.局部变量 l_Point, 整数型
.局部变量 l_Item, 整数型
.局部变量 n, 整数型
.局部变量 i, 整数型
l_Item ＝ 选择 (是否为空 (匹配索引), 1, 匹配索引 － 1)
取匹配 (l_Item)
l_FirstIndex ＝ m_Match.读数值属性 (“FirstIndex”, )
.如果真 (l_FirstIndex ＞ 0)
    l_Bytes ＝ 到字节集 (m_Search.取文本 ())
    l_Len ＝ 取字节集长度 (l_Bytes)
    n ＝ 1
    i ＝ 0
    .判断循环首 (n ＜ l_Len)
        .判断开始 (n ＋ 1 ＞ l_Len)
            l_Width ＝ 1
        .判断 (l_Bytes [n] ＞ 128)
            l_Width ＝ 2
        .默认
            l_Width ＝ 1
        .判断结束
        .如果真 (i ≥ l_FirstIndex)
            跳出循环 ()
        .如果真结束
        n ＝ n ＋ l_Width
        i ＝ i ＋ 1
    .判断循环尾 ()
.如果真结束
返回 (n)
.程序集 类_DOM, , 公开
.程序集变量 类成员_对象, 对象
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
' https://bbs.125.la/forum.php?mod=viewthread&tid=14482679
' CoInitialize (0)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
' CoUninitialize ()
.子程序 创建, 逻辑型, 公开
.局部变量 ww, 逻辑型
.局部变量 局_对象, 对象
ww ＝ 局_对象.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
局_对象.写属性 (“designMode”, “on”)
类成员_对象 ＝ 局_对象
返回 (ww)
.子程序 解析, 逻辑型, 公开
.参数 html文本, 文本型
.局部变量 ww, 逻辑型
.局部变量 局_对象, 对象
ww ＝ 局_对象.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
局_对象.写属性 (“designMode”, “on”)
类成员_对象.清除 ()
类成员_对象 ＝ 局_对象
类成员_对象.方法 (“write”, html文本)
返回 (真)
.子程序 _____继承______, , 公开, 内部使用,外部别用
.参数 参数_对象, 对象, 参考
类成员_对象 ＝ 参数_对象
.子程序 取节点_按节点名_数组, 类_DOM_数组, 公开, TagName 建议在解析主对象用,返回的对象不一定有用 有效,------------需要.读对象型属性 (“body”, )
.参数 参数_节点名, 文本型
.局部变量 局_dom, 类_DOM_数组
局_dom._____继承______ (类成员_对象.对象型方法 (“getElementsByTagName”, 参数_节点名))
返回 (局_dom)
.子程序 取节点_按Name_数组, 类_DOM_数组, 公开, Name   有效
.参数 Name, 文本型
.局部变量 局_dom_pro, 类_DOM_数组
局_dom_pro._____继承______ (类成员_对象.对象型方法 (“getElementsByName”, Name))
返回 (局_dom_pro)
.子程序 取节点_按Class_数组, 类_DOM_数组, 公开, Class 测试有效,.读对象型属性 (“body”, )
.参数 class, 文本型
.局部变量 局_dom_pro, 类_DOM_数组
局_dom_pro._____继承______ (类成员_对象.对象型方法 (“getElementsByClassName”, class))
返回 (局_dom_pro)
.子程序 取节点_数组_全部子节点, 类_DOM_数组, 公开, css表达式 测试有效.---.读对象型属性 (“body”, )
.局部变量 局_dom_pro, 类_DOM_数组
局_dom_pro._____继承______ (类成员_对象.读对象型属性 (“childNodes”, ))
返回 (局_dom_pro)
.子程序 取节点_数组_全部后代, 类_DOM_数组, 公开, css表达式 测试有效.---.读对象型属性 (“body”, )
.局部变量 局_dom_pro, 类_DOM_数组
局_dom_pro._____继承______ (类成员_对象.读对象型属性 (“all”, ))
返回 (局_dom_pro)
.子程序 _css_数组, 类_DOM_数组, 公开, css表达式 可用
.参数 css表达式, 文本型, 参考
.局部变量 局_dom_pro, 类_DOM_数组
局_dom_pro._____继承______ (类成员_对象.对象型方法 (“querySelectorAll”, css表达式))
返回 (局_dom_pro)
.子程序 _css_数组2, 类_DOM_数组, 公开, css表达式 可用
.参数 css表达式, 文本型, 参考
.局部变量 局_dom_pro, 类_DOM_数组
.局部变量 html文本, 文本型
.局部变量 局_对象, 对象
.局部变量 局_对象2, 对象
html文本 ＝ “<html><body>” ＋ 类成员_对象.读文本属性 (“outerHTML”, ) ＋ “</body></html>”
局_对象.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
局_对象.写属性 (“designMode”, “on”)
局_对象.方法 (“write”, html文本)
局_对象2 ＝ 局_对象.对象型方法 (“querySelectorAll”, css表达式)
局_dom_pro._____继承______ (局_对象2)
返回 (局_dom_pro)
.子程序 _css_1, 类_DOM, 公开, css表达式 只返回首个匹配结果
.参数 css表达式, 文本型
.局部变量 局_dom_pro, 类_DOM
局_dom_pro._____继承______ (类成员_对象.对象型方法 (“querySelector”, css表达式))
返回 (局_dom_pro)
.子程序 取节点_按id_1, 类_DOM, 公开
.参数 参数_ID, 文本型
.局部变量 局_dom_pro, 类_DOM
局_dom_pro._____继承______ (类成员_对象.对象型方法 (“getElementById”, 参数_ID))
返回 (局_dom_pro)
.子程序 取父节点_1, 类_DOM, 公开, css表达式 测试有效......读对象型属性 (“body”, )
.局部变量 局_dom_pro, 类_DOM
局_dom_pro._____继承______ (类成员_对象.读对象型属性 (“parentNode”, ))
返回 (局_dom_pro)
.子程序 _Body_, 类_DOM, 公开
.局部变量 局_dom, 类_DOM
局_dom._____继承______ (类成员_对象.读对象型属性 (“body”, ))
返回 (局_dom)
.子程序 取框架_iframe, 类_DOM, 公开, iframe
.局部变量 局_dom, 类_DOM
返回 (局_dom)
.子程序 是否有某属性, 逻辑型, 公开, 有用
.参数 属性名_参数, 文本型
返回 (类成员_对象.逻辑方法 (“hasAttribute”, 属性名_参数))
.子程序 是否有_属性, 逻辑型, 公开, 有用
返回 (类成员_对象.逻辑方法 (“hasAttributes”, ))
.子程序 是否有子节点, 逻辑型, 公开, so   有用
返回 (类成员_对象.逻辑方法 (“hasChildNodes”, ))
.子程序 取节点类型, 整数型, 公开, 某个数字代表某个类型,需要翻译
返回 (到整数 (类成员_对象.读数值属性 (“nodeType”, )))
.子程序 取属性值_按属性名, 文本型, 公开, value   有用
.参数 属性名_参数, 文本型
返回 (类成员_对象.文本方法 (“getAttribute”, 属性名_参数))
.子程序 取节点名, 文本型, 公开, 标签名
返回 (类成员_对象.读文本属性 (“tagName”, ))
.子程序 取title, 文本型, 公开, 标题
返回 (类成员_对象.读文本属性 (“title”, ))
.子程序 取ID, 文本型, 公开, id
返回 (类成员_对象.读文本属性 (“id”, ))
.子程序 取class, 文本型, 公开
返回 (类成员_对象.读文本属性 (“className”, ))
.子程序 取href, 文本型, 公开, href,就是链接,网页中的链接
返回 (类成员_对象.读文本属性 (“href”, ))
.子程序 取outerText, 文本型, 公开
返回 (类成员_对象.读文本属性 (“outerText”, ))
.子程序 取innerText, 文本型, 公开
返回 (类成员_对象.读文本属性 (“innerText”, ))
.子程序 取textContent, 文本型, 公开, 本节点可见字符串
返回 (类成员_对象.读文本属性 (“textContent”, ))
.子程序 取innerHTML, 文本型, 公开, 全部后代源码,不包含自己
返回 (类成员_对象.读文本属性 (“innerHTML”, ))
.子程序 取outerHTML, 文本型, 公开, 全部后代源码,包含自己
返回 (类成员_对象.读文本属性 (“outerHTML”, ))
.程序集 类_DOM_数组, , 公开
.程序集变量 类成员_对象, 对象
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 _____继承______, , 公开, 内部使用,外部别用
.参数 参数_对象, 对象, 参考
类成员_对象 ＝ 参数_对象
.子程序 _, 类_DOM, 公开, 取成员
.参数 索引, 整数型, 可空, 从1开始,为空就是第一个
.局部变量 局_DOM, 类_DOM
索引 ＝ 选择 (是否为空 (索引), 1, 索引)
局_DOM._____继承______ (类成员_对象.对象型方法 (“item”, 索引 － 1))
返回 (局_DOM)
.子程序 取成员, 类_DOM, 公开, 取成员
.参数 索引, 整数型, 可空, 从1开始,为空就是第一个
.局部变量 局_DOM, 类_DOM
索引 ＝ 选择 (是否为空 (索引), 1, 索引)
局_DOM._____继承______ (类成员_对象.对象型方法 (“item”, 索引 － 1))
返回 (局_DOM)
.子程序 取成员数, 整数型, 公开, 取成员数
返回 (到整数 (类成员_对象.读数值属性 (“length”, )))
.程序集 集_文本
.程序集变量 集_计次, 整数型
.子程序 数组_去重复_整数型, 整数型, 公开, 返回剩余不重复数组的成员数量
.参数 整数数组, 整数型, 数组, 要去重复的 整数数组
.局部变量 成员数, 整数型
.局部变量 i, 长整数型
.局部变量 a, 整数型
' 该历程收录自：https://bbs.125.la/thread-14402954-1-1.html
数组排序 (整数数组, 真)
成员数 ＝ 取数组成员数 (整数数组)
i ＝ 0
a ＝ 1
.判断循环首 (a ≤ 成员数)
    i ＝ i ＋ 1
    整数数组 [i] ＝ 整数数组 [a]
    .循环判断首 ()
        a ＝ a ＋ 1
        .如果真 (a ＞ 成员数)
            跳出循环 ()
        .如果真结束
    .循环判断尾 (整数数组 [i] ＝ 整数数组 [a])
.判断循环尾 ()
重定义数组 (整数数组, 真, i)
返回 (i)
.子程序 文本_取长度ex, 整数型, 公开, 全角汉字字符算一个长度
.参数 参数_被计算文本, 文本型
' 命令出自：https://bbs.125.la/thread-14326444-1-1.html
返回 (MultiByteToWideChar (0, 0, 取指针文本_ (参数_被计算文本), 文本_取长度 (参数_被计算文本), 0, 0))
.子程序 文本_分割文本, 整数型, 公开, 能够将连续的分隔符视为一个分隔符 返回成员数
.参数 待分割文本, 文本型
.参数 分隔符, 文本型, 可空
.参数 返回子文本数目, 整数型, 可空
.参数 返回数组, 文本型, 参考 数组
.局部变量 i, 整数型
.局部变量 临时数组, 文本型, , "0"
重定义数组 (返回数组, 假, 0)
.如果真 (分隔符 ＝ “”)
    分隔符 ＝ “,”
.如果真结束
.如果 (返回子文本数目 ＝ 0)
    临时数组 ＝ 分割文本 (待分割文本, 分隔符, )
.否则
    临时数组 ＝ 分割文本 (待分割文本, 分隔符, 返回子文本数目)
.如果结束
.计次循环首 (取数组成员数 (临时数组), i)
    .如果真 (临时数组 [i] ≠ “”)
        加入成员 (返回数组, 临时数组 [i])
    .如果真结束
.计次循环尾 ()
返回 (取数组成员数 (返回数组))
.子程序 文本_寻找文本, 整数型, 公开, 成功找到返回位置索引，未找到返回-1。调用Ntdll命令，比核心库快三倍以上，注意！此命令不是严格按易语言文本型来查找。
.参数 参_原始文本, 文本型
.参数 参_查找文本, 文本型
.参数 参_搜寻位置, 整数型, 可空, 可以被省略。位置值从 1 开始。如果本参数被省略，默认为 1
.参数 参_不分大写, 逻辑型, 可空, 初始值为“假”。为真不区分大小写，为假区分。
.局部变量 局_原始文本, 文本型
.局部变量 局_查找文本, 文本型
.如果真 (参_搜寻位置 ＝ 0)
    参_搜寻位置 ＝ 1
.如果真结束
.如果真 (取文本长度 (参_原始文本) ＝ 0 或 取文本长度 (参_查找文本) ＝ 0)
    返回 (-1)
.如果真结束
.判断开始 (参_不分大写)
    局_原始文本 ＝ 参_原始文本
    局_查找文本 ＝ 参_查找文本
    返回 (_寻找文本 (API_文本小写 (局_原始文本), API_文本小写 (局_查找文本), 参_搜寻位置))
.默认
    返回 (_寻找文本 (参_原始文本, 参_查找文本, 参_搜寻位置))
.判断结束
.子程序 _寻找文本, 整数型
.参数 原始文本, 文本型
.参数 查找文本, 文本型
.参数 搜寻位置, 整数型
.局部变量 查找索引, 整数型
.局部变量 文本地址, 整数型
.如果真 (原始文本 ＝ “”)
    返回 (-1)
.如果真结束
文本地址 ＝ 取指针文本_ (原始文本)
搜寻位置 ＝ 搜寻位置 － 1
查找索引 ＝ API_查找文本 (文本地址 ＋ 搜寻位置, 查找文本)
.如果真 (查找索引 ＝ 0)
    返回 (-1)
.如果真结束
返回 (查找索引 － 文本地址 ＋ 1)
.子程序 文本_是否UTF8_汇编, 逻辑型, 公开, utf8编码返回真, 其他编码返回假, 支持多线程; 感谢【@jr21066 】
.参数 参_内容, 字节集
.如果真 (参_内容 ＝ {  })
    返回 (假)
.如果真结束
置入代码 ({ 86, 87, 83, 139, 69, 8, 139, 24, 139, 75, 4, 139, 48, 131, 198, 8, 139, 67, 8, 37, 255, 255, 255, 0, 61, 191, 187, 239, 0, 116, 101, 172, 138, 224, 60, 127, 118, 88, 192, 232, 6, 60, 6, 117, 19, 172, 80, 192, 232, 6, 60, 2, 117, 74, 88, 192, 232, 7, 60, 0, 116, 70, 235, 62, 138, 196, 192, 232, 4, 60, 14, 117, 18, 172, 192, 232, 6, 60, 2, 117, 47, 172, 192, 232, 6, 60, 2, 117, 39, 235, 41, 138, 196, 192, 232, 3, 60, 30, 117, 28, 172, 192, 232, 6, 60, 2, 117, 20, 172, 192, 232, 6, 60, 2, 117, 12, 172, 192, 232, 6, 60, 2, 117, 4, 235, 6, 226, 159, 51, 192, 235, 3, 51, 192, 64, 91, 95, 94, 201, 194, 4, 0 })
返回 (假)
' *** 缩略程序块 ***
.子程序 文本_均分文本, , 公开, 方便将大的文件内容均分为几段来处理
.参数 参_内容, 字节集, , 要处理的文本内容
.参数 参_文本数组, 文本型, 数组, 用于存放返回文本的数组
.参数 参_分割数, 整数型, , 分割的段数
.局部变量 局_区间值, 整数型
.局部变量 局_偏移, 整数型
.局部变量 局_内容, 字节集
.局部变量 局_计数器, 整数型
' 复制源内容,保护原文本
局_内容 ＝ 参_内容
' 求区段长度
局_区间值 ＝ 四舍五入 (取字节集长度 (局_内容) ÷ 参_分割数, )
清除数组 (参_文本数组)
.计次循环首 (参_分割数 － 1, 局_计数器)
    ' 寻找上一换行符位置,分割完整的文本行
    局_偏移 ＝ 倒找字节集 (局_内容, { 13, 10 }, 局_区间值)
    加入成员 (参_文本数组, 到文本 (取字节集中间 (局_内容, 1, 局_偏移)))
    局_内容 ＝ 取字节集右边 (局_内容, 取字节集长度 (局_内容) － 局_偏移)
.计次循环尾 ()
' 最后一段文本
加入成员 (参_文本数组, 到文本 (局_内容))
.子程序 文本_均分文本1, 文本型, 公开, 按长度给文本加入换行符
.参数 欲均分的文本, 文本型
.参数 每行文本长度, 整数型
.局部变量 局_判断, 逻辑型
.局部变量 局_分割, 文本型, , "0"
.局部变量 局_编码, 文本型
.局部变量 局_返回, 文本型
.局部变量 i, 整数型
' https://bbs.125.la/forum.php?mod=viewthread&tid=14622764
局_编码 ＝ 编码_Ansi到Unicode_文本型 (欲均分的文本)
局_分割 ＝ 分割文本 (局_编码, “&#”, )
局_判断 ＝ 真
.计次循环首 (取数组成员数 (局_分割), i)
    局_返回 ＝ 局_返回 ＋ 编码_Unicode到Ansi_文本型 (“&#” ＋ 局_分割 [i])
    .如果真 (取文本长度 (局_返回) ≥ 每行文本长度 且 局_判断 ＝ 真)
        局_返回 ＝ 局_返回 ＋ #换行符
        局_判断 ＝ 假
    .如果真结束
    .如果真 (局_判断 ＝ 假)
        .如果真 (取文本长度 (文本_取右边 (局_返回, #换行符, , )) ≥ 每行文本长度)
            局_返回 ＝ 局_返回 ＋ #换行符
        .如果真结束
    .如果真结束
.计次循环尾 ()
返回 (局_返回)
.子程序 文本_删除空行_汇编, 文本型, 公开, 汇编,一次完成搜索替换 感谢【@jr21066 】分享开源
.参数 参_内容, 文本型
.局部变量 返回值, 文本型
.如果真 (参_内容 ＝ “”)
    返回 (“”)
.如果真结束
返回值 ＝ 取空白文本 (取文本长度 (参_内容))
' 打个补丁,用于处理第一个字符就是换行符的特殊情况
.如果 (取文本左边 (参_内容, 2) ＝ #换行符)
    取指针文本_ (参_内容)
    置入代码 ({ 64, 64 })
.否则
    取指针文本_ (参_内容)
.如果结束
置入代码 ({ 96, 137, 198, 139, 125, 252, 172, 132, 192, 116, 22, 60, 13, 117, 12, 170, 172, 170, 172, 132, 192, 116, 10, 60, 13, 116, 3, 170, 235, 232, 70, 235, 241, 49, 192, 170, 97 })
返回 (返回值)
.子程序 文本_取全部汉字拼音, 文本型, 公开, 支持取出文本中所有国标汉字的拼音，默认不保留非国标汉字字符。
.参数 文本, 文本型, , 欲取拼音的文本
.参数 保留非汉字, 逻辑型, 可空, 默认假，不保留原文本里的符号和数字等非国标汉字字符；真则保留。
.局部变量 b, 字节集
.局部变量 c, 整数型
.局部变量 n, 整数型
.局部变量 z, 整数型
.局部变量 ret, 文本型
.局部变量 p0, 文本型
.局部变量 p1, 文本型
.如果真 (是否为空 (保留非汉字))
    保留非汉字 ＝ 假
.如果真结束
b ＝ 到字节集 (文本)
c ＝ 取字节集长度 (b)
n ＝ 1
.判断循环首 (n ≤ c)
    .如果 (n ＞ c)
        z ＝ 1
    .否则
        .如果 (b [n] ＞ 128)
            z ＝ 2
            p0 ＝ 到文本 (取字节集中间 (b, n, 2))
            p1 ＝ 取拼音 (p0, 1)
            .判断开始 (取文本长度 (删全部空 (p1)) ≠ 0)
                ret ＝ ret ＋ p1 ＋ “空”
            .默认
                .如果真 (保留非汉字)
                    ret ＝ ret ＋ p0
                .如果真结束
            .判断结束
        .否则
            .如果 (b [n] ≠ 13)
                z ＝ 1
            .否则
                .如果 (b [n ＋ 1] ＝ 10)
                    z ＝ 2
                .否则
                    z ＝ 1
                .如果结束
            .如果结束
            .如果真 (保留非汉字)
                .如果 (取文本长度 (删全部空 (取拼音 (到文本 (取字节集中间 (b, n ＋ 1, 2)), 1))) ≠ 0)  ' ‘判断单字节字符后面是否是双字节字符
                    ret ＝ ret ＋ 到文本 (取字节集中间 (b, n, z)) ＋ “空”
                .否则
                    ret ＝ ret ＋ 到文本 (取字节集中间 (b, n, z))
                .如果结束
            .如果真结束
        .如果结束
    .如果结束
    n ＝ n ＋ z
.判断循环尾 ()
ret ＝ 子文本替换 (ret, “ ”, “”, , , 真)  ' ’删除中间多余的空格
ret ＝ 子文本替换 (ret, “空”, “ ”, , , 真)  ' ’把用作隔开的“空”替换为“ ”
.如果真 (取文本右边 (ret, 1) ＝ “ ”)  ' ’删除尾部多余空格
    ret ＝ 取文本左边 (ret, 取文本长度 (ret) － 1)
.如果真结束
返回 (ret)
.子程序 文本_插入文本到关键字所在行后, 文本型, 公开, 插入文本到关键字所在行后，返回处理后的文本  [Harry· 提供]
.参数 原文本, 文本型
.参数 关键字, 文本型
.参数 插入内容, 文本型
.参数 是否换行, 逻辑型, 可空, 是否换行插入文本，默认为真
.局部变量 i, 整数型
.局部变量 临时数组, 文本型, , "0"
.局部变量 临时文本, 文本型
临时数组 ＝ 分割文本 (原文本, #换行符, )
.如果真 (是否为空 (是否换行) ＝ 真)
    是否换行 ＝ 真
.如果真结束
.计次循环首 (取数组成员数 (临时数组), i)
    .如果真 (寻找文本 (临时数组 [i], 关键字, , 假) ≠ -1)
        .如果 (是否换行 ＝ 真)
            临时数组 [i] ＝ 临时数组 [i] ＋ #换行符 ＋ 插入内容 ＋ #换行符
        .否则
            临时数组 [i] ＝ 临时数组 [i] ＋ 插入内容 ＋ #换行符
        .如果结束
    .如果真结束
    临时文本 ＝ 临时文本 ＋ 临时数组 [i]
.计次循环尾 ()
返回 (临时文本)
.子程序 文本_删左边, 文本型, 公开
.参数 欲处理文本, 文本型
.参数 删除长度, 整数型
返回 (取文本右边 (欲处理文本, 取文本长度 (欲处理文本) － 删除长度))
.子程序 文本_删右边, 文本型, 公开
.参数 欲处理文本, 文本型
.参数 删除长度, 整数型
返回 (取文本左边 (欲处理文本, 取文本长度 (欲处理文本) － 删除长度))
.子程序 文本_删中间, 文本型, 公开
.参数 欲处理文本, 文本型
.参数 起始位置, 整数型
.参数 删除长度, 整数型
返回 (取文本左边 (欲处理文本, 起始位置 － 1) ＋ 文本_删左边 (欲处理文本, 起始位置 ＋ 删除长度 － 1))
.子程序 文本_删中间2, 文本型, 公开, 本命令会删除前面文本和后面文本之间的所有内容（包括后面文本），如文本中含有多个前面文本或后面文本则删除首个前面文本与最后一个后面文本之间的所有内容。
.参数 原文本, 文本型, , 待处理的文本
.参数 前面文本, 文本型
.参数 后面文本, 文本型
.参数 是否不区分大小写, 逻辑型, 可空, 默认为假，即区分大小写。
.参数 保留前面文本, 逻辑型, 可空, 默认为假
.参数 保留后面文本, 逻辑型, 可空, 默认为假
.局部变量 局_开始位置, 整数型
.局部变量 局_结束位置, 整数型
.局部变量 局_返回文本, 文本型
.局部变量 局_右边文本, 文本型
.局部变量 局_返回后文本, 文本型
.局部变量 局_返回前文本, 文本型
局_开始位置 ＝ 寻找文本 (原文本, 前面文本, , 是否不区分大小写)
.如果真 (局_开始位置 ＝ -1)
    返回 (原文本)
.如果真结束
局_返回前文本 ＝ 取文本左边 (原文本, 局_开始位置 － 1)
.如果真 (保留前面文本)
    局_返回前文本 ＝ 局_返回前文本 ＋ 前面文本
.如果真结束
局_右边文本 ＝ 取文本右边 (原文本, 取文本长度 (原文本) － 取文本长度 (局_返回前文本))
局_结束位置 ＝ 倒找文本 (局_右边文本, 后面文本, , 是否不区分大小写)
.如果真 (局_结束位置 ＝ -1)
    返回 (原文本)
.如果真结束
局_返回后文本 ＝ 取文本右边 (局_右边文本, 取文本长度 (局_右边文本) － 局_结束位置 － 取文本长度 (后面文本) ＋ 1)
局_返回文本 ＝ 局_返回前文本 ＋ 局_返回后文本
.如果真 (保留后面文本)
    局_返回文本 ＝ 局_返回前文本 ＋ 后面文本 ＋ 局_返回后文本
.如果真结束
返回 (局_返回文本)
.子程序 文本_取出文本中汉字, 文本型, 公开, 取出指定文本中的汉字
.参数 字符串, 文本型
.局部变量 字节集长度, 整数型
.局部变量 字节集, 字节集
.局部变量 取出位置, 整数型
.局部变量 文本, 文本型
字节集 ＝ 到字节集 (字符串)
字节集长度 ＝ 取字节集长度 (字节集)
取出位置 ＝ 1
.判断循环首 (取出位置 ＜ 字节集长度)
    .判断开始 (字节集 [取出位置] ≥ 176 且 字节集 [取出位置 ＋ 1] ≥ 161 且 字节集 [取出位置] ≤ 247 且 字节集 [取出位置 ＋ 1] ≤ 254)  ' 判断GBK/2: GB2312 汉字
        文本 ＝ 文本 ＋ 到文本 (取字节集中间 (字节集, 取出位置, 2))
        取出位置 ＝ 取出位置 ＋ 2
    .判断 (字节集 [取出位置] ＞ 127 且 字节集 [取出位置 ＋ 1] ＞ 127)  ' 判断是否全角字符)
        取出位置 ＝ 取出位置 ＋ 2
    .默认
        取出位置 ＝ 取出位置 ＋ 1
    .判断结束
.判断循环尾 ()
返回 (文本)
.子程序 文本_取随机Ip, 文本型, 公开, 返回一个随机的IP地址
.参数 只取国内, 逻辑型, 可空, 可空，默认为真
.局部变量 局_Ip, 文本型, , "0"
.局部变量 Arr, 文本型, , "0"
.局部变量 Str, 文本型
.局部变量 局_IP1, 文本型
.局部变量 局_IP2, 文本型
.局部变量 局_IP头, 文本型
.局部变量 IP数组1, 文本型, , "0"
.局部变量 IP数组2, 文本型, , "0"
置随机数种子 ()
.如果真 (是否为空 (只取国内))
    只取国内 ＝ 真
.如果真结束
.如果真 (只取国内)
    .如果真 (取数组成员数 (局_Ip) ＝ 0)
        局_Ip ＝ 分割文本 (#常量_IP, #换行符, )
    .如果真结束
    Str ＝ 局_Ip [取随机数 (1, 取数组成员数 (局_Ip))]
    局_IP1 ＝ 文本_取左边 (Str, “-”)
    局_IP2 ＝ 文本_取右边 (Str, “-”)
    IP数组1 ＝ 分割文本 (局_IP1, “.”, )
    IP数组2 ＝ 分割文本 (局_IP2, “.”, )
    .如果真 (取数组成员数 (IP数组1) ≠ 4 或 取数组成员数 (IP数组2) ≠ 4)
        返回 (文本_取随机Ip (只取国内))
    .如果真结束
    Str ＝ IP数组1 [1] ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [2]), 到整数 (IP数组2 [2])))
    Str ＝ Str ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [3]), 到整数 (IP数组2 [3])))
    Str ＝ Str ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [4]), 到整数 (IP数组2 [4])))
    返回 (Str)
.如果真结束
.如果真 (取数组成员数 (局_Ip) ＝ 0)
    Str ＝ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254))
.如果真结束
返回 (Str)
.子程序 文本_逐字分割, 整数型, 公开, 将指定文本,逐字分割成数组,保存为指定的变量数组中,返回成员个数,可识别换行符及全半角字符和汉字
.参数 文本, 文本型, , 需要分割的文本
.参数 返回的数组, 文本型, 参考 可空 数组, 保存分割结果的数组变量
.局部变量 c, 整数型
.局部变量 n, 整数型
.局部变量 z, 整数型
.局部变量 返回文本, 文本型
.局部变量 临时字节集, 字节集
清除数组 (返回的数组)
临时字节集 ＝ 到字节集 (文本)
c ＝ 取字节集长度 (临时字节集)
n ＝ 1
.判断循环首 (n ≤ c)
    .如果 (n ＋ 1 ＞ c)
        z ＝ 1
    .否则
        .如果 (临时字节集 [n] ＞ 128)
            z ＝ 2
        .否则
            .如果 (临时字节集 [n] ≠ 13)
                z ＝ 1
            .否则
                .如果 (临时字节集 [n ＋ 1] ＝ 10)
                    z ＝ 2
                .否则
                    z ＝ 1
                .如果结束
            .如果结束
        .如果结束
    .如果结束
    加入成员 (返回的数组, 到文本 (取字节集中间 (临时字节集, n, z)))
    n ＝ n ＋ z
.判断循环尾 ()
返回 (取数组成员数 (返回的数组))
.子程序 文本_逐字分割_汇编, 整数型, 公开, 超长文本计算时有优势 调用该命令前请确定内容不为空
.参数 参_内容, 文本型
.参数 参_文本数组, 文本型, 数组
.局部变量 返回值, 文本型
' 例程收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14228410
.如果真 (参_内容 ＝ “”)
    返回 (0)
.如果真结束
返回值 ＝ 取空白文本 (取文本长度 (参_内容) × 2)
置入代码 ({ 139, 69, 8, 139, 48, 139, 125, 252, 172, 168, 128, 117, 26, 60, 32, 116, 247, 60, 9, 116, 243, 60, 13, 116, 239, 60, 10, 116, 235, 132, 192, 116, 28, 170, 176, 9, 170, 235, 225, 60, 161, 117, 10, 134, 224, 172, 60, 161, 116, 214, 134, 224, 78, 170, 172, 170, 176, 9, 170, 235, 203, 49, 192, 170 })
参_文本数组 ＝ 分割文本 (返回值, 到文本 ({ 9 }), )
返回 (取数组成员数 (参_文本数组))
.子程序 文本_逐字分割_快速, 整数型, 公开, @福仔 【注意】 必须和 文本_逐字分割_快速_释放() 配套使用, 如果不释放可能会导致崩溃, 快速把一个文本按每个字符进行分割, 返回分割后的成员数
.参数 待分割文本, 文本型
.参数 接收结果数组, 文本型, 参考 数组, 调用完之后必须调用 文本_逐字分割_快速_释放() 把这个数组传递进去进行释放, 不允许修改这个数组
.参数 换行符是否为单个字符, 逻辑型, 可空, 为真则 \r\n(13, 10) 算一个成员, 否则会分割成两个成员, 默认为真
.局部变量 len, 整数型
.局部变量 i, 整数型
.局部变量 pBuf, 整数型
.局部变量 pStr, 整数型
.局部变量 by, 整数型
.局部变量 offset, 整数型
.局部变量 n, 整数型
.局部变量 pAry, 整数型
.如果真 (是否为空 (换行符是否为单个字符))
    换行符是否为单个字符 ＝ 真
.如果真结束
pStr ＝ 取指针_文本型 (待分割文本)
len ＝ lstrlenA (pStr)
pBuf ＝ malloc (len × 3)
memset (pBuf, 0, len × 3)
重定义数组 (接收结果数组, 假, len)
pAry ＝ 取数据_通用型_数组 (接收结果数组)
.判断循环首 (i ＜ len)
    __set (pAry, n × 4, pBuf ＋ offset)
    by ＝ __get_byte (pStr, i)
    __set_byte (pBuf, offset, by)
    offset ＝ offset ＋ 1
    .如果真 (by ＞ 128 或 换行符是否为单个字符 且 by ＝ 13)
        i ＝ i ＋ 1
        __set_byte (pBuf, offset, __get_byte (pStr, i))
        offset ＝ offset ＋ 1
    .如果真结束
    offset ＝ offset ＋ 1
    n ＝ n ＋ 1
    i ＝ i ＋ 1
.判断循环尾 ()
__set (pAry － 4, 0, n)  ' 直接修改成员数
' 重定义数组 (接收结果数组, 真, n)
返回 (n)
.子程序 文本_逐字分割_快速_释放, , 公开, @福仔 释放 文本_逐字分割_快速() 参考返回的数组
.参数 接收结果数组, 文本型, 参考 数组, 文本_逐字分割_快速() 第二个参数
.局部变量 pAry, 整数型
.局部变量 ptr, 整数型
.局部变量 i, 整数型
pAry ＝ 取数据_通用型_数组 (接收结果数组)
ptr ＝ __get (pAry, 0)  ' 文本_逐字分割_快速是把指针保存在第一个成员里, 取出来释放
.如果真 (ptr ＝ 0)
    返回 ()
.如果真结束
free (ptr)
.计次循环首 (取数组成员数 (接收结果数组), i)
    __set (pAry, (i － 1) × 4, 0)  ' 把易语言的数组逐个赋值为0, 防止易语言会释放
.计次循环尾 ()
.子程序 文本_递减, 文本型, 公开, 把文本递减1  编辑框1.内容 ＝ 文本_递减 (编辑框1.内容)
.参数 要递减的文本, 文本型, 参考
返回 (到文本 (原子递减变量 (到数值 (要递减的文本))))
.子程序 文本_递增, 文本型, 公开, 把文本递增1  编辑框1.内容 ＝ 文本_递增 (编辑框1.内容)
.参数 要递增的文本, 文本型, 参考
返回 (到文本 (原子递增变量 (到数值 (要递增的文本))))
.子程序 文本_替换, 文本型, 公开, 批量替换文本；
.参数 原文本, 文本型
.参数 替换进行的次数, 整数型, 可空, 可空；参数值指定对子文本进行替换的次数。如果省略，默认进行所有可能的替换。
.参数 替换的起始位置, 整数型, 可空, 可空；参数值指定被替换子文本的起始搜索位置。如果省略，默认从 1 开始
.参数 是否区分大小写, 逻辑型, 可空, 可空； 初始值为“假”不区分大小写；为真区分大小写。
.参数 欲被替换的子文本1, 文本型
.参数 用作替换的子文本1, 文本型
.参数 欲被替换的子文本2, 文本型, 可空
.参数 用作替换的子文本2, 文本型, 可空
.参数 欲被替换的子文本3, 文本型, 可空
.参数 用作替换的子文本3, 文本型, 可空
.参数 欲被替换的子文本4, 文本型, 可空
.参数 用作替换的子文本4, 文本型, 可空
.参数 欲被替换的子文本5, 文本型, 可空
.参数 用作替换的子文本5, 文本型, 可空
.局部变量 局_文本, 文本型
.如果真 (替换的起始位置 ＝ 0)
    替换的起始位置 ＝ 1
.如果真结束
.如果 (是否为空 (替换进行的次数))
    局_文本 ＝ 子文本替换 (原文本, 欲被替换的子文本1, 用作替换的子文本1, 替换的起始位置, , 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本2, 用作替换的子文本2, 替换的起始位置, , 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本3, 用作替换的子文本3, 替换的起始位置, , 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本4, 用作替换的子文本4, 替换的起始位置, , 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本5, 用作替换的子文本5, 替换的起始位置, , 是否区分大小写)
.否则
    局_文本 ＝ 子文本替换 (原文本, 欲被替换的子文本1, 用作替换的子文本1, 替换的起始位置, 替换进行的次数, 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本2, 用作替换的子文本2, 替换的起始位置, 替换进行的次数, 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本3, 用作替换的子文本3, 替换的起始位置, 替换进行的次数, 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本4, 用作替换的子文本4, 替换的起始位置, 替换进行的次数, 是否区分大小写)
    局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本5, 用作替换的子文本5, 替换的起始位置, 替换进行的次数, 是否区分大小写)
.如果结束
返回 (局_文本)
.子程序 文本_投递, , 公开, 向指定窗口句柄的窗口中后台发送文本内容,对游戏有效(无返回值)
.参数 窗口句柄, 整数型, , 接收消息的窗口句柄
.参数 文本内容, 文本型, , 发送的文本内容
.局部变量 消息, 字节集
.局部变量 计次, 整数型
消息 ＝ 到字节集 (文本内容)
.计次循环首 (取字节集长度 (消息), 计次)
    投递消息整数 (窗口句柄, 258, 消息 [计次], 0)
.计次循环尾 ()
.子程序 文本_投递W, , 公开, 支持Unicode字符。
.参数 窗口句柄, 整数型
.参数 文本内容, 字节集, , unicode编码
.局部变量 计次, 整数型
.变量循环首 (1, 取字节集长度 (文本内容), 2, 计次)
    SendMessageW (窗口句柄, 258, 取字节集数据 (文本内容, #短整数型, 计次), 0)
.变量循环尾 ()
.子程序 文本_颠倒, 文本型, 公开, 将指定文本倒序 (比如:"123456"倒序后成:"654321")
.参数 欲转换文本, 文本型, , 欲倒序的文本
.参数 带有中文, 逻辑型, 可空, 如果要颠倒的文本中带有汉字，请把此参数设置为真。
.局部变量 字符数, 整数型
.局部变量 倒序内容, 文本型
.局部变量 循环变量, 整数型
.局部变量 字节集, 字节集
.局部变量 局_结果, 字节集
.局部变量 i, 整数型
.如果真 (带有中文)
    字节集 ＝ 编码_Ansi到Unicode (欲转换文本, 真)
    .变量循环首 (取字节集长度 (字节集) － 1, 1, -2, i)
        局_结果 ＝ 局_结果 ＋ 取字节集中间 (字节集, i, 2)
    .变量循环尾 ()
    返回 (编码_Unicode到Ansi (局_结果))
.如果真结束
字符数 ＝ 取文本长度 (到文本 (欲转换文本))
.变量循环首 (1, 字符数, 1, 循环变量)
    倒序内容 ＝ 倒序内容 ＋ 取文本中间 (欲转换文本, 字符数 ＋ 1 － 循环变量, 1)
.变量循环尾 ()
返回 (倒序内容)
.子程序 文本_发送, , 公开, 向指定文本框后台发送文本(无返回值)
.参数 文本框句柄, 整数型, , 文本框的句柄
.参数 发送的内容, 文本型, , 要发送的文本
SendMessageA (文本框句柄, 194, 1, 取指针文本_ (发送的内容))
.子程序 文本_粘贴, , 公开, 往指定的窗口粘贴文本
.参数 窗口句柄, 整数型, 可空, 欲粘贴文本的窗口句柄
.参数 文本内容, 文本型, 可空, 欲粘贴的文本内容
.局部变量 局_文本, 文本型
局_文本 ＝ 取剪辑板文本 ()
.如果真 (是否为空 (文本内容) ＝ 假)
    置剪辑板文本 (文本内容)
.如果真结束
SendMessageA (窗口句柄, 770, 0, 0)
置剪辑板文本 (局_文本)
.子程序 文本_全选, , 公开, 让指定的文本框内容全部选中
.参数 文本框句柄, 整数型, , 文本框的句柄
.参数 类型, 整数型, 可空, 默认为0全选，1=取消全选
.如果 (类型 ＝ 0)
    SendMessageA (文本框句柄, 177, 0, -1)
.否则
    SendMessageA (文本框句柄, 177, 0, 0)
.如果结束
.子程序 文本_去重复文本, 文本型, 公开, 去除原文本中重复的文本
.参数 原文本, 文本型
.参数 分割符, 文本型, 可空, 原文本单个内容间的分隔符，例如：---  留空为：逐字分割
.局部变量 局_数组, 文本型, , "0"
.局部变量 局_数组1, 文本型, , "0"
.局部变量 局_计次, 整数型
.局部变量 局_文本, 文本型
.如果 (是否为空 (分割符))
    文本_逐字分割 (原文本, 局_数组)
.否则
    局_数组 ＝ 分割文本 (原文本, 分割符, )
.如果结束
.计次循环首 (取数组成员数 (局_数组), 局_计次)
    .如果真 (内部_数组成员是否存在_文本 (局_数组1, 局_数组 [局_计次]) ＝ -1)
        加入成员 (局_数组1, 局_数组 [局_计次])
        局_文本 ＝ 局_文本 ＋ 局_数组 [局_计次] ＋ 分割符
    .如果真结束
.计次循环尾 ()
局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 取文本长度 (分割符))
返回 (局_文本)
.子程序 内部_数组成员是否存在_文本, 整数型
.参数 数组, 文本型, 数组
.参数 要判断值, 文本型
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (数组), 局_计次)
    .如果真 (数组 [局_计次] ＝ 要判断值)
        返回 (局_计次)
    .如果真结束
.计次循环尾 ()
返回 (-1)
.子程序 内部_数组成员是否存在_整数, 整数型
.参数 数组, 整数型, 数组
.参数 要判断值, 整数型
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (数组), 局_计次)
    .如果真 (数组 [局_计次] ＝ 要判断值)
        返回 (局_计次)
    .如果真结束
.计次循环尾 ()
返回 (-1)
.子程序 数组_排序, , 公开, 二分法排序.只能对文本数组进行排序,整数数组请用核心支持库的.
.参数 要排序的数组, 文本型, 参考 数组
.参数 排序方式, 字节型, 可空, 可空,默认为0  0=升序排序 1=降序排序
.参数 区分大小写, 逻辑型, 可空, 可空,默认“真”。真=区分大小写，假=不区分
.局部变量 N, 整数型
.局部变量 排序数组, 文本型, , "0"
.局部变量 成员数量, 整数型
.局部变量 高位, 整数型
.局部变量 低位, 整数型
.局部变量 中间位, 整数型
.局部变量 比较结果, 整数型, , , 感谢会员 落雪 提供代码
复制数组 (排序数组, 要排序的数组)
清除数组 (要排序的数组)
.如果真 (是否为空 (区分大小写) ＝ 真)
    区分大小写 ＝ 真
.如果真结束
.计次循环首 (取数组成员数 (排序数组), N)
    .判断开始 (成员数量 ＝ 0)
        插入成员 (要排序的数组, 1, 排序数组 [N])
    .默认
        高位 ＝ 成员数量
        低位 ＝ 1
        中间位 ＝ (高位 ＋ 低位) ＼ 2
        ' ; lstrcmp 通过比较ASCII码进行文本的排序,速度快,但存在问题
        .判断开始 (区分大小写 ＝ 假)
            比较结果 ＝ 文本比较 (到大写 (排序数组 [N]), 到大写 (要排序的数组 [成员数量]), 真)  ' 不区分就都算大写好了.因为在ACSII码中,大小写字母都是挨着的,所以不会出现"夹"在中间的字符.
        .默认
            比较结果 ＝ 文本比较 (排序数组 [N], 要排序的数组 [成员数量], 真)
        .判断结束
        .判断开始 (比较结果 ≥ 0)
            插入成员 (要排序的数组, 成员数量 ＋ 1, 排序数组 [N])
        .判断 (文本比较 (排序数组 [N], 要排序的数组 [1], 真) ≤ 0)
            插入成员 (要排序的数组, 1, 排序数组 [N])
        .默认
            .判断循环首 (高位 － 低位 ＞ 1)
                .如果真 (排序数组 [N] ＝ 要排序的数组 [中间位])
                    跳出循环 ()
                .如果真结束
                .如果 (文本比较 (排序数组 [N], 要排序的数组 [中间位], 真) ＜ 0)
                    高位 ＝ 中间位
                .否则
                    低位 ＝ 中间位
                .如果结束
                中间位 ＝ (高位 ＋ 低位) ＼ 2
            .判断循环尾 ()
            .判断开始 (文本比较 (排序数组 [N], 要排序的数组 [中间位], 真) ≤ 0)
                插入成员 (要排序的数组, 中间位, 排序数组 [N])
            .默认
                插入成员 (要排序的数组, 中间位 ＋ 1, 排序数组 [N])
            .判断结束
        .判断结束
    .判断结束
    成员数量 ＝ 取数组成员数 (要排序的数组)
.计次循环尾 ()
.如果真 (排序方式 ＝ 1)
    数组_反转 (要排序的数组)
.如果真结束
.子程序 数组_寻找数组, 整数型, 公开, 寻找指定成员在数组中出现的次数，
.参数 待查找的数组, 文本型, 数组
.参数 待查找的成员, 文本型
.参数 寻找到的数组, 整数型, 参考 数组, 返回出现的位置数组信息
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (待查找的数组), i)
    系统_处理事件 ()
    .如果真 (待查找的成员 ＝ 待查找的数组 [i])
        加入成员 (寻找到的数组, i)
    .如果真结束
.计次循环尾 ()
返回 (取数组成员数 (寻找到的数组))
.子程序 数组_反转, , 公开, 数组倒序。数组的第一个成员与最后一个成员互换，第二个和倒数第二个互换，以此类推
.参数 反转的数组, 文本型, 参考 数组
.局部变量 成员数量, 整数型
.局部变量 折中数量, 整数型
.局部变量 N, 整数型
成员数量 ＝ 取数组成员数 (反转的数组)
折中数量 ＝ 成员数量 ÷ 2
.计次循环首 (折中数量, N)
    文本_交换变量 (反转的数组 [N], 反转的数组 [成员数量])
    成员数量 ＝ 成员数量 － 1
.计次循环尾 ()
.子程序 文本_交换变量
.参数 参数一, 文本型
.参数 参数二, 文本型
置入代码 ({ 139, 69, 8, 139, 77, 12, 139, 16, 135, 17, 137, 16 })
' mov eax,[ebp+8]
' mov ecx,[ebp+12]
' mov edx,dword ptr ds:[eax]
' xchg dword ptr ds:[ecx],edx
' mov dword ptr ds:[eax],edx
.子程序 数组_输出, , 公开, 输出数组,方便查看
.参数 文本数组, 文本型, 可空 数组
.参数 整数数组, 整数型, 可空 数组
.局部变量 i, 整数型
.局部变量 局_文本, 文本型
.如果真 (是否为空 (文本数组) ＝ 假)
    局_文本 ＝ “文本数组 - ”
    .计次循环首 (取数组成员数 (文本数组), i)
        局_文本 ＝ 局_文本 ＋ “成员” ＋ 到文本 (i) ＋ “(” ＋ 文本数组 [i] ＋ “)  ”
    .计次循环尾 ()
    输出调试文本 (删首尾空 (局_文本))
.如果真结束
.如果真 (是否为空 (整数数组) ＝ 假)
    局_文本 ＝ “整数数组 - ”
    .计次循环首 (取数组成员数 (整数数组), i)
        局_文本 ＝ 局_文本 ＋ “成员” ＋ 到文本 (i) ＋ “(” ＋ 到文本 (整数数组 [i]) ＋ “)  ”
    .计次循环尾 ()
    输出调试文本 (删首尾空 (局_文本))
.如果真结束
.子程序 数组_合并, 文本型, 公开, 连接数组，类似VB中的join方法,合并一个文本数组到字符串。
.参数 文本数组, 文本型, 数组
.参数 合并字符, 文本型, 可空, 可空，默认为,
.局部变量 i, 整数型
.局部变量 返回文本, 文本型
合并字符 ＝ 选择 (是否为空 (合并字符), “,”, 合并字符)
.计次循环首 (取数组成员数 (文本数组), i)
    .如果 (i ＝ 1)
        返回文本 ＝ 文本数组 [i]
    .否则
        返回文本 ＝ 返回文本 ＋ 合并字符 ＋ 文本数组 [i]
    .如果结束
.计次循环尾 ()
返回 (返回文本)
.子程序 数组_合并_快速, 文本型, 公开, @福仔 把数组里所有的成员组合成一个文本
.参数 欲处理的数组, 文本型, 数组
.参数 间隔符, 文本型, 可空
.局部变量 pArr, 整数型, , , 数组指针
.局部变量 len, 整数型, , , 数组长度
.局部变量 i, 整数型
.局部变量 bufSize, 整数型
.局部变量 pBuf, 整数型
.局部变量 pSub, 整数型
.局部变量 nSub, 整数型
.局部变量 offset, 整数型
.局部变量 strLen, 整数型
.局部变量 pStr, 整数型
.局部变量 nStr, 整数型
.局部变量 pTmp, 整数型
.局部变量 tmpSize, 整数型
.局部变量 ret, 文本型
len ＝ 取数组成员数 (欲处理的数组)
.如果真 (len ＝ 0)
    返回 (“”)
.如果真结束
pArr ＝ 取数据_通用型_数组 (欲处理的数组)  ' 数组数据指针
bufSize ＝ len × 260  ' 缓冲区长度
pBuf ＝ malloc (bufSize ＋ 1)  ' 缓冲区
.如果真 (取反 (是否为空 (间隔符)))  ' 间隔符
    pSub ＝ 取指针_文本型 (间隔符)
    .如果真 (pSub ≠ 0)  ' 防止用户传递 字符(0)
        nSub ＝ strlen (pSub)
    .如果真结束
.如果真结束
.计次循环首 (len, i)
    pStr ＝ __get (pArr, (i － 1) × 4)  ' 取出数组成员
    .如果真 (pStr ＝ 0)
        到循环尾 ()
    .如果真结束
    nStr ＝ strlen (pStr)  ' 成员长度
    .如果真 (offset ＋ nStr ＞ bufSize)  ' 内存超了, 需要重新分配
        tmpSize ＝ bufSize
        bufSize ＝ bufSize × 2 ＋ nStr  ' 原来是内存扩充一倍
        ' pBuf ＝ realloc (bufSize)
        pTmp ＝ malloc (bufSize)
        memcpy (pTmp, pBuf, tmpSize)  ' 拷贝原来的数据, 然后释放
        free (pBuf)
        pBuf ＝ pTmp
    .如果真结束
    memcpy (pBuf ＋ offset, pStr, nStr)
    offset ＝ offset ＋ nStr
    .如果真 (pSub ≠ 0 且 i ＜ len)
        memcpy (pBuf ＋ offset, pSub, nSub)
        offset ＝ offset ＋ nSub
    .如果真结束
.计次循环尾 ()
__set_byte (pBuf, offset, 0)  ' 结束标识
ret ＝ 指针到文本 (pBuf)
free (pBuf)
返回 (ret)
.子程序 数组_去重复, 整数型, 公开, 返回剩余不重复数组的成员数量，可处理特殊字符效率较慢
.参数 文本数组, 文本型, 可空 数组, 要去重复的 文本数组
.参数 整数数组, 整数型, 可空 数组, 要去重复的 整数数组
.局部变量 局_文本数组, 文本型, , "0"
.局部变量 局_整数数组, 整数型, , "0"
.局部变量 局_计次, 整数型
.如果真 (是否为空 (文本数组) ＝ 假)
    .计次循环首 (取数组成员数 (文本数组), 局_计次)
        .如果真 (内部_数组成员是否存在_文本 (局_文本数组, 文本数组 [局_计次]) ＝ -1)
            加入成员 (局_文本数组, 文本数组 [局_计次])
        .如果真结束
    .计次循环尾 ()
    文本数组 ＝ 局_文本数组
    返回 (取数组成员数 (文本数组))
.如果真结束
.如果真 (是否为空 (整数数组) ＝ 假)
    .计次循环首 (取数组成员数 (整数数组), 局_计次)
        .如果真 (内部_数组成员是否存在_整数 (局_整数数组, 整数数组 [局_计次]) ＝ -1)
            加入成员 (局_整数数组, 整数数组 [局_计次])
        .如果真结束
    .计次循环尾 ()
    整数数组 ＝ 局_整数数组
    返回 (取数组成员数 (整数数组))
.如果真结束
返回 (0)
.子程序 数组_取次数, 整数型, 公开, 取指定数组成员出现相同数量，源码由易友【C盘是头猪】提供。
.参数 参数_数组, 文本型, 数组
.参数 参数_成员, 文本型
.局部变量 n, 整数型
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (参数_数组), i)
    .如果真 (参数_数组 [i] ＝ 参数_成员)
        n ＝ n ＋ 1
    .如果真结束
    处理事件 ()
.计次循环尾 ()
返回 (n)
.子程序 文本_取长度, 整数型, 公开, 取一段文本的长度，中文算两个长度，字母算一个长度
.参数 源文本, 文本型
返回 (lstrlenA (取指针文本_ (源文本)))
.子程序 文本_取长度W, 整数型, 公开, 取一段文本的长度，中文和字母都算一个长度
.参数 源文本, 字节集, , Unicode字节集
返回 (lstrlenW (取指针_字节集型 (源文本)))
.子程序 文本_取声母, 文本型, 公开, 取一组文本中每个字的拼音首字,如果不是中文就直接取
.参数 文本, 文本型, , 转换前文本
.局部变量 循环次数, 整数型
.局部变量 结果, 文本型
文本 ＝ 到全角 (文本)
.计次循环首 (取文本长度 (文本), 循环次数)
    .判断开始 (取代码 (到半角 (取文本中间 (文本, 循环次数 × 2 － 1, 2)), ) ＞ 0)
        结果 ＝ 结果 ＋ 到半角 (取文本中间 (文本, 循环次数 × 2 － 1, 2))
    .默认
        结果 ＝ 结果 ＋ 取文本左边 (取声母 (取文本中间 (文本, 循环次数 × 2 － 1, 2), 1), 1)
    .判断结束
.计次循环尾 ()
返回 (结果)
.子程序 文本_到小写, 文本型, 公开, 把字母转换到小写
.参数 要转换的文本, 文本型, , 要转换的文本
.局部变量 局_欲转换的文本, 文本型
局_欲转换的文本 ＝ 要转换的文本
返回 (CharLowerA (局_欲转换的文本))
.子程序 文本_到小写EX, 文本型, 公开, 把字母转换到小写
.参数 要转换的文本, 文本型, , 要转换的文本
.局部变量 局_转换, 文本型
局_转换 ＝ 要转换的文本
返回 (API_文本小写 (局_转换))
.子程序 文本_到小写m, 文本型, 公开, 将文本中的大写英文字母变换为小写，返回变换后的结果文本。本命令为初级命令。
.参数 欲变换的文本, 文本型
置入代码 ({ 81 })  ' 00445FC0      51            push ecx
置入代码 ({ 82 })  ' 00445FC1      52            push edx
置入代码 ({ 83 })  ' 00445FC2      53            push ebx
置入代码 ({ 86 })  ' 00445FC3      56            push esi
置入代码 ({ 87 })  ' 00445FC4      57            push edi
' -------------------------------------------------------------------
RtlAllocateHeap (GetProcessHeap (), 0, 32)  ' 申请一块栈空间地址
' 置入代码 ({ 139, 248 })  ' 8BF8          mov edi,eax           ;  目的内存地址
置入代码 ({ 80 })  ' 50            push eax                    ;  保存内存地址
' ------------取参数<欲变换的文本>长度------------------------------
置入代码 ({ 139, 125, 8 })  ' 8B7D 08       mov edi,dword ptr ss:[ebp+0x8]
置入代码 ({ 139, 63 })  ' 8B3F          mov edi,dword ptr ds:[edi]
置入代码 ({ 139, 247 })  ' 8BF7               mov esi,edi
置入代码 ({ 131, 201, 255 })  ' 83C9 FF       or ecx,0xFFFFFFFF
置入代码 ({ 51, 192 })  ' 33C0          xor eax,eax
置入代码 ({ 242, 174 })  ' F2:AE         repne scas byte ptr es:[edi]
置入代码 ({ 247, 209 })  ' F7D1          not ecx
置入代码 ({ 73 })  ' 49            dec ecx
置入代码 ({ 95 })  ' 5F              pop edi
置入代码 ({ 87 })  ' 57              push edi
' -------------复制内容到刚申请的内存地址里-------------------------------------------
置入代码 ({ 139, 217 })  ' 8BD9             mov ebx,ecx
置入代码 ({ 193, 233, 2 })  ' C1E9 02          shr ecx,0x2
置入代码 ({ 38, 243, 165 })  ' 26:F3:A5         rep movs dword ptr es:[edi],dword ptr es:[esi]
置入代码 ({ 139, 203 })  ' 8BCB             mov ecx,ebx
置入代码 ({ 131, 225, 3 })  ' 83E1 03          and ecx,0x3
置入代码 ({ 243, 164 })  ' F3:A4            rep movs byte ptr es:[edi],byte ptr [esi]
置入代码 ({ 198, 7, 0 })  ' C607 00          mov byte ptr [edi],0x0
' ---------------转大写-----------------------------------------------------------------
置入代码 ({ 51, 210 })  ' 33D2             xor edx,edx
置入代码 ({ 88 })  ' 58               pop eax
置入代码 ({ 139, 248 })  ' 8BF8          mov edi,eax
置入代码 ({ 128, 60, 58, 65 })  ' 803C3A 41       cmp byte ptr [edx+edi],0x41
置入代码 ({ 124, 10 })  ' 7C 0A           jl X0040112F
置入代码 ({ 128, 60, 58, 90 })  ' 803C3A 5A       cmp byte ptr [edx+edi],0x5A
置入代码 ({ 127, 4 })  ' 7F 04           jg X0040112F
置入代码 ({ 128, 12, 58, 32 })  ' 800C3A 20       or byte ptr [edx+edi],0x20
置入代码 ({ 128, 60, 58, 0 })  ' 803C3A 00       cmp byte ptr [edx+edi],0x0
置入代码 ({ 116, 3 })  ' 74 03            je X0040101E
置入代码 ({ 66 })  ' 42               inc edx
置入代码 ({ 235, 231 })  ' EB E7            jmp X00401005
' -------------恢复寄存器原状态-------------------------------------------------------------
置入代码 ({ 95 })  ' 00445FC5      5F            pop edi
置入代码 ({ 94 })  ' 00445FC6      5E            pop esi
置入代码 ({ 91 })  ' 00445FC7      5B            pop ebx
置入代码 ({ 90 })  ' 00445FC8      5A            pop edx
置入代码 ({ 89 })  ' 00445FC9      59            pop ecx
置入代码 ({ 201 })  ' C9                       leave
置入代码 ({ 194, 4, 0 })  ' C2 0400       retn 0x4
返回 (“”)
.子程序 文本_到大写, 文本型, 公开, 把字母转换到大写
.参数 要转换的文本, 文本型, , 要转换的文本
.局部变量 局_欲转换的文本, 文本型
局_欲转换的文本 ＝ 要转换的文本
返回 (CharUpperA (局_欲转换的文本))
.子程序 文本_折行, 文本型, 公开, 把一段长文本按你指定的字数分行
.参数 要处理的文本, 文本型
.参数 每行字数, 整数型, 可空, 半角字数，如果为空，将不进行分行操作，直接返回文本内容，如果包含文本或全角字符，则需要把每行字数至少设置为2
.参数 是否强行分行, 逻辑型, 可空, 为真则强行按设定长度分行。为假则保留连续半角数字或字母为一行。默认为假。
.参数 是否全角, 逻辑型, 可空, 是否将半角转换为全角,如果为空即不转换
.参数 首空字节数, 整数型, 可空, 在每行前面加入空格,如果为空,为0,即不加空格
.局部变量 操作文本, 文本型
.局部变量 开始位置, 整数型
.局部变量 读取长度, 整数型
.局部变量 开始计算半角, 逻辑型
.局部变量 半角位置, 整数型
.局部变量 结果文本, 文本型
.如果真 (是否为空 (每行字数))
    返回 (要处理的文本)
.如果真结束
.如果真 (是否为空 (是否强行分行))
    是否强行分行 ＝ 假
.如果真结束
.如果真 (是否全角 ＝ 真)
    要处理的文本 ＝ 子文本替换 (要处理的文本, “...”, “…”, 1, , 真)
    要处理的文本 ＝ 子文本替换 (要处理的文本, “->”, “→”, 1, , 真)
    要处理的文本 ＝ 子文本替换 (要处理的文本, “<-”, “←”, 1, , 真)
    要处理的文本 ＝ 子文本替换 (要处理的文本, “--”, “—”, 1, , 真)
    要处理的文本 ＝ 到全角 (要处理的文本)
.如果真结束
.如果真 (首空字节数 ≥ 1)
    要处理的文本 ＝ 取空白文本 (首空字节数) ＋ 要处理的文本
    要处理的文本 ＝ 子文本替换 (要处理的文本, #换行符, #换行符 ＋ 取空白文本 (首空字节数), 1, , 真)
.如果真结束
操作文本 ＝ 要处理的文本
.判断循环首 (取文本长度 (操作文本) ＞ 每行字数)
    .判断循环首 (读取长度 ＜ 每行字数)
        ' 首先这里存在2个情况，一个是如果为全角或汉字。则他们1位是2个长度，直接取是取不出来的。
        .如果 (取代码 (操作文本, 读取长度 ＋ 1) ≥ 127 或 取代码 (操作文本, 读取长度 ＋ 1) ＜ 0)
            ' 如果不是半角的话。则需要把读取长度增加到2
            半角位置 ＝ 0
            开始计算半角 ＝ 假
            .如果真 (读取长度 ＝ 每行字数 － 1)
                输出调试文本 (“文本_折行 - 注意：检测到文本中包含中文或全角字符，需要把每行字数至少设置为2.”)
                ' 返回 (“”)
                跳出循环 ()
            .如果真结束
            读取长度 ＝ 读取长度 ＋ 2
        .否则
            .判断开始 (取文本中间 (操作文本, 读取长度 ＋ 1, 1) ＝ “ ”)
                读取长度 ＝ 读取长度 ＋ 1
                半角位置 ＝ 0
                开始计算半角 ＝ 假
            .判断 (取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ #换行符)
                读取长度 ＝ 读取长度 ＋ 2
                跳出循环 ()
            .默认
                .如果真 (开始计算半角 ＝ 假)
                    半角位置 ＝ 读取长度
                    开始计算半角 ＝ 真
                .如果真结束
                读取长度 ＝ 读取长度 ＋ 1
            .判断结束
        .如果结束
    .判断循环尾 ()
    .如果真 (读取长度 ≥ 每行字数)
        .如果 (是否强行分行 ＝ 假)
            读取长度 ＝ 选择 (半角位置 ＝ 0, 每行字数, 选择 (取代码 (操作文本, 每行字数 ＋ 1) ≥ 127 或 取代码 (操作文本, 每行字数 ＋ 1) ＜ 0, 每行字数, 半角位置))
            开始计算半角 ＝ 假
            半角位置 ＝ 0
        .否则
            读取长度 ＝ 每行字数
        .如果结束
    .如果真结束
    .如果真 (是否强行分行 ＝ 假)
        .如果 (取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “《” 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “（” 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ #左引号 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “〈” 或 取文本中间 (操作文本, 读取长度 － 11, 2) ＝ “‘”)
            读取长度 ＝ 读取长度 － 2
        .否则
            .如果真 (取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “》” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “）” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ #右引号 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “〉” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “，” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “。” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “？” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “：” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “’” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “；” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “、”)
                .如果 (取代码 (操作文本, 读取长度) ≥ 127 或 取代码 (操作文本, 读取长度) ＜ 0)
                    读取长度 ＝ 读取长度 － 2
                .否则
                    读取长度 ＝ 读取长度 － 1
                .如果结束
            .如果真结束
        .如果结束
    .如果真结束
    .如果 (取文本中间 (操作文本, 读取长度 － 1, 2) ＝ #换行符)
        结果文本 ＝ 结果文本 ＋ 取文本左边 (操作文本, 读取长度)
    .否则
        结果文本 ＝ 结果文本 ＋ 取文本左边 (操作文本, 读取长度) ＋ #换行符
    .如果结束
    操作文本 ＝ 取文本右边 (操作文本, 取文本长度 (操作文本) － 读取长度)
    读取长度 ＝ 0
.判断循环尾 ()
结果文本 ＝ 结果文本 ＋ 操作文本
返回 (结果文本)
.子程序 文本_删首尾空, 文本型, 公开, 删除一段文本前后的空格
.参数 源文本, 文本型
.局部变量 局_欲删除空格的文本, 字节集
局_欲删除空格的文本 ＝ 到字节集 (源文本) ＋ { 0 }
PathRemoveBlanksA (取指针_字节集型 (局_欲删除空格的文本))
返回 (取字节集数据 (局_欲删除空格的文本, #文本型, ))
.子程序 文本_删除空行, 文本型, 公开, 删除文本当中的空白行
.参数 要操作的文本, 文本型
.局部变量 正则, 正则表达式类
.如果真 (取文本左边 (要操作的文本, 2) ＝ #换行符)
    要操作的文本 ＝ 取文本右边 (要操作的文本, 取文本长度 (要操作的文本) － 2)
.如果真结束
.如果真 (取文本右边 (要操作的文本, 2) ＝ #换行符)
    要操作的文本 ＝ 取文本左边 (要操作的文本, 取文本长度 (要操作的文本) － 2)
.如果真结束
正则.创建 (“(?:^\r|\n$)”, 要操作的文本, , , , )  ' 原表达式“\n\s*\r”
返回 (正则.替换 (“”))
.子程序 文本_是否重复, 逻辑型, 公开, 判断文本中的指定文本是否有重复，有重复返回真，没得复返回假
.参数 源文本, 文本型
.参数 查询的文本, 文本型
.参数 严格模式, 逻辑型, 可空, 可空。默认为正常模式。
.局部变量 位置1, 整数型
.局部变量 位置2, 整数型
位置1 ＝ 寻找文本 (源文本, 查询的文本, , 真)
.如果 (严格模式)
    返回 (寻找文本 (源文本, 查询的文本, 位置1 ＋ 1, 真) ＞ 0)
.否则
    .如果真 (位置1 ＜ 1)
        返回 (假)
    .如果真结束
    返回 (寻找文本 (源文本, 查询的文本, 位置1 ＋ 取文本长度 (查询的文本), 真) ＞ 0)
.如果结束
返回 (假)
.子程序 文本_取左边, 文本型, 公开, 从文本的左边按 欲寻找的文本 开始寻找
.参数 被查找的文本, 文本型, , 被查找的文本
.参数 欲寻找的文本, 文本型, , 欲寻找的文本
.参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
.参数 是否不区分大小写, 逻辑型, 可空, 初始值为“假”。为真不区分大小写，为假区分。
.局部变量 局_长度, 整数型
.局部变量 局_起始搜寻位置, 整数型
.局部变量 局_方向, 整数型
.局部变量 局_找到的位置, 整数型
.局部变量 局_返回结果, 文本型
局_长度 ＝ 取文本长度 (被查找的文本)
局_起始搜寻位置 ＝ 起始寻找位置
.如果真 (局_起始搜寻位置 ＜ 0)
    局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
    .如果真 (局_起始搜寻位置 ＝ 1)
        局_起始搜寻位置 ＝ 0
    .如果真结束
    局_方向 ＝ 1
.如果真结束
.如果 (局_方向 ＝ 1)
    局_找到的位置 ＝ 倒找文本 (被查找的文本, 欲寻找的文本, 局_长度 － 局_起始搜寻位置 ＋ 1, 是否不区分大小写)
.否则
    .如果真 (局_起始搜寻位置 ＝ 0)
        局_起始搜寻位置 ＝ 1
    .如果真结束
    局_找到的位置 ＝ 寻找文本 (被查找的文本, 欲寻找的文本, 局_起始搜寻位置, 是否不区分大小写)
.如果结束
.如果真 (局_找到的位置 ＝ -1)
    返回 (“”)
.如果真结束
局_返回结果 ＝ 取文本左边 (被查找的文本, 局_找到的位置 － 1)
返回 (局_返回结果)
.子程序 文本_取右边, 文本型, 公开, 从文本的右边按 欲寻找的文本 开始寻找, 取行右边 (“1234567890”, “5”, 1, 真)
.参数 被查找的文本, 文本型, , 被查找的文本
.参数 欲寻找的文本, 文本型, , 欲寻找的文本
.参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从右往左寻找，如果为负数，则从左往右寻找。
.参数 是否不区分大小写, 逻辑型, 可空, 默认为假,区分大小写
.局部变量 局_长度, 整数型
.局部变量 局_起始搜寻位置, 整数型
.局部变量 局_方向, 整数型
.局部变量 局_找到的位置, 整数型
.局部变量 局_返回结果, 文本型
局_长度 ＝ 取文本长度 (被查找的文本)
局_起始搜寻位置 ＝ 起始寻找位置
.如果真 (局_起始搜寻位置 ＜ 0)
    局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
    .如果真 (局_起始搜寻位置 ＝ 1)
        局_起始搜寻位置 ＝ 0
    .如果真结束
    局_方向 ＝ 1
.如果真结束
.如果 (局_方向 ＝ 1)
    .如果真 (局_起始搜寻位置 ＝ 0)
        局_起始搜寻位置 ＝ 1
    .如果真结束
    局_找到的位置 ＝ 寻找文本 (被查找的文本, 欲寻找的文本, 局_起始搜寻位置, 是否不区分大小写)
.否则
    局_找到的位置 ＝ 倒找文本 (被查找的文本, 欲寻找的文本, 局_长度 － 局_起始搜寻位置 ＋ 1, 是否不区分大小写)
.如果结束
.如果真 (局_找到的位置 ＝ -1)
    返回 (“”)
.如果真结束
局_返回结果 ＝ 取文本右边 (被查找的文本, 局_长度 － 取文本长度 (欲寻找的文本) － 局_找到的位置 ＋ 1)
返回 (局_返回结果)
.子程序 文本_取首拼, 文本型, 公开, 取出给出文本的首拼;注:英文,数字,符号则直接返回.首拼一律为小写[V雪落有声V]
.参数 文本, 文本型, , 需要取出首拼的文本.可以包含数字,字母.请使用半角格式.
.局部变量 局_计次, 整数型
.局部变量 局_文本, 文本型
.局部变量 局_返回文本, 文本型
局_计次 ＝ 1
文本 ＝ 到半角 (文本)
.判断循环首 (局_计次 ≤ 取文本长度 (文本))
    局_文本 ＝ 取文本中间 (文本, 局_计次, 1)
    .如果 (取代码 (局_文本, ) ＜ 0)
        局_文本 ＝ 取文本中间 (文本, 局_计次, 2)
        .如果真 (文本_是否为汉字 (局_文本))
            局_文本 ＝ 取文本左边 (取拼音 (局_文本, 1), 1)
            局_返回文本 ＝ 局_返回文本 ＋ 局_文本
        .如果真结束
        局_计次 ＝ 局_计次 ＋ 1
    .否则
        局_返回文本 ＝ 局_返回文本 ＋ 局_文本
    .如果结束
    局_计次 ＝ 局_计次 ＋ 1
.判断循环尾 ()
返回 (局_返回文本)
.子程序 文本_取空白文本, 文本型, 公开, 汇编方式申请空白文本, 返回具有指定数目半角空格的文本; 注意, 命令本身不会处理内存释放, 请不要连续反复调用
.参数 文本长度, 整数型
.局部变量 address, 整数型
address ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 文本长度 ＋ 8)
RtlFillMemory_字节 (address, 文本长度, 32)
置入代码 ({ 139, 69, 8, 3, 69, 252, 139, 69, 252, 137, 236, 93, 194, 4, 0 })
' mov eax,[ebp+8]
' add eax,[ebp-4]
' mov eax,[ebp-4]
' mov esp,ebp
' pop ebp
' retn 4
返回 (“”)
.子程序 文本_取行数, 整数型, 公开, 取一个文本共有有多少行。
.参数 文本, 文本型
置入代码 ({ 87, 51, 192, 139, 125, 8, 139, 63, 133, 255, 116, 24, 51, 201, 138, 15, 71, 128, 249, 10, 117, 1, 64, 132, 201, 117, 243, 138, 79, 255, 128, 249, 10, 116, 1, 64, 95, 139, 229, 93, 194, 4, 0 })
返回 (0)
.子程序 文本_转拼音, 文本型, 公开, 把一段文本转换到拼音
.参数 欲转拼音的文本, 文本型
.参数 是否加空格, 逻辑型, 可空, 可空,默认为假,不加;
.参数 是否全角, 逻辑型, 可空, 可空，默认为假，半角
.参数 是否正则, 逻辑型, 可空, 是否正则方式判断，可以判断生僻的汉字，可空，默认为假 
.局部变量 局_文本, 文本型
.局部变量 局_字符数量, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_结果, 文本型
欲转拼音的文本 ＝ 到全角 (欲转拼音的文本)
局_字符数量 ＝ 取文本长度 (欲转拼音的文本) ÷ 2
.计次循环首 (局_字符数量, 局_计次)
    局_文本 ＝ 取文本中间 (欲转拼音的文本, 局_计次 × 2 － 1, 2)
    .如果 (文本_是否为汉字 (局_文本, 是否正则))
        .判断开始 (是否加空格)
            局_结果 ＝ 局_结果 ＋ 取拼音 (局_文本, 1) ＋ “ ”
        .默认
            局_结果 ＝ 局_结果 ＋ 取拼音 (局_文本, 1)
        .判断结束
    .否则
        .判断开始 (是否全角)
            局_结果 ＝ 局_结果 ＋ 到全角 (局_文本)
        .默认
            局_结果 ＝ 局_结果 ＋ 到半角 (局_文本)
        .判断结束
    .如果结束
.计次循环尾 ()
欲转拼音的文本 ＝ 到半角 (欲转拼音的文本)
返回 (局_结果)
.子程序 文本_替换行内容, 文本型, 公开, 替换指定行整行内容，返回替换后的文本。
.参数 文本, 文本型
.参数 行数, 整数型
.参数 替换内容, 文本型
.局部变量 输出文本, 文本型
.局部变量 计次, 整数型
.局部变量 临时文本, 文本型, , "0"
.局部变量 局_总数, 整数型
临时文本 ＝ 分割文本 (文本, #换行符, )
局_总数 ＝ 取数组成员数 (临时文本)
.如果真 (行数 ＞ 局_总数)
    输出调试文本 (“传入行数大于实际文本行”)
    返回 (“”)
.如果真结束
临时文本 [行数] ＝ 替换内容
.计次循环首 (局_总数, 计次)
    .如果真 (取数组成员数 (临时文本) ≠ 计次)
        输出文本 ＝ 输出文本 ＋ 临时文本 [计次] ＋ #换行符
        到循环尾 ()
    .如果真结束
    输出文本 ＝ 输出文本 ＋ 临时文本 [计次]
.计次循环尾 ()
清除数组 (临时文本)
返回 (输出文本)
.子程序 文本_取随机汉字, 文本型, 公开, 取常用的随机汉字
.参数 个数, 整数型, , 要取出多少个汉字！
.参数 汉字或全拼, 整数型, 可空, 0为汉字，否则为全拼音！
.局部变量 计次, 整数型
.局部变量 得到的文本, 文本型
.判断开始 (汉字或全拼 ＝ 0)
    .计次循环首 (个数, 计次)
        得到的文本 ＝ 得到的文本 ＋ 到文本 (字符 (－汇编_取随机数 (38, 80)) ＋ 字符 (－汇编_取随机数 (38, 80)))
    .计次循环尾 ()
.默认
    .计次循环首 (个数, 计次)
        得到的文本 ＝ 得到的文本 ＋ 取拼音 (到文本 (字符 (－汇编_取随机数 (38, 80)) ＋ 字符 (－汇编_取随机数 (38, 80))), 1)
    .计次循环尾 ()
.判断结束
返回 (得到的文本)
.子程序 文本_取随机汉字_快速, 文本型, 公开, 返回指定个数的汉字
.参数 个数, 整数型
.局部变量 i, 整数型
.局部变量 汉字, 字节集
.局部变量 指针, 整数型
' https://bbs.125.la/forum.php?mod=viewthread&tid=14658489
置随机数种子 ()
汉字 ＝ 取空白字节集 (左移 (个数, 1))
.变量循环首 (1, 左移 (个数, 1), 2, i)
    汉字 [i] ＝ 取随机数 (176, 247)  ' 176-0xF7
    汉字 [i ＋ 1] ＝ 取随机数 (161, 254)  ' 161-0xFE
.变量循环尾 ()
返回 (到文本 (汉字))
.子程序 文本_取随机字母, 文本型, 公开, 取随机26个字母！
.参数 要取的字符数, 整数型, , 要取字符个数；
.参数 字母类型, 整数型, 可空, 可空：默认为小写字母；0=小写字母；1=大写字母；2=大小写字母混合；
.局部变量 临时文本, 文本型
.局部变量 大小写, 整数型
.判断开始 (字母类型 ＝ 0)
    .计次循环首 (要取的字符数, )
        临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (97, 122)))
    .计次循环尾 ()
.判断 (字母类型 ＝ 1)
    .计次循环首 (要取的字符数, )
        临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (65, 90)))
    .计次循环尾 ()
.默认
    .计次循环首 (要取的字符数, )
        大小写 ＝ 汇编_取随机数 (0, 1)
        .如果 (大小写 ＝ 1)
            临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (97, 122)))
        .否则
            临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (65, 90)))
        .如果结束
    .计次循环尾 ()
.判断结束
返回 (临时文本)
.子程序 文本_取随机姓氏, 文本型, 公开, 取出一个随机的百家姓！
.参数 汉字或全拼, 整数型, 可空, 0为汉字，否则为全拼音！
.判断开始 (汉字或全拼 ＝ 0)
    返回 (取文本中间 (#百家姓, 到数值 (文本_取随机范围数字 (1, 814, 1)), 2))
.默认
    返回 (取拼音 (取文本中间 (#百家姓, 到数值 (文本_取随机范围数字 (1, 814, 1)), 2), 1))
.判断结束
.子程序 文本_取随机数字, 文本型, 公开, 汇编_取随机数字，可选单或双！
.参数 字符数, 整数型, , 要取字符个数
.参数 单双选择, 整数型, 可空, 0为单双，1为单，其他数值为双；默认单双一起
.局部变量 返回的文本, 文本型
.判断开始 (单双选择 ＝ 0)
    .计次循环首 (字符数, )
        返回的文本 ＝ 返回的文本 ＋ 到文本 (汇编_取随机数 (0, 9))
    .计次循环尾 ()
.判断 (单双选择 ＝ 1)
    .计次循环首 (字符数, )
        返回的文本 ＝ 返回的文本 ＋ 到文本 (多项选择 (汇编_取随机数 (1, 5), 1, 3, 5, 7, 9))
    .计次循环尾 ()
.默认
    .计次循环首 (字符数, )
        返回的文本 ＝ 返回的文本 ＋ 到文本 (多项选择 (汇编_取随机数 (1, 5), 0, 2, 4, 6, 8))
    .计次循环尾 ()
.判断结束
返回 (返回的文本)
.子程序 汇编_取随机数, 整数型, 公开, 返回一个指定范围内的随机数值。在使用本命令取一系列的随机数之前，应该先使用“置随机数种子”命令为随机数生成器初始化一个种子值。本命令为初级命令。
.参数 欲取随机数的最小值, 整数型, 可空, 参数必须大于或等于零。本参数如果被省略，默认为 0。
.参数 欲取随机数的最大值, 整数型, 可空, 参数必须大于或等于零。本参数如果被省略，默认为无限。
' 例程来自：https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=13841642&pid=8692203
置入代码 ({ 81, 82, 15, 49, 105, 192, 253, 67, 3, 0, 5, 195, 158, 38, 0, 193, 232, 16, 37, 255, 127, 0, 0, 139, 77, 16, 133, 201, 117, 5, 185, 255, 255, 255, 127, 43, 77, 8, 65, 51, 210, 247, 241, 3, 85, 8, 139, 194, 90, 89, 139, 229, 93, 194, 16, 0 })
' PUSH EBP
' MOV EBP, ESP
' PUSH ECX
' PUSH EDX
' RDTSC
' IMUL EAX, EAX, 343FDh
' ADD EAX, 269EC3h
' SHR EAX, 10h
' AND EAX, 7FFFh
' MOV ECX, DWORD PTR SS:[EBP+10h]
' TEST ECX, ECX
' JNZ SHORT Jump
' MOV ECX, 7FFFFFFFh
' @Jump:
' SUB ECX, DWORD PTR SS:[EBP+8h]
' INC ECX
' XOR EDX, EDX
' DIV ECX
' ADD EDX, DWORD PTR SS:[EBP+8h]
' MOV EAX, EDX
' POP EDX
' POP ECX
' MOV ESP, EBP
' POP EBP
' RETN 10h
返回 (0)
.子程序 汇编_取随机数_硬件版, 整数型, 公开, 部分CPU不支持 失败返回 0
.参数 欲取随机数的最小值, 整数型, 可空
.参数 欲取随机数的最大值, 整数型, 可空
' 例程来自：http://bbs.eyuyan.com/read.php?tid=405670
.判断开始 (IsRdRandSupported ())
    .如果真 (欲取随机数的最小值 ＝ 0)
        欲取随机数的最小值 ＝ 1
    .如果真结束
    .如果真 (欲取随机数的最大值 ＝ 0)
        欲取随机数的最大值 ＝ 9999
    .如果真结束
    返回 (RdRand (欲取随机数的最小值, 欲取随机数的最大值))
.默认
    返回 (0)
.判断结束
.子程序 汇编_取随机数种子_硬件版, 整数型, 公开, 部分CPU不支持 失败返回 0
' 例程来自：http://bbs.eyuyan.com/read.php?tid=405670
.判断开始 (IsRdSeedSupported ())
    返回 (RdSeed ())
.默认
    返回 (0)
.判断结束
.子程序 IsRdRandSupported, 逻辑型
置入代码 ({ 184, 1, 0, 0, 0, 15, 162, 49, 192, 15, 186, 225, 30, 17, 192, 201, 195 })
返回 (假)
.子程序 IsRdSeedSupported, 逻辑型
置入代码 ({ 184, 7, 0, 0, 0, 49, 201, 15, 162, 49, 192, 15, 186, 227, 18, 17, 192, 201, 195 })
返回 (假)
.子程序 RdRand, 整数型, , 直接调用取随机数即可 不需要随机种子 By莽
.参数 Min, 整数型
.参数 Max, 整数型
置入代码 ({ 81, 82, 15, 199, 240, 139, 77, 12, 43, 77, 8, 65, 51, 210, 247, 241, 3, 85, 8, 139, 194, 90, 89, 201, 194, 8, 0 })
返回 (0)
.子程序 RdSeed, 长整数型, , 取随机数种子 作为其他伪随机数的种子 By莽
置入代码 ({ 15, 199, 248, 201, 195 })
返回 (0)
.子程序 文本_取随机字符, 文本型, 公开, 取随机可见字符,只取能显示的字符
.参数 要取的字符数, 整数型, , 要取字符个数
.参数 获取模式, 整数型, 可空, 获取模式, 1=数字, 2=小写字母, 4=大写字母, 8=特殊字符, 需要多个组合用位或或起来, 默认为1, 只返回数字
.局部变量 buffer, 字节集
.局部变量 pBuffer, 整数型
.局部变量 bufferSize, 整数型
.局部变量 str, 文本型
.局部变量 pStr, 整数型
.局部变量 tmp, 整数型
.局部变量 i, 整数型
.局部变量 n, 整数型
置随机数种子 ()
buffer ＝ 取空白字节集 (129)
pBuffer ＝ 取指针_字节集型 (buffer)
str ＝ 取空白文本 (要取的字符数)
pStr ＝ 取指针_文本型 (str)
.如果真 (位与 (获取模式, 1) ≠ 0)
    tmp ＝ 位或 (tmp, 1)
.如果真结束
.如果真 (位与 (获取模式, 2) ≠ 0)
    tmp ＝ 位或 (tmp, 2)
.如果真结束
.如果真 (位与 (获取模式, 4) ≠ 0)
    tmp ＝ 位或 (tmp, 4)
.如果真结束
.如果真 (位与 (获取模式, 8) ≠ 0)
    tmp ＝ 位或 (tmp, 8)
.如果真结束
.如果真 (tmp ＝ 0)
    tmp ＝ 1
.如果真结束
获取模式 ＝ tmp
.如果真 (位与 (获取模式, 1) ≠ 0)
    RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“0123456789”), 10)
    bufferSize ＝ bufferSize ＋ 10
.如果真结束
.如果真 (位与 (获取模式, 2) ≠ 0)
    RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“abcdefghijklmnopqrstuvwxyz”), 26)
    bufferSize ＝ bufferSize ＋ 26
.如果真结束
.如果真 (位与 (获取模式, 4) ≠ 0)
    RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“ABCDEFGHIJKLMNOPQRSTUVWXYZ”), 26)
    bufferSize ＝ bufferSize ＋ 26
.如果真结束
.如果真 (位与 (获取模式, 8) ≠ 0)
    RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“ !” ＋ #引号 ＋ “#$%&'()*+,-./:;<=>?@[\]^_`{|}~”), 33)
    bufferSize ＝ bufferSize ＋ 33
.如果真结束
bufferSize ＝ bufferSize － 1
.计次循环首 (要取的字符数, i)
    RtlMoveMemory (pStr ＋ i － 1, pBuffer ＋ 取随机数 (0, bufferSize), 1)
.计次循环尾 ()
返回 (str)
.子程序 文本_插入新一行, 文本型, 公开, 在指定行插入文本，原文本后移，返回插入后的文本。
.参数 原文本, 文本型
.参数 行数, 整数型
.参数 新一文本行内容, 文本型
.局部变量 文本数组, 文本型, , "0"
.局部变量 输出文本, 文本型
.局部变量 计次, 整数型
文本数组 ＝ 分割文本 (原文本, #换行符, )
插入成员 (文本数组, 行数, 新一文本行内容)
.计次循环首 (取数组成员数 (文本数组), 计次)
    .如果真 (取数组成员数 (文本数组) ＝ 计次)
        输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
        跳出循环 ()
    .如果真结束
    输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
.计次循环尾 ()
清除数组 (文本数组)
返回 (输出文本)
.子程序 文本_是否为汉字, 逻辑型, 公开, 中间不能有空格,判断一个文本是否全为汉字,是汉字返回真,否则返回假
.参数 欲判断文本, 文本型
.参数 正则方式, 逻辑型, 可空, 是否正则方式判断，可以判断生僻的汉字
.局部变量 局_区码, 字节型
.局部变量 局_位码, 字节型
.局部变量 RegExp, 对象
.局部变量 匹配文本, 文本型
.局部变量 bool, 逻辑型
.局部变量 局_长度
.局部变量 i, 整数型
.局部变量 局_键代码, 整数型
局_长度 ＝ 取文本长度 (删全部空 (欲判断文本))
.如果真 (局_长度 ≤ 1)
    返回 (假)
.如果真结束
.如果真 (正则方式)
    CoInitialize (0)
    RegExp.创建 (“VBScript.RegExp”, )
    RegExp.写属性 (“Pattern”, “^[\u4e00-\u9fa5]{1,}$”)
    bool ＝ RegExp.逻辑方法 (“Test”, 欲判断文本)
    RegExp.清除 ()
    CoUninitialize ()
    返回 (bool)
.如果真结束
' 非正则方式判断------------------------------------------------
.计次循环首 (局_长度, i)
    局_键代码 ＝ 取代码 (欲判断文本, i)
    .如果真 (局_键代码 ≥ 0)
        返回 (假)
    .如果真结束
.计次循环尾 ()
返回 (真)
.子程序 文本_是否为汉字2, 逻辑型, 公开, 中间不能有空格,判断一个文本第一个字是否是汉字,是汉字返回真,否则返回假
.参数 欲判断文本, 文本型
.局部变量 局_欲判断文本, 文本型
.局部变量 局_长度, 整数型
.局部变量 局_拼音, 文本型
局_欲判断文本 ＝ 欲判断文本
局_欲判断文本 ＝ 删全部空 (局_欲判断文本)
局_长度 ＝ 取文本长度 (局_欲判断文本)
.如果真 (局_长度 ＜ 2)
    返回 (假)
.如果真结束
局_拼音 ＝ 取拼音 (取文本左边 (局_欲判断文本, 2), 1)
返回 (局_拼音 ≠ “”)
.子程序 文本_是否为双字节字符, 逻辑型, 公开, By 火威网络 如果为双字节返回真，否则返回假。如果指定位置超出文本长度，返回0
.参数 欲检查文本, 字节集
.参数 欲检查的字符位置, 整数型, , 0为首位置，1为第2个位置，如此类推，必须是大于0。
返回 (IsDBCSLeadByte (取字节集数据 (欲检查文本, #字节型, 欲检查的字符位置)))
.子程序 文本_是否为双字节字符Ex, 逻辑型, 公开, By 火威网络 如果为双字节返回真，否则返回假。如果指定位置超出文本长度，返回0
.参数 欲检查文本, 字节集
.参数 欲检查的字符位置, 整数型, , 0为首位置，1为第2个位置，如此类推，必须是大于0。
返回 (IsDBCSLeadByteEx (0, 取字节集数据 (欲检查文本, #字节型, 欲检查的字符位置)))  ' CP_ACP
.子程序 文本_是否为字母, 逻辑型, 公开, 中间不能有空格
.参数 文本字符, 文本型
.局部变量 Len, 整数型
.局部变量 i, 整数型
.局部变量 asc, 整数型
Len ＝ 取文本长度 (文本字符)
.如果真 (Len ＝ 0)
    返回 (假)
.如果真结束
.计次循环首 (Len, i)
    asc ＝ 取代码 (文本字符, i)
    .判断开始 (asc ≥ 65 且 asc ≤ 90)  ' A-Z
    .判断 (asc ≥ 97 且 asc ≤ 122)  ' a-z
    .默认
        返回 (假)
    .判断结束
.计次循环尾 ()
返回 (真)
.子程序 文本_取出现次数, 整数型, 公开, 返回指定文本中指定内容出现的次数
.参数 被搜索文本, 文本型
.参数 欲搜索文本, 文本型
.参数 是否区分大小写, 逻辑型, 可空
.局部变量 位置_, 整数型, , , 感谢论坛会员 Mr.Yang提供的代码
.局部变量 i, 整数型
.如果真 (取文本长度 (被搜索文本) ＞ 0 且 取文本长度 (欲搜索文本) ＞ 0)
    位置_ ＝ 寻找文本 (被搜索文本, 欲搜索文本, , 取反 (是否区分大小写))
    .判断循环首 (位置_ ≠ -1)
        i ＝ i ＋ 1
        位置_ ＝ 寻找文本 (被搜索文本, 欲搜索文本, 位置_ ＋ 取文本长度 (欲搜索文本), 取反 (是否区分大小写))
    .判断循环尾 ()
.如果真结束
返回 (i)
.子程序 文本_首字母改大写, 文本型, 公开, 〈文本型〉 首字母大写 （文本）例： FOXPRO 或 foxpro，返回 Foxpro，注意本命令对首字为汉字的文本无效
.参数 英文文本, 文本型
返回 (到大写 (取文本左边 (英文文本, 1)) ＋ 取文本中间 (英文文本, 2, 取文本长度 (英文文本)))
.子程序 文本_取汉字区位码, 文本型, 公开, 返回一个汉字的区位码,如果汉字过长,只取第一个字,如果不是汉字,返回空
.参数 汉字, 文本型, , 传送一个汉字进行处理
.参数 区码还是位码, 整数型, 可空, 需返回的内容,1表示区码,2表示位码,3表示区码与位码都返回,默认为3
.局部变量 区码, 字节型
.局部变量 位码, 字节型
区码 ＝ 取代码 (取文本左边 (汉字, 1), )
位码 ＝ 取代码 (取文本中间 (汉字, 2, 1), )
.如果真 (区码 ＜ 176 或 区码 ＞ 247 或 位码 ＜ 161 或 位码 ＞ 254)
    返回 (“”)
.如果真结束
.判断开始 (区码还是位码 ＝ 1)
    返回 (到文本 (区码))
.判断 (区码还是位码 ＝ 2)
    返回 (到文本 (位码))
.判断 (区码还是位码 ＝ 3)
    返回 (到文本 (区码) ＋ 到文本 (位码))
.默认
    返回 (“”)
.判断结束
.子程序 文本_取汉字机内码, 文本型, 公开
.参数 汉字, 文本型
.局部变量 机内码, 整数型
.如果真 (取代码 (汉字, 1) ＞ 0)
    返回 (“”)
.如果真结束
机内码 ＝ (取代码 (汉字, 1) ＋ 256) × 256 ＋ 取代码 (汉字, 2) ＋ 256
返回 (取十六进制文本 (机内码))
' 区位码 ＝ 机内码 － 41120  ' 41120=A0A0H
.子程序 文本_取出中间文本, 文本型, 公开, 比如：欲取全文本为“12345”,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”，
.参数 欲取全文本, 文本型, , 比如：欲取全文本为 12345
.参数 前面文本, 文本型, , 3的前面为“2”，引号直接用 #引号，如："<font color="#引号red#引号">"
.参数 后面文本, 文本型, , 3的后面为“4”，引号直接用 #引号，如："<font color="#引号red#引号">"
.参数 起始搜寻位置, 整数型, 可空, 可空,这里是指搜寻 参数二 前面文本 的开始位置
.参数 是否不区分大小写, 逻辑型, 可空, 为真不区分大小写，为假区分。
.局部变量 局_前面文本位置, 整数型
.局部变量 局_后面文本位置, 整数型
.局部变量 局_前面文本, 文本型
.局部变量 局_后面文本, 文本型
局_前面文本 ＝ 子文本替换 (前面文本, “#引号”, #引号, , , 真)
局_后面文本 ＝ 子文本替换 (后面文本, “#引号”, #引号, , , 真)
局_前面文本位置 ＝ 寻找文本 (欲取全文本, 局_前面文本, 起始搜寻位置, 是否不区分大小写)
.如果真 (局_前面文本位置 ≠ -1)
    局_前面文本位置 ＝ 局_前面文本位置 ＋ 取文本长度 (局_前面文本)
    局_后面文本位置 ＝ 寻找文本 (欲取全文本, 局_后面文本, 局_前面文本位置, 是否不区分大小写)
    .如果真 (局_后面文本位置 ≠ -1)
        返回 (取文本中间 (欲取全文本, 局_前面文本位置, 局_后面文本位置 － 局_前面文本位置))
    .如果真结束
.如果真结束
返回 (“”)
.子程序 文本_倒取出中间文本, 文本型, 公开, 比如：欲取全文本为“0012345”,现在要取出“123”，<123>的右边为“4”，<123>的左边为“0”，注意这里是倒取
.参数 欲取全文本, 文本型, , 比如：欲取全文本为“0012345”
.参数 右边文本, 文本型, , 123的右边为“4”，引号直接用 #引号，如："<font color=#引号red#引号>" 注意左右
.参数 左边文本, 文本型, , 123的左边为“0”，引号直接用 #引号，如："<font color=#引号red#引号>" 注意左右
.参数 倒数搜寻位置, 整数型, 可空, 可空,这里是指搜寻 参数二 右边文本的开始位置
.参数 是否不区分大小写, 逻辑型, 可空, 默认为假：区分大小写 真：不区分大小写
.局部变量 局_左边, 文本型
.局部变量 局_右边, 文本型
.局部变量 rPos, 整数型
.局部变量 lPos, 整数型
局_右边 ＝ 子文本替换 (右边文本, “#引号”, #引号, , , 真)
局_左边 ＝ 子文本替换 (左边文本, “#引号”, #引号, , , 真)
倒数搜寻位置 ＝ 选择 (倒数搜寻位置 ≤ 0, -1, 倒数搜寻位置)
倒数搜寻位置 ＝ 取文本长度 (欲取全文本) － 倒数搜寻位置
rPos ＝ 倒找文本 (欲取全文本, 局_右边, 倒数搜寻位置, 是否不区分大小写)
.如果真 (rPos ≠ -1)
    lPos ＝ 倒找文本 (欲取全文本, 局_左边, rPos, 是否不区分大小写)
    .如果真 (lPos ≠ -1)
        lPos ＝ lPos ＋ 取文本长度 (局_左边)
    .如果真结束
    返回 (取文本中间 (欲取全文本, lPos, rPos － lPos))
.如果真结束
返回 (“”)
.子程序 文本_取文本所在行, 整数型, 公开, 查找某段字或关键中在文本中的哪一行出现，成功返回行数，失败返回0
.参数 源文本, 文本型
.参数 欲查找的文本, 文本型
.参数 是否区分大小写, 逻辑型, 可空
.局部变量 局_文本, 文本型, , "0"
.局部变量 局_计次, 整数型
局_文本 ＝ 分割文本 (源文本, #换行符, )
.计次循环首 (取数组成员数 (局_文本), 局_计次)
    .如果真 (寻找文本 (局_文本 [局_计次], 欲查找的文本, , 取反 (是否区分大小写)) ≠ -1)
        返回 (局_计次)
    .如果真结束
.计次循环尾 ()
返回 (0)
.子程序 文本_取文本所在行_优化版, 整数型, 公开, 查找某段字或关键中在文本中的哪一行出现，成功返回行数，失败返回0
.参数 源文本, 文本型
.参数 欲查找的文本, 文本型
.参数 起始搜寻位置, 整数型, 可空, 位置值从 1 开始。如果本参数被省略，默认为 1 【单位：行】
.参数 是否区分大小写, 逻辑型, 可空
.局部变量 局_文本, 文本型, , "0"
.局部变量 局_计次, 整数型
局_文本 ＝ 分割文本 (源文本, #换行符, )
.计次循环首 (取数组成员数 (局_文本), 局_计次)
    .如果真 (是否为空 (起始搜寻位置))
        起始搜寻位置 ＝ 1
    .如果真结束
    .如果真 (寻找文本 (局_文本 [局_计次], 欲查找的文本, , 取反 (是否区分大小写)) ≠ -1)
        .如果真 (局_计次 ≥ 起始搜寻位置)
            返回 (局_计次)
        .如果真结束
    .如果真结束
.计次循环尾 ()
返回 (0)
.子程序 文本_取汉字区位码2, 整数型, 公开
.参数 汉字, 文本型
.局部变量 机内码, 整数型
.如果真 (取代码 (汉字, 1) ＞ 0)
    返回 (0)
.如果真结束
机内码 ＝ (取代码 (汉字, 1) ＋ 256) × 256 ＋ 取代码 (汉字, 2) ＋ 256
' 返回 (取十六进制文本 (机内码))
返回 (机内码 － 41120)  ' 41120=A0A0H
.子程序 文本_删除指定文本行, 文本型, 公开, 删除指定文本的一行文本，返回删行后的文本
.参数 源文本, 文本型
.参数 行数, 整数型, , 输入你想删除的行数，如：想删除第3行的整行文本就直接输3
.局部变量 临时文本, 文本型, , "0"
.局部变量 计次, 整数型
.局部变量 输出文本, 文本型
输出文本 ＝ 源文本
.如果真 (寻找文本 (输出文本, #换行符, , 假) ＝ -1)
    输出文本 ＝ 输出文本 ＋ #换行符
.如果真结束
临时文本 ＝ 分割文本 (输出文本, #换行符, )
输出文本 ＝ “”
删除成员 (临时文本, 行数, )
.计次循环首 (取数组成员数 (临时文本), 计次)
    .如果 (取数组成员数 (临时文本) ≠ 计次)
        输出文本 ＝ 输出文本 ＋ 临时文本 [计次] ＋ #换行符
    .否则
        输出文本 ＝ 输出文本 ＋ 临时文本 [计次]
    .如果结束
.计次循环尾 ()
清除数组 (临时文本)
返回 (输出文本)
.子程序 文本_删除指定文件行, 逻辑型, 公开, 删除指定文件内的一行文本。
.参数 文件路径, 文本型
.参数 要删除的文本行文本, 文本型
.局部变量 内容, 字节集
.局部变量 行头, 整数型
.局部变量 局_数据, 字节集
内容 ＝ 读入文件 (文件路径)
行头 ＝ 寻找字节集 (内容, 到字节集 (要删除的文本行文本), )
局_数据 ＝ 字节集替换 (内容, 行头, 取字节集长度 (到字节集 (要删除的文本行文本) ＋ { 13, 10 }), {  })
返回 (写到文件 (文件路径, 局_数据))
.子程序 文本_取随机范围数字, 文本型, 公开, 如1-100之间的双数或单数或单双一起！
.参数 起始数, 整数型, , 如：1
.参数 结束数, 整数型, , 如：1000
.参数 单双选择, 整数型, 可空, 1为单，2为双,否则为取单双
.局部变量 临时整数, 整数型
.判断开始 (起始数 ＝ 结束数)
    返回 (到文本 (起始数))
.判断 (起始数 ＞ 结束数)
    临时整数 ＝ 汇编_取随机数 (结束数, 起始数)
.默认
    临时整数 ＝ 汇编_取随机数 (起始数, 结束数)
.判断结束
.判断开始 (单双选择 ＝ 1)
    .如果真 (临时整数 ％ 2 ＝ 0)
        .判断开始 (临时整数 ＝ 结束数)
            临时整数 ＝ 临时整数 － 1
        .默认
            临时整数 ＝ 临时整数 ＋ 1
        .判断结束
    .如果真结束
    返回 (到文本 (临时整数))
.判断 (单双选择 ＝ 2)
    .如果真 (临时整数 ％ 2 ＝ 1)
        .判断开始 (临时整数 ＝ 结束数)
            临时整数 ＝ 临时整数 － 1
        .默认
            临时整数 ＝ 临时整数 ＋ 1
        .判断结束
    .如果真结束
    返回 (到文本 (临时整数))
.默认
    返回 (到文本 (临时整数))
.判断结束
.子程序 文本_删除指定文件文本行1, 逻辑型, 公开, 感谢 @jr21066 分享开源
.参数 参_文件路径, 文本型
.参数 参_行号, 整数型
.局部变量 局_内容, 字节集
.局部变量 局_行开始, 整数型
.局部变量 局_行结束, 整数型
' 真有人来参数0.也不出错了
.如果真 (参_行号 ＝ 0)
    返回 (假)
.如果真结束
局_内容 ＝ 读入文件 (参_文件路径)
.计次循环首 (参_行号 － 1, )
    ' 行开始定位到换行符的后边
    局_行开始 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
    .如果 (局_行开始 ＝ -1)
        返回 (假)
    .否则
        局_行开始 ＝ 局_行开始 ＋ 1
    .如果结束
.计次循环尾 ()
局_行结束 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
.如果 (局_行结束 ＝ -1)
    ' 如果文件尾没有换行符就以文件尾为单位
    .如果 (取字节集长度 (局_内容) ＞ 局_行开始)
        局_行结束 ＝ 取字节集长度 (局_内容)
    .否则
        返回 (假)
    .如果结束
.否则
    局_行结束 ＝ 局_行结束 ＋ 1
.如果结束
.如果真 (写到文件 (参_文件路径, 取字节集左边 (局_内容, 局_行开始) ＋ 取字节集右边 (局_内容, 取字节集长度 (局_内容) － 局_行结束)))
    返回 (真)
.如果真结束
返回 (假)
.子程序 文本_删除指定变量文本行1, 文本型, 公开, 感谢【@jr21066 】分享开源
.参数 参_文本, 文本型
.参数 参_行号, 整数型
.局部变量 局_行开始, 整数型
.局部变量 局_行结束, 整数型
.如果真 (参_行号 ＝ 0)
    返回 (参_文本)
.如果真结束
.计次循环首 (参_行号 － 1, )
    局_行开始 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
    .如果 (局_行开始 ＝ -1)
        返回 (“”)
    .否则
        局_行开始 ＝ 局_行开始 ＋ 1
    .如果结束
.计次循环尾 ()
局_行结束 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
.如果 (局_行结束 ＝ -1)
    .如果 (取文本长度 (参_文本) ＞ 局_行开始)
        局_行结束 ＝ 取文本长度 (参_文本)
    .否则
        返回 (“”)
    .如果结束
.否则
    局_行结束 ＝ 局_行结束 ＋ 1
.如果结束
返回 (取文本左边 (参_文本, 局_行开始) ＋ 取文本右边 (参_文本, 取文本长度 (参_文本) － 局_行结束))
.子程序 文本_取文本起始位置, , 公开, 返回某个字符的在整个文本中出现的位置数组，数组第一个成员是第一次出现的位置。
.参数 文本, 文本型
.参数 欲搜寻的文本, 文本型
.参数 起始位置, 整数型, 参考 数组
.局部变量 起始位置数值, 整数型
.局部变量 起始位置数值2, 整数型
.局部变量 文本长度, 整数型
.局部变量 计次, 整数型
文本长度 ＝ 取文本长度 (欲搜寻的文本)
.计次循环首 (文本_取出现次数 (文本, 欲搜寻的文本), 计次)
    .如果 (计次 ＝ 1)
        起始位置数值 ＝ 寻找文本 (文本, 欲搜寻的文本, , 真)
        起始位置数值2 ＝ 起始位置数值 ＋ 文本长度 ＋ 1
        加入成员 (起始位置, 起始位置数值)
    .否则
        起始位置数值2 ＝ 寻找文本 (文本, 欲搜寻的文本, 起始位置数值2, 真)
        加入成员 (起始位置, 起始位置数值2)
        起始位置数值2 ＝ 起始位置数值2 ＋ 文本长度
    .如果结束
.计次循环尾 ()
.子程序 字节集_取空白字节集, 字节集, 公开, 汇编方式申请空白字节集, 返回具有特定数目 0 字节的字节集; 注意, 命令本身不会处理内存释放, 请不要连续反复调用
.参数 字节集长度, 整数型
HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 字节集长度 ＋ 8)
置入代码 ({ 199, 0, 1, 0, 0, 0, 255, 117, 8, 143, 64, 4, 139, 229, 93, 194, 4, 0 })
' mov dword ptr[eax],01h  ;字节集 前4位 为整数1，第二个4位 是整数 字节集长度，写入1标记为字节集，可以当 字节数组引用
' push dword ptr[ebp+8]
' pop dword ptr[eax+4]
' mov esp,ebp
' pop ebp
' retn 4
返回 ({  })
.子程序 文本_文本数组排序, , 公开, 排序从z到a排序或从a-z排序
.参数 要排序的数组, 文本型, 数组, 要排序的数组。
.参数 排序后的数组, 文本型, 参考 数组, 排序后结果返回的数组。
.参数 排序方向是否从大到小, 逻辑型, 可空, 如果参数值为真，排序将从小到大；如果为假，则为从打到小。如果本参数被省略，将默认为假
.局部变量 A, 整数型
.局部变量 B, 整数型
.局部变量 C, 整数型
.局部变量 临时_文本, 文本型
.如果真 (是否为空 (排序方向是否从大到小))
    排序方向是否从大到小 ＝ 假
.如果真结束
' 注意：这里要保证原来的数组不发生改变，所以所有的排序操作都应该在排序后的数组中。
复制数组 (排序后的数组, 要排序的数组)
A ＝ 取数组成员数 (排序后的数组)
.如果 (排序方向是否从大到小 ＝ 真)
    .判断循环首 (A ＞ 0)
        C ＝ 0
        .变量循环首 (1, A － 1, 1, B)
            .如果真 (排序后的数组 [B] ＜ 排序后的数组 [B ＋ 1])
                临时_文本 ＝ 排序后的数组 [B]
                排序后的数组 [B] ＝ 排序后的数组 [B ＋ 1]
                排序后的数组 [B ＋ 1] ＝ 临时_文本
                C ＝ B
            .如果真结束
        .变量循环尾 ()
        A ＝ C
    .判断循环尾 ()
.否则
    .判断循环首 (A ＞ 0)
        C ＝ 0
        .变量循环首 (1, A － 1, 1, B)
            .如果真 (排序后的数组 [B] ＞ 排序后的数组 [B ＋ 1])
                临时_文本 ＝ 排序后的数组 [B]
                排序后的数组 [B] ＝ 排序后的数组 [B ＋ 1]
                排序后的数组 [B ＋ 1] ＝ 临时_文本
                C ＝ B
            .如果真结束
        .变量循环尾 ()
        A ＝ C
    .判断循环尾 ()
.如果结束
.子程序 文本_插入文本到某行前, 文本型, 公开, 将文本加入到某行之前，返回加入后的文本。
.参数 原文本, 文本型
.参数 行数, 整数型
.参数 欲插入内容, 文本型
.局部变量 文本数组, 文本型, , "0"
.局部变量 输出文本, 文本型
.局部变量 计次, 整数型
文本数组 ＝ 分割文本 (原文本, #换行符, )
.如果真 (行数 ≤ 取数组成员数 (文本数组))
    文本数组 [行数] ＝ 欲插入内容 ＋ 文本数组 [行数]
    .计次循环首 (取数组成员数 (文本数组), 计次)
        .如果真 (取数组成员数 (文本数组) ＝ 计次)
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
            跳出循环 ()
        .如果真结束
        输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
    .计次循环尾 ()
    清除数组 (文本数组)
    返回 (输出文本)
.如果真结束
清除数组 (文本数组)
返回 (“”)
.子程序 文本_插入文本到某行后, 文本型, 公开, 将文本加入到某行之后，返回加入后的文本。
.参数 原文本, 文本型
.参数 行数, 整数型, , 行数不能小于或等于0
.参数 欲插入内容, 文本型
.局部变量 文本数组, 文本型, , "0"
.局部变量 输出文本, 文本型
.局部变量 计次, 整数型
文本数组 ＝ 分割文本 (原文本, #换行符, )
.如果真 (行数 ＞ 0 且 行数 ≤ 取数组成员数 (文本数组))
    文本数组 [行数] ＝ 文本数组 [行数] ＋ 欲插入内容
    .计次循环首 (取数组成员数 (文本数组), 计次)
        .如果真 (取数组成员数 (文本数组) ＝ 计次)
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
            跳出循环 ()
        .如果真结束
        输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
    .计次循环尾 ()
    清除数组 (文本数组)
    返回 (输出文本)
.如果真结束
清除数组 (文本数组)
返回 (“”)
.子程序 文本_插入文本到某位置, 文本型, 公开, 插入某文本到左起某一位置，原文本后移，返回插入后的文本。
.参数 原文本, 文本型
.参数 欲插入的文本, 文本型
.参数 插入位置, 整数型, , 位置必须为偶数值（字母、数字、标点、符号都和汉字均占2长度)
返回 (到半角 (文本替换 (到全角 (原文本), 插入位置 － 1, 0, 到全角 (欲插入的文本))))
.子程序 文本_取字符串宽度, 整数型, 公开
.参数 启动窗口句柄, 整数型
.参数 欲要取出的字符串, 文本型
.局部变量 Size, 精易_坐标
GetTextExtentPointA (GetDC (启动窗口句柄), 欲要取出的字符串, 取文本长度 (欲要取出的字符串), Size)
返回 (Size.横)
.子程序 文本_取指定文件文本行, 文本型, 公开, 成功返回指定的文本行文本，失败返回空文本。
.参数 文件路径, 文本型
.参数 行号, 整数型
.局部变量 文本数组, 文本型, , "0"
.局部变量 文本内容, 文本型
文本内容 ＝ 到文本 (读入文件 (文件路径))
文本数组 ＝ 分割文本 (文本内容, #换行符, )
.如果真 (行号 ≤ 0)
    返回 (“”)
.如果真结束
.如果真 (行号 ＞ 取数组成员数 (文本数组))
    返回 (“”)
.如果真结束
返回 (文本数组 [行号])
.子程序 文本_取指定变量文本行, 文本型, 公开, 成功返回指定的文本行文本，失败返回空文本。
.参数 文本, 文本型
.参数 行号, 整数型
.局部变量 文本数组, 文本型, , "0"
文本数组 ＝ 分割文本 (文本, #换行符, )
.如果真 (行号 ≤ 0)
    返回 (“”)
.如果真结束
.如果真 (行号 ＞ 取数组成员数 (文本数组))
    返回 (“”)
.如果真结束
返回 (文本数组 [行号])
.子程序 文本_取指定文件文本行1, 文本型, 公开, 感谢【@jr21066】分享开源
.参数 参_文件路径, 文本型
.参数 参_行号, 整数型
.局部变量 局_内容, 字节集
.局部变量 局_行开始, 整数型
.局部变量 局_行结束, 整数型
.如果真 (参_行号 ＝ 0)
    返回 (“”)
.如果真结束
局_内容 ＝ 读入文件 (参_文件路径)
.计次循环首 (参_行号 － 1, )
    局_行开始 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
    .如果 (局_行开始 ＝ -1)
        返回 (“”)
    .否则
        局_行开始 ＝ 局_行开始 ＋ 2
    .如果结束
.计次循环尾 ()
.如果真 (局_行开始 ＝ 0)
    局_行开始 ＝ 1
.如果真结束
局_行结束 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
.如果 (局_行结束 ＝ -1)
    .如果 (取字节集长度 (局_内容) ＞ 局_行开始)
        局_行结束 ＝ 取字节集长度 (局_内容) ＋ 1
    .否则
        返回 (“”)
    .如果结束
.否则
    局_行结束 ＝ 局_行结束 ＋ 2
.如果结束
返回 (到文本 (取字节集中间 (局_内容, 局_行开始, 局_行结束 － 局_行开始)))
.子程序 文本_取指定变量文本行1, 文本型, 公开
.参数 欲取其部分的文本, 文本型
.参数 行号, 整数型
.局部变量 局_长度, 整数型
.局部变量 局_次数, 整数型
.局部变量 i, 整数型
.局部变量 局_行首, 整数型
.局部变量 局_行尾, 整数型
' https://bbs.125.la/thread-14539818-1-1.html
.如果真 (行号 ＝ 0)
    返回 (“”)
.如果真结束
局_次数 ＝ 行号 － 1
局_行首 ＝ 1
.计次循环首 (局_次数, i)
    局_行首 ＝ 寻找文本 (欲取其部分的文本, #换行符, 局_行首, 假)
    .如果真 (局_行首 ＝ -1)
        返回 (“”)
    .如果真结束
    局_行首 ＝ 局_行首 ＋ 2
.计次循环尾 ()
局_行尾 ＝ 寻找文本 (欲取其部分的文本, #换行符, 局_行首, 假)
.如果 (局_行尾 ＝ -1)
    局_长度 ＝ 取文本长度 (欲取其部分的文本)
    返回 (取文本右边 (欲取其部分的文本, 局_长度 － 局_行首 ＋ 1))
.否则
    返回 (取文本中间 (欲取其部分的文本, 局_行首, 局_行尾 － 局_行首))
.如果结束
.子程序 文本_取文本行出现次数, 整数型, 公开, 取某行文本共出现了多少次，不存在返回-1。
.参数 被搜寻的文本, 文本型
.参数 行数, 整数型
.局部变量 文本数组, 文本型, , "0"
.局部变量 出现的次数, 整数型
文本数组 ＝ 分割文本 (被搜寻的文本, 文本_取指定变量文本行 (被搜寻的文本, 行数), )
出现的次数 ＝ 取数组成员数 (文本数组) － 1
.如果 (出现的次数 ＜ 0)
    清除数组 (文本数组)
    返回 (-1)
.否则
    清除数组 (文本数组)
    返回 (出现的次数)
.如果结束
.子程序 文本_取文本行起始位置, , 公开, 返回某行在整个文本中出现的位置数组，数组第一个成员是第一次出现的位置。
.参数 文本, 文本型
.参数 行数, 整数型
.参数 起始位置, 整数型, 参考 数组
.局部变量 起始位置数值, 整数型
.局部变量 起始位置数值2, 整数型
.局部变量 文本行, 文本型
.局部变量 文本长度, 整数型
.局部变量 计次, 整数型
文本行 ＝ 文本_取指定变量文本行 (文本, 行数)
文本长度 ＝ 取文本长度 (文本行)
.计次循环首 (文本_取文本行出现次数 (文本, 行数), 计次)
    .如果 (计次 ＝ 1)
        起始位置数值 ＝ 寻找文本 (文本, 文本行, , 真)
        起始位置数值2 ＝ 起始位置数值 ＋ 文本长度 ＋ 1
        加入成员 (起始位置, 起始位置数值)
    .否则
        起始位置数值2 ＝ 寻找文本 (文本, 文本行, 起始位置数值2, 真)
        加入成员 (起始位置, 起始位置数值2)
        起始位置数值2 ＝ 起始位置数值2 ＋ 文本长度
    .如果结束
.计次循环尾 ()
.子程序 文本_寻找出文本并删除, 文本型, 公开, 比如：欲寻找的全文本为<12345789>,现在要删除2到5之间的全部字符，包括2跟5,成功返回删除后的结果文本，失败返回原文本！
.参数 欲寻找的全文本, 文本型, , 比如：欲寻找的全文本为 12345789
.参数 前面文本, 文本型, , 前面为“2”
.参数 后面文本, 文本型, , 后面为“5”
.参数 是否保留前后文本, 逻辑型, 可空, 默认不保留
.局部变量 中间文本, 文本型
.局部变量 起始位置, 整数型
.计次循环首 (文本_取出现次数 (欲寻找的全文本, 前面文本, ), )
    中间文本 ＝ 文本_取出中间文本 (欲寻找的全文本, 前面文本, 后面文本, 起始位置, )
    .如果 (是否保留前后文本 ＝ 真)
        欲寻找的全文本 ＝ 子文本替换 (欲寻找的全文本, 前面文本 ＋ 中间文本 ＋ 后面文本, 前面文本 ＋ 后面文本, , 1, 真)
        起始位置 ＝ 寻找文本 (欲寻找的全文本, 前面文本 ＋ 后面文本, 起始位置, 假) ＋ 取文本长度 (前面文本 ＋ 后面文本)
    .否则
        欲寻找的全文本 ＝ 子文本替换 (欲寻找的全文本, 前面文本 ＋ 中间文本 ＋ 后面文本, , , 1, 真)
    .如果结束
.计次循环尾 ()
返回 (欲寻找的全文本)
.子程序 文本_插入文本到某字前, 文本型, 公开, 插入文本到某字前，返回插入后的文本。
.参数 原文本, 文本型
.参数 某字, 文本型
.参数 被插在某字前的文本, 文本型
.参数 插入次数, 整数型, 可空, 如果省略，默认进行所有可能的插入
.如果真 (是否为空 (插入次数))
    返回 (子文本替换 (原文本, 某字, 被插在某字前的文本 ＋ 某字, , , 假))
.如果真结束
返回 (子文本替换 (原文本, 某字, 被插在某字前的文本 ＋ 某字, , 插入次数, 假))
.子程序 文本_插入文本到某字后, 文本型, 公开, 插入文本到某字后，返回插入后的文本。
.参数 原文本, 文本型
.参数 某字, 文本型
.参数 被插在某字后的文本, 文本型
.参数 插入次数, 整数型, 可空, 如果省略，默认进行所有可能的插入
.如果真 (是否为空 (插入次数))
    返回 (子文本替换 (原文本, 某字, 某字 ＋ 被插在某字后的文本, , , 假))
.如果真结束
返回 (子文本替换 (原文本, 某字, 某字 ＋ 被插在某字后的文本, , 插入次数, 假))
.子程序 文本_取出N组不重复数字, , 公开, 取出N组不重复数字,如：在1-100之间取出80个数字，要求不重复。
.参数 返回取出的数组, 整数型, 数组, 存放取出来的数组
.参数 欲取多少组, 整数型, , 要取多少组
.参数 最小值, 整数型, , 要取的最小数值
.参数 最大值, 整数型, , 要取的最大数值
.局部变量 局_计次, 整数型
.局部变量 局_大计次, 整数型
.局部变量 局_随机数, 整数型
清除数组 (返回取出的数组)
.计次循环首 (欲取多少组, 局_大计次)
    局_随机数 ＝ 汇编_取随机数 (最小值, 最大值)
    .如果 (取数组成员数 (返回取出的数组) ＞ 0)
        .循环判断首 ()
            局_计次 ＝ 局_计次 ＋ 1
            .如果真 (局_随机数 ＝ 返回取出的数组 [局_计次])
                局_随机数 ＝ 汇编_取随机数 (最小值, 最大值)
                局_计次 ＝ 0
                到循环尾 ()
            .如果真结束
            .如果真 (局_随机数 ≠ 返回取出的数组 [局_计次] 且 局_计次 ＝ 取数组成员数 (返回取出的数组))
                加入成员 (返回取出的数组, 局_随机数)
                局_计次 ＝ 0
                跳出循环 ()
            .如果真结束
        .循环判断尾 (局_计次 ≠ 取数组成员数 (返回取出的数组))
    .否则
        加入成员 (返回取出的数组, 局_随机数)
    .如果结束
.计次循环尾 ()
.子程序 文本_取GB2312简体汉字笔画数, 整数型, 公开
.参数 汉字, 文本型
.局部变量 数据, 整数型, 静态, "0", 代码作者：袁晓辉（海洋）
.局部变量 区码, 字节型
.局部变量 位码, 字节型
.局部变量 索引, 整数型
数据 ＝ { 10, 7, 10, 10, 8, 10, 9, 11, 17, 14, 13, 5, 13, 10, 12, 15, 10, 6, 10, 9, 13, 8, 10, 10, 8, 8, 10, 5, 10, 14, 16, 9, 12, 12, 15, 15, 7, 10, 5, 5, 7, 10, 2, 9, 4, 8, 12, 13, 7, 10, 7, 21, 10, 8, 5, 9, 6, 13, 8, 8, 9, 13, 12, 10, 13, 7, 10, 10, 8, 8, 7, 8, 7, 19, 5, 4, 8, 5, 9, 10, 14, 14, 9, 12, 15, 10, 15, 12, 12, 8, 9, 5, 15, 10, 16, 13, 9, 12, 8, 8, 8, 7, 15, 10, 13, 19, 8, 13, 12, 8, 5, 12, 9, 4, 9, 10, 7, 8, 12, 12, 10, 8, 8, 5, 11, 11, 11, 9, 9, 18, 9, 12, 14, 4, 13, 10, 8, 14, 13, 14, 6, 10, 9, 4, 7, 13, 6, 11, 14, 5, 13, 16, 17, 16, 9, 18, 5, 12, 8, 9, 9, 8, 4, 16, 16, 17, 12, 9, 11, 15, 8, 19, 16, 7, 15, 11, 12, 16, 13, 10, 13, 7, 6, 9, 5, 8, 9, 9, 10, 6, 8, 11, 15, 8, 10, 8, 12, 9, 13, 10, 14, 7, 8, 11, 11, 14, 12, 8, 7, 10, 2, 10, 7, 11, 4, 5, 7, 19, 10, 8, 17, 11, 12, 7, 3, 7, 12, 15, 8, 11, 11, 14, 16, 8, 10, 9, 11, 11, 7, 7, 10, 4, 7, 17, 16, 16, 15, 11, 9, 8, 12, 8, 5, 9, 7, 19, 12, 3, 9, 9, 9, 14, 12, 14, 7, 9, 8, 8, 10, 10, 12, 11, 14, 12, 11, 13, 11, 6, 11, 19, 8, 11, 6, 9, 11, 4, 11, 7, 2, 12, 8, 11, 10, 12, 7, 9, 12, 15, 15, 11, 7, 8, 4, 7, 15, 12, 7, 15, 10, 6, 7, 6, 11, 7, 7, 7, 12, 8, 15, 10, 9, 16, 6, 7, 10, 12, 12, 15, 8, 8, 10, 10, 10, 6, 13, 9, 11, 6, 7, 6, 6, 10, 8, 8, 4, 7, 10, 5, 9, 6, 6, 6, 11, 8, 8, 13, 12, 14, 13, 13, 13, 4, 11, 14, 4, 10, 7, 5, 16, 12, 18, 12, 13, 12, 9, 13, 10, 12, 24, 13, 13, 5, 12, 3, 9, 13, 7, 11, 12, 7, 9, 12, 15, 7, 6, 6, 7, 8, 11, 13, 8, 9, 13, 15, 10, 11, 7, 21, 18, 11, 11, 9, 14, 14, 13, 13, 10, 7, 6, 8, 12, 6, 15, 12, 7, 5, 4, 5, 11, 11, 15, 17, 9, 19, 16, 12, 14, 11, 13, 10, 13, 14, 11, 14, 7, 6, 3, 14, 15, 12, 11, 10, 13, 12, 6, 12, 14, 5, 3, 7, 4, 12, 17, 9, 9, 5, 9, 11, 9, 11, 9, 10, 8, 4, 8, 10, 11, 9, 5, 12, 7, 11, 11, 8, 11, 11, 6, 9, 10, 9, 10, 2, 10, 17, 10, 7, 11, 6, 8, 15, 11, 12, 11, 15, 11, 8, 19, 6, 12, 12, 17, 14, 4, 12, 7, 14, 8, 10, 11, 7, 10, 14, 14, 8, 8, 6, 12, 11, 9, 7, 10, 12, 16, 11, 13, 13, 9, 8, 16, 9, 5, 7, 7, 8, 11, 12, 11, 13, 13, 5, 16, 10, 2, 11, 6, 8, 10, 12, 10, 14, 15, 8, 11, 13, 2, 7, 5, 7, 8, 12, 13, 8, 4, 6, 5, 5, 12, 15, 6, 9, 8, 9, 7, 9, 11, 7, 4, 9, 7, 10, 12, 10, 13, 9, 12, 9, 10, 11, 13, 12, 7, 14, 7, 9, 12, 7, 14, 12, 14, 9, 11, 12, 11, 7, 4, 5, 15, 7, 19, 12, 10, 7, 9, 9, 12, 11, 9, 6, 6, 9, 13, 6, 13, 11, 8, 12, 11, 13, 10, 12, 9, 15, 6, 10, 10, 4, 7, 12, 11, 10, 10, 6, 2, 6, 5, 9, 9, 2, 9, 5, 9, 12, 6, 4, 9, 8, 9, 18, 6, 12, 18, 15, 8, 8, 17, 3, 10, 4, 7, 8, 8, 5, 7, 7, 7, 7, 4, 8, 8, 6, 7, 6, 6, 7, 8, 11, 8, 11, 3, 8, 10, 10, 7, 8, 8, 8, 9, 7, 11, 7, 8, 4, 7, 7, 12, 7, 10, 8, 6, 8, 12, 12, 4, 9, 8, 13, 10, 12, 4, 9, 11, 10, 5, 13, 6, 8, 4, 7, 7, 4, 15, 8, 14, 7, 8, 13, 12, 9, 11, 6, 9, 8, 10, 11, 13, 11, 5, 7, 7, 11, 10, 10, 8, 11, 12, 8, 14, 9, 11, 18, 12, 9, 12, 5, 8, 4, 13, 6, 12, 4, 7, 6, 13, 8, 15, 14, 8, 7, 13, 9, 11, 12, 3, 5, 7, 9, 9, 7, 10, 13, 8, 11, 21, 4, 6, 9, 9, 7, 7, 7, 12, 7, 16, 10, 10, 14, 10, 16, 13, 15, 15, 7, 10, 14, 12, 4, 11, 10, 8, 12, 9, 12, 10, 12, 9, 12, 11, 3, 6, 9, 10, 13, 10, 7, 8, 19, 10, 10, 11, 3, 7, 5, 10, 11, 8, 10, 4, 9, 3, 6, 7, 9, 7, 6, 9, 4, 7, 8, 8, 9, 8, 8, 11, 12, 11, 8, 14, 7, 8, 8, 8, 13, 5, 11, 9, 7, 8, 9, 10, 8, 12, 8, 5, 9, 14, 9, 13, 8, 8, 8, 12, 6, 8, 9, 6, 14, 11, 23, 12, 20, 8, 6, 3, 10, 13, 8, 6, 11, 5, 7, 9, 6, 9, 8, 9, 10, 8, 13, 9, 8, 12, 13, 12, 12, 10, 8, 8, 14, 6, 9, 15, 9, 10, 10, 6, 10, 9, 12, 14, 7, 12, 7, 11, 12, 8, 12, 7, 16, 16, 10, 7, 16, 10, 11, 6, 5, 5, 8, 10, 17, 17, 14, 11, 9, 6, 10, 5, 10, 8, 12, 10, 11, 10, 5, 8, 7, 6, 11, 13, 9, 8, 11, 14, 14, 15, 9, 15, 12, 11, 9, 9, 9, 10, 7, 15, 16, 9, 8, 9, 10, 9, 11, 9, 7, 5, 6, 12, 9, 12, 7, 9, 10, 6, 8, 5, 8, 13, 10, 12, 9, 15, 8, 15, 12, 8, 8, 11, 7, 4, 7, 4, 7, 9, 6, 12, 12, 8, 6, 4, 8, 13, 9, 7, 11, 7, 6, 8, 10, 7, 12, 10, 11, 10, 12, 13, 11, 10, 9, 4, 9, 12, 11, 16, 15, 17, 9, 11, 12, 13, 10, 13, 9, 11, 6, 9, 12, 17, 9, 12, 6, 13, 10, 15, 5, 12, 11, 10, 11, 6, 10, 5, 6, 9, 9, 9, 8, 11, 13, 9, 11, 17, 9, 6, 4, 10, 8, 12, 16, 8, 11, 5, 6, 11, 6, 13, 15, 10, 14, 6, 5, 9, 16, 4, 7, 10, 11, 12, 6, 7, 12, 13, 20, 12, 3, 9, 10, 6, 7, 13, 6, 9, 2, 10, 3, 13, 7, 16, 8, 6, 11, 8, 11, 9, 11, 11, 4, 5, 9, 7, 7, 7, 10, 6, 14, 9, 6, 8, 10, 5, 9, 12, 10, 5, 10, 11, 15, 6, 9, 8, 13, 7, 10, 7, 6, 11, 7, 13, 10, 8, 8, 6, 12, 9, 11, 9, 14, 12, 8, 10, 13, 9, 11, 11, 9, 14, 13, 12, 9, 4, 13, 15, 6, 10, 10, 9, 8, 11, 12, 10, 8, 15, 9, 9, 10, 6, 19, 12, 10, 9, 6, 6, 13, 8, 15, 12, 17, 12, 10, 6, 8, 9, 9, 9, 20, 12, 11, 11, 8, 11, 9, 7, 9, 16, 9, 13, 11, 14, 10, 10, 5, 12, 12, 11, 9, 11, 12, 6, 14, 7, 5, 10, 8, 11, 13, 14, 9, 9, 13, 8, 7, 17, 7, 9, 10, 4, 9, 9, 8, 3, 12, 4, 8, 4, 9, 18, 10, 13, 4, 13, 7, 13, 10, 13, 7, 10, 10, 6, 7, 9, 14, 8, 13, 12, 16, 8, 11, 14, 13, 8, 4, 19, 12, 11, 14, 14, 12, 16, 8, 10, 13, 11, 10, 8, 9, 12, 12, 7, 5, 7, 9, 3, 7, 2, 10, 11, 11, 5, 6, 13, 8, 12, 8, 17, 8, 8, 10, 8, 8, 11, 7, 8, 9, 9, 8, 14, 7, 11, 4, 8, 11, 15, 13, 10, 5, 11, 8, 10, 10, 12, 10, 10, 11, 8, 10, 15, 23, 7, 11, 10, 17, 9, 6, 6, 9, 7, 11, 9, 6, 7, 10, 9, 12, 10, 9, 10, 12, 8, 5, 9, 4, 12, 13, 8, 12, 5, 12, 11, 7, 9, 9, 11, 14, 17, 6, 7, 4, 8, 6, 9, 10, 15, 8, 8, 9, 12, 15, 14, 9, 7, 9, 5, 12, 7, 8, 9, 10, 8, 11, 9, 10, 7, 7, 8, 10, 4, 11, 7, 3, 6, 11, 9, 10, 13, 8, 14, 7, 12, 6, 9, 9, 13, 10, 7, 13, 8, 7, 10, 12, 6, 12, 7, 10, 8, 11, 7, 7, 3, 11, 8, 13, 12, 9, 13, 11, 12, 12, 12, 8, 8, 10, 7, 9, 6, 13, 12, 8, 8, 12, 14, 12, 14, 11, 10, 7, 13, 13, 11, 9, 8, 16, 12, 5, 15, 14, 12, 9, 16, 12, 9, 13, 11, 12, 10, 11, 8, 10, 10, 10, 7, 7, 6, 8, 9, 13, 10, 10, 11, 5, 13, 18, 16, 15, 11, 17, 9, 16, 6, 9, 8, 12, 13, 7, 9, 11, 11, 15, 16, 10, 10, 13, 11, 7, 7, 15, 5, 10, 9, 6, 10, 7, 5, 7, 10, 4, 7, 12, 8, 9, 12, 5, 11, 7, 8, 2, 14, 10, 9, 12, 10, 7, 18, 13, 8, 10, 8, 11, 11, 12, 10, 9, 8, 13, 10, 11, 13, 7, 7, 11, 12, 12, 9, 10, 15, 11, 14, 7, 16, 14, 5, 15, 2, 14, 17, 14, 10, 6, 12, 10, 6, 11, 12, 8, 17, 16, 9, 7, 20, 11, 15, 10, 7, 8, 9, 11, 13, 13, 10, 7, 11, 10, 7, 10, 8, 11, 5, 5, 13, 11, 14, 12, 13, 10, 6, 15, 10, 9, 4, 5, 11, 8, 11, 16, 11, 8, 8, 7, 13, 9, 12, 15, 14, 8, 7, 5, 11, 7, 8, 11, 7, 8, 12, 19, 13, 21, 13, 10, 11, 16, 12, 8, 7, 15, 7, 6, 11, 8, 10, 15, 12, 12, 10, 12, 9, 11, 13, 11, 9, 10, 9, 13, 7, 7, 11, 11, 7, 8, 6, 4, 7, 7, 6, 11, 17, 8, 11, 13, 14, 14, 13, 12, 9, 9, 9, 6, 11, 7, 8, 9, 3, 9, 14, 6, 10, 6, 7, 8, 6, 9, 15, 14, 12, 13, 14, 11, 14, 14, 13, 6, 9, 8, 8, 6, 10, 11, 8, 13, 4, 5, 10, 5, 8, 9, 12, 14, 9, 3, 8, 8, 11, 14, 15, 13, 7, 9, 12, 14, 7, 9, 9, 12, 8, 12, 3, 7, 5, 11, 13, 17, 13, 13, 11, 11, 8, 11, 15, 19, 17, 9, 11, 8, 6, 10, 8, 8, 14, 11, 12, 12, 10, 11, 11, 7, 9, 10, 12, 9, 8, 11, 13, 17, 9, 12, 8, 7, 14, 5, 5, 8, 5, 11, 10, 9, 8, 16, 8, 11, 6, 8, 13, 13, 14, 19, 14, 14, 16, 15, 20, 8, 5, 10, 15, 16, 8, 13, 13, 8, 11, 6, 9, 8, 7, 7, 8, 5, 13, 14, 13, 12, 14, 4, 5, 13, 8, 16, 10, 9, 7, 9, 6, 9, 7, 6, 2, 5, 9, 8, 9, 7, 10, 22, 9, 10, 9, 8, 11, 8, 10, 4, 14, 10, 8, 16, 10, 8, 5, 7, 7, 10, 13, 9, 13, 14, 8, 6, 15, 15, 11, 8, 10, 14, 5, 7, 10, 10, 19, 11, 15, 15, 10, 11, 9, 8, 16, 5, 8, 8, 4, 7, 9, 7, 10, 9, 6, 7, 5, 7, 9, 3, 13, 9, 8, 9, 17, 20, 10, 10, 8, 9, 8, 18, 7, 11, 7, 11, 9, 8, 8, 8, 12, 8, 11, 12, 11, 12, 9, 19, 15, 11, 15, 9, 10, 7, 9, 6, 8, 10, 16, 9, 7, 8, 7, 9, 10, 12, 8, 8, 9, 11, 14, 12, 10, 10, 8, 7, 12, 9, 10, 8, 11, 15, 12, 13, 12, 13, 16, 16, 8, 13, 11, 13, 8, 9, 21, 7, 8, 15, 12, 9, 11, 12, 10, 5, 4, 12, 15, 7, 20, 15, 11, 4, 12, 15, 14, 16, 11, 14, 16, 9, 13, 8, 9, 13, 6, 8, 8, 11, 5, 8, 10, 7, 9, 8, 8, 11, 11, 10, 14, 8, 11, 10, 5, 12, 4, 10, 12, 11, 13, 10, 6, 10, 12, 10, 14, 19, 18, 12, 12, 10, 11, 8, 2, 10, 14, 9, 7, 8, 12, 8, 8, 11, 11, 10, 6, 14, 8, 6, 11, 10, 6, 3, 6, 7, 9, 9, 16, 4, 6, 7, 7, 8, 5, 11, 9, 9, 9, 6, 8, 10, 3, 6, 13, 5, 12, 11, 16, 10, 10, 9, 15, 13, 8, 15, 11, 12, 4, 14, 8, 7, 12, 7, 14, 14, 12, 7, 16, 14, 14, 10, 10, 17, 6, 8, 5, 16, 15, 12, 10, 9, 10, 4, 8, 5, 8, 9, 9, 9, 9, 10, 12, 13, 7, 15, 12, 13, 7, 8, 9, 9, 10, 10, 11, 16, 12, 12, 11, 8, 10, 6, 12, 7, 9, 5, 7, 11, 7, 5, 9, 8, 12, 4, 11, 6, 11, 8, 7, 11, 8, 11, 17, 15, 5, 11, 23, 6, 16, 10, 6, 11, 10, 4, 8, 4, 10, 8, 16, 7, 13, 14, 12, 11, 12, 13, 12, 16, 5, 9, 22, 20, 20, 20, 5, 9, 7, 9, 12, 10, 4, 4, 2, 7, 7, 6, 4, 3, 7, 6, 5, 4, 4, 6, 9, 13, 9, 16, 14, 13, 10, 9, 4, 12, 9, 6, 9, 20, 16, 17, 6, 10, 8, 6, 2, 15, 8, 6, 15, 13, 12, 7, 10, 8, 10, 15, 9, 11, 13, 17, 13, 14, 3, 8, 6, 12, 10, 13, 8, 12, 12, 6, 12, 13, 6, 10, 12, 14, 10, 9, 6, 8, 7, 7, 13, 11, 13, 12, 10, 9, 8, 7, 3, 7, 14, 8, 5, 8, 16, 17, 16, 12, 6, 10, 15, 14, 6, 11, 12, 10, 3, 8, 14, 11, 10, 12, 10, 6, 3, 14, 4, 10, 7, 8, 11, 11, 11, 6, 8, 11, 13, 10, 13, 10, 7, 6, 10, 5, 8, 7, 7, 11, 10, 8, 9, 7, 8, 11, 9, 8, 13, 11, 7, 5, 12, 9, 4, 11, 9, 11, 12, 9, 5, 6, 5, 9, 9, 12, 8, 3, 8, 2, 5, 9, 7, 4, 9, 9, 8, 7, 5, 5, 8, 9, 8, 8, 6, 5, 3, 5, 9, 8, 9, 14, 10, 8, 9, 13, 16, 9, 5, 8, 12, 8, 4, 5, 9, 9, 8, 8, 6, 4, 9, 6, 7, 11, 11, 8, 14, 11, 15, 8, 11, 10, 7, 13, 8, 12, 11, 12, 4, 12, 11, 15, 16, 12, 17, 13, 13, 12, 13, 12, 5, 8, 9, 7, 6, 9, 14, 11, 13, 14, 10, 8, 9, 14, 10, 5, 5, 10, 9, 17, 4, 11, 10, 4, 13, 12, 7, 17, 9, 12, 9, 11, 10, 9, 12, 15, 15, 9, 7, 5, 5, 6, 13, 6, 13, 5, 7, 6, 8, 3, 8, 10, 8, 10, 9, 7, 6, 9, 12, 15, 16, 14, 7, 12, 9, 10, 10, 12, 14, 13, 13, 11, 7, 8, 14, 13, 14, 9, 11, 11, 10, 21, 13, 6, 17, 12, 14, 10, 6, 10, 10, 13, 11, 10, 14, 11, 10, 12, 8, 13, 5, 5, 6, 12, 16, 9, 17, 15, 9, 8, 8, 5, 10, 11, 4, 8, 7, 7, 13, 8, 15, 13, 7, 17, 13, 15, 14, 10, 8, 12, 10, 14, 11, 5, 9, 6, 13, 13, 11, 12, 15, 10, 16, 10, 15, 11, 15, 10, 11, 10, 13, 10, 11, 10, 9, 11, 10, 5, 10, 10, 18, 13, 10, 13, 11, 10, 15, 12, 12, 15, 16, 12, 7, 12, 17, 11, 10, 9, 8, 4, 11, 13, 5, 11, 9, 14, 12, 9, 7, 8, 11, 13, 9, 10, 8, 4, 7, 9, 5, 6, 11, 9, 9, 9, 12, 10, 10, 13, 17, 6, 11, 7, 12, 11, 10, 12, 9, 12, 11, 7, 5, 10, 5, 7, 9, 8, 10, 10, 10, 11, 3, 6, 8, 12, 6, 11, 13, 13, 13, 14, 9, 7, 4, 17, 8, 6, 11, 10, 7, 6, 8, 12, 7, 8, 12, 9, 9, 12, 9, 9, 4, 10, 9, 5, 15, 9, 12, 8, 10, 3, 11, 7, 13, 10, 11, 12, 11, 8, 11, 3, 12, 7, 4, 3, 8, 6, 8, 8, 11, 7, 6, 9, 20, 13, 6, 4, 7, 10, 7, 11, 11, 4, 14, 11, 7, 11, 8, 6, 6, 7, 7, 5, 14, 8, 9, 9, 12, 17, 7, 12, 11, 11, 15, 3, 14, 12, 10, 4, 9, 7, 7, 14, 10, 6, 13, 10, 8, 9, 13, 10, 12, 7, 14, 8, 12, 7, 7, 7, 9, 4, 6, 9, 9, 4, 7, 11, 7, 7, 4, 8, 4, 10, 4, 14, 6, 9, 7, 5, 13, 11, 8, 4, 5, 10, 9, 8, 14, 8, 6, 11, 8, 12, 15, 6, 13, 10, 12, 10, 7, 11, 15, 3, 11, 14, 11, 13, 6, 12, 17, 11, 10, 3, 13, 12, 11, 9, 7, 12, 6, 8, 15, 9, 7, 17, 14, 13, 9, 8, 9, 3, 12, 10, 6, 11, 13, 6, 5, 14, 6, 9, 8, 11, 11, 7, 9, 8, 13, 9, 9, 8, 13, 7, 13, 11, 12, 9, 10, 8, 8, 9, 11, 22, 9, 15, 17, 12, 3, 12, 10, 8, 13, 9, 8, 9, 9, 15, 13, 6, 11, 11, 12, 15, 9, 10, 18, 12, 10, 10, 11, 10, 3, 7, 10, 7, 11, 10, 10, 13, 8, 13, 15, 15, 6, 9, 13, 6, 11, 8, 11, 5, 11, 9, 19, 16, 8, 8, 12, 10, 16, 7, 12, 8, 7, 13, 7, 4, 9, 11, 9, 13, 12, 12, 6, 6, 9, 7, 6, 6, 16, 8, 7, 8, 8, 5, 4, 10, 6, 7, 12, 14, 6, 9, 10, 6, 13, 12, 7, 10, 10, 14, 6, 14, 11, 14, 9, 10, 6, 13, 11, 9, 6, 7, 10, 9, 12, 12, 11, 11, 7, 12, 9, 11, 11, 5, 9, 19, 10, 9, 13, 16, 8, 5, 11, 6, 9, 14, 12, 6, 8, 6, 6, 6, 10, 6, 5, 5, 9, 6, 6, 8, 9, 10, 7, 3, 7, 4, 10, 11, 13, 11, 12, 9, 6, 6, 11, 9, 11, 10, 11, 10, 7, 9, 12, 8, 7, 7, 15, 11, 8, 8, 8, 11, 11, 9, 14, 10, 12, 16, 6, 9, 12, 10, 9, 12, 10, 11, 10, 9, 5, 10, 10, 7, 6, 8, 8, 6, 9, 6, 10, 6, 11, 9, 10, 14, 16, 13, 7, 14, 13, 6, 13, 11, 12, 9, 9, 10, 9, 9, 20, 12, 15, 8, 6, 11, 7, 3, 6, 11, 5, 5, 6, 12, 8, 11, 1, 12, 7, 12, 11, 8, 6, 6, 13, 6, 12, 11, 5, 10, 14, 7, 8, 9, 18, 12, 9, 10, 3, 1, 7, 4, 4, 7, 8, 7, 6, 3, 7, 17, 11, 13, 9, 6, 13, 13, 15, 4, 3, 10, 13, 8, 5, 10, 7, 6, 17, 11, 8, 9, 9, 6, 10, 9, 6, 8, 7, 11, 11, 11, 7, 4, 4, 11, 5, 8, 15, 11, 18, 7, 14, 10, 11, 11, 9, 14, 7, 17, 9, 15, 13, 12, 9, 9, 8, 7, 17, 10, 11, 13, 14, 13, 8, 8, 10, 5, 11, 9, 5, 9, 6, 11, 7, 4, 5, 7, 10, 7, 8, 12, 7, 6, 4, 5, 7, 12, 9, 2, 5, 6, 11, 3, 8, 13, 13, 13, 14, 7, 9, 12, 8, 12, 12, 11, 11, 4, 10, 8, 3, 6, 9, 6, 9, 6, 5, 11, 6, 8, 6, 12, 12, 10, 12, 13, 11, 9, 8, 13, 10, 12, 12, 10, 15, 5, 10, 11, 10, 4, 9, 10, 10, 12, 14, 7, 7, 10, 13, 13, 12, 7, 8, 14, 9, 9, 4, 6, 12, 11, 9, 8, 12, 4, 10, 10, 10, 4, 9, 4, 9, 4, 7, 15, 11, 10, 13, 5, 5, 10, 6, 10, 9, 7, 10, 10, 6, 6, 9, 19, 12, 16, 10, 10, 12, 14, 17, 12, 19, 8, 6, 16, 9, 20, 16, 10, 7, 7, 17, 8, 8, 6, 8, 10, 9, 15, 15, 12, 16, 4, 12, 12, 5, 5, 11, 8, 9, 9, 14, 8, 5, 9, 7, 14, 10, 6, 10, 10, 14, 18, 9, 13, 11, 8, 10, 8, 14, 11, 10, 22, 9, 5, 9, 10, 12, 11, 15, 11, 14, 14, 7, 12, 10, 7, 3, 7, 8, 5, 8, 16, 13, 8, 9, 7, 8, 9, 13, 13, 6, 14, 5, 14, 7, 10, 12, 16, 8, 13, 14, 7, 10, 9, 13, 10, 13, 10, 16, 6, 7, 8, 8, 10, 7, 15, 10, 15, 6, 13, 9, 11, 8, 9, 6, 8, 16, 9, 5, 9, 9, 10, 8, 7, 6, 8, 4, 7, 14, 8, 8, 10, 5, 3, 8, 11, 8, 12, 12, 6, 10, 8, 7, 9, 4, 11, 5, 6, 7, 7, 10, 11, 6, 10, 13, 8, 9, 8, 12, 10, 13, 8, 8, 11, 12, 8, 11, 4, 9, 8, 9, 10, 8, 9, 8, 9, 6, 6, 6, 8, 6, 9, 7, 12, 9, 7, 8, 8, 10, 8, 9, 17, 10, 10, 12, 6, 11, 10, 8, 10, 6, 10, 12, 8, 17, 15, 5, 11, 9, 7, 11, 8, 12, 12, 7, 8, 9, 8, 7, 4, 9, 4, 9, 8, 15, 14, 15, 10, 6, 12, 6, 15, 6, 7, 12, 13, 9, 14, 7, 11, 10, 10, 10, 8, 8, 10, 12, 8, 10, 11, 11, 7, 9, 9, 9, 10, 9, 12, 11, 7, 12, 5, 9, 13, 3, 6, 11, 6, 18, 12, 15, 8, 11, 9, 7, 7, 7, 9, 12, 10, 7, 8, 11, 9, 7, 7, 8, 10, 20, 16, 15, 12, 13, 12, 15, 9, 5, 7, 9, 11, 7, 7, 10, 0, 0, 0, 0, 0, 3, 3, 3, 4, 4, 4, 5, 6, 6, 10, 10, 16, 1, 8, 1, 2, 3, 4, 4, 5, 5, 6, 9, 11, 14, 14, 19, 1, 8, 14, 2, 6, 4, 7, 7, 11, 14, 4, 6, 10, 11, 12, 14, 15, 16, 2, 5, 8, 11, 11, 15, 8, 7, 2, 4, 6, 7, 8, 8, 8, 9, 10, 10, 10, 13, 13, 14, 14, 15, 16, 2, 8, 2, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 13, 14, 14, 14, 14, 14, 14, 15, 15, 5, 6, 7, 7, 9, 17, 6, 8, 4, 12, 16, 17, 18, 21, 2, 9, 9, 11, 6, 6, 7, 2, 8, 10, 10, 11, 12, 12, 12, 13, 16, 19, 19, 2, 6, 8, 8, 10, 2, 10, 10, 2, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 19, 2, 8, 2, 5, 5, 6, 6, 7, 7, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 11, 16, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 13, 13, 13, 14, 14, 16, 19, 17, 5, 7, 5, 7, 7, 8, 10, 10, 11, 15, 9, 17, 20, 2, 2, 6, 10, 2, 5, 10, 12, 7, 9, 9, 14, 16, 16, 17, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14, 15, 20, 21, 22, 3, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 19, 19, 19, 20, 20, 22, 3, 9, 6, 7, 9, 9, 10, 10, 11, 3, 5, 5, 12, 3, 6, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 17, 19, 23, 25, 3, 7, 8, 12, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 19, 25, 3, 6, 6, 7, 7, 8, 9, 10, 11, 11, 16, 7, 8, 8, 8, 10, 11, 11, 11, 12, 14, 14, 15, 15, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 17, 17, 19, 3, 7, 8, 9, 9, 9, 10, 11, 11, 12, 13, 15, 16, 24, 3, 3, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 14, 14, 15, 15, 16, 17, 20, 6, 14, 12, 14, 3, 3, 6, 7, 7, 7, 7, 7, 8, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15, 15, 25, 5, 7, 7, 8, 9, 9, 11, 11, 11, 11, 12, 13, 14, 15, 16, 16, 17, 3, 5, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 13, 13, 14, 15, 15, 15, 16, 16, 18, 8, 17, 4, 6, 7, 7, 7, 7, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 3, 4, 8, 3, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 19, 19, 19, 20, 20, 21, 24, 3, 5, 8, 8, 9, 10, 12, 13, 14, 14, 15, 16, 16, 17, 17, 3, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 15, 15, 16, 16, 17, 17, 18, 3, 11, 9, 12, 5, 9, 10, 10, 12, 14, 15, 21, 8, 8, 9, 11, 12, 22, 3, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 16, 16, 17, 17, 20, 5, 9, 7, 8, 12, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 19, 20, 3, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 19, 3, 15, 3, 8, 10, 6, 6, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 16, 17, 17, 17, 18, 20, 20, 13, 13, 14, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 13, 14, 8, 9, 9, 9, 11, 11, 11, 12, 12, 14, 16, 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 12, 12, 12, 12, 13, 15, 16, 10, 5, 8, 11, 12, 12, 13, 13, 13, 14, 14, 8, 9, 12, 16, 16, 17, 4, 6, 6, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 12, 13, 13, 14, 14, 16, 18, 18, 20, 21, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 14, 9, 10, 11, 12, 13, 14, 15, 15, 9, 13, 6, 8, 9, 11, 11, 12, 12, 12, 13, 14, 10, 11, 12, 14, 17, 10, 10, 12, 12, 12, 13, 15, 16, 16, 22, 5, 6, 7, 7, 9, 10, 10, 11, 13, 4, 11, 13, 12, 13, 15, 9, 15, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 17, 17, 17, 17, 17, 16, 7, 11, 12, 13, 13, 16, 9, 9, 12, 13, 16, 16, 4, 13, 13, 17, 12, 15, 16, 8, 10, 10, 10, 11, 11, 13, 14, 7, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 15, 15, 15, 16, 16, 16, 18, 21, 30, 4, 11, 13, 16, 8, 8, 9, 11, 12, 4, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 12, 12, 13, 14, 16, 21, 7, 7, 9, 10, 10, 10, 10, 10, 10, 11, 13, 13, 14, 16, 16, 17, 17, 24, 4, 6, 8, 9, 12, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 19, 18, 21, 11, 12, 17, 19, 8, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 18, 7, 8, 9, 9, 9, 10, 12, 13, 17, 9, 10, 10, 12, 13, 14, 14, 16, 17, 17, 10, 16, 23, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 20, 14, 9, 12, 13, 9, 9, 10, 10, 11, 12, 12, 12, 13, 13, 15, 15, 16, 17, 18, 22, 9, 11, 12, 13, 17, 10, 11, 7, 7, 8, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 17, 18, 18, 22, 5, 7, 7, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 18, 18, 18, 18, 21, 23, 11, 12, 8, 8, 9, 9, 10, 11, 13, 13, 14, 14, 14, 15, 5, 8, 9, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 17, 19, 24, 5, 9, 11, 12, 9, 6, 9, 10, 12, 12, 13, 14, 15, 15, 16, 16, 22, 12, 8, 11, 11, 11, 12, 15, 16, 12, 9, 10, 10, 12, 12, 12, 12, 13, 15, 15, 16, 16, 16, 18, 20, 21, 6, 10, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 21, 24, 26, 6, 14, 17, 17, 10, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 19, 8, 9, 11, 12, 10, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13, 14, 15, 17, 18, 19, 10, 10, 11, 13, 13, 19, 11, 11, 13, 15, 15, 16, 9, 10, 10, 11, 11, 12, 12, 13, 14, 14, 14, 15, 15, 15, 15, 15, 16, 18, 6, 15, 9, 11, 12, 14, 14, 15, 15, 16, 17, 6, 12, 14, 14, 17, 25, 11, 19, 9, 12, 13, 13, 23, 11, 15, 10, 11, 9, 10, 10, 10, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 19, 20, 20, 21, 7, 16, 10, 13, 14, 18, 18, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 19, 19, 19, 19, 19, 20, 21, 22, 22, 23, 24, 7, 12, 13, 13, 17, 17, 11, 11, 12, 12, 13, 13, 14, 15, 13, 18, 12, 11, 12, 12, 14, 14, 16, 16, 16, 19, 19, 20, 22, 10, 13, 13, 13, 14, 14, 15, 15, 17, 8, 12, 20, 8, 10, 10, 13, 14, 18, 18, 14, 14, 15, 16, 17, 18, 18, 21, 24, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 14, 14, 15, 15, 16, 18, 18, 18, 19, 19, 13, 13, 14, 14, 14, 15, 15, 17, 17, 18, 18, 19, 19, 22, 14, 14, 15, 16, 16, 17, 19, 12, 15, 18, 22, 22, 10, 13, 14, 15, 15, 16, 16, 16, 18, 19, 20, 23, 25, 14, 15, 17, 13, 16, 16, 17, 19, 19, 21, 23, 17, 17, 17, 18, 18, 19, 20, 20, 20, 20, 21, 17, 18, 20, 23, 23, 16, 17, 23 }
' unsigned offset;
    if ( c1 < 0xB0 || c1 > 0xF7
        || c2 < 0xA1 || c2 > 0xFE )
    {
        // not a valid gb2312 Chinese character
        return -1;
    }
    offset = ((unsigned)c1-0xB0) * (0xFE-0xA0) + ((unsigned)c2-0xA1);
    return gb2312_stroke_count[ offset ];
区码 ＝ 取代码 (取文本左边 (汉字, 1), )
位码 ＝ 取代码 (取文本中间 (汉字, 2, 1), )
.如果真 (区码 ＜ 176 或 区码 ＞ 247 或 位码 ＜ 161 或 位码 ＞ 254)
    返回 (-1)
.如果真结束
索引 ＝ (区码 － 176) × (254 － 160) ＋ 位码 － 161
返回 (数据 [索引 ＋ 1])
.子程序 文本_取中间_批量, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
.参数 源文本, 文本型, , 比如：欲取全文本为 12345
.参数 前面标识文本, 文本型, , 3的前面为“2”
.参数 后面标识文本, 文本型, , 3的后面为“4”
.参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
.参数 是否不区分大小写, 逻辑型, 可空, 是否区分大小写
.参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要;如取出的文本大于50的不要;留空为不限制(下面参数中的加入的后缀不算在其中，标志文本为真那么标志算在其中)
.参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
.参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
.参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出? 默认为假，不取出！
.参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出? 默认为假，不取出！
.参数 起始位置, 整数型, 可空
.局部变量 数组数量, 整数型
.局部变量 已经找到的, 整数型
.局部变量 StartPos, 整数型
.局部变量 EndPos, 整数型
.局部变量 Search, 文本型
.局部变量 中间长度, 整数型
清除数组 (存放取出文本的数组)
StartPos ＝ 起始位置
.循环判断首 ()
    StartPos ＝ 寻找文本 (源文本, 前面标识文本, StartPos, 是否不区分大小写)
    .如果 (StartPos ≠ -1)
        StartPos ＝ StartPos ＋ 取文本长度 (前面标识文本)
        EndPos ＝ 寻找文本 (源文本, 后面标识文本, StartPos, 是否不区分大小写)
        .如果 (EndPos ≠ -1)
            中间长度 ＝ EndPos － StartPos
            Search ＝ 取文本中间 (源文本, StartPos, 中间长度)
            Search ＝ 为取出的文本加上前缀 ＋ Search ＋ 为取出的文本加上后缀
            .如果真 (连前面标识文本一起取出 ＝ 真)
                Search ＝ 前面标识文本 ＋ Search
            .如果真结束
            .如果真 (连后面标识文本一起取出 ＝ 真)
                Search ＝ Search ＋ 后面标识文本
            .如果真结束
            .如果 (文本长度大于此数的不要 ＝ 0)
                加入成员 (存放取出文本的数组, Search)
            .否则
                .如果真 (取文本长度 (Search) ＜ 文本长度大于此数的不要)
                    加入成员 (存放取出文本的数组, Search)
                .如果真结束
            .如果结束
            处理事件 ()
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.循环判断尾 (StartPos ≠ -1)
返回 (取数组成员数 (存放取出文本的数组))
.子程序 文本_取中间_批量_正则方式, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
.参数 源文本, 文本型, , 比如：欲取全文本为 12345
.参数 前面标识文本, 文本型, , 3的前面为“2”
.参数 后面标识文本, 文本型, , 3的后面为“4”
.参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
.参数 是否区分大小写, 逻辑型, 可空, 是否区分大小写
.参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要，如取出的文本大于50的不要。留空为不限制
.参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
.参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
.参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出?  默认为假，不取出！
.参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出?  默认为假，不取出！
.局部变量 局_计次, 整数型
.局部变量 局_文本, 文本型
.局部变量 正则, 正则表达式类
清除数组 (存放取出文本的数组)
正则.创建 (正则元字符转义 (前面标识文本) ＋ “([\s\S]*?)” ＋ 正则元字符转义 (后面标识文本), 源文本)
.判断开始 (文本长度大于此数的不要 ≠ 0)
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_文本 ＝ 正则.取子匹配文本 (局_计次, 1)
        .如果真 (取文本长度 (局_文本) ≤ 文本长度大于此数的不要)
            局_文本 ＝ 为取出的文本加上前缀 ＋ 局_文本 ＋ 为取出的文本加上后缀
            .如果真 (连前面标识文本一起取出)
                局_文本 ＝ 前面标识文本 ＋ 局_文本
            .如果真结束
            .如果真 (连后面标识文本一起取出)
                局_文本 ＝ 局_文本 ＋ 后面标识文本
            .如果真结束
            加入成员 (存放取出文本的数组, 局_文本)
        .如果真结束
    .计次循环尾 ()
.默认
    ' 取匹配到的全部数据，不筛选
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_文本 ＝ 正则.取子匹配文本 (局_计次, 1)
        局_文本 ＝ 为取出的文本加上前缀 ＋ 局_文本 ＋ 为取出的文本加上后缀
        .如果真 (连前面标识文本一起取出)
            局_文本 ＝ 前面标识文本 ＋ 局_文本
        .如果真结束
        .如果真 (连后面标识文本一起取出)
            局_文本 ＝ 局_文本 ＋ 后面标识文本
        .如果真结束
        加入成员 (存放取出文本的数组, 局_文本)
    .计次循环尾 ()
.判断结束
返回 (取数组成员数 (存放取出文本的数组))
.子程序 文本_倒取中间_批量, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的后面为“4”，<3>的前面为“2”
.参数 源文本, 文本型, , 比如：欲取全文本为 12345
.参数 后面标识文本, 文本型, , 3的后面为“4”
.参数 前面标识文本, 文本型, , 3的前面为“2”
.参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
.参数 是否不区分大小写, 逻辑型, 可空, 是否区分大小写
.参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要;如取出的文本大于50的不要;留空为不限制(下面参数中的加入的后缀不算在其中，标志文本为真那么标志算在其中)
.参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
.参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
.参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出? 默认为假，不取出！
.参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出? 默认为假，不取出！
.参数 起始位置, 整数型, 可空
.局部变量 StartPos, 整数型
.局部变量 EndPos, 整数型
.局部变量 Search, 文本型
.局部变量 中间长度, 整数型
.局部变量 lpos, 整数型
清除数组 (存放取出文本的数组)
EndPos ＝ 选择 (起始位置 ≤ 0, 取文本长度 (源文本) ＋ 取文本长度 (后面标识文本), 起始位置)
.循环判断首 ()
    EndPos ＝ 倒找文本 (源文本, 后面标识文本, EndPos, 是否不区分大小写)
    .如果 (EndPos ≠ -1)
        StartPos ＝ 倒找文本 (源文本, 前面标识文本, EndPos, 是否不区分大小写)
        .如果 (StartPos ≠ -1)
            lpos ＝ StartPos ＋ 取文本长度 (前面标识文本)
            中间长度 ＝ EndPos － lpos
            EndPos ＝ StartPos
            Search ＝ 取文本中间 (源文本, lpos, 中间长度)
            Search ＝ 为取出的文本加上前缀 ＋ Search ＋ 为取出的文本加上后缀
            .如果真 (连后面标识文本一起取出 ＝ 真)
                Search ＝ Search ＋ 后面标识文本
            .如果真结束
            .如果真 (连前面标识文本一起取出 ＝ 真)
                Search ＝ 前面标识文本 ＋ Search
            .如果真结束
            .如果 (文本长度大于此数的不要 ＝ 0)
                加入成员 (存放取出文本的数组, Search)
            .否则
                .如果真 (取文本长度 (Search) ＜ 文本长度大于此数的不要)
                    加入成员 (存放取出文本的数组, Search)
                .如果真结束
            .如果结束
            处理事件 ()
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.循环判断尾 (EndPos ≠ -1)
返回 (取数组成员数 (存放取出文本的数组))
.子程序 正则元字符转义, 文本型
.参数 要处理的文本, 文本型
.局部变量 局_文本, 文本型
局_文本 ＝ 文本_替换 (要处理的文本, , , , “?”, “\?”, “*”, “\*”, “+”, “\+”, “[”, “\[”, “]”, “\]”)
局_文本 ＝ 文本_替换 (局_文本, , , , “(”, “\(”, “)”, “\)”, “{”, “\{”, “}”, “\}”, “#引号”, #引号)
局_文本 ＝ 子文本替换 (局_文本, #换行符, “\n”, , , 真)
返回 (局_文本)
.子程序 文本区分_只取汉字, 文本型, 公开, 在一大串网页源码中 只取出汉字
.参数 源文本, 文本型, , 要取出汉字的源文本
.参数 是否正则, 逻辑型, 可空, 可空，默认为假 不使用正则方式
.参数 是否去除空格和空行, 逻辑型, 可空, 可为空，默认为假。
.局部变量 正则, 正则表达式类
.局部变量 局_临时文本, 文本型
.局部变量 局_计次, 整数型
.局部变量 局_源文本, 文本型
.如果 (是否正则)
    正则.创建 (“[^\x20-\x7f]”, 源文本)
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    .如果真 (是否去除空格和空行)
        正则.创建 (“\s”, 局_临时文本)
        局_临时文本 ＝ 正则.替换 (“”)
    .如果真结束
    返回 (局_临时文本)
.否则
    局_源文本 ＝ 源文本
    .如果真 (是否去除空格和空行)
        局_源文本 ＝ 文本_替换 (源文本, , , , #换行符, “”, “ ”, “”)
    .如果真结束
    返回 (_只取汉字 (源文本))
.如果结束
' 中文编码范围，中文汉字的正则也许用的着。
' 双字节字符编码范围：
' 一、 GBK (GB2312/GB18030)
' \x00-\xff          →GBK双字节编码范围
' \x20-\x7f         →ASCII
' \xa1-\xff 中文 →gb2312 取出所有中文
' \x80-\xff 中文 →gbk  取出所有中文
' 二、 UTF-8 (Unicode)
' \u4e00-\u9fa5     →(中文) 取出所有中文
' \x3130-\x318F    →(韩文)  取出所有韩文
' \xAC00-\xD7A3   →(韩文)  取出所有韩文
' \u0800-\u4e00   →(日文)   取出所有日文
.子程序 _只取汉字, 文本型, 公开
.参数 字符串, 文本型
.局部变量 字节集长度, 整数型
.局部变量 字节集, 字节集
.局部变量 取出位置, 整数型
.局部变量 文本, 文本型
字节集 ＝ 到字节集 (字符串)
字节集长度 ＝ 取字节集长度 (字节集)
取出位置 ＝ 1
.判断循环首 (取出位置 ＜ 字节集长度)
    .判断开始 (字节集 [取出位置] ≥ 176 且 字节集 [取出位置 ＋ 1] ≥ 161 且 字节集 [取出位置] ≤ 247 且 字节集 [取出位置 ＋ 1] ≤ 254)  ' 判断GBK/2: GB2312 汉字
        文本 ＝ 文本 ＋ 到文本 (取字节集中间 (字节集, 取出位置, 2))
        取出位置 ＝ 取出位置 ＋ 2
    .判断 (字节集 [取出位置] ≥ 129 且 字节集 [取出位置 ＋ 1] ≥ 64 且 字节集 [取出位置] ≤ 160 且 字节集 [取出位置 ＋ 1] ≤ 126 或 字节集 [取出位置] ≥ 129 且 字节集 [取出位置 ＋ 1] ≥ 128 且 字节集 [取出位置] ≤ 160 且 字节集 [取出位置 ＋ 1] ≤ 161)  ' 判断是否全角字符)
        文本 ＝ 文本 ＋ 到文本 (取字节集中间 (字节集, 取出位置, 2))
        取出位置 ＝ 取出位置 ＋ 2
    .判断 (字节集 [取出位置] ≥ 170 且 字节集 [取出位置 ＋ 1] ≥ 64 且 字节集 [取出位置] ≤ 176 且 字节集 [取出位置 ＋ 1] ≤ 126 或 字节集 [取出位置] ≥ 170 且 字节集 [取出位置 ＋ 1] ≥ 128 且 字节集 [取出位置] ≤ 176 且 字节集 [取出位置 ＋ 1] ≤ 161)  ' 判断是否全角字符)
        文本 ＝ 文本 ＋ 到文本 (取字节集中间 (字节集, 取出位置, 2))
        取出位置 ＝ 取出位置 ＋ 2
    .判断 (字节集 [取出位置] ＞ 127 且 字节集 [取出位置 ＋ 1] ＞ 127)  ' 判断是否全角字符)
        取出位置 ＝ 取出位置 ＋ 2
    .默认
        取出位置 ＝ 取出位置 ＋ 1
    .判断结束
.判断循环尾 ()
返回 (文本)
.子程序 文本区分_只取字母, 文本型, 公开, 在一大串网页源码中 只取字母
.参数 源文本, 文本型, , 要取出字母的源文本
.参数 大小写类型, 整数型, 可空, 默认为0  0=取大小写  1只取小写  2只取大写
.局部变量 正则, 正则表达式类
.局部变量 局_临时文本, 文本型
.局部变量 局_计次, 整数型
.判断开始 (大小写类型 ＝ 0)
    正则.创建 (“[a-zA-Z]”, 源文本, 真)
.判断 (大小写类型 ＝ 1)
    正则.创建 (“[a-z]”, 源文本, 真)
.判断 (大小写类型 ＝ 2)
    正则.创建 (“[A-Z]”, 源文本, 真)
.默认
.判断结束
.计次循环首 (正则.取匹配数量 (), 局_计次)
    局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
.计次循环尾 ()
返回 (局_临时文本)
.子程序 文本区分_只取符号, 文本型, 公开, 在一大串网页源码中 只取符号
.参数 源文本, 文本型, , 要取出符号的源文本
.局部变量 正则, 正则表达式类
.局部变量 局_临时文本, 文本型
.局部变量 局_计次, 整数型
正则.创建 (“[^0-9a-z\u4e00-\u9fa5]”, 源文本)
.计次循环首 (正则.取匹配数量 (), 局_计次)
    局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
.计次循环尾 ()
返回 (局_临时文本)
.子程序 文本区分_只取数字, 文本型, 公开, 在一大串网页源码中 只取数字
.参数 源文本, 文本型, , 要取出数字的源文本
.局部变量 正则, 正则表达式类
.局部变量 局_临时文本, 文本型
.局部变量 局_计次, 整数型
正则.创建 (“[0-9]”, 源文本)
.计次循环首 (正则.取匹配数量 (), 局_计次)
    局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
.计次循环尾 ()
返回 (局_临时文本)
.子程序 文本_朗读, , 公开, 朗读一段指定的文本
.参数 朗读的文本, 文本型, 可空
.参数 百度语音引擎, 逻辑型, 可空, 可为空，默认使用微软语音引擎。
.参数 音频数据, 字节集, 可空
.参数 音频文件, 文本型, 可空, 如：C:\mp3，C:\MAV等等
.参数 保存朗读文本至文件, 文本型, 可空, 只针对“朗读的文本”和“音频数据”有效，请提供要保存至的文件夹路径，如：C:\
.参数 朗读方式, 逻辑型, 可空, 真=支持库方式  假=API方式  默认为假  API方式
.局部变量 局_语音, 字节集
.局部变量 局_文件名, 文本型
.局部变量 局_引擎地址, 文本型
局_文件名 ＝ “”
.如果真 (是否为空 (保存朗读文本至文件) ＝ 假 且 目录_是否存在 (保存朗读文本至文件))
    .如果真 (取文本左边 (保存朗读文本至文件, 1) ≠ “\”)
        保存朗读文本至文件 ＝ 保存朗读文本至文件 ＋ “\”
    .如果真结束
.如果真结束
.判断开始 (删首尾空 (朗读的文本) ≠ “”)
    局_文件名 ＝ 目录_取临时目录 () ＋ 校验_取md5 (到字节集 (朗读的文本)) ＋ “.mp3”
    .如果真 (文件_是否存在 (局_文件名) ＝ 假)
        .如果 (百度语音引擎)
            局_引擎地址 ＝ “http://tts.baidu.com/text2audio?lan=zh&ie=UTF-8&text=” ＋ 编码_URL编码 (朗读的文本, , 真)
        .否则
            局_引擎地址 ＝ “http://api.microsofttranslator.com/V2/Http.svc/Speak?language=zh-CN&appid=05DBC69E5594C137B9E22680F92F8E5E115A7817&text=” ＋ 编码_URL编码 (朗读的文本, , 真) ＋ “&format=audio/mp3&options=MaxQuality”
        .如果结束
        局_语音 ＝ 网页_访问 (局_引擎地址)
        写到文件 (局_文件名, 局_语音)
    .如果真结束
    .如果真 (是否为空 (保存朗读文本至文件) ＝ 假)
        .如果 (取字节集长度 (局_语音) ＝ 0)
            文件_复制 (局_文件名, 保存朗读文本至文件 ＋ 朗读的文本 ＋ “.mp3”, 0)
        .否则
            写到文件 (保存朗读文本至文件 ＋ 朗读的文本 ＋ “.mp3”, 局_语音)
        .如果结束
    .如果真结束
.判断 (是否为空 (音频数据) ＝ 假)
    局_文件名 ＝ 目录_取临时目录 () ＋ 校验_取md5 (音频数据) ＋ “.mp3”
    .如果真 (文件_是否存在 (局_文件名) ＝ 假)
        写到文件 (局_文件名, 音频数据)
    .如果真结束
    .如果真 (是否为空 (保存朗读文本至文件) ＝ 假)
        写到文件 (保存朗读文本至文件 ＋ “音频数据.mp3”, 音频数据)
    .如果真结束
.判断 (文件_是否存在 (音频文件))
    局_文件名 ＝ 音频文件
.默认
    输出调试文本 (“朗读的文本、音频数据和音频文件必须提供一个”)
.判断结束
.如果真 (文件_是否存在 (局_文件名))
    .判断开始 (朗读方式)
        播放MP3 (1, 局_文件名)
    .默认
        音乐_播放 (局_文件名, 文本_取随机汉字 (10, ))
    .判断结束
.如果真结束
.子程序 文本_朗读Ex, 逻辑型, 公开, 本命令由【sizaizuotian】提供接口
.参数 朗读文本, 文本型
.参数 保存朗读文本至文件, 文本型, 可空
.参数 朗读方式, 逻辑型, 可空, 真=支持库方式  假=API方式  默认为假  API方式
.局部变量 局_朗读内容, 文本型
.局部变量 局_接口地址, 文本型
.局部变量 局_朗读文件, 字节集
.局部变量 局_临时文件, 文本型
.局部变量 局_保存结果, 逻辑型
局_朗读内容 ＝ 编码_URL编码 (朗读文本, , 真)
局_接口地址 ＝ “http://fanyi.baidu.com/gettts?lan=zh&text=” ＋ 局_朗读内容 ＋ “&spd=5&source=web.mp3”
局_朗读文件 ＝ 网页_访问_对象 (局_接口地址)
.如果 (是否为空 (保存朗读文本至文件) ＝ 假)
    局_保存结果 ＝ 写到文件 (保存朗读文本至文件, 局_朗读文件)
    返回 (局_保存结果)
.否则
    局_临时文件 ＝ 目录_取临时目录 () ＋ 校验_取md5 (到字节集 (局_朗读文件)) ＋ “.mp3”
    局_保存结果 ＝ 写到文件 (局_临时文件, 局_朗读文件)
    .判断开始 (朗读方式)
        播放MP3 (1, 局_临时文件)
    .默认
        音乐_播放 (局_临时文件, 文本_取随机汉字 (10, ))
    .判断结束
    返回 (局_保存结果)
.如果结束
返回 (真)
.子程序 文本_指针到文本A, 文本型, 公开, 返回指定内存指针所指向地址处的文本，注意调用本命令前一定要确保所提供的内存指针真实有效，且指向一个以零字符结束的文本串。
.参数 内存文本指针, 整数型
返回 (lstrcat (内存文本指针, 0))
.子程序 文本_指针到文本W, 文本型, 公开, 取内存中Unicode字符串文本。返回指定内存指针所指向地址处的文本，注意调用本命令前一定要确保所提供的内存指针真实有效，且指向一个以零字符结束的文本串。 
.参数 Unicode内存指针
.局部变量 tmp, 字节型, , "0"
.局部变量 tmpLen
.如果真 (Unicode内存指针 ≠ 0)
    tmpLen ＝ lstrlen (Unicode内存指针) × 2 ＋ 8
    .如果真 (tmpLen ≠ 0)
        重定义数组 (tmp, 假, tmpLen － 1)
        RtlMoveMemory (取数据_通用型_数组 (tmp), Unicode内存指针, tmpLen)
        返回 (编码_Unicode到Ansi (到字节集 (tmp)))
    .如果真结束
.如果真结束
返回 (“”)
.子程序 文本_加密c, 字节集, 公开, 支持密钥加密，成功返回加密后文本，失败返回空。
.参数 欲加密文本, 文本型
.参数 密码, 文本型, 可空, 可为空，默认为 “bbs.125.la”
.局部变量 lHHash
.局部变量 lHkey
.局部变量 lHCryptprov
.局部变量 lCryptLength
.局部变量 lCryptBufLen
.局部变量 sCryptBuffer, 字节集
.局部变量 bresult, 逻辑型
.如果真 (取文本长度 (欲加密文本) ≠ 0)
    bresult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 0)
    .如果真 (bresult ＝ 假)  ' 如果没有默认密钥容器，然后创建一个
        bresult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 8)
        .如果真 (bresult ＝ 假)
            返回 ({  })
        .如果真结束
    .如果真结束
    密码 ＝ 选择 (是否为空 (密码), “bbs.125.la”, 密码)
    CryptCreateHash (lHCryptprov, 32771, 0, 0, lHHash)
    CryptHashData (lHHash, 到字节集 (密码), 取文本长度 (密码), 0)
    CryptDeriveKey (lHCryptprov, 26625, lHHash, 0, lHkey)
    CryptDestroyHash (lHHash)
    lCryptLength ＝ 取文本长度 (欲加密文本)
    lCryptBufLen ＝ lCryptLength
    sCryptBuffer ＝ 取空白字节集 (lCryptLength)
    sCryptBuffer ＝ 到字节集 (欲加密文本)
    bresult ＝ CryptEncrypt (lHkey, 0, 1, 0, sCryptBuffer, lCryptLength, lCryptBufLen)
    CryptDestroyKey (lHkey)
    CryptDestroyHash (lHHash)
    CryptReleaseContext (lHCryptprov, 0)
.如果真结束
返回 (选择 (bresult, sCryptBuffer, {  }))
.子程序 文本_解密c, 文本型, 公开, 支持密钥解密，成功返回解密后文本，失败返回空。
.参数 加密后文本, 字节集
.参数 密码, 文本型, 可空, 可为空，默认为 “bbs.125.la”
.局部变量 lHCryptprov
.局部变量 lHHash
.局部变量 lHkey
.局部变量 bResult, 逻辑型
.局部变量 sCryptBuffer, 字节集
.局部变量 lCryptBufLen
.局部变量 lCryptPoint
.如果真 (取字节集长度 (加密后文本) ≠ 0)
    bResult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 0)
    .如果真 (bResult ＝ 假)
        bResult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 8)
        .如果真 (bResult ＝ 假)
            返回 (“”)
        .如果真结束
    .如果真结束
    密码 ＝ 选择 (是否为空 (密码), “bbs.125.la”, 密码)
    CryptCreateHash (lHCryptprov, 32771, 0, 0, lHHash)
    CryptHashData (lHHash, 到字节集 (密码), 取文本长度 (密码), 0)
    CryptDeriveKey (lHCryptprov, 26625, lHHash, 0, lHkey)
    CryptDestroyHash (lHHash)
    lCryptBufLen ＝ 取字节集长度 (加密后文本)
    sCryptBuffer ＝ 取空白字节集 (lCryptBufLen)
    sCryptBuffer ＝ 加密后文本
    bResult ＝ CryptDecrypt (lHkey, 0, 1, 0, sCryptBuffer, lCryptBufLen)
    CryptDestroyKey (lHkey)
    CryptDestroyHash (lHHash)
    CryptReleaseContext (lHCryptprov, 0)
.如果真结束
返回 (选择 (bResult, 到文本 (sCryptBuffer), “”))
.子程序 文本_加密, 文本型, 公开, 失败返回空文本
.参数 参数_待加密文本, 文本型, , 待加密文本
.参数 参数_加密的密码, 文本型, , 加密的密码<建议5位以上的数字>
.局部变量 局_计次, 整数型
.局部变量 局_过度字节集, 字节集
.局部变量 局_待加密文本, 字节集
局_待加密文本 ＝ 到字节集 (参数_待加密文本)
.计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
    局_过度字节集 ＝ 局_过度字节集 ＋ 到字节集 (到字节 (位异或 (局_待加密文本 [局_计次], 3600)))
.计次循环尾 ()
返回 (字节集_字节集到十六进制 (局_过度字节集) ＋ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_加密的密码)), 3, 9)))
.子程序 文本_解密, 文本型, 公开, 失败返回空文本
.参数 参数_待解密文本, 文本型, , 待解密文本
.参数 参数_解密的密码, 文本型, , 解密的密码<建议5位以上的数字>
.局部变量 局_计次, 整数型
.局部变量 局_过度字节集, 字节集
.局部变量 局_待加密文本, 字节集
.如果真 (取文本右边 (参数_待解密文本, 9) ≠ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_解密的密码)), 3, 9)))
    返回 (“”)
.如果真结束
局_待加密文本 ＝ 字节集_十六进制到字节集 (取文本左边 (参数_待解密文本, 取文本长度 (参数_待解密文本) － 9))
.计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
    局_过度字节集 ＝ 局_过度字节集 ＋ 到字节集 (到字节 (位异或 (局_待加密文本 [局_计次], 3600)))
.计次循环尾 ()
返回 (到文本 (局_过度字节集))
.子程序 文本_加密_优化, 文本型, 公开, 失败返回空文本
.参数 参数_待加密文本, 文本型, , 待加密文本
.参数 参数_加密的密码, 文本型, , 加密的密码<建议5位以上的数字>
.局部变量 局_计次, 整数型
.局部变量 局_待加密文本, 字节集
' https://bbs.125.la/forum.php?mod=viewthread&tid=14655519
局_待加密文本 ＝ 到字节集 (参数_待加密文本)
.计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
    局_待加密文本 [局_计次] ＝ 位异或 (局_待加密文本 [局_计次], 3600)
.计次循环尾 ()
返回 (字节集_字节集到十六进制2 (局_待加密文本) ＋ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_加密的密码), , ), 3, 9)))
.子程序 文本_解密_优化, 文本型, 公开, 失败返回空文本
.参数 参数_待解密文本, 文本型, , 待解密文本
.参数 参数_解密的密码, 文本型, , 解密的密码<建议5位以上的数字>
.局部变量 局_计次, 整数型
.局部变量 局_待加密文本, 字节集
' https://bbs.125.la/forum.php?mod=viewthread&tid=14655519
.如果真 (取文本右边 (参数_待解密文本, 9) ≠ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_解密的密码), , ), 3, 9)))
    返回 (“”)
.如果真结束
局_待加密文本 ＝ 字节集_十六进制到字节集2 (取文本左边 (参数_待解密文本, 取文本长度 (参数_待解密文本) － 9))
.计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
    局_待加密文本 [局_计次] ＝ 位异或 (局_待加密文本 [局_计次], 3600)
.计次循环尾 ()
返回 (到文本 (局_待加密文本))
.子程序 文本_是否为数字, 逻辑型, 公开, 中间不能有空格,判断指定文本是否是数字
.参数 参_文本, 文本型
.局部变量 i, 整数型
.局部变量 Len, 整数型
.局部变量 asc, 整数型
Len ＝ 取文本长度 (参_文本)
.如果真 (Len ＝ 0)
    返回 (假)
.如果真结束
.计次循环首 (Len, i)
    asc ＝ 取代码 (参_文本, i)
    .判断开始 (asc ＜ 48)  ' a=97
        返回 (假)
    .判断 (asc ＞ 57)  ' z=122
        返回 (假)
    .默认
    .判断结束
.计次循环尾 ()
返回 (真)
.子程序 文本_自动补零, 文本型, 公开, 当指定文本长度不足时前面自动补零，通用用于数据库序列号
.参数 参_欲补齐文本, 文本型
.参数 参_补齐长度
返回 (取重复文本 (参_补齐长度 － 取文本长度 (参_欲补齐文本), “0”) ＋ 参_欲补齐文本)
.子程序 文本_是否小写字母, 逻辑型, 公开, 中间不能有空格,By:邓学彬(泪闯天涯)
.参数 字符串, 文本型
.局部变量 Len, 整数型
.局部变量 i, 整数型
.局部变量 asc, 整数型
Len ＝ 取文本长度 (字符串)
.如果真 (Len ＝ 0)
    返回 (假)
.如果真结束
.计次循环首 (Len, i)
    asc ＝ 取代码 (字符串, i)
    .判断开始 (asc ＜ 97)  ' a=97
        返回 (假)
    .判断 (asc ＞ 122)  ' z=122
        返回 (假)
    .默认
    .判断结束
.计次循环尾 ()
返回 (真)
.子程序 文本_是否大写字母, 逻辑型, 公开, 中间不能有空格,By:邓学彬(泪闯天涯)
.参数 字符串, 文本型
.局部变量 Len, 整数型
.局部变量 i, 整数型
.局部变量 asc, 整数型
Len ＝ 取文本长度 (字符串)
.如果真 (Len ＝ 0)
    返回 (假)
.如果真结束
.计次循环首 (Len, i)
    asc ＝ 取代码 (字符串, i)
    .判断开始 (asc ＜ 65)  ' A=65
        返回 (假)
    .判断 (asc ＞ 90)  ' Z=90
        返回 (假)
    .默认
    .判断结束
.计次循环尾 ()
返回 (真)
.子程序 文本_取某位置文本, 文本型, 公开, 取某位置下的文本，如果指定位置超出文本长度，返回空文本。
.参数 文本, 文本型
.参数 位置, 整数型
.参数 取出文本类型, 逻辑型, 参考 可空, 得到指定位置的文本类型，全角为真，半角为假。
.局部变量 _局部变量1, 文本型
' https://bbs.125.la/thread-14428295-1-1.html
.如果真 (位置 ＞ 取文本长度 (文本) 或 位置 ≤ 0)
    返回 (“”)
.如果真结束
_局部变量1 ＝ 取文本中间 (文本, 位置, 2)
.如果真 (取代码 (_局部变量1, ) ＜ 0)
    _局部变量1 ＝ 取文本中间 (文本, 位置 － 1, 2)
    .如果真 (取代码 (_局部变量1, ) ＜ 0)
        取出文本类型 ＝ 真
        返回 (_局部变量1)
    .如果真结束
    取出文本类型 ＝ 真
    返回 (取文本中间 (文本, 位置, 2))
.如果真结束
取出文本类型 ＝ 假
返回 (取文本中间 (文本, 位置, 1))
.子程序 格式化文本A, 文本型, 公开, 字节集类型的参数必须传递数据指针, 比如 取指针_字节集型() 
.参数 格式, 文本型
.参数 参数1, 通用型, 参考 可空
.参数 参数2, 通用型, 参考 可空
.参数 参数3, 通用型, 参考 可空
.参数 参数4, 通用型, 参考 可空
.参数 参数5, 通用型, 参考 可空
.参数 参数6, 通用型, 参考 可空
.参数 参数7, 通用型, 参考 可空
.参数 参数8, 通用型, 参考 可空
.参数 参数9, 通用型, 参考 可空
.参数 参数10, 通用型, 参考 可空
.参数 参数11, 通用型, 参考 可空
.参数 参数12, 通用型, 参考 可空
.参数 参数13, 通用型, 参考 可空
.参数 参数14, 通用型, 参考 可空
.参数 参数15, 通用型, 参考 可空
.参数 参数16, 通用型, 参考 可空
.参数 参数17, 通用型, 参考 可空
.参数 参数18, 通用型, 参考 可空
.参数 参数19, 通用型, 参考 可空
.参数 参数20, 通用型, 参考 可空
.局部变量 buf, 整数型
.局部变量 bufSize, 整数型
.局部变量 list, 整数型
.局部变量 i, 整数型
.局部变量 len, 整数型
.局部变量 ret, 文本型
.局部变量 format, 整数型
list ＝ __make_list ()
.如果真 (list ＝ 0)
    返回 (“”)
.如果真结束
bufSize ＝ 4096
buf ＝ malloc (bufSize)
format ＝ 取指针_文本型 (格式)
len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环首 (len ＝ -1)
    free (buf)
    bufSize ＝ bufSize × 2
    buf ＝ malloc (bufSize)
    len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环尾 ()
ret ＝ 指针到文本 (buf)
free (buf)
free (list)
返回 (ret)
.子程序 格式化文本W, 字节集, 公开, Unicode文本必须以\0\0结尾, 字节集类型的参数必须传递数据指针, 比如 取指针_字节集型() 
.参数 格式, 字节集
.参数 参数1, 通用型, 参考 可空
.参数 参数2, 通用型, 参考 可空
.参数 参数3, 通用型, 参考 可空
.参数 参数4, 通用型, 参考 可空
.参数 参数5, 通用型, 参考 可空
.参数 参数6, 通用型, 参考 可空
.参数 参数7, 通用型, 参考 可空
.参数 参数8, 通用型, 参考 可空
.参数 参数9, 通用型, 参考 可空
.参数 参数10, 通用型, 参考 可空
.参数 参数11, 通用型, 参考 可空
.参数 参数12, 通用型, 参考 可空
.参数 参数13, 通用型, 参考 可空
.参数 参数14, 通用型, 参考 可空
.参数 参数15, 通用型, 参考 可空
.参数 参数16, 通用型, 参考 可空
.参数 参数17, 通用型, 参考 可空
.参数 参数18, 通用型, 参考 可空
.参数 参数19, 通用型, 参考 可空
.参数 参数20, 通用型, 参考 可空
.局部变量 buf, 整数型
.局部变量 bufSize, 整数型
.局部变量 format, 整数型
.局部变量 list, 整数型
.局部变量 i, 整数型
.局部变量 len, 整数型
.局部变量 ret, 字节集
list ＝ __make_list ()
.如果真 (list ＝ 0)
    返回 ({  })
.如果真结束
bufSize ＝ 4096
buf ＝ malloc (bufSize × 2)  ' Unicode单位是字符长度, 这里申请的长度需要按字节来申请
format ＝ 取指针_字节集型 (格式)
len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环首 (len ＝ -1)
    free (buf)
    bufSize ＝ bufSize × 2
    buf ＝ malloc (bufSize × 2)
    len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环尾 ()
ret ＝ 指针到字节集 (buf, len × 2 ＋ 2)
free (buf)
返回 (ret)
.子程序 格式化文本A_数组, 文本型, 公开, 数组里如果用到字节集参数那这个成员必须指向字节集数据地址, 可以使用 取指针_字节集型() 来获取
.参数 格式, 文本型
.参数 参数, 整数型, 参考 可空 数组
.局部变量 buf, 整数型
.局部变量 bufSize, 整数型
.局部变量 format, 整数型
.局部变量 list, 整数型
.局部变量 i, 整数型
.局部变量 len, 整数型
.局部变量 ret, 文本型
bufSize ＝ 4096
buf ＝ malloc (bufSize)
list ＝ 取数据_通用型_数组 (参数)
format ＝ 取指针_文本型 (格式)
len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环首 (len ＝ -1)
    free (buf)
    bufSize ＝ bufSize × 2
    buf ＝ malloc (bufSize)
    len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环尾 ()
ret ＝ 指针到文本 (buf)
free (buf)
返回 (ret)
.子程序 格式化文本W_数组, 字节集, 公开, 数组里如果用到字节集参数那这个成员必须指向字节集数据地址, 可以使用 取指针_字节集型() 来获取
.参数 格式, 字节集
.参数 参数, 整数型, 参考 可空 数组
.局部变量 buf, 整数型
.局部变量 bufSize, 整数型
.局部变量 format, 整数型
.局部变量 list, 整数型
.局部变量 i, 整数型
.局部变量 len, 整数型
.局部变量 ret, 字节集
bufSize ＝ 4096
buf ＝ malloc (bufSize × 2)  ' Unicode单位是字符长度, 这里申请的长度需要按字节来申请
list ＝ 取数据_通用型_数组 (参数)
format ＝ 取指针_字节集型 (格式)
len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环首 (len ＝ -1)
    free (buf)
    bufSize ＝ bufSize × 2
    buf ＝ malloc (bufSize × 2)
    len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
.判断循环尾 ()
ret ＝ 指针到字节集 (buf, len × 2 ＋ 2)
free (buf)
返回 (ret)
.程序集 集_字节集
.子程序 字节集_字节集转文本, 文本型, 公开, 以文本表示字节集，适合于字节集的调试用,查看字节集可以将一串字节集用文本形式表示出来，极大地方便了调试字节集变量。感谢易友[缘诚]提供优化查看速度方案
.参数 原始字节集, 字节集, , 要查看的字节集
.局部变量 局_文件句柄, 整数型
.局部变量 局_字节集长度, 整数型
.局部变量 局_i, 整数型
.局部变量 局_文本, 文本型
局_文件句柄 ＝ 打开内存文件 ()
局_字节集长度 ＝ 取字节集长度 (原始字节集)
.计次循环首 (局_字节集长度, 局_i)
    插入文本 (局_文件句柄, 到文本 (原始字节集 [局_i]) ＋ “,”)
    处理事件 ()
.计次循环尾 ()
移到文件首 (局_文件句柄)
局_文本 ＝ “{” ＋ 读入文本 (局_文件句柄, )
关闭文件 (局_文件句柄)
.如果 (取文本右边 (局_文本, 1) ＝ “,”)
    局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 1) ＋ “}”
.否则
    局_文本 ＝ 局_文本 ＋ “}”
.如果结束
返回 (局_文本)
.子程序 字节集_字节集转文本ex, 文本型, 公开, 感谢【@贫民窟 】提供源码
.参数 字节集, 字节集
.局部变量 长度, 整数型
.局部变量 缓冲区, 字节集
.局部变量 缓冲区索引, 整数型
.局部变量 i, 整数型
.局部变量 字节, 字节型
.局部变量 字节1, 字节型
.局部变量 字节2, 字节型
.局部变量 字节3, 字节型
长度 ＝ 取字节集长度 (字节集)
.如果真 (长度 ＝ 0)
    返回 (“”)
.如果真结束
缓冲区 ＝ 取空白字节集 (长度 × 4 ＋ 2)
缓冲区 [1] ＝ 123
缓冲区索引 ＝ 1
.计次循环首 (长度, i)
    字节 ＝ 字节集 [i]
    缓冲区索引 ＝ 缓冲区索引 ＋ 1
    字节1 ＝ 字节 ＼ 100
    字节 ＝ 字节 － 字节1 × 100
    字节2 ＝ 字节 ＼ 10
    字节 ＝ 字节 － 字节2 × 10
    .判断开始 (字节1 ＞ 0)
        缓冲区 [缓冲区索引] ＝ 字节1 ＋ 48
        缓冲区索引 ＝ 缓冲区索引 ＋ 1
        缓冲区 [缓冲区索引] ＝ 字节2 ＋ 48
        缓冲区索引 ＝ 缓冲区索引 ＋ 1
    .默认
        .如果真 (字节2 ＞ 0)
            缓冲区 [缓冲区索引] ＝ 字节2 ＋ 48
            缓冲区索引 ＝ 缓冲区索引 ＋ 1
        .如果真结束
    .判断结束
    缓冲区 [缓冲区索引] ＝ 字节 ＋ 48
    .判断开始 (长度 ＝ i)
        缓冲区 [缓冲区索引 ＋ 1] ＝ 125
    .默认
        缓冲区索引 ＝ 缓冲区索引 ＋ 1
        缓冲区 [缓冲区索引] ＝ 44
    .判断结束
.计次循环尾 ()
返回 (到文本 (缓冲区))
.子程序 字节集_文本转字节集ex, 字节集, 公开, 感谢【@贫民窟 】提供源码
.参数 参_文本, 文本型
.局部变量 局_缓冲区, 字节集
.局部变量 局_缓冲区索引, 整数型
.局部变量 局_数字缓冲区, 字节集
.局部变量 局_数字缓冲索引, 整数型
.局部变量 局_字节集, 字节集
.局部变量 局_长度, 整数型
.局部变量 i, 整数型
.局部变量 局_字节, 字节型
.局部变量 局_插入逻辑, 逻辑型
.局部变量 局_位数, 整数型
.局部变量 局_文本, 文本型
局_文本 ＝ 参_文本
.如果真 (取文本左边 (局_文本, 1) ≠ “{”)
    局_文本 ＝ “{” ＋ 局_文本
.如果真结束
.如果真 (取文本右边 (局_文本, 1) ≠ “}”)
    局_文本 ＝ 局_文本 ＋ “}”
.如果真结束
局_字节集 ＝ 到字节集 (删全部空 (局_文本))
局_长度 ＝ 取字节集长度 (局_字节集)
.如果真 (局_长度 ＜ 1)
    返回 ({  })
.如果真结束
局_缓冲区 ＝ 取空白字节集 (局_长度)
局_缓冲区索引 ＝ 1
局_数字缓冲区 ＝ { 0, 0, 0 }
局_数字缓冲索引 ＝ 1
.计次循环首 (局_长度, i)
    局_字节 ＝ 局_字节集 [i]
    .判断开始 (局_字节 ＞ 47 且 局_字节 ＜ 58)  ' 数字。
        .如果真 (局_数字缓冲索引 ＞ 3)
            信息框 (“error”, 0, , )
            返回 ({  })
        .如果真结束
        局_数字缓冲区 [局_数字缓冲索引] ＝ 局_字节 － 48
        局_数字缓冲索引 ＝ 局_数字缓冲索引 ＋ 1
        局_插入逻辑 ＝ 真
        局_位数 ＝ 局_位数 ＋ 1
    .默认
        .如果真 (局_插入逻辑)
            局_插入逻辑 ＝ 假
            .判断开始 (局_位数 ＝ 1)
                局_字节 ＝ 局_数字缓冲区 [1]
            .判断 (局_位数 ＝ 2)
                局_字节 ＝ 局_数字缓冲区 [1] × 10 ＋ 局_数字缓冲区 [2]
            .默认
                局_字节 ＝ 局_数字缓冲区 [1] × 100 ＋ 局_数字缓冲区 [2] × 10 ＋ 局_数字缓冲区 [3]
            .判断结束
            局_缓冲区 [局_缓冲区索引] ＝ 局_字节
            局_缓冲区索引 ＝ 局_缓冲区索引 ＋ 1
            局_数字缓冲区 [1] ＝ 0
            局_数字缓冲区 [2] ＝ 0
            局_数字缓冲区 [3] ＝ 0
            局_数字缓冲索引 ＝ 1
            局_位数 ＝ 0
        .如果真结束
    .判断结束
.计次循环尾 ()
返回 (取字节集左边 (局_缓冲区, 局_缓冲区索引 － 1))
.子程序 字节集_文本转字节集, 字节集, 公开, 将“字节集_字节集转文本”得到的文本字节集重新转换为字节集。感谢【御风软件】提供代码
.参数 文本字节集, 文本型
.局部变量 N, 整数型
.局部变量 文本数组, 文本型, , "0"
.局部变量 字节长度, 整数型
.局部变量 新字节集, 字节集
文本数组 ＝ 分割文本 (取文本中间 (文本字节集, 2, 取文本长度 (文本字节集) － 1), “,”, )
字节长度 ＝ 取数组成员数 (文本数组)
新字节集 ＝ 取空白字节集 (字节长度)
.计次循环首 (字节长度, N)
    新字节集 [N] ＝ 到字节 (文本数组 [N])
.计次循环尾 ()
返回 (新字节集)
.子程序 字节集_十六进制到字节集, 字节集, 公开, 将一串十六进制文本还原为字节集。还原为字节集可以将默认的16进制文本转换成字节集。如“00BFAD00”可还原为{0,191,173,0}
.参数 原始16进制文本, 文本型, , 如“00BFAD00AFD4FD4F9E054F9FF91FC5FF2076FBAFDB071044”
.局部变量 字节集, 字节集
.局部变量 次数, 整数型
.局部变量 临时变量, 长整数型
.变量循环首 (1, 取文本长度 (原始16进制文本), 2, 次数)
    临时变量 ＝ 进制_十六到十 (取文本中间 (原始16进制文本, 次数, 2))
    字节集 ＝ 字节集 ＋ 到字节集 (到字节 (临时变量))
    处理事件 ()
.变量循环尾 ()
返回 (字节集)
.子程序 字节集_字节集到十六进制, 文本型, 公开, 将字节集用16进制表示.可以将字节集用系统标准16进制表示
.参数 原始字节集, 字节集, , 用于转换的字节集
.局部变量 局_文件句柄, 整数型
.局部变量 局_字节集长度, 整数型
.局部变量 局_i, 整数型
.局部变量 局_文本, 文本型
局_文件句柄 ＝ 打开内存文件 ()
局_字节集长度 ＝ 取字节集长度 (原始字节集)
.计次循环首 (局_字节集长度, 局_i)
    插入文本 (局_文件句柄, 到十六进制 (原始字节集 [局_i]))
    处理事件 ()
.计次循环尾 ()
移到文件首 (局_文件句柄)
局_文本 ＝ 读入文本 (局_文件句柄, )
关闭文件 (局_文件句柄)
返回 (局_文本)
.子程序 字节集_十六进制到字节集2, 字节集, 公开, 将一串十六进制文本还原为字节集。还原为字节集可以将默认的16进制文本转换成字节集。如“00BFAD00”可还原为{0,191,173,0}
.参数 原始16进制文本, 文本型, , 如“00BFAD00AFD4FD4F9E054F9FF91FC5FF2076FBAFDB071044”
.局部变量 bytes, 字节集
.局部变量 bytes_ret, 字节集
.局部变量 len, 整数型
.局部变量 p1, 整数型
.局部变量 i, 整数型
.局部变量 byte1, 整数型
.局部变量 byte2, 整数型
' https://bbs.125.la/forum.php?mod=viewthread&tid=14653144
bytes ＝ 到字节集 (原始16进制文本)
len ＝ 取字节集长度 (bytes)
.如果真 (位与 (len, 1) ＝ 1)
    bytes ＝ bytes ＋ 取空白字节集 (1)
    len ＝ len ＋ 1
    bytes [len] ＝ bytes [len － 1]
    bytes [len － 1] ＝ 48
.如果真结束
bytes_ret ＝ 取空白字节集 (右移 (len, 1))
.变量循环首 (1, len, 2, p1)
    i ＝ i ＋ 1
    byte1 ＝ bytes [p1]
    byte2 ＝ bytes [p1 ＋ 1]
    .判断开始 (byte1 ＞ 96)
        byte1 ＝ byte1 － 87
    .判断 (byte1 ＞ 64)
        byte1 ＝ byte1 － 55
    .默认
        byte1 ＝ byte1 － 48
    .判断结束
    .判断开始 (byte2 ＞ 96)
        byte2 ＝ byte2 － 87
    .判断 (byte2 ＞ 64)
        byte2 ＝ byte2 － 55
    .默认
        byte2 ＝ byte2 － 48
    .判断结束
    bytes_ret [i] ＝ 左移 (byte1, 4) ＋ byte2
.变量循环尾 ()
返回 (bytes_ret)
.子程序 字节集_字节集到十六进制2, 文本型, 公开, 将字节集用16进制表示.可以将字节集用系统标准16进制表示
.参数 原始字节集, 字节集, , 用于转换的字节集
.局部变量 len, 整数型
.局部变量 byte, 整数型
.局部变量 high, 整数型
.局部变量 low, 整数型
.局部变量 ret, 字节集
.局部变量 len_ret, 整数型
.局部变量 i, 整数型
.局部变量 j, 整数型
len ＝ 取字节集长度 (原始字节集)
len_ret ＝ len × 2
' ret ＝ 取重复字节集 (len_ret, { 48 })
ret ＝ 取空白字节集 (len_ret)
.变量循环首 (1, len_ret, 2, j)
    i ＝ i ＋ 1
    byte ＝ 原始字节集 [i]
    .如果 (byte ＞ 15)
        high ＝ 位与 (右移 (byte, 4), 15)
        .如果 (high ＞ 9)
            ret [j] ＝ high ＋ 55
        .否则
            ret [j] ＝ high ＋ 48
        .如果结束
    .否则
        ret [j] ＝ 48
    .如果结束
    low ＝ 位与 (byte, 15)
    .如果 (low ＞ 9)
        ret [j ＋ 1] ＝ low ＋ 55
    .否则
        ret [j ＋ 1] ＝ low ＋ 48
    .如果结束
.变量循环尾 ()
返回 (到文本 (ret))
.子程序 到十六进制, 文本型, , 返回转换后的十六进制文本
.参数 十进制数据, 整数型, , 传入十进制整型数据
.局部变量 局部_结果, 文本型
局部_结果 ＝ 取十六进制文本 (十进制数据)
.如果真 (取文本长度 (局部_结果) ％ 2 ＝ 1)
    返回 (“0” ＋ 局部_结果)
.如果真结束
返回 (局部_结果)
.子程序 字节集_寻找取左, 字节集, 公开, 从字节集的左边按 欲寻找的字节集 开始寻找 如 字节集_取左边({105,108,121,13,10,83,101},{13,10}) 将返回 {105,108,121}
.参数 被查找的字节集, 字节集, , 被查找的字节集
.参数 欲寻找的字节集, 字节集, , 欲寻找的字节集
.参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
.局部变量 局_长度, 整数型
.局部变量 局_起始搜寻位置, 整数型
.局部变量 局_方向, 整数型
.局部变量 局_找到的位置, 整数型
.局部变量 局_返回结果, 字节集
局_长度 ＝ 取字节集长度 (被查找的字节集)
局_起始搜寻位置 ＝ 起始寻找位置
.如果真 (局_起始搜寻位置 ＜ 0)
    局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
    .如果真 (局_起始搜寻位置 ＝ 1)
        局_起始搜寻位置 ＝ 0
    .如果真结束
    局_方向 ＝ 1
.如果真结束
.如果 (局_方向 ＝ 1)
    局_找到的位置 ＝ 倒找字节集 (被查找的字节集, 欲寻找的字节集, 局_长度 － 局_起始搜寻位置)
.否则
    .如果真 (局_起始搜寻位置 ＝ 0)
        局_起始搜寻位置 ＝ 1
    .如果真结束
    局_找到的位置 ＝ 寻找字节集 (被查找的字节集, 欲寻找的字节集, 局_起始搜寻位置)
.如果结束
.如果真 (局_找到的位置 ＝ -1)
    返回 ({  })
.如果真结束
局_返回结果 ＝ 取字节集左边 (被查找的字节集, 局_找到的位置 － 1)
返回 (局_返回结果)
.子程序 字节集_寻找取右, 字节集, 公开, 从字节集的右边按 欲寻找的字节集 开始寻找  如 字节集_取右边({105,108,121,13,10,83,101},{13,10}) 将返回 {83,101}
.参数 被查找的字节集, 字节集, , 被查找的字节集
.参数 欲寻找的字节集, 字节集, , 欲寻找的字节集
.参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
.局部变量 局_长度, 整数型
.局部变量 局_起始搜寻位置, 整数型
.局部变量 局_方向, 整数型
.局部变量 局_找到的位置, 整数型
.局部变量 局_返回结果, 字节集
局_长度 ＝ 取字节集长度 (被查找的字节集)
局_起始搜寻位置 ＝ 起始寻找位置
.如果真 (局_起始搜寻位置 ＜ 0)
    局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
    .如果真 (局_起始搜寻位置 ＝ 1)
        局_起始搜寻位置 ＝ 0
    .如果真结束
    局_方向 ＝ 1
.如果真结束
.如果 (局_方向 ＝ 1)
    局_找到的位置 ＝ 倒找字节集 (被查找的字节集, 欲寻找的字节集, 局_长度 － 局_起始搜寻位置)
.否则
    .如果真 (局_起始搜寻位置 ＝ 0)
        局_起始搜寻位置 ＝ 1
    .如果真结束
    局_找到的位置 ＝ 寻找字节集 (被查找的字节集, 欲寻找的字节集, 局_起始搜寻位置)
.如果结束
.如果真 (局_找到的位置 ＝ -1)
    返回 ({  })
.如果真结束
局_返回结果 ＝ 取字节集右边 (被查找的字节集, 局_长度 － 取字节集长度 (欲寻找的字节集) － 局_找到的位置 ＋ 1)
返回 (局_返回结果)
.子程序 字节集_寻找取中, 字节集, 公开
.参数 要操作的字节集, 字节集
.参数 前面字节集, 字节集
.参数 后面字节集, 字节集
.参数 起始搜寻位置, 整数型, 可空, 可空。1为首位置，2为第2个位置，如此类推，如果被省略，则“寻找字节集”命令默认从首部开始，“倒找字节集”命令默认从尾部开始。
.局部变量 局_字节集, 字节集
.局部变量 局_位置, 整数型
局_位置 ＝ 寻找字节集 (要操作的字节集, 前面字节集, 起始搜寻位置)
.如果真 (局_位置 ＝ -1)
    返回 ({  })
.如果真结束
局_字节集 ＝ 取字节集右边 (要操作的字节集, 取字节集长度 (要操作的字节集) － 局_位置 － 取字节集长度 (前面字节集) ＋ 1)
局_位置 ＝ 寻找字节集 (局_字节集, 后面字节集, )
.如果真 (局_位置 ＝ -1)
    返回 ({  })
.如果真结束
局_字节集 ＝ 取字节集左边 (局_字节集, 局_位置 － 1)
返回 (局_字节集)
.子程序 字节集_到文本, 文本型, 公开
.参数 字节集, 字节集
.局部变量 返回值, 文本型
.局部变量 Temp, 字节集
Temp ＝ 字节集 ＋ { 0 }
返回 (指针到文本 (字节集_取指针 (Temp)))
.子程序 字节集_到整数, 整数型, 公开
.参数 字节集, 字节集
.参数 位置, 整数型, 可空, 默认为1
.局部变量 返回值, 整数型
.局部变量 Address, 整数型
.局部变量 Len, 整数型
Address ＝ 字节集_取指针 (字节集)
Len ＝ 字节集_取长度 (字节集)
.如果真 (是否为空 (位置) ＝ 真)
    位置 ＝ 1
.如果真结束
.如果真 (位置 ＞ Len 或 位置 ＜ 1)
    返回 (0)
.如果真结束
.如果 (Len － 位置 ＜ 4)
    RtlMoveMemory_整数传址1 (返回值, Address ＋ 位置 － 1, Len － 位置 ＋ 1)
.否则
    RtlMoveMemory_整数传址1 (返回值, Address ＋ 位置 － 1, 4)
.如果结束
返回 (返回值)
.子程序 整数型_到文本, 文本型
.参数 整数, 整数型
.局部变量 返回值, 文本型
.局部变量 参数, 整数型, , "1"
返回值 ＝ 文本型_取空白 (4)
参数 [1] ＝ 整数
wsprintfA (返回值, “%d”, 参数)
返回 (返回值)
.子程序 字节集_取左边, 字节集, 公开
.参数 字节集, 字节集
.参数 欲取出字节的数目, 整数型
.局部变量 Len, 整数型
.局部变量 Address, 整数型
Len ＝ 字节集_取长度 (字节集)
.如果真 (Len ＜ 1)
    返回 ({  })
.如果真结束
.判断开始 (欲取出字节的数目 ＜ 1)
    返回 ({  })
.判断 (欲取出字节的数目 ＞ Len)
    欲取出字节的数目 ＝ Len
.默认
.判断结束
Address ＝ 字节集_取指针 (字节集)
返回 (指针到字节集 (Address, 欲取出字节的数目))
.子程序 字节集_取右边, 字节集, 公开
.参数 字节集, 字节集
.参数 欲取出字节的数目, 整数型
.局部变量 Len, 整数型
.局部变量 Address, 整数型
Len ＝ 字节集_取长度 (字节集)
.如果真 (Len ＜ 1)
    返回 ({  })
.如果真结束
.判断开始 (欲取出字节的数目 ＜ 1)
    返回 ({  })
.判断 (欲取出字节的数目 ＞ Len)
    欲取出字节的数目 ＝ Len
.默认
.判断结束
Address ＝ 字节集_取指针 (字节集) ＋ Len － 欲取出字节的数目
返回 (指针到字节集 (Address, 欲取出字节的数目))
.子程序 字节集_取空白, 字节集, 公开
.参数 零字节数目, 整数型
.局部变量 Address, 整数型
.局部变量 返回值, 字节集
.如果真 (零字节数目 ＜ 1)
    返回 ({  })
.如果真结束
Address ＝ LocalAlloc (64, 零字节数目)
.如果真 (Address ＝ 0)
    返回 ({  })
.如果真结束
返回值 ＝ 指针到字节集 (Address, 零字节数目)
LocalFree (Address)
返回 (返回值)
.子程序 字节集_取长度, 整数型, 公开
.参数 字节集, 字节集
.局部变量 返回值, 整数型
.局部变量 Address, 整数型
.如果真 (字节集 ＝ {  })
    返回 (0)
.如果真结束
置入代码 ({ 139, 93, 8, 139, 27, 139, 91, 4, 137, 93, 252 })  ' 取字节集长度
' Address ＝ 字节集_取指针 (字节集)
' RtlMoveMemory_Int (返回值, Address － 4, 4)
返回 (返回值)
.子程序 字节集_取指定位置字节集, 字节集, 公开
.参数 字节集, 字节集
.参数 起始取出位置, 整数型
.参数 欲取出字节的数目, 整数型
.局部变量 Len, 整数型
.局部变量 Address, 整数型
Len ＝ 字节集_取长度 (字节集)
.如果真 (Len ＜ 1)
    返回 ({  })
.如果真结束
.判断开始 (起始取出位置 ＜ 1)
    起始取出位置 ＝ 1
.判断 (起始取出位置 ＞ Len)
    返回 ({  })
.默认
.判断结束
.如果真 (欲取出字节的数目 ＜ 1)
    返回 ({  })
.如果真结束
.如果真 (欲取出字节的数目 ＋ 起始取出位置 － 1 ＞ Len)
    欲取出字节的数目 ＝ Len － 起始取出位置 ＋ 1
.如果真结束
Address ＝ 字节集_取指针 (字节集) ＋ 起始取出位置 － 1
返回 (指针到字节集 (Address, 欲取出字节的数目))
.子程序 字节集_取中间, 字节集, 公开, 取指定字节集中 指定前后字节集中间的数据，用法与”文本_取出中间文本“类似
.参数 要操作的字节集, 字节集
.参数 前面字节集, 字节集
.参数 后面字节集, 字节集
.参数 起始搜寻位置, 整数型, 可空, 可空。1为首位置，2为第2个位置，如此类推，如果被省略，则“寻找字节集”命令默认从首部开始，“倒找字节集”命令默认从尾部开始。
.局部变量 局_字节集, 字节集
.局部变量 局_位置, 整数型
局_位置 ＝ 寻找字节集 (要操作的字节集, 前面字节集, 起始搜寻位置)
.如果真 (局_位置 ＝ -1)
    返回 ({  })
.如果真结束
局_字节集 ＝ 取字节集右边 (要操作的字节集, 取字节集长度 (要操作的字节集) － 局_位置 － 取字节集长度 (前面字节集) ＋ 1)
局_位置 ＝ 寻找字节集 (局_字节集, 后面字节集, 起始搜寻位置)
.如果真 (局_位置 ＝ -1)
    返回 ({  })
.如果真结束
局_字节集 ＝ 取字节集左边 (局_字节集, 局_位置 － 1)
返回 (局_字节集)
' 文本_取出中间文本 ()
' 子程序名：文本_取出中间文本
' 比如：欲取全文本为“12345”,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”，
' 返回值类型：文本型
' 参数<1>的名称为“欲取全文本”，类型为“文本型”。注明：比如：欲取全文本为 12345。
' 参数<2>的名称为“前面文本”，类型为“文本型”。注明：3的前面为“2”，引号直接用 #引号，如："<font color=#引号red#引号>"。
' 参数<3>的名称为“后面文本”，类型为“文本型”。注明：3的后面为“4”，引号直接用 #引号，如："<font color=#引号red#引号>"。
.子程序 字节集_替换, 字节集, 公开, 将指定字节集的某一部分用其它的字节集替换,然后返回替换后的结果.
.参数 欲替换其部分的字节集, 字节集
.参数 起始替换位置, 整数型, , 替换的起始位置,1为首位置,2为第2个位置,如此类推.
.参数 替换长度, 整数型
.参数 用作替换的字节集, 字节集, 可空, 可以被省略.如果本参数被省略,则删除字节集中的指定部分.
.局部变量 Len_X, 整数型
.局部变量 Temp1, 字节集
.局部变量 Temp2, 字节集
.如果真 (欲替换其部分的字节集 ＝ {  })
    返回 ({  })
.如果真结束
.如果真 (替换长度 ＜ 1)
    返回 (欲替换其部分的字节集)
.如果真结束
Len_X ＝ 字节集_取长度 (欲替换其部分的字节集)
.如果真 (起始替换位置 ＜ 1)
    起始替换位置 ＝ 1
.如果真结束
.如果真 (起始替换位置 ＞ Len_X)
    返回 (欲替换其部分的字节集)
.如果真结束
Temp1 ＝ 字节集_取左边 (欲替换其部分的字节集, 起始替换位置 － 1)
Temp2 ＝ 字节集_取右边 (欲替换其部分的字节集, Len_X － (起始替换位置 ＋ 替换长度) ＋ 1)
返回 (Temp1 ＋ 用作替换的字节集 ＋ Temp2)
.子程序 字节集_寻找, 整数型, 公开, 返回一字节集在另一字节集中最先出现的位置,位置值从 1 开始.如果未找到,返回 -1.
.参数 被搜寻的字节集, 字节集
.参数 欲寻找的字节集, 字节集
.参数 起始搜寻位置, 整数型, 可空, 1为首位置,2为第2个位置,如此类推,如果被省略,则“寻找字节集”命令默认从首部开始,“倒找字节集”命令默认从尾部开始.
置入代码 ({ 83, 82, 86, 87, 139, 125, 8, 139, 63, 133, 255, 116, 119, 139, 95, 4, 131, 251, 0, 126, 111, 141, 87, 8, 139, 117, 12, 139, 54, 133, 246, 116, 99, 139, 78, 4, 131, 249, 0, 126, 91, 141, 70, 8, 137, 69, 244, 139, 69, 16, 72, 131, 248, 0, 125, 2, 49, 192, 137, 69, 16, 41, 195, 57, 217, 127, 65, 73, 137, 77, 248, 41, 203, 137, 93, 252, 1, 194, 139, 117, 244, 137, 215, 137, 217, 138, 38, 70, 227, 42, 138, 7, 71, 73, 48, 224, 117, 246, 137, 250, 137, 203, 139, 77, 248, 227, 15, 138, 38, 138, 7, 70, 71, 48, 224, 117, 217, 73, 227, 2, 235, 241, 139, 69, 16, 3, 69, 252, 41, 216, 235, 3, 131, 200, 255, 95, 94, 90, 91, 131, 196, 12, 137, 236, 93, 194, 16, 0 })
返回 (0)
.子程序 字节集_取指针, 整数型, 公开
.参数 字节集, 字节集
返回 (lstrcpyn_字节集 (字节集, 字节集, 0))
.子程序 字节集_子替换, 字节集, 公开, 将所有的预被替换的字节集用 用作替换的子字节集 替换
.参数 欲被替换的字节集, 字节集
.参数 欲被替换的子字节集, 字节集
.参数 用作替换的子字节集, 字节集, 可空, 可以被省略。如果省略本参数，则默认为空字节集。
.参数 进行替换的起始位置, 整数型, 可空, 可以被省略。被替换子字节集的起始搜索位置。如果省略，默认从1开始。
.参数 替换进行的次数, 整数型, 可空, 可以被省略。对子字节集进行替换的次数。如果省略，默认进行所有可能的替换。
.局部变量 offset, 整数型, , "0"
.局部变量 count, 整数型
.局部变量 i, 整数型
.局部变量 ret, 字节集
.局部变量 len, 整数型
.局部变量 偏移, 整数型
.如果真 (欲被替换的字节集 ＝ {  } 或 欲被替换的子字节集 ＝ {  })
    返回 ({  })
.如果真结束
.如果真 (是否为空 (进行替换的起始位置))
    进行替换的起始位置 ＝ 1
.如果真结束
count ＝ 字节集_寻找子 (欲被替换的字节集, 欲被替换的子字节集, offset, 进行替换的起始位置)
.如果真 (count ＝ 0)
    返回 (欲被替换的字节集)
.如果真结束
.如果真 (是否为空 (替换进行的次数) 或 替换进行的次数 ＞ count)
    替换进行的次数 ＝ count
.如果真结束
ret ＝ 欲被替换的字节集
len ＝ 字节集_取长度 (欲被替换的子字节集)
偏移 ＝ 字节集_取长度 (用作替换的子字节集) － len
.计次循环首 (替换进行的次数, i)
    .如果 (i ＝ 1)
        ret ＝ 字节集_替换 (ret, offset [i], len, 用作替换的子字节集)
    .否则
        ret ＝ 字节集_替换 (ret, offset [i] ＋ 偏移 × (i － 1), len, 用作替换的子字节集)
    .如果结束
.计次循环尾 ()
返回 (ret)
.子程序 字节集_寻找子, 整数型, 公开, 查找所有欲寻找的字节集 ，将每个位置放入 结果数组
.参数 被搜寻的字节集, 字节集
.参数 欲寻找的字节集, 字节集
.参数 结果数组, 整数型, 数组
.参数 开始偏移, 整数型, 可空
.局部变量 i
.局部变量 j
.局部变量 len_y
清除数组 (结果数组)
i ＝ 1
.如果 (是否为空 (开始偏移))
    j ＝ 1
.否则
    j ＝ 开始偏移
.如果结束
len_y ＝ 字节集_取长度 (欲寻找的字节集)
.判断循环首 (i ≠ -1)
    i ＝ 字节集_寻找 (被搜寻的字节集, 欲寻找的字节集, j)
    .如果真 (i ≠ -1)
        加入成员 (结果数组, i)
        j ＝ i ＋ len_y
    .如果真结束
.判断循环尾 ()
返回 (取数组成员数 (结果数组))
.程序集 类_快速文本, , 公开, 文本的快速累加
.程序集变量 _文件句柄, 整数型
.程序集变量 集_缓冲区, 字节集
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
_文件句柄 ＝ 打开内存文件 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
关闭文件 (_文件句柄)
.子程序 添加, , 公开
.参数 文本内容, 文本型
写出文本 (_文件句柄, 文本内容)
.子程序 取文本, 文本型, 公开
.如果真 (取读写位置 (_文件句柄) ≠ 0)
    移到文件首 (_文件句柄)
.如果真结束
返回 (读入文本 (_文件句柄, 取文件长度 (_文件句柄)))
.子程序 取文件号, 整数型, 公开
返回 (_文件句柄)
.子程序 插入, 逻辑型, 公开, 在指定字符后(含中文)插入文本内容
.参数 参_插入位置, 整数型, 可空, 字符数,中文也算一个字符,可空,默认最前
.参数 参_文本内容, 文本型, , 要插入的文本内容
.局部变量 局_缓冲区长度, 整数型
.局部变量 局_偏移, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
局_偏移 ＝ 1
.如果真 (是否为空 (参_插入位置))
    参_插入位置 ＝ 0
.如果真结束
局_偏移 ＝ 字数到位置 (参_插入位置)
局_偏移 ＝ 局_偏移 － 1
移动读写位置 (_文件句柄, #文件首, 局_偏移)
返回 (插入文本 (_文件句柄, 参_文本内容))
.子程序 取文本内容, 文本型, 公开, 取出文本内容
.参数 参_起始位置, 整数型, 可空, 可空.默认从第一个字符开始
.参数 参_字符数, 整数型, 可空, 可空,默认取全部
.局部变量 局_偏移, 整数型
.局部变量 局_缓冲区长度, 整数型
.局部变量 局_偏移2, 整数型
.如果真 (取读写位置 (_文件句柄) ≠ 0)
    移到文件首 (_文件句柄)
.如果真结束
.如果真 (是否为空 (参_字符数) 且 是否为空 (参_起始位置))
    返回 (读入文本 (_文件句柄, ))
.如果真结束
集_缓冲区 ＝ 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))
.如果真 (是否为空 (参_起始位置))
    参_起始位置 ＝ 1
.如果真结束
.如果真 (是否为空 (参_字符数))
    参_字符数 ＝ 取字节集长度 (集_缓冲区)
.如果真结束
参_起始位置 ＝ 参_起始位置 － 1
局_偏移 ＝ 1
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
局_偏移 ＝ 字数到位置 (参_起始位置)
局_偏移2 ＝ 字数到位置 (参_起始位置 ＋ 参_字符数)
返回 (到文本 (取字节集中间 (集_缓冲区, 局_偏移, 局_偏移2 － 局_偏移)))
.子程序 清空内容, , 公开, 清空文本内容
关闭文件 (_文件句柄)
_文件句柄 ＝ 打开内存文件 ()
.子程序 删除文本, 逻辑型, 公开, 删除指定位置内容
.参数 参_起始位置, 整数型, , 起始位置
.参数 参_字符数, 整数型, , 删除个数,汉字算一个
.局部变量 局_偏移, 整数型
.局部变量 局_缓冲区长度, 整数型
.局部变量 局_偏移2, 整数型
.如果真 (取读写位置 (_文件句柄) ≠ 0)
    移到文件首 (_文件句柄)
.如果真结束
集_缓冲区 ＝ 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
局_偏移 ＝ 字数到位置 (参_起始位置)
局_偏移2 ＝ 字数到位置 (参_起始位置 ＋ 参_字符数)
移动读写位置 (_文件句柄, #文件首, 局_偏移 － 1)
返回 (删除数据 (_文件句柄, 局_偏移2 － 局_偏移))
.子程序 替换文本内容, 逻辑型, 公开, 替换指定位置文本
.参数 参_替换位置, 整数型, , 起始位置
.参数 参_替换长度, 整数型, , 替换长度
.参数 参_替换文本, 文本型, 可空, 替换文本,可空
.局部变量 局_偏移1, 整数型
.局部变量 局_偏移2, 整数型
.局部变量 局_缓冲区长度, 整数型
写缓存区 ()
局_偏移1 ＝ 1
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
局_偏移1 ＝ 字数到位置 (参_替换位置)
局_偏移2 ＝ 字数到位置 (参_替换位置 ＋ 参_替换长度)
清空内容 ()
返回 (写出字节集 (_文件句柄, 字节集替换 (集_缓冲区, 局_偏移1, 局_偏移2 － 局_偏移1, 到字节集 (参_替换文本))))
.子程序 取长度, 整数型, 公开, 取字符数,汉字算一个
.如果真 (取读写位置 (_文件句柄) ≠ 0)
    移到文件首 (_文件句柄)
.如果真结束
返回 (汇编_取字数 (到字节集 (取文本内容 (, ))))
.子程序 寻找文本内容, 整数型, 公开, 寻找文本
.参数 参_寻找文本内容, 文本型, , 欲寻找文本
.参数 参_起始寻找位置, 整数型, 可空, 起始位置,可空,默认从最头开始
.局部变量 局_偏移, 整数型
.局部变量 局_文本, 字节集
.局部变量 i, 整数型
写缓存区 ()
局_偏移 ＝ 1
.如果真 (是否为空 (参_起始寻找位置))
    参_起始寻找位置 ＝ 1
.如果真结束
局_偏移 ＝ 字数到位置 (参_起始寻找位置)
i ＝ 寻找字节集 (集_缓冲区, 到字节集 (参_寻找文本内容), 局_偏移)
.如果真 (i ＝ 1)
    返回 (1)
.如果真结束
局_文本 ＝ 取字节集左边 (集_缓冲区, i － 1)
.如果 (局_文本 ＝ {  })
    返回 (0)
.否则
    返回 (汇编_取字数 (局_文本) ＋ 1)
.如果结束
.子程序 替换子文本内容, 逻辑型, 公开, 子文本替换
.参数 参_被替换文本, 文本型, , 被替换内容
.参数 参_替换为文本, 文本型, 可空, 替换为内容,可空.默认删除
.参数 参_起始替换位置, 整数型, 可空, 起始位置,可空,默认从最前开始
.参数 参_最大替换次数, 整数型, 可空, 最大替换次数.可空.默认替换所有
.局部变量 局_偏移, 整数型
.局部变量 局_缓冲区长度, 整数型
写缓存区 ()
局_偏移 ＝ 1
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
.如果真 (是否为空 (参_起始替换位置))
    参_起始替换位置 ＝ 1
.如果真结束
局_偏移 ＝ 字数到位置 (参_起始替换位置)
清空内容 ()
.如果 (是否为空 (参_最大替换次数))
    返回 (写出字节集 (_文件句柄, 子字节集替换 (集_缓冲区, 到字节集 (参_被替换文本), 到字节集 (参_替换为文本), 局_偏移, )))
.否则
    返回 (写出字节集 (_文件句柄, 子字节集替换 (集_缓冲区, 到字节集 (参_被替换文本), 到字节集 (参_替换为文本), 局_偏移, 参_最大替换次数)))
.如果结束
.子程序 汇编_取字数, 整数型, 公开, 取文本中英文字数
.参数 参_内容, 字节集
参_内容 ＝ 参_内容 ＋ { 0 }
取变量堆栈地址_字节集 (参_内容)
置入代码 ({ 139, 24, 139, 75, 4, 141, 115, 8, 172, 132, 192, 116, 7, 168, 128, 116, 1, 70, 226, 244, 139, 67, 4, 41, 200, 201, 194, 4, 0 })
返回 (0)
.子程序 置文本, 逻辑型, 公开, 置文本
.参数 参_文本, 文本型, , 文本内容
关闭文件 (_文件句柄)
_文件句柄 ＝ 打开内存文件 ()
返回 (写出文本 (_文件句柄, 参_文本))
.子程序 从文件读入, 逻辑型, 公开, 读文件内容到内存
.参数 参_文件名, 文本型, , 要读入的文件名
关闭文件 (_文件句柄)
_文件句柄 ＝ 打开内存文件 ()
返回 (写出字节集 (_文件句柄, 读入文件 (参_文件名)))
.子程序 写出到文件, 逻辑型, 公开, 写内存内容到文件
.参数 参_文件名, 文本型, , 要写出的文件名
.如果真 (取读写位置 (_文件句柄) ≠ 0)
    移到文件首 (_文件句柄)
.如果真结束
返回 (写到文件 (参_文件名, 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))))
.子程序 删全部空格, 逻辑型, 公开, 删除所有中英文空格
.局部变量 局_计数器, 整数型
.局部变量 局_缓冲区长度, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
清空内容 ()
局_计数器 ＝ 1
.判断循环首 (局_缓冲区长度 ＞ 局_计数器)
    .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
        局_计数器 ＝ 局_计数器 ＋ 1
        到循环尾 ()
    .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 ＋ 1] ＝ 161)
        局_计数器 ＝ 局_计数器 ＋ 2
        到循环尾 ()
    .默认
        写出字节集 (_文件句柄, 到字节集 (集_缓冲区 [局_计数器]))
        局_计数器 ＝ 局_计数器 ＋ 1
    .判断结束
.判断循环尾 ()
.如果 (取长度 () ＝ 0)
    返回 (假)
.否则
    返回 (真)
.如果结束
.子程序 写缓存区
.如果真 (取读写位置 (_文件句柄) ≠ 0)
    移到文件首 (_文件句柄)
.如果真结束
集_缓冲区 ＝ 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))
.子程序 删首尾空格, 逻辑型, 公开
.局部变量 局_计数器, 整数型
.局部变量 局_缓冲区长度, 整数型
.局部变量 局_偏移1, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
清空内容 ()
局_计数器 ＝ 1
.判断循环首 (局_缓冲区长度 ＞ 局_计数器)
    .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
        局_计数器 ＝ 局_计数器 ＋ 1
        到循环尾 ()
    .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 ＋ 1] ＝ 161)
        局_计数器 ＝ 局_计数器 ＋ 2
        到循环尾 ()
    .默认
        跳出循环 ()
    .判断结束
.判断循环尾 ()
局_偏移1 ＝ 局_计数器
局_计数器 ＝ 局_缓冲区长度
.判断循环首 (局_计数器 ＞ 1)
    .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
        局_计数器 ＝ 局_计数器 － 1
        到循环尾 ()
    .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 － 1] ＝ 161)
        局_计数器 ＝ 局_计数器 － 2
        到循环尾 ()
    .默认
        跳出循环 ()
    .判断结束
.判断循环尾 ()
返回 (写出字节集 (_文件句柄, 取字节集中间 (集_缓冲区, 局_偏移1, 局_计数器 － 局_偏移1 ＋ 1)))
.子程序 删首空格, 逻辑型, 公开
.局部变量 局_计数器, 整数型
.局部变量 局_缓冲区长度, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
清空内容 ()
局_计数器 ＝ 1
.判断循环首 (局_缓冲区长度 ＞ 局_计数器)
    .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
        局_计数器 ＝ 局_计数器 ＋ 1
        到循环尾 ()
    .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 ＋ 1] ＝ 161)
        局_计数器 ＝ 局_计数器 ＋ 2
        到循环尾 ()
    .默认
        跳出循环 ()
    .判断结束
.判断循环尾 ()
返回 (写出字节集 (_文件句柄, 取字节集右边 (集_缓冲区, 局_缓冲区长度 － 局_计数器 ＋ 1)))
.子程序 删尾空格, 逻辑型, 公开
.局部变量 局_计数器, 整数型
.局部变量 局_缓冲区长度, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
清空内容 ()
局_计数器 ＝ 局_缓冲区长度
.判断循环首 (局_计数器 ＞ 1)
    .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
        局_计数器 ＝ 局_计数器 － 1
        到循环尾 ()
    .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 － 1] ＝ 161)
        局_计数器 ＝ 局_计数器 － 2
        到循环尾 ()
    .默认
        跳出循环 ()
    .判断结束
.判断循环尾 ()
返回 (写出字节集 (_文件句柄, 取字节集左边 (集_缓冲区, 局_计数器)))
.子程序 到小写字母, 逻辑型, 公开
.参数 参_起始位置, 整数型, 可空
.参数 参_转换字母数, 整数型, 可空
.局部变量 局_缓冲区长度, 整数型
.局部变量 局_偏移, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
清空内容 ()
局_偏移 ＝ 1
.如果真 (是否为空 (参_起始位置))
    参_起始位置 ＝ 1
.如果真结束
.如果真 (是否为空 (参_转换字母数))
    参_转换字母数 ＝ 汇编_取字数 (集_缓冲区) － 字数到位置 (参_起始位置)
.如果真结束
局_偏移 ＝ 字数到位置 (参_起始位置)
.计次循环首 (参_转换字母数, )
    .如果真 (局_偏移 ＞ 局_缓冲区长度)
        跳出循环 ()
    .如果真结束
    .如果 (集_缓冲区 [局_偏移] ＞ 128)
        局_偏移 ＝ 局_偏移 ＋ 2
    .否则
        .如果真 (集_缓冲区 [局_偏移] ＞ 64 且 集_缓冲区 [局_偏移] ＜ 91)
            集_缓冲区 [局_偏移] ＝ 位或 (集_缓冲区 [局_偏移], 32)
        .如果真结束
        局_偏移 ＝ 局_偏移 ＋ 1
    .如果结束
.计次循环尾 ()
返回 (写出字节集 (_文件句柄, 集_缓冲区))
.子程序 到大写字母, 逻辑型, 公开
.参数 参_起始位置, 整数型, 可空
.参数 参_转换字母数, 整数型, 可空
.局部变量 局_缓冲区长度, 整数型
.局部变量 局_偏移, 整数型
写缓存区 ()
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
清空内容 ()
局_偏移 ＝ 1
.如果真 (是否为空 (参_起始位置))
    参_起始位置 ＝ 1
.如果真结束
.如果真 (是否为空 (参_转换字母数))
    参_转换字母数 ＝ 汇编_取字数 (集_缓冲区) － 字数到位置 (参_起始位置)
.如果真结束
局_偏移 ＝ 字数到位置 (参_起始位置)
.计次循环首 (参_转换字母数, )
    .如果真 (局_偏移 ＞ 局_缓冲区长度)
        跳出循环 ()
    .如果真结束
    .如果 (集_缓冲区 [局_偏移] ＞ 128)
        局_偏移 ＝ 局_偏移 ＋ 2
    .否则
        .如果真 (集_缓冲区 [局_偏移] ＞ 96 且 集_缓冲区 [局_偏移] ＜ 123)
            集_缓冲区 [局_偏移] ＝ 位与 (集_缓冲区 [局_偏移], 95)
        .如果真结束
        局_偏移 ＝ 局_偏移 ＋ 1
    .如果结束
.计次循环尾 ()
返回 (写出字节集 (_文件句柄, 集_缓冲区))
.子程序 字数到位置, 整数型
.参数 参_字数, 整数型
.局部变量 局_偏移, 整数型
.局部变量 局_缓冲区长度, 整数型
局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
局_偏移 ＝ 1
.计次循环首 (参_字数 － 1, )
    .如果真 (局_偏移 ＞ 局_缓冲区长度)
        跳出循环 ()
    .如果真结束
    .如果 (集_缓冲区 [局_偏移] ＞ 128)
        局_偏移 ＝ 局_偏移 ＋ 2
    .否则
        局_偏移 ＝ 局_偏移 ＋ 1
    .如果结束
.计次循环尾 ()
返回 (局_偏移)
.程序集 集_取硬盘特征字
.子程序 系统_取硬盘特征字, 整数型, 公开, 获取系统硬盘特征字
.参数 iDrive, 整数型, 可空
.参数 硬盘序列号, 文本型, 参考 可空
.参数 硬盘模型号, 文本型, 参考 可空
.局部变量 sFilePath, 文本型
.局部变量 hDevice, 整数型
.局部变量 InBufferIDE, 取硬盘特征号0
.局部变量 OutBufferIDE, 取硬盘特征号1
.局部变量 InBufferSCSI, 取硬盘特征号2
.局部变量 OutBuffer, 字节集
.局部变量 BytesRet, 整数型
.局部变量 IDEData, 取硬盘特征号3
.局部变量 硬盘特征码, 整数型
硬盘特征码 ＝ 取硬盘特征字 ()
.如果真 (硬盘特征码 ≠ 0)
    返回 (硬盘特征码)
.如果真结束
.如果 (系统_取操作系统类别 () ≥ 4)
    sFilePath ＝ “\\.\PHYSICALDRIVE” ＋ 整数型_到文本 (iDrive)
    hDevice ＝ CreateFileA (sFilePath, 位或 (2147483648, 1073741824), 位或 (1, 2), 0, 3, 0, 0)
    .判断开始 (hDevice ≠ -1)
        .如果真 (_设备操作0 (hDevice, 475264, 0, 0, OutBufferIDE, 24, BytesRet, 0) ≠ 0)
            OutBuffer ＝ 字节集_取空白 (544)
            InBufferIDE.cBufferSize ＝ 512
            InBufferIDE.bSectorCountReg ＝ 1
            InBufferIDE.bSectorNumberReg ＝ 1
            .如果 (位与 (iDrive, 1) ≠ 0)
                InBufferIDE.bDriveHeadReg ＝ 176
            .否则
                InBufferIDE.bDriveHeadReg ＝ 160
            .如果结束
            .如果 (iDrive ≠ 0)
                InBufferIDE.bCommandReg ＝ OutBufferIDE.bIDEDeviceMap ÷ 位与 (iDrive, 16)
            .否则
                InBufferIDE.bCommandReg ＝ OutBufferIDE.bIDEDeviceMap
            .如果结束
            .如果 (InBufferIDE.bCommandReg ＝ 0)
                InBufferIDE.bCommandReg ＝ 161
            .否则
                InBufferIDE.bCommandReg ＝ 236
            .如果结束
            .如果真 (DeviceIoControl (hDevice, 508040, InBufferIDE, 32, OutBuffer, 544, BytesRet, 0) ＝ 0)
                InBufferIDE.bCommandReg ＝ 236
                DeviceIoControl (hDevice, 508040, InBufferIDE, 32, OutBuffer, 544, BytesRet, 0)
            .如果真结束
            RtlMoveMemory_取硬盘特征号3 (IDEData, 字节集_取指定位置字节集 (OutBuffer, 17, 256), 256)
        .如果真结束
    .默认
        CloseHandle (hDevice)
        sFilePath ＝ “\\.\SCSI” ＋ 整数型_到文本 (iDrive) ＋ “:”
        hDevice ＝ CreateFileA (sFilePath, 位或 (2147483648, 1073741824), 位或 (1, 2), 0, 3, 0, 0)
        .如果真 (hDevice ≠ -1)
            InBufferSCSI.HeaderLength ＝ 28
            RtlMoveMemory (取数据_通用型_数组 (InBufferSCSI.Signature), 取指针_文本型 (“SCSIDISK”), 8)
            InBufferSCSI.Timeout ＝ 2
            InBufferSCSI.Length ＝ 544
            InBufferSCSI.ControlCode ＝ 1770753
            InBufferSCSI.cBufferSize ＝ 512
            InBufferSCSI.bSectorCountReg ＝ 1
            InBufferSCSI.bSectorNumberReg ＝ 1
            .如果 (位与 (iDrive, 1) ≠ 0)
                InBufferSCSI.bDriveHeadReg ＝ 176
            .否则
                InBufferSCSI.bDriveHeadReg ＝ 160
            .如果结束
            InBufferSCSI.bCommandReg ＝ 236
            OutBuffer ＝ 字节集_取空白 (572)
            .如果真 (_设备操作2 (hDevice, 315400, InBufferSCSI, 60, OutBuffer, 572, BytesRet, 0) ≠ 0)
                RtlMoveMemory_取硬盘特征号3 (IDEData, 字节集_取指定位置字节集 (OutBuffer, 45, 256), 256)
            .如果真结束
        .如果真结束
    .判断结束
.否则
    sFilePath ＝ “\\.\SMARTVSD”
    hDevice ＝ CreateFileA (sFilePath, 0, 0, 0, 1, 0, 0)
    .如果真 (hDevice ≠ -1)
        InBufferIDE.cBufferSize ＝ 512
        InBufferIDE.bSectorCountReg ＝ 1
        InBufferIDE.bSectorNumberReg ＝ 1
        .如果 (位与 (iDrive, 1) ≠ 0)
            InBufferIDE.bDriveHeadReg ＝ 176
        .否则
            InBufferIDE.bDriveHeadReg ＝ 160
        .如果结束
        InBufferIDE.bCommandReg ＝ 236
        OutBuffer ＝ 字节集_取空白 (528)
        .如果真 (DeviceIoControl (hDevice, 508040, InBufferIDE, 32, OutBuffer, 528, BytesRet, 0) ≠ 0)
            RtlMoveMemory_取硬盘特征号3 (IDEData, 字节集_取指定位置字节集 (OutBuffer, 17, 256), 256)
        .如果真结束
    .如果真结束
.如果结束
CloseHandle (hDevice)
.如果真 (是否为空 (硬盘序列号) ＝ 假)
    硬盘序列号 ＝ FixString (IDEData.sSerialNumber)
.如果真结束
.如果真 (是否为空 (硬盘模型号) ＝ 假)
    硬盘模型号 ＝ FixString (IDEData.sModelNumber)
.如果真结束
硬盘特征码 ＝ 特征字计算 (IDEData)
.如果真 (取文本长度 (到文本 (硬盘特征码)) ≤ 2)
    硬盘特征码 ＝ 系统_取硬盘特征字1 ()
.如果真结束
返回 (硬盘特征码)
.子程序 系统_取操作系统类别, 整数型, 公开, 返回当前操作系统的版本类别。返回值为以下值之一：0、未知； 1、Win95； 2、Win98； 3、WinME； 4、WinNT； 5、Win2000； 6、WinXP； 7、Win2003； 8、Vista；9、Win7； 10、Win8； 11、Win8.1； 12、Win10
置入代码 ({ 83, 49, 192, 100, 139, 29, 24, 0, 0, 0, 100, 139, 13, 48, 0, 0, 0, 133, 201, 121, 32, 185, 0, 0, 83, 0, 57, 75, 88, 117, 4, 176, 1, 235, 113, 57, 75, 84, 117, 4, 176, 2, 235, 104, 57, 75, 124, 117, 99, 176, 3, 235, 95, 139, 153, 168, 0, 0, 0, 139, 137, 164, 0, 0, 0, 131, 249, 4, 119, 4, 176, 4, 235, 74, 131, 249, 5, 117, 27, 131, 251, 0, 117, 4, 176, 5, 235, 60, 131, 251, 1, 117, 4, 176, 6, 235, 51, 131, 251, 2, 117, 4, 176, 7, 235, 42, 131, 249, 6, 117, 35, 131, 251, 0, 117, 4, 176, 8, 235, 28, 131, 251, 1, 117, 2, 176, 9, 131, 251, 2, 117, 2, 176, 10, 131, 251, 3, 117, 2, 176, 11, 131, 251, 4, 117, 2, 176, 12, 91, 201, 195 })
返回 (0)
.子程序 系统_取硬盘特征字1, 整数型, 公开, 返回0说明未取到。这个主要是补充易不能在某些系统或是硬盘上取硬盘特征字。
.局部变量 driveName, 文本型
.局部变量 hPhysicalDriveIOCTL, 整数型
.局部变量 query, 字节集
.局部变量 cbBytesReturned, 整数型
.局部变量 buffer, 字节集
.局部变量 buffersize, 整数型
.局部变量 st, 逻辑型
.局部变量 crc1, 整数型
driveName ＝ “\\.\PhysicalDrive0”
hPhysicalDriveIOCTL ＝ CreateFileA (driveName, 0, 位或 (1, 2), 0, 3, 0, 0)
.如果真 (hPhysicalDriveIOCTL ＝ -1)
    返回 (0)
.如果真结束
buffersize ＝ 1024
query ＝ 取空白字节集 (12)
buffer ＝ 取空白字节集 (buffersize)
st ＝ DeviceIoControl1 (hPhysicalDriveIOCTL, 2954240, lstrcpynA_字节集 (query, query, 0), 12, lstrcpynA_字节集 (buffer, buffer, 0), buffersize, cbBytesReturned, 0)
.如果真 (st ＝ 真)
    crc1 ＝ get_crc32 (buffer)
.如果真结束
CloseHandle (hPhysicalDriveIOCTL)
返回 (crc1)
.子程序 get_crc32, 整数型, , 1
.参数 原文, 字节集, , 主要用来取文本的crc32，取文件的crc32要专门写个取文件的
.局部变量 crcval, 整数型
.局部变量 长度, 整数型
.局部变量 i, 整数型
.局部变量 结果, 整数型
.局部变量 位置, 整数型
.局部变量 crc, 整数型
.局部变量 table, 整数型, , "256"
长度 ＝ 取字节集长度 (原文)
.如果真 (长度 ＜ 1)
    返回 (0)
.如果真结束
.变量循环首 (0, 255, 1, i)  ' 用来得到码表
    crc ＝ i
    .变量循环首 (1, 8, 1, )
        .如果 (位与 (crc, 1) ≠ 0)
            crc ＝ 位异或 (位与 (右移 (crc, 1), 2147483647), 3988292384)  ' crc xor EDB88320
        .否则
            crc ＝ 位与 (右移 (crc, 1), 2147483647)
        .如果结束
    .变量循环尾 ()
    table [i ＋ 1] ＝ crc
.变量循环尾 ()
crcval ＝ 4294967295
.计次循环首 (长度, i)
    位置 ＝ 位异或 (原文 [i], 位与 (crcval, 255)) ＋ 1  ' 查表
    crcval ＝ 位异或 (位与 (右移 (crcval, 8), 16777215), table [位置])
.计次循环尾 ()
结果 ＝ 位取反 (crcval)
返回 (结果)
.子程序 FixString, 文本型
.参数 pwDiskData, 字节型, 数组
.局部变量 DiskData, 字节集
.局部变量 i, 整数型
DiskData ＝ 字节集_取空白 (取数组成员数 (pwDiskData))
.变量循环首 (1, 取数组成员数 (pwDiskData), 2, i)
    DiskData [i] ＝ pwDiskData [i ＋ 1]
    DiskData [i ＋ 1] ＝ pwDiskData [i]
.变量循环尾 ()
DiskData ＝ 子字节集替换 (DiskData, { 32 }, , , )
返回 (字节集_到文本 (DiskData))
.子程序 特征字计算, 整数型
.参数 Data, 取硬盘特征号3
.局部变量 Dword, 字节集
.局部变量 i, 整数型
.局部变量 ToData, 整数型
.局部变量 Total, 整数型
.局部变量 返回值, 整数型
Dword ＝ { 0, 0, 0, 0 }
.计次循环首 (40, i)
    .判断开始 (i ％ 2 ＝ 0)
        Dword [2] ＝ Data.sModelNumber [i]
        Total ＝ Total ＋ 字节集_到整数 (Dword)
    .默认
        Dword [1] ＝ Data.sModelNumber [i]
    .判断结束
.计次循环尾 ()
.计次循环首 (8, i)
    .判断开始 (i ％ 2 ＝ 0)
        Dword [2] ＝ Data.sFirmwareRev [i]
        Total ＝ Total ＋ 字节集_到整数 (Dword)
    .默认
        Dword [1] ＝ Data.sFirmwareRev [i]
    .判断结束
.计次循环尾 ()
.计次循环首 (20, i)
    .判断开始 (i ％ 2 ＝ 0)
        Dword [2] ＝ Data.sSerialNumber [i]
        Total ＝ Total ＋ 字节集_到整数 (Dword)
    .默认
        Dword [1] ＝ Data.sSerialNumber [i]
    .判断结束
.计次循环尾 ()
ToData ＝ Data.wBufferSize ＋ Data.wSectorsPerTrack ＋ Data.wNumHeads ＋ Data.wNumCyls
.如果 (ToData × 65536 ＋ Total ≤ 4294967295)
    返回值 ＝ ToData × 65536 ＋ Total
.否则
    返回值 ＝ ((ToData － 1) ％ 65535 ＋ 1) × 65536 ＋ Total ％ 65535
.如果结束
返回 (返回值)
.子程序 字节集_子寻找, 整数型, , 分割字节集时用
.参数 X, 字节集
.参数 Y, 字节集
.参数 Z, 整数型, 数组
.参数 StartOffset, 整数型, 可空
.局部变量 i, 整数型
.局部变量 j, 整数型
.局部变量 Len_Y, 整数型
清除数组 (Z)
i ＝ 1
.如果 (是否为空 (StartOffset))
    j ＝ 1
.否则
    j ＝ StartOffset
.如果结束
Len_Y ＝ 字节集_取长度 (Y)
.判断循环首 (i ≠ -1)
    i ＝ 字节集_寻找 (X, Y, j)
    .如果真 (i ≠ -1)
        加入成员 (Z, i)
        j ＝ i ＋ Len_Y
    .如果真结束
    程序_延时 (1)
.判断循环尾 ()
返回 (取数组成员数 (Z))
.子程序 文本型_取空白, 文本型, , 支持斩月,但速度不是最快,不过简单,哈～～
.参数 零字节数目, 整数型
.局部变量 Address, 整数型
.局部变量 返回值, 文本型
.如果真 (零字节数目 ＜ 1)
    返回 (“”)
.如果真结束
Address ＝ LocalAlloc (64, 零字节数目 ＋ 1)
.如果真 (Address ＝ 0)
    返回 (“”)
.如果真结束
RtlFillMemory_字节 (Address, 零字节数目, 32)
返回值 ＝ 指针到文本 (Address)
LocalFree (Address)
返回 (返回值)
.程序集 集_剪辑板
.子程序 剪辑板_置文本, , 公开, 设置指定文本到系统剪辑板
.参数 要置的文本, 文本型
.局部变量 dwLength, 整数型
.局部变量 hGlobalMemory, 整数型
.局部变量 GHND, 整数型
.局部变量 lpGlobalMemory, 整数型
.局部变量 hWnd, 整数型
.局部变量 i, 整数型
dwLength ＝ 取文本长度 (要置的文本)
GHND ＝ 2
hGlobalMemory ＝ GlobalAlloc (GHND, dwLength ＋ 1)
lpGlobalMemory ＝ GlobalLock (hGlobalMemory)
RtlMoveMemory_文本型 (lpGlobalMemory, 要置的文本, dwLength)
GlobalUnlock (hGlobalMemory)
hWnd ＝ 窗口_取顶端窗口句柄 ()
OpenClipboard (hWnd)
EmptyClipboard ()
SetClipboardData (1, hGlobalMemory)  ' #CF_TEXT=1
CloseClipboard ()
.子程序 剪辑板_置字节集, , 公开, 设置指定宽字符到系统剪辑板
.参数 欲置剪辑版的数据, 字节集, , Unicode文本格式
.局部变量 dwLength, 整数型
.局部变量 hGlobalMemory, 整数型
.局部变量 GHND, 整数型
.局部变量 lpGlobalMemory, 整数型
.局部变量 hWnd, 整数型
.局部变量 i, 整数型
dwLength ＝ 取字节集长度 (欲置剪辑版的数据)
GHND ＝ 2
hGlobalMemory ＝ GlobalAlloc (GHND, dwLength ＋ 1)
lpGlobalMemory ＝ GlobalLock (hGlobalMemory)
RtlMoveMemory_字节集 (lpGlobalMemory, 欲置剪辑版的数据, dwLength)
GlobalUnlock (hGlobalMemory)
OpenClipboard (0)
EmptyClipboard ()
SetClipboardData (#CF_UNICODETEXT, hGlobalMemory)
CloseClipboard ()
.子程序 剪辑板_取文本, 文本型, 公开, 取出系统剪辑板中存放的文本
.局部变量 hwnd, 整数型
.局部变量 lpData, 整数型
.局部变量 nSize, 整数型
.局部变量 hMem, 整数型
.局部变量 s, 字节集
.局部变量 返回值, 文本型
OpenClipboard (0)
.如果真 (IsClipboardFormatAvailable (#CF_UNICODETEXT) ≠ 0)
    hMem ＝ GetClipboardData (#CF_UNICODETEXT)
    lpData ＝ GlobalLock (hMem)
    nSize ＝ GlobalSize (hMem)
    s ＝ 取空白字节集 (nSize)
    RtlMoveMemory (取指针_字节集型 (s), lpData, nSize)
    GlobalUnlock (hMem)
    返回值 ＝ 编码_Unicode到Ansi (s)  ' 系统底层是unicode和ansi编码
.如果真结束
CloseClipboard ()
返回 (返回值)
.子程序 剪辑板_取文本W, 字节集, 公开, 取出系统剪辑板中存放的Unicode编码的文本
.局部变量 hwnd, 整数型
.局部变量 lpData, 整数型
.局部变量 nSize, 整数型
.局部变量 hMem, 整数型
.局部变量 返回值, 字节集
OpenClipboard (0)
.如果真 (IsClipboardFormatAvailable (#CF_UNICODETEXT) ≠ 0)
    hMem ＝ GetClipboardData (#CF_UNICODETEXT)
    lpData ＝ GlobalLock (hMem)
    nSize ＝ GlobalSize (hMem)
    返回值 ＝ 取空白字节集 (nSize)
    RtlMoveMemory (取指针_字节集型 (返回值), lpData, nSize)
    GlobalUnlock (hMem)
    ' 系统底层是unicode和ansi编码
.如果真结束
CloseClipboard ()
返回 (返回值)
.子程序 剪辑板_置图片, , 公开, 设置指定图片到系统剪辑板
.参数 图片数据, 字节集, , 要置入剪辑板的图片数据
.局部变量 图片, 对象
.局部变量 图片句柄, 整数型
CoInitialize (0)
图片.创建图片对象 (图片数据)
图片句柄 ＝ 图片.读数值属性 (“Handle”, )
CoUninitialize ()
OpenClipboard (窗口_取焦点句柄 ())
EmptyClipboard ()
SetClipboardData (2, 图片句柄)
CloseClipboard ()
.子程序 剪辑板_取图片, 字节集, 公开, 获取系统剪辑板中的图片
.参数 窗口句柄, 整数型
.局部变量 剪辑板数据句柄, 整数型
.局部变量 全局内存块大小, 整数型
.局部变量 全局内存块, 整数型
.局部变量 大小, 整数型
.局部变量 图片, 字节集
.局部变量 文件头, 字节集
OpenClipboard (窗口句柄)
剪辑板数据句柄 ＝ GetClipboardData (8)
.如果真 (剪辑板数据句柄 ≠ 0)
    全局内存块大小 ＝ GlobalSize (剪辑板数据句柄)
    全局内存块 ＝ GlobalLock (剪辑板数据句柄)
    .如果真 (全局内存块大小 ≠ 0 且 全局内存块 ≠ 0)
        图片 ＝ 指针到字节集 (全局内存块, 全局内存块大小)
    .如果真结束
.如果真结束
CloseClipboard ()
.如果真 (取字节集长度 (图片) ＝ 0)
    返回 ({  })
.如果真结束
文件头 ＝ 到字节集 (“BM”) ＋ 整数_到字节集 (取字节集长度 (图片) ＋ 2) ＋ 取空白字节集 (4) ＋ 整数_到字节集 (54) ＋ 取字节集左边 (图片, 16) ＋ 取空白字节集 (4) ＋ 整数_到字节集 (取字节集长度 (图片) － 52) ＋ 取空白字节集 (16)
返回 (文件头 ＋ 取字节集右边 (图片, 取字节集长度 (图片) － 52))
.子程序 剪辑板_取位图数据A, 字节集, 公开, 获取系统剪辑板中的图片，支持QQ截图
.参数 窗口句柄, 整数型, , 当前程序的窗口句柄
.局部变量 图片句柄, 整数型
.局部变量 信息, BITMAPINFOHEADER
.局部变量 文件, BITMAPFILEHEADER
.局部变量 hMem, 整数型
.局部变量 lpData, 整数型
.局部变量 hBitmap, 整数型
.局部变量 指针, 整数型
.局部变量 位图, 字节集
.局部变量 bmp, 位图结构_
.局部变量 hdc, 整数型
.局部变量 私画布句柄, 整数型
OpenClipboard (窗口句柄)
图片句柄 ＝ GetClipboardData (2)
CloseClipboard ()
.如果真 (图片句柄 ＝ 0)
    返回 ({  })
.如果真结束
.如果真 (取对象属性_ (图片句柄, 28, bmp) ＝ 0)
    返回 ({  })
.如果真结束
信息.biSize ＝ 40
信息.biWidth ＝ bmp.位图宽度
信息.biHeight ＝ bmp.位图高度
信息.biPlanes ＝ 1
信息.biBitCount ＝ 24
信息.biCompression ＝ 0
信息.biSizeImage ＝ (bmp.位图宽度 × 24 ＋ 31) ÷ 8 × bmp.位图高度
信息.biXPelsPerMeter ＝ 0
信息.biYPelsPerMeter ＝ 0
信息.biClrUsed ＝ 0
信息.biClrImportant ＝ 0
hdc ＝ GetDC (0)
私画布句柄 ＝ CreateCompatibleDC (hdc)
hMem ＝ GlobalAlloc (位或 (0, 64), 信息.biSizeImage)
lpData ＝ GlobalLock (hMem)
GetDIBits_x (私画布句柄, 图片句柄, 0, 信息.biHeight, lpData, 信息, 0)
文件.bfType ＝ 19778
文件.bfReserved1 ＝ 0
文件.bfReserved2 ＝ 0
文件.bfSize ＝ 14 ＋ 40 ＋ 信息.biSizeImage
文件.bfOffBits ＝ 14 ＋ 40
指针 ＝ VirtualAlloc (0, 54 ＋ 信息.biSizeImage, 4096, 4)
RtlMoveMemory_BITMAPFILEHEADER_整数1 (指针, 文件, 14)
RtlMoveMemory_BITMAPINFOHEADER_整数 (指针 ＋ 14, 信息, 40)
RtlMoveMemory (指针 ＋ 54, lpData, 信息.biSizeImage)
位图 ＝ 指针到字节集 (指针, 54 ＋ 信息.biSizeImage)
VirtualFree (指针, 0, 32768)
GlobalFree (hMem)
DeleteDC (私画布句柄)
返回 (位图)
.子程序 剪辑板_取位图数据B, 字节集, 公开, 获取系统剪辑板中的图片，支持QQ截图
.参数 窗口句柄, 整数型, , 当前程序的窗口句柄
.局部变量 图片句柄, 整数型
.局部变量 信息, BITMAPINFOHEADER
.局部变量 lpData, 整数型
.局部变量 指针, 整数型
.局部变量 位图, 字节集
.局部变量 bmp, 位图结构_
.局部变量 私画布句柄, 整数型
.局部变量 文件头, 字节集
OpenClipboard (窗口句柄)
图片句柄 ＝ GetClipboardData (2)
CloseClipboard ()
.如果真 (图片句柄 ＝ 0)
    返回 ({  })
.如果真结束
.如果真 (取对象属性_ (图片句柄, 28, bmp) ＝ 0)
    返回 ({  })
.如果真结束
信息.biSize ＝ 40
信息.biWidth ＝ bmp.位图宽度
信息.biHeight ＝ bmp.位图高度
信息.biPlanes ＝ 1
信息.biBitCount ＝ 24
信息.biCompression ＝ 0
信息.biSizeImage ＝ (bmp.位图宽度 × 24 ＋ 31) ÷ 8 × bmp.位图高度
信息.biXPelsPerMeter ＝ 0
信息.biYPelsPerMeter ＝ 0
信息.biClrUsed ＝ 0
信息.biClrImportant ＝ 0
私画布句柄 ＝ CreateCompatibleDC (0)
位图 ＝ 取空白字节集 (信息.biSizeImage)
lpData ＝ lstrcpyn_字节集 (位图, 位图, 0)
GetDIBits_x (私画布句柄, 图片句柄, 0, 信息.biHeight, lpData, 信息, 0)
文件头 ＝ 到字节集 (“BM”) ＋ 整数_到字节集 (信息.biSizeImage ＋ 54) ＋ 取空白字节集 (4) ＋ { 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 整数_到字节集 (bmp.位图宽度) ＋ 整数_到字节集 (bmp.位图高度) ＋ { 1, 0, 24, 0 } ＋ 取空白字节集 (4) ＋ 整数_到字节集 (信息.biSizeImage) ＋ 取空白字节集 (16)
位图 ＝ 文件头 ＋ 指针到字节集 (lpData, 信息.biSizeImage)
DeleteDC (私画布句柄)
返回 (位图)
.子程序 剪辑板_置文件, 逻辑型, 公开, 将指定文件复制到剪贴板，成功返回真，失败返回假。
.参数 文件数组, 文本型, 数组, 欲复制到剪贴板的文件数组路径;
.参数 状态, 逻辑型, 可空, 默认为假。真=对文件执行了剪切操作；假=对文件执行了复制操作
.局部变量 sTmp, 字节集
.局部变量 dfs, 剪贴板_置文件
.局部变量 hGlobal, 整数型
.局部变量 i, 整数型
.局部变量 ret, 整数型
.局部变量 lngFormat, 整数型
.局部变量 lpGlobal, 整数型
.如果真 (OpenClipboard (0) ＝ 0)
    返回 (假)
.如果真结束
EmptyClipboard ()
.计次循环首 (取数组成员数 (文件数组), i)
    sTmp ＝ sTmp ＋ 到字节集 (文件数组 [i]) ＋ { 0 }
.计次循环尾 ()
sTmp ＝ sTmp ＋ { 0 }
hGlobal ＝ GlobalAlloc (66, 20 ＋ 字节集_取长度 (sTmp))
.如果真 (hGlobal ＝ 0)
    CloseClipboard ()
    返回 (假)
.如果真结束
lpGlobal ＝ GlobalLock (hGlobal)
dfs.pFiles ＝ 20
RtlMoveMemory_剪贴板_置文件 (lpGlobal, dfs, 20)
RtlMoveMemory_字节集 (lpGlobal ＋ 20, sTmp, 字节集_取长度 (sTmp))
GlobalUnlock (hGlobal)
ret ＝ SetClipboardData (#CF_HDROP, hGlobal)
GlobalFree (hGlobal)
.如果真 (状态 且 ret ＞ 0)
    lngFormat ＝ RegisterClipboardFormatA (“Preferred DropEffect”)
    hGlobal ＝ GlobalAlloc (66, 4)
    RtlMoveMemory (GlobalLock (hGlobal), 2, 4)
    GlobalUnlock (hGlobal)
    SetClipboardData (lngFormat, hGlobal)
    GlobalFree (hGlobal)
.如果真结束
CloseClipboard ()
返回 (ret ＞ 0)
.子程序 剪辑板_取文件, 整数型, 公开, 取已经复制到剪贴板的文件名，返回文件个数。
.参数 文件数组, 文本型, 可空 数组, 用于存放文件路径的数组,留空则只返回文件数量。
.参数 状态, 逻辑型, 参考 可空, 返回=真,对文件执行了剪切操作；返回=假,对文件执行了复制操作
.局部变量 hDrop, 整数型
.局部变量 sTmp, 文本型
.局部变量 null, 文本型
.局部变量 lngFormat, 整数型
.局部变量 lngEffect, 整数型
.局部变量 lcount, 整数型
.局部变量 i, 整数型
清除数组 (文件数组)
.如果真 (IsClipboardFormatAvailable (#CF_HDROP) ＝ 0 或 OpenClipboard (0) ＝ 0)
    返回 (0)
.如果真结束
hDrop ＝ GetClipboardData (#CF_HDROP)
lcount ＝ DragQueryFileA (hDrop, -1, null, 0)
sTmp ＝ 取空白文本 (260)
.计次循环首 (lcount, i)
    DragQueryFileA (hDrop, i － 1, sTmp, 260)
    加入成员 (文件数组, sTmp)
.计次循环尾 ()
.如果真 (是否为空 (状态) ＝ 假)
    lngFormat ＝ RegisterClipboardFormatA (“Preferred DropEffect”)
    hDrop ＝ GetClipboardData (lngFormat)
    RtlMoveMemory_整数传址1 (lngEffect, hDrop, 4)
    状态 ＝ lngEffect ＝ 2
    GlobalFree (hDrop)
.如果真结束
CloseClipboard ()
返回 (lcount)
.子程序 剪辑板_取数据权窗口句柄, 整数型, 公开, 返回复制该数据的窗口句柄；如：一段文字是在记事本复制的，则返回记事本的窗口句柄
返回 (GetClipboardOwner ())
.子程序 整数_到字节集, 字节集
.参数 整数, 整数型
.局部变量 字节集, 字节集
字节集 ＝ 取空白字节集 (4)
写到内存 (整数, lstrcpyn_字节集 (字节集, 字节集, 0), 4)
返回 (字节集)
.子程序 剪辑板_取所有内容, 逻辑型, 公开
.参数 参_剪辑版数据, 剪辑版数据, 参考 数组
.局部变量 数据格式, 整数型
.局部变量 剪辑版数据, 剪辑版数据
.局部变量 缓冲区, 文本型
.局部变量 数据句柄, 整数型
.局部变量 内存指针, 整数型
' 源码采纳地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14221328
.如果真 (OpenClipboard (0) ＝ 0)  ' 打开剪辑版
    返回 (假)
.如果真结束
清除数组 (参_剪辑版数据)  ' 清除数据
.判断循环首 (真)
    数据格式 ＝ EnumClipboardFormats (数据格式)  ' 取出剪切板内容的数据格式
    .如果真 (数据格式 ＝ 0)  ' 没有格式……
        跳出循环 ()
    .如果真结束
    剪辑版数据.剪辑版数据格式 ＝ 数据格式
    缓冲区 ＝ 取空白文本 (255)  ' 生成缓冲区
    .判断开始 (数据格式 ≤ 14)
        剪辑版数据.文本型数据 ＝ “”
    .判断 (GetClipboardFormatNameA (数据格式, 缓冲区, 255) ＝ 0)  ' 获取剪贴板内数据格式的名称，判断是否有文本
        剪辑版数据.文本型数据 ＝ “”  ' 没有文本……
    .默认
        剪辑版数据.文本型数据 ＝ 缓冲区
    .判断结束
    数据句柄 ＝ GetClipboardData (数据格式)  ' 取剪辑板数据句柄
    .如果真 (数据句柄 ＝ 0)  ' 没有数据……
        到循环尾 ()  ' 开启下一个循环
    .如果真结束
    剪辑版数据.字节集长度 ＝ GlobalSize (数据句柄)  ' 返回全局内存块大小，就是取出字节集长度
    内存指针 ＝ GlobalLock (数据句柄)  ' 锁定内存对象并返回剪辑板数据指针
    剪辑版数据.字节集数据 ＝ 取空白字节集 (剪辑版数据.字节集长度)  ' 生成缓冲区
    RtlMoveMemory (取数据_通用型 (剪辑版数据.字节集数据) ＋ 8, 内存指针, 剪辑版数据.字节集长度)  ' 复制出来
    加入成员 (参_剪辑版数据, 剪辑版数据)  ' OK，收工
    .如果真 (取数组成员数 (参_剪辑版数据) ＞ 100)  ' 这么多……，估计是复制文件，但是再多估计进程会废了（内存严重怀疑溢出）
        跳出循环 ()
    .如果真结束
.判断循环尾 ()
CloseClipboard ()  ' 关闭剪辑版
返回 (真)
.子程序 剪辑板_置内容, 逻辑型, 公开
.参数 参_剪辑版数据, 剪辑版数据, 参考 数组
.局部变量 局_计次, 整数型
.局部变量 剪辑版数据格式, 整数型
.局部变量 剪辑版格式, 整数型
.局部变量 内存地址, 整数型
.局部变量 内存指针, 整数型
.如果真 (OpenClipboard (0) ＝ 0)  ' 打开剪辑版
    返回 (假)
.如果真结束
EmptyClipboard ()  ' 清空剪切板并释放剪切板内数据的句柄，但是数据仿佛没有什么用了，2333
.计次循环首 (取数组成员数 (参_剪辑版数据), 局_计次)  ' 开始计次……
    剪辑版数据格式 ＝ 参_剪辑版数据 [局_计次].剪辑版数据格式
    .如果真 (参_剪辑版数据 [局_计次].文本型数据 ≠ “”)
        剪辑版格式 ＝ RegisterClipboardFormatA (参_剪辑版数据 [局_计次].文本型数据)  ' 它注册一个新的剪贴板格式，此后这个格式可作为有效的剪贴板格式。
        .如果真 (剪辑版格式 ＞ 0)  ' 注册成功！
            剪辑版数据格式 ＝ 剪辑版格式
        .如果真结束
    .如果真结束
    内存地址 ＝ GlobalAlloc (位或 (#CF_BITMAP, #CF_LIMITSIZE), 参_剪辑版数据 [局_计次].字节集长度)  ' 在剪辑版中分配内存
    内存指针 ＝ GlobalLock (内存地址)  ' 锁定内存对象并返回剪辑版指针
    RtlMoveMemory (内存指针, 取数据_通用型 (参_剪辑版数据 [局_计次].字节集数据) ＋ 8, 参_剪辑版数据 [局_计次].字节集长度)  ' 倒着写回去
    GlobalUnlock (内存地址)  ' 开锁全局内存块
    SetClipboardData (剪辑版数据格式, 内存地址)  ' 剪辑板置数据，写回去
.计次循环尾 ()
CloseClipboard ()  ' 关闭剪辑版
返回 (真)
.子程序 剪贴板_监听, , 公开, 把指定的窗口句柄加入到剪贴板查看器链中
.参数 窗口句柄, 整数型
.参数 回调函数, 子程序指针, , WndProc(整数型 hwnd, 整数型 uMsg, 整数型 wParam, 整数型 lParam)，返回1拦截。
SetPropA (窗口句柄, “Clipboard_Monitor”, SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&WndProc_Clipboard_Monitor)))
SetPropA (窗口句柄, “Clipboard_Callback”, 到整数 (回调函数))
SetPropA (窗口句柄, “Clipboard_Viewer”, SetClipboardViewer (窗口句柄))
.子程序 WndProc_Clipboard_Monitor, 整数型
.参数 hWnd, 整数型
.参数 uMsg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 this, 整数型
.局部变量 call, 整数型
.局部变量 viewer, 整数型
this ＝ GetPropA (hWnd, “Clipboard_Monitor”)
call ＝ GetPropA (hWnd, “Clipboard_Callback”)
viewer ＝ GetPropA (hWnd, “Clipboard_Viewer”)
.如果真 (uMsg ＝ #WM_DRAWCLIPBOARD 或 uMsg ＝ #WM_CHANGECBCHAIN 或 uMsg ＝ #WM_DESTROY)
    .如果真 (CallWindowProcA (call, hWnd, uMsg, wParam, lParam) ＝ 1)  ' 拦截
        返回 (1)
    .如果真结束
    .如果真 (uMsg ＝ #WM_CHANGECBCHAIN 且 wParam ≠ viewer)
        SendMessageA (viewer, uMsg, wParam, lParam)
    .如果真结束
.如果真结束
返回 (CallWindowProcA (this, hWnd, uMsg, wParam, lParam))
.子程序 剪贴板_停止监听, , 公开, 从剪贴板查看器链中删除指定的窗口句柄
.参数 窗口句柄, 整数型
.局部变量 this, 整数型
this ＝ GetPropA (窗口句柄, “Clipboard_Monitor”)
ChangeClipboardChain (窗口句柄, GetPropA (窗口句柄, “Clipboard_Viewer”))
SetWindowLongA (窗口句柄, #GWL_WNDPROC, this)
RemovePropA (窗口句柄, “Clipboard_Monitor”)
RemovePropA (窗口句柄, “Clipboard_Callback”)
RemovePropA (窗口句柄, “Clipboard_Viewer”)
.程序集 集_对话框
.子程序 对话框_打开文件, 文本型, 公开, 成功打开返回文件路径,失败返回空文本
.参数 窗口句柄, 整数型, , 拥有者窗口句柄,如启动窗口的句柄
.参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录,如果留空将跳转到当前目录
.参数 对话框标题, 文本型, 可空, 对话框的标题，可空:默认为"打开文件"
.参数 过滤器, 文本型, 可空, 可空，默认为“所有文件(*.*)|*.*”  每对中的第一个字符串是描述过滤器的显示字符串（例如，文本文件），第二个字符串指定过滤器模式（例如，*.TXT）。要为单个显示字符串指定多个过滤器模式，请使用分号分隔模式（例如，*.TXT; *.DOC; *.BAK）。模式字符串可以是有效文件名字和星号（*）通配符的组合。模式字符串中不要包含空格。
.参数 修改当前目录, 逻辑型, 可空, 可以为空。默认为假，不改变当前目录。真 = 把初始目录改成当前目录。
.局部变量 局_结构, OPENFILENAME
.局部变量 局_计次, 整数型
.局部变量 局_数组, 文本型, , "0"
.局部变量 局_当前目录, 文本型
局_当前目录 ＝ 取当前目录 ()
.如果真 (是否为空 (对话框标题))
    对话框标题 ＝ “打开文件”
.如果真结束
.如果真 (是否为空 (过滤器))
    过滤器 ＝ “所有文件(*.*)|*.*”
.如果真结束
局_结构.结构大小 ＝ 76
局_结构.窗口句柄 ＝ 窗口句柄
局_结构.实例句柄 ＝ 0
局_数组 ＝ 分割文本 (过滤器, “|”, )
.计次循环首 (取数组成员数 (局_数组), 局_计次)
    .如果 (取数组成员数 (局_数组) ＝ 局_计次)
        局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0, 0 }
    .否则
        局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0 }
    .如果结束
.计次循环尾 ()
局_结构.自定义过滤器 ＝ 字符 (0)
局_结构.自定义过滤器最大长度 ＝ 0
局_结构.过滤器索引 ＝ 1
局_结构.文件名 ＝ { 0 } ＋ 取空白字节集 (512)
局_结构.文件名最大长度 ＝ 512
局_结构.文件标题 ＝ 取空白文本 (512)
局_结构.文件标题最大长度 ＝ 512
局_结构.初始目录 ＝ 选择 (是否为空 (初始目录), 局_当前目录, 初始目录)
局_结构.标题 ＝ 对话框标题
局_结构.标志 ＝ 0
局_结构.文件扩展名 ＝ 0
.如果 (GetOpenFileNameA (局_结构))
    .如果真 (修改当前目录 ＝ 假)
        改变目录 (局_当前目录)
    .如果真结束
    返回 (到文本 (局_结构.文件名))
.否则
    .如果真 (修改当前目录 ＝ 假)
        改变目录 (局_当前目录)
    .如果真结束
    返回 (“”)
.如果结束
.子程序 对话框_另存文件, 文本型, 公开, 成功打开返回文件路径,失败返回空文本
.参数 窗口句柄, 整数型, , 拥有者窗口句柄,如启动窗口的句柄
.参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录,如果留空将跳转到当前目录
.参数 对话框标题, 文本型, 可空, 对话框的标题，可空:默认为"保存文件"
.参数 默认文件名, 文本型, 可空
.参数 过滤器, 文本型, 可空, 可空，每对中的第一个字符串是描述过滤器的显示字符串（例如，文本文件），第二个字符串指定过滤器模式（例如，*.TXT）。要为单个显示字符串指定多个过滤器模式，请使用分号分隔模式（例如，*.TXT; *.DOC; *.BAK）。模式字符串可以是有效文件名字和星号（*）通配符的组合。模式字符串中不要包含空格。
.参数 初始过滤器, 整数型, 可空, 可空，默认为1，指定初始的过滤器，1为第一个过滤器
.参数 修改当前目录, 逻辑型, 可空, 可以为空。默认为假，不改变当前目录。真 = 把初始目录改成当前目录。
.局部变量 过滤器索引, 整数型
.局部变量 局_结构, OPENFILENAME
.局部变量 局_计次, 整数型
.局部变量 局_数组, 文本型, , "0"
.局部变量 局_当前目录, 文本型
局_当前目录 ＝ 取当前目录 ()
.如果真 (是否为空 (对话框标题))
    对话框标题 ＝ “保存文件”
.如果真结束
.如果真 (是否为空 (过滤器))
    过滤器 ＝ “TXT文档(*.txt)|*.txt|所有文件(*.*)|*.*”
.如果真结束
.如果真 (初始过滤器 ＝ 0)
    初始过滤器 ＝ 1
.如果真结束
.如果真 (是否为空 (默认文件名))
    默认文件名 ＝ 到文本 ({ 0 })
.如果真结束
局_结构.结构大小 ＝ 76
局_结构.窗口句柄 ＝ 窗口句柄
局_结构.实例句柄 ＝ 0
局_数组 ＝ 分割文本 (过滤器, “|”, )
.计次循环首 (取数组成员数 (局_数组), 局_计次)
    .如果 (取数组成员数 (局_数组) ＝ 局_计次)
        局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0, 0 }
    .否则
        局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0 }
    .如果结束
.计次循环尾 ()
局_结构.自定义过滤器 ＝ 字符 (0)
局_结构.自定义过滤器最大长度 ＝ 0
局_结构.过滤器索引 ＝ 初始过滤器
' 局_结构.文件名 ＝ { 0 } ＋ 取空白字节集 (512)
' 局_结构.文件名最大长度 ＝ 512
局_结构.文件名 ＝ 到字节集 (默认文件名) ＋ 取空白字节集 (512 － 取字节集长度 (到字节集 (默认文件名)))
局_结构.文件名最大长度 ＝ 512 － 取字节集长度 (到字节集 (默认文件名))
局_结构.文件标题 ＝ 取空白文本 (512)
局_结构.文件标题最大长度 ＝ 512
局_结构.初始目录 ＝ 选择 (是否为空 (初始目录), 局_当前目录, 初始目录)
局_结构.标题 ＝ 对话框标题
局_结构.标志 ＝ 0
局_结构.文件扩展名 ＝ 0
局_结构.默认扩展名 ＝ “”
.如果 (GetSaveFileNameA (局_结构))
    .如果真 (修改当前目录 ＝ 假)
        改变目录 (局_当前目录)
    .如果真结束
    返回 (到文本 (局_结构.文件名))
.否则
    .如果真 (修改当前目录 ＝ 假)
        改变目录 (局_当前目录)
    .如果真结束
    返回 (“”)
.如果结束
.子程序 对话框_打开颜色选择框, 整数型, 公开, 打开颜色选择框,成功返回指定的颜色值,取消或失败返回-1
.参数 窗口句柄, 整数型, , 拥有者窗口句柄
.局部变量 颜色对话框, 精易_颜色对话框
.局部变量 局_成功, 整数型
颜色对话框.窗口句柄 ＝ 窗口句柄
颜色对话框.颜色数长度 ＝ 取空白文本 (15)
颜色对话框.长度 ＝ 36
局_成功 ＝ ChooseColorA (颜色对话框)
.如果真 (局_成功 ＝ 1)
    返回 (颜色对话框.rgbResult)
.如果真结束
返回 (-1)
.子程序 对话框_打开文件多选框, 文本型, 公开, 打开多选文件对话框,可单个一个文件,将直接返回文件路径,如果选择多个文件,将以换行符分隔
.参数 窗口句柄, 整数型, 可空, 拥有者窗口句柄
.参数 窗口标题, 文本型, 可空, 对话框窗口标题
.参数 过滤器, 文本型, 可空, 可为空,默认即所有文件,过滤器文本由单个或多个成对的文本串组成，每对文本串的第一个描述显示形式，如：“文本文件（*.txt）”；第二个指定实际的过滤匹配符，如：“*.txt”，所有各文本串之间用“|”号隔开
.参数 初始目录, 文本型, 可空, 可以为空。如果留空将跳转到当前目录
.参数 修改当前目录, 逻辑型, 可空, 可以为空。默认为假，不改变当前目录。真 = 把初始目录改成当前目录。
.局部变量 文件列表, OPENFILENAME
.局部变量 文件名, 字节集
.局部变量 文件名数组, 文本型, , "0"
.局部变量 局_计次, 整数型, , , 记录循环的次数
.局部变量 多选文件, 文本型
.局部变量 文件缓冲数, 整数型, , , 决定可以打开文件的个数，原为8192，可打开80个文件
.局部变量 局_当前目录, 文本型
局_当前目录 ＝ 取当前目录 ()
文件缓冲数 ＝ 98192  ' 大小决定打开文件的数量，此可以打开200个文件
文件列表.结构大小 ＝ 76  ' 文件列表.lStructSize ＝ 76
文件列表.窗口句柄 ＝ 窗口句柄
文件列表.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0 } ＋ { 0 }
文件列表.文件名 ＝ 取空白字节集 (文件缓冲数)
文件列表.文件名最大长度 ＝ 文件缓冲数
文件列表.文件标题 ＝ 取空白文本 (文件缓冲数)
文件列表.文件标题最大长度 ＝ 文件缓冲数
文件列表.初始目录 ＝ 选择 (是否为空 (初始目录), 局_当前目录, 初始目录)
文件列表.标题 ＝ 窗口标题
文件列表.标志 ＝ 524800
.如果 (GetOpenFileNameA (文件列表))  ' 打开文件成功
    文件名 ＝ 文件列表.文件名  ' 文件名 ＝ 文件列表.lpstrFile
    文件名 ＝ 取字节集左边 (文件名, 寻找字节集 (文件名, { 0, 0 }, ) － 1)
    .如果 (寻找字节集 (文件名, { 0 }, ) ≠ -1)  ' 是否选择多个文件
        文件名数组 ＝ 分割文本 (到文本 (子字节集替换 (文件名, { 0 }, { 124 }, , )), “|”, )
        .如果真 (取文本右边 (文件名数组 [1], 1) ≠ “\”)  ' 选择多个文件时，第一个数组为路径名，后面为不包括路径的文件名
            文件名数组 [1] ＝ 文件名数组 [1] ＋ “\”
        .如果真结束
        .计次循环首 (取数组成员数 (文件名数组) － 1, 局_计次)
            .如果 (取数组成员数 (文件名数组) － 1 ≠ 局_计次)  ' 最后一个文件名不用加分隔字符“；”
                多选文件 ＝ 多选文件 ＋ 文件名数组 [1] ＋ 文件名数组 [局_计次 ＋ 1] ＋ #换行符
            .否则
                多选文件 ＝ 多选文件 ＋ 文件名数组 [1] ＋ 文件名数组 [局_计次 ＋ 1]
            .如果结束
        .计次循环尾 ()
        .如果真 (修改当前目录 ＝ 假)
            改变目录 (局_当前目录)
        .如果真结束
        返回 (多选文件)
    .否则
        .如果真 (修改当前目录 ＝ 假)
            改变目录 (局_当前目录)
        .如果真结束
        返回 (到文本 (文件名))
    .如果结束
.否则
    返回 (“”)
.如果结束
.子程序 对话框_整理收藏夹, , 公开
.参数 窗口句柄, 整数型, , 直接用 取窗口句柄() 命令即可
DoOrganizeFavDlg (窗口句柄, 目录_取特定目录 (2))
.子程序 对话框_添加到收藏夹, , 公开
.参数 窗口句柄, 整数型, , 直接用 取窗口句柄() 命令即可
.参数 网页标题, 文本型
.参数 网页地址, 文本型
.局部变量 局_pid, 整数型
.局部变量 局_写入路径, 文本型
局_写入路径 ＝ 目录_取特定目录 (2)
.如果真 (网页标题 ＝ “” 或 网页地址 ＝ “about:blank”)
    返回 ()
.如果真结束
SHGetSpecialFolderLocation (窗口句柄, 6, 局_pid)
.如果真 (DoAddToFavDlg (窗口句柄, 局_写入路径, 256, 网页标题, 256, 局_pid))
    .如果真 (写配置项 (局_写入路径, “InternetShortcut”, “URL”, 网页地址))
        提示框 (“已经添加到收藏夹”, #信息图标, , 窗口句柄)
    .如果真结束
.如果真结束
CoTaskMemFree (局_pid)
.程序集 集_菜单类
.子程序 菜单_点击, , 公开, 后台点击指定窗口上的指定菜单；
.参数 窗口句柄, 整数型, , 要点击菜单的窗口句柄；
.参数 菜单句柄, 整数型, , 要点击的菜单句柄；
.参数 菜单索引, 整数型, , 菜单索引从0开始；
投递消息整数 (窗口句柄, 273, 菜单_取ID (菜单句柄, 菜单索引), 0)
.子程序 菜单_取ID, 整数型, 公开
.参数 菜单句柄, 整数型
.参数 菜单索引, 整数型
返回 (GetMenuItemID (菜单句柄, 菜单索引))
.子程序 菜单_清除, 逻辑型, 公开, 成功返回真，失败返回假；
.参数 菜单句柄, 整数型
返回 (DestroyMenu (菜单句柄))
.子程序 菜单_重画, 逻辑型, 公开, 为指定的窗口重画菜单,成功返回真，失败返回假；
.参数 窗口句柄, 整数型, , 窗口句柄
返回 (DrawMenuBar (窗口句柄))
.子程序 菜单_删除, 逻辑型, 公开, 成功返回真，失败返回假；
.参数 菜单句柄, 整数型, , 同级的菜单句柄；
.参数 菜单索引, 整数型, , 索引从0开始；
返回 (RemoveMenu (菜单句柄, 菜单索引, 1024))
.子程序 菜单_取数量, 整数型, 公开, 成功返回菜单数量，失败返回0；
.参数 菜单句柄, 整数型, , 要取数量的菜单句柄；
返回 (GetMenuItemCount (菜单句柄))
.子程序 菜单_取句柄, 整数型, 公开, 成功返回菜单句柄，失败返回0；
.参数 窗口句柄, 整数型, , 要取菜单的窗口句柄；
返回 (GetMenu (窗口句柄))
.子程序 菜单_取标题, 文本型, 公开, 成功返回菜单标题；失败返回空文本；
.参数 菜单句柄, 整数型, , 菜单句柄
.参数 菜单索引, 整数型, , 索引从0开始；
.局部变量 文本, 文本型
.局部变量 返回, 整数型
.局部变量 菜单ID, 整数型
文本 ＝ 取空白文本 (255)
菜单ID ＝ GetMenuItemID (菜单句柄, 菜单索引)
GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 0)
.如果真 (文本 ＝ “”)
    GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 3)
.如果真结束
.如果真 (文本 ＝ “”)
    GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 8)
.如果真结束
.如果真 (文本 ＝ “”)
    GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 1024)
.如果真结束
.如果真 (文本 ＝ “”)
    GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 2048)
.如果真结束
.如果真 (文本 ＝ “” 且 菜单ID ≠ -1)
    文本 ＝ “分隔符”
.如果真结束
返回 (文本)
.子程序 菜单_枚举, 整数型, 公开, 成功返回菜单的数量和标题数组；失败返回0；
.参数 窗口句柄, 整数型, , 要枚举菜单标题的窗口句柄；
.参数 菜单标题数组, 文本型, 参考 可空 数组, 用于存放菜单标题的文本数组；
.参数 菜单ID数组, 整数型, 参考 可空 数组, 用于存放菜单ID的整数数组；
.局部变量 一级菜单, 整数型
.局部变量 二级菜单, 整数型
.局部变量 三级菜单, 整数型
.局部变量 局_一级计次, 整数型
.局部变量 局_二级计次, 整数型
.局部变量 局_三级计次, 整数型
.局部变量 局_一级数量, 整数型
.局部变量 局_二级数量, 整数型
.局部变量 局_三级数量, 整数型
.局部变量 局_菜单索引, 整数型
一级菜单 ＝ 菜单_取句柄 (窗口句柄)
局_菜单索引 ＝ 19999
.如果真 (一级菜单 ＞ 0)
    局_一级数量 ＝ 菜单_取数量 (一级菜单)
    .计次循环首 (局_一级数量, 局_一级计次)
        加入成员 (菜单标题数组, 菜单_取标题 (一级菜单, 局_一级计次 － 1))
        局_菜单索引 ＝ 局_菜单索引 ＋ 1
        加入成员 (菜单ID数组, 局_菜单索引)
        二级菜单 ＝ 菜单_取子句柄 (一级菜单, 局_一级计次 － 1)
        局_二级数量 ＝ 菜单_取数量 (二级菜单)
        .如果真 (局_二级数量 ＞ 0)
            .计次循环首 (局_二级数量, 局_二级计次)
                加入成员 (菜单标题数组, 菜单_取标题 (二级菜单, 局_二级计次 － 1))
                局_菜单索引 ＝ 局_菜单索引 ＋ 1
                加入成员 (菜单ID数组, 局_菜单索引)
                三级菜单 ＝ 菜单_取子句柄 (二级菜单, 局_二级计次 － 1)
                局_三级数量 ＝ 菜单_取数量 (三级菜单)
                .如果真 (局_三级数量 ＞ 0)
                    .计次循环首 (局_三级数量, 局_三级计次)
                        加入成员 (菜单标题数组, 菜单_取标题 (三级菜单, 局_三级计次 － 1))
                        局_菜单索引 ＝ 局_菜单索引 ＋ 1
                        加入成员 (菜单ID数组, 局_菜单索引)
                        处理事件 ()
                    .计次循环尾 ()
                .如果真结束
                处理事件 ()
            .计次循环尾 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
.如果真结束
返回 (取数组成员数 (菜单ID数组))
.子程序 菜单_枚举子级菜单, 整数型, 公开, 枚举子级菜单标题，成功返回子菜单数量，失败返回0；
.参数 窗口句柄, 整数型
.参数 父菜单标题, 文本型
.参数 子菜单标题数组, 文本型, 可空 数组, 用于装载子菜单标题的数组变量；
.局部变量 局_菜单句柄, 整数型
.局部变量 局_子菜单句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_菜单数量, 整数型
局_菜单句柄 ＝ 菜单_取句柄 (窗口句柄)
局_菜单数量 ＝ 菜单_取数量 (局_菜单句柄)
.计次循环首 (局_菜单数量, 局_计次)
    .如果真 (菜单_取标题 (局_菜单句柄, 局_计次 － 1) ＝ 父菜单标题)
        局_子菜单句柄 ＝ 菜单_取子句柄 (局_菜单句柄, 局_计次 － 1)
        跳出循环 ()
    .如果真结束
    处理事件 ()
.计次循环尾 ()
局_菜单数量 ＝ 菜单_取数量 (局_子菜单句柄)
.计次循环首 (局_菜单数量, 局_计次)
    加入成员 (子菜单标题数组, 菜单_取标题 (局_子菜单句柄, 局_计次 － 1))
    处理事件 ()
.计次循环尾 ()
返回 (取数组成员数 (子菜单标题数组))
.子程序 菜单_修改标题, 逻辑型, 公开, 成功返回真，失败返回假；只能改子菜单标题；
.参数 菜单句柄, 整数型, , 要修改标题的菜单句柄；
.参数 菜单新标题, 文本型, , 菜单新标题
.参数 菜单索引, 整数型, , 索引从0开始；
.局部变量 局_菜单ID, 整数型
局_菜单ID ＝ GetMenuItemID (菜单句柄, 菜单索引)
.判断开始 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 局_菜单ID, 菜单新标题))
    返回 (真)
.判断 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 3, 菜单新标题))
    返回 (真)
.判断 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 8, 菜单新标题))
    返回 (真)
.判断 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 1024, 菜单新标题))
    返回 (真)
.默认
    返回 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 2048, 菜单新标题))
.判断结束
返回 (假)
.子程序 菜单_取子句柄, 整数型, 公开, 成功返回子菜单句柄，失败返回0；
.参数 父菜单句柄, 整数型, , 菜单句柄
.参数 父菜单索引, 整数型, , 索引从0开始；
返回 (GetSubMenu (父菜单句柄, 父菜单索引))
.子程序 菜单_添加, 逻辑型, 公开, 成功返回真，失败返回假；
.参数 菜单句柄, 整数型, , 同级的菜单句柄；
.参数 菜单标题, 文本型, 可空, 如果 菜单类型 为4时，此参数留空；
.参数 菜单类型, 整数型, 可空, 0=普通；1=禁止；2=打勾；3=分支菜单；4=菜单分隔条；
.参数 弹出式菜单句柄, 整数型, 参考 可空, 如果  菜单类型 为3时，引参数用来接收弹出式菜单句柄的；
.参数 菜单数值, 整数型, 可空, 用于辩认菜单的数值，跟列表框的数值一样；
.判断开始 (菜单类型 ＝ 0)
    返回 (AppendMenuA (菜单句柄, 0, 菜单数值, 菜单标题))
.判断 (菜单类型 ＝ 1)
    返回 (AppendMenuA (菜单句柄, 3, 菜单数值, 菜单标题))
.判断 (菜单类型 ＝ 2)
    返回 (AppendMenuA (菜单句柄, 8, 菜单数值, 菜单标题))
.判断 (菜单类型 ＝ 3)
    弹出式菜单句柄 ＝ CreatePopupMenu ()
    返回 (AppendMenuA (菜单句柄, 16, 弹出式菜单句柄, 菜单标题))
.默认
    返回 (AppendMenuA (菜单句柄, 2048, 菜单数值, “”))
.判断结束
返回 (假)
.子程序 菜单_点击按标题, , 公开, 如果有的菜单点击不了,请将参数4设置为真试试；
.参数 窗口句柄, 整数型, , 要点击菜单的窗口；
.参数 菜单标题, 文本型, , 要点击的菜单标题；
.参数 模糊点击, 逻辑型, 可空, 可空，默认为假，精确点击；真=模糊点击；
.参数 备用参数, 逻辑型, 可空, 如果有的菜单点击不了请将些参数设置为真试试；
.局部变量 临时文本, 文本型
.局部变量 计次, 整数型
.局部变量 菜单数量, 整数型
.局部变量 菜单标题数组, 文本型, , "0"
.局部变量 菜单ID数组, 整数型, , "0"
菜单数量 ＝ 菜单_枚举 (窗口句柄, 菜单标题数组, 菜单ID数组)
.计次循环首 (菜单数量, 计次)
    临时文本 ＝ 菜单标题数组 [计次]
    .如果 (模糊点击)
        .如果真 (寻找文本 (临时文本, 菜单标题, , 假) ≠ -1)
            .如果 (备用参数)
                投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20000, 0)
            .否则
                投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20001, 0)
            .如果结束
            跳出循环 ()
        .如果真结束
    .否则
        .如果真 (临时文本 ＝ 菜单标题)
            .如果 (备用参数)
                投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20000, 0)
            .否则
                投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20001, 0)
            .如果结束
            跳出循环 ()
        .如果真结束
    .如果结束
    处理事件 ()
.计次循环尾 ()
.子程序 菜单_添加图标, 逻辑型, 公开, 在指定定的菜单处加入图标
.参数 子菜单索引, 整数型, , 子菜单索引
.参数 菜单句柄, 整数型, , 欲添加图标的菜单句柄
.参数 未选图标句柄, 整数型, , 未选中时的图标句柄,可以用 图标_取句柄() 命令取得 图标句柄
.参数 已选图标句柄, 整数型, , 已选中时的图标句柄,可以用 图标_取句柄() 命令取得 图标句柄
返回 (SetMenuItemBitmaps (菜单句柄, 子菜单索引, 1024, 未选图标句柄, 已选图标句柄))
.程序集 集_rar解压缩
.程序集变量 集_rar所在路径, 文本型
.子程序 rar_初始化, 逻辑型, 公开, 使用解压缩前先调用一次该命令初始化获取rar.exe所在路径，成功初始化返回真，失败返回假。
.参数 rar所在路径, 文本型, 可空, 请传入完整路径，如果传入为空，则检测当前目录是否存在rar.exe文件，若不存在，则返回假。该文件可以在此地址下载：http://ec.125.la/source/plugin/plugin1/upload/rar.exe
.参数 rar主程序文件名, 文本型, 可空, 默认文件名为“rar.exe”，如果你想自定义文件名可以传入内容，比如传入“myrar.exe”，同时修改主程序的文件名，否则留空即可。
.局部变量 局_WinRAR目录, 文本型
rar主程序文件名 ＝ 删首尾空 (rar主程序文件名)
.如果真 (是否为空 (rar主程序文件名) 或 rar主程序文件名 ＝ “”)
    rar主程序文件名 ＝ “rar.exe”
.如果真结束
rar所在路径 ＝ 删首尾空 (rar所在路径)
.如果 (是否为空 (rar所在路径) 或 rar所在路径 ＝ “”)  ' 优先判断运行目录
    .如果 (文件是否存在 (取运行目录 () ＋ “\” ＋ rar主程序文件名))
        集_rar所在路径 ＝ 取运行目录 () ＋ “\” ＋ rar主程序文件名
        返回 (真)
    .否则
        局_WinRAR目录 ＝ 程序_取安装目录 (“WinRAR.exe”)  ' 其次判断注册表
        .如果真 (局_WinRAR目录 ≠ “” 且 文件是否存在 (局_WinRAR目录 ＋ rar主程序文件名))
            集_rar所在路径 ＝ 局_WinRAR目录 ＋ rar主程序文件名
            返回 (真)
        .如果真结束
    .如果结束
.否则
    集_rar所在路径 ＝ rar所在路径
    .如果真 (文件是否存在 (集_rar所在路径))
        返回 (真)
    .如果真结束
.如果结束
' 如果文件不存在，返回假
集_rar所在路径 ＝ “”
返回 (假)
.子程序 rar_压缩, 文本型, 公开, 压缩文件或文件夹，若成功返回空文本，失败则返回错误提示。
.参数 被压缩的文件, 文本型, , 文件或文件夹都可以
.参数 压缩到的路径, 文本型, , 全路径和rar/zip文件名，填入完整的路径，该路径所在文件夹必须存在，否则会失败
.参数 压缩密码, 文本型, 可空, 设置压缩密码
.参数 注释地址, 文本型, 可空, 注释文本文件的完整路径，以txt结尾
.参数 是否等待, 逻辑型, 可空, 默认为假，不等待，为真则为等待压缩完毕
.参数 是否显示压缩过程, 逻辑型, 可空, 默认为假，不显示
.参数 压缩程度, 整数型, 可空, 范围为1-5,1的压缩程度最小，5压缩程度最大，但时间最久。默认为3，如果传值不正确也为3
.局部变量 压缩过程, 整数型
.局部变量 程度数组, 整数型, , "5"
.局部变量 循环次数, 整数型
.如果真 (集_rar所在路径 ＝ “”)
    返回 (“rar路径不存在，请确认是否初始化成功”)
.如果真结束
.如果真 (是否为空 (压缩程度))
    压缩程度 ＝ 3
.如果真结束
.如果真 (压缩程度 ＜ 1 或 压缩程度 ＞ 5)
    压缩程度 ＝ 3
.如果真结束
.如果真 (是否为空 (是否显示压缩过程))
    是否显示压缩过程 ＝ 假
.如果真结束
.判断开始 (是否显示压缩过程 ＝ 真)
    压缩过程 ＝ #显示rar窗口
.默认
    压缩过程 ＝ #隐藏rar窗口
.判断结束
.判断开始 (压缩密码 ＝ “”)
    .判断开始 (注释地址 ＝ “”)
        ' 无密码无注释的情况
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号, 是否等待, 压缩过程)
    .默认
        ' 无密码有注释的情况
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ -z” ＋ #引号 ＋ 注释地址 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号, 是否等待, 压缩过程)
    .判断结束
.判断 (注释地址 ＝ “”)
    ' 有密码无注释的情况
    运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号 ＋ “ -p” ＋ 压缩密码, 是否等待, 压缩过程)
.默认
    ' 有密码有注释的情况
    运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ -z” ＋ #引号 ＋ 注释地址 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号 ＋ “ -p” ＋ 压缩密码, 是否等待, 压缩过程)
.判断结束
返回 (“”)
.子程序 rar_解压, 文本型, 公开, 解压压缩包，成功返回空文本，失败返回错误提示。
.参数 压缩文件完整路径, 文本型, , 全路径带上rar/zip文件名
.参数 解压到的文件夹, 文本型, , 文件夹全路径
.参数 解压密码, 文本型, 可空, 压缩时设定的解压密码
.参数 是否覆盖已存在的文件, 逻辑型, 可空, 默认为假
.参数 是否等待, 逻辑型, 可空, 是否等待解压完毕，默认为假，为真则解压完成后才运行后面的代码
.参数 是否显示解压过程, 逻辑型, 可空, 默认为假，不显示
.局部变量 解压过程, 整数型
.如果真 (集_rar所在路径 ＝ “”)
    返回 (“rar路径不存在，请确认是否初始化成功”)
.如果真结束
.如果真 (是否为空 (是否覆盖已存在的文件))
    是否覆盖已存在的文件 ＝ 假
.如果真结束
.如果真 (是否为空 (是否显示解压过程))
    是否显示解压过程 ＝ 假
.如果真结束
.判断开始 (是否显示解压过程 ＝ 真)
    解压过程 ＝ #显示rar窗口
.默认
    解压过程 ＝ #隐藏rar窗口
.判断结束
.判断开始 (解压密码 ＝ “”)
    .判断开始 (是否覆盖已存在的文件 ＝ 假)
        ' 密码为空不覆盖原有文件
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o- ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号, 是否等待, 解压过程)
    .默认
        ' 密码为空覆盖原有文件
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o+ ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号, 是否等待, 解压过程)
    .判断结束
.判断 (是否覆盖已存在的文件 ＝ 假)
    ' 有密码不覆盖原有文件
    运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o- ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号 ＋ “ -p” ＋ 解压密码, 是否等待, 解压过程)
.默认
    ' 有密码覆盖原有文件
    运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o+ ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号 ＋ “ -p” ＋ 解压密码, 是否等待, 解压过程)
.判断结束
返回 (“”)
.子程序 rar_添加文件注释, 文本型, 公开, 给已经压缩好的压缩文件添加注释 成功返回空文本，失败返回错误提示。
.参数 压缩文件完整路径, 文本型, , 压缩文件全路径，rar/zip
.参数 注释文件地址, 文本型, , 以txt结尾的完整路径
.参数 是否等待, 逻辑型, 可空, 默认为假，不等待
.参数 是否显示过程, 逻辑型, 可空, 默认为假，不显示
.局部变量 过程, 整数型
.如果真 (集_rar所在路径 ＝ “”)
    返回 (“rar路径不存在，请确认是否初始化成功”)
.如果真结束
.如果真 (是否为空 (是否显示过程))
    是否显示过程 ＝ 假
.如果真结束
.判断开始 (是否显示过程 ＝ 真)
    过程 ＝ #显示rar窗口
.默认
    过程 ＝ #隐藏rar窗口
.判断结束
运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ c ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ -z” ＋ #引号 ＋ 注释文件地址 ＋ #引号, 是否等待, 过程)
返回 (“”)
.子程序 rar_删除压缩包内的文件, 文本型, 公开, 删除压缩包里面的文件，成功返回空文本，失败返回错误提示。
.参数 压缩文件, 文本型, , 压缩文件全路径 rar/zip
.参数 要删除的文件名, 文本型, , 文件名不能带路径，但是要带后缀，如果是最后一个文件，那么整个压缩包会被删除
.参数 是否等待, 逻辑型, 可空, 默认为假，不等待
.参数 是否显示过程, 逻辑型, 可空, 默认为假，不显示
.局部变量 过程, 整数型
.如果真 (集_rar所在路径 ＝ “”)
    返回 (“rar路径不存在，请确认是否初始化成功”)
.如果真结束
.如果真 (是否为空 (是否显示过程))
    是否显示过程 ＝ 假
.如果真结束
.判断开始 (是否显示过程 ＝ 真)
    过程 ＝ #显示rar窗口
.默认
    过程 ＝ #隐藏rar窗口
.判断结束
运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ d ” ＋ #引号 ＋ 压缩文件 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 要删除的文件名 ＋ #引号, 是否等待, 过程)
返回 (“”)
.子程序 rar_测试文件, 逻辑型, 公开, 测试压缩包密码是否正确
.参数 压缩文件, 文本型
.参数 密码, 文本型, 可空
.局部变量 局_目录, 文本型
.局部变量 局_密码, 文本型
.局部变量 局_结果, 文本型
局_目录 ＝ 文件_取目录 (集_rar所在路径)
.如果真 (密码 ≠ “”)
    局_密码 ＝ “ -p” ＋ 密码
.如果真结束
局_结果 ＝ 系统_取DOS执行结果 (“cd ” ＋ #引号 ＋ 局_目录 ＋ #引号 ＋ “&” ＋ #引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ t ” ＋ #引号 ＋ 压缩文件 ＋ #引号 ＋ 局_密码)
返回 (倒找文本 (局_结果, “全部成功”, , 真) ＞ -1)
.子程序 rar_取压缩包内的文件数量, 整数型, 公开
.参数 压缩文件, 文本型
.参数 密码, 文本型, 可空
.局部变量 局_目录, 文本型
.局部变量 局_密码, 文本型
.局部变量 局_结果, 文本型
局_目录 ＝ 文件_取目录 (集_rar所在路径)
.如果真 (密码 ≠ “”)
    局_密码 ＝ “ -p” ＋ 密码
.如果真结束
局_结果 ＝ 系统_取DOS执行结果 (“cd ” ＋ #引号 ＋ 局_目录 ＋ #引号 ＋ “&” ＋ #引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ v ” ＋ #引号 ＋ 压缩文件 ＋ #引号 ＋ 局_密码)
局_结果 ＝ 文本_取右边 (局_结果, “-” ＋ #换行符, , )
返回 (到整数 (局_结果))
.程序集 集_DLL
.子程序 投递消息整数, , 公开
.参数 窗口句柄, 整数型
.参数 消息号, 整数型
.参数 消息参数1, 整数型
.参数 消息参数2, 整数型
PostMessageA (窗口句柄, 消息号, 消息参数1, 消息参数2)
.子程序 发送消息整数, 整数型, 公开, 发送特定的消息到一个或多个窗口。该命令不会立即返回，只有在消息被处理完毕后才返回结果。返回值的具体含义随消息的不同而不同
.参数 窗口句柄, 整数型, , 本参数指定接收消息的窗口的句柄
.参数 消息号, 整数型, , 本参数指定欲发送的消息
.参数 消息参数1, 整数型, , 本参数指定消息的第一个参数。具体含义随消息的不同而不同
.参数 消息参数2, 整数型, , 本参数指定消息的第二个参数。具体含义随消息的不同而不同
返回 (SendMessageA (窗口句柄, 消息号, 消息参数1, 消息参数2))
.子程序 发送消息文本, 整数型, 公开, 发送特定的消息到一个或多个窗口。该命令不会立即返回，只有在消息被处理完毕后才返回结果。返回值的具体含义随消息的不同而不同
.参数 窗口句柄, 整数型, , 本参数指定接收消息的窗口的句柄
.参数 消息号, 整数型, , 本参数指定欲发送的消息
.参数 消息参数1, 整数型, , 本参数指定消息的第一个参数。具体含义随消息的不同而不同
.参数 消息参数2, 文本型, , 本参数指定消息的第二个参数。具体含义随消息的不同而不同
返回 (SendMessageA (窗口句柄, 消息号, 消息参数1, 取指针文本_ (消息参数2)))
.子程序 发送消息逻辑, 整数型, 公开, 发送特定的消息到一个或多个窗口。该命令不会立即返回，只有在消息被处理完毕后才返回结果。返回值的具体含义随消息的不同而不同
.参数 窗口句柄, 整数型, , 本参数指定接收消息的窗口的句柄
.参数 消息号, 整数型, , 本参数指定欲发送的消息
.参数 消息参数1, 逻辑型, , 本参数指定消息的第一个参数。具体含义随消息的不同而不同
.参数 消息参数2, 整数型, , 本参数指定消息的第二个参数。具体含义随消息的不同而不同
返回 (SendMessageA (窗口句柄, 消息号, 到整数 (消息参数1), 消息参数2))
.子程序 API_取空白文本, 文本型, 公开, 返回具有指定数目半角空格的文本。
.参数 重复次数, 整数型
.局部变量 文本指针, 整数型
' 注：以下的代码仿效了易核心库命令“取空白文本”，只是填充空白字符0x20部分使用了API函数来实现。
.如果真 (重复次数 ≤ 0)
    ' 这里嵌入汇编代码取代  返回 (“”)
    置入代码 ({ 51, 192, 139, 229, 93, 194, 4, 0 })
    ' XOR EAX,EAX
    ' MOV ESP,EBP
    ' POP EBP
    ' RETN 04
.如果真结束
' 分配可用内存空间，+1是为了填充文本终止符“0”。
文本指针 ＝ HeapAlloc (GetProcessHeap (), 0, 重复次数 ＋ 1)
.如果真 (文本指针 ＝ 0)
    ' 这里嵌入汇编代码取代  返回 (“”)
    置入代码 ({ 139, 229, 93, 194, 4, 0 })
    ' MOV ESP,EBP
    ' POP EBP
    ' RETN 04
.如果真结束
' 以空白字符0x20填充分配的内存块字节数据，这里使用了API函数，当然也可以用嵌入汇编来实现。
RtlFillMemory_字节 (文本指针, 重复次数, 32)
' 嵌入汇编代码以替换掉原来的返回代码，并添加文本终止符标志“0”。
' 如用“指针到文本”命令会使效率大大减低，不推荐使用。
置入代码 ({ 139, 69, 8, 3, 69, 252, 198, 0, 0, 139, 69, 252, 139, 229, 93, 194, 4, 0 })
' 至于释放内存就交给易IDE了，使用HeapAlloc申请内存的目的就在这里，因为易IDE也是使用HeapAlloc
' 申请内存的，最终易IDE会帮我们使用HeapFree释放内存。哈哈！是不是有点欺骗易IDE的味道。
返回 (“”)
.子程序 API_取空白字节集, 字节集, 公开, 返回具有特定数目 0 字节的字节集
.参数 零字节数目, 整数型
.局部变量 字节集指针, 整数型
.如果真 (零字节数目 ≤ 0)
    ' 这里嵌入汇编代码取代  返回 ({ })
    置入代码 ({ 51, 192, 139, 229, 93, 194, 4, 0 })
    ' XOR EAX,EAX
    ' MOV ESP,EBP
    ' POP EBP
    ' RETN 04
.如果真结束
' 分配可用内存空间，+8是为了填充字节集类型标志
字节集指针 ＝ HeapAlloc (GetProcessHeap (), 8, 零字节数目 ＋ 8)  ' #HEAP_ZERO_MEMORY=8
.如果真 (字节集指针 ＝ 0)
    ' 这里嵌入汇编代码取代  返回 ({ })
    置入代码 ({ 139, 229, 93, 194, 4, 0 })
    ' MOV ESP,EBP
    ' POP EBP
    ' RETN 04
.如果真结束
' 嵌入汇编代码以替换掉原来的返回代码，并添加字节集类型标志。
置入代码 ({ 254, 0, 255, 117, 8, 143, 64, 4, 139, 229, 93, 194, 4, 0 })
返回 ({  })
.程序集 集_算术运算
.子程序 运算_求阶乘, 长整数型, 公开, 返回参数中给定数值的计算阶乘结果。
.参数 阶乘数, 整数型, , 要求阶乘的数值
.局部变量 计算结果, 长整数型
.局部变量 计数, 整数型
计算结果 ＝ 1
.计次循环首 (阶乘数, 计数)
    计算结果 ＝ 计算结果 × 计数
.计次循环尾 ()
返回 (计算结果)  ' 将计算结果返回给调用本程序的命令行
.子程序 运算_二分查找, 整数型, 公开
.参数 数组, 文本型, 数组
.参数 待查, 文本型
.参数 类型, 整数型
.参数 区分大小写, 逻辑型
.局部变量 位置, 整数型
.局部变量 数组总数, 整数型
.局部变量 对分, 整数型
.局部变量 数值A, 双精度小数型
.局部变量 数值B, 双精度小数型
.局部变量 文本, 文本型
位置 ＝ 1
数组总数 ＝ 取数组成员数 (数组)
.如果真 (数组总数 ＝ 0)
    返回 (1)
.如果真结束
.判断开始 (类型 ＝ 0)
    数值A ＝ 到数值 (待查)
    .如果真 (数值A ≥ 到数值 (数组 [数组总数]))
        返回 (数组总数 ＋ 1)
    .如果真结束
    .如果真 (数值A ≤ 到数值 (数组 [1]))
        返回 (1)
    .如果真结束
    .判断循环首 (位置 ＜ 数组总数 － 1)
        对分 ＝ (位置 ＋ 数组总数) ＼ 2
        数值B ＝ 到数值 (数组 [对分])
        .如果真 (数值A ＝ 数值B)
            位置 ＝ 对分
            跳出循环 ()
        .如果真结束
        .如果 (数值A ＜ 数值B)
            数组总数 ＝ 对分
        .否则
            位置 ＝ 对分
        .如果结束
    .判断循环尾 ()
.判断 (类型 ＝ 1)
    .如果真 (文本比较 (待查, 数组 [数组总数], 区分大小写) ≥ 0)
        返回 (数组总数 ＋ 1)
    .如果真结束
    .如果真 (文本比较 (待查, 数组 [1], 区分大小写) ≤ 0)
        返回 (1)
    .如果真结束
    .判断循环首 (位置 ＜ 数组总数 － 1)
        对分 ＝ (位置 ＋ 数组总数) ＼ 2
        .如果真 (文本比较 (待查, 数组 [对分], 区分大小写) ＝ 0)
            位置 ＝ 对分
            跳出循环 ()
        .如果真结束
        .如果 (文本比较 (待查, 数组 [对分], 区分大小写) ＜ 0)
            数组总数 ＝ 对分
        .否则
            位置 ＝ 对分
        .如果结束
    .判断循环尾 ()
.判断 (类型 ＝ 2)
    数值A ＝ 取字节集数据 (到字节集 (到时间 (待查)), #双精度小数型)
    .如果真 (数值A ≥ 取字节集数据 (到字节集 (到时间 (数组 [数组总数])), #双精度小数型))
        返回 (数组总数 ＋ 1)
    .如果真结束
    .如果真 (数值A ≤ 取字节集数据 (到字节集 (到时间 (数组 [1])), #双精度小数型))
        返回 (1)
    .如果真结束
    .判断循环首 (位置 ＜ 数组总数 － 1)
        对分 ＝ (位置 ＋ 数组总数) ＼ 2
        数值B ＝ 取字节集数据 (到字节集 (到时间 (数组 [对分])), #双精度小数型)
        .如果真 (数值A ＝ 数值B)
            位置 ＝ 对分
            跳出循环 ()
        .如果真结束
        .如果 (数值A ＜ 数值B)
            数组总数 ＝ 对分
        .否则
            位置 ＝ 对分
        .如果结束
    .判断循环尾 ()
.默认
.判断结束
返回 (位置 ＋ 1)
.子程序 运算_函数计算, 文本型, 公开, 求正弦、余弦、正切、余切
.参数 Text, 文本型
.参数 单位, 逻辑型, , 真为弧度制，假为角度制
.局部变量 TempText, 文本型
.局部变量 FText, 文本型, , , 寻找值
.局部变量 FNum, 整数型, , , 寻找值的长度
.局部变量 ZText, 文本型, , , 函数括号内文本
.局部变量 RetText, 文本型, , , 函数括号内计算结果
.局部变量 i, 整数型
.局部变量 Find, 整数型, , , 寻找到的位置
.局部变量 YFind, 整数型, , , 寻找到右括号的位置
TempText ＝ Text
.计次循环首 (4, i)
    FText ＝ 多项选择 (i, “sin(”, “cos(”, “tg(”, “ctg(”)
    FNum ＝ 多项选择 (i, 4, 4, 3, 4)
    Find ＝ 寻找文本 (TempText, FText, , 假)
    .判断循环首 (Find ≠ -1)
        YFind ＝ 寻找文本 (TempText, “)”, Find, 假)  ' 寻找右括号
        .如果真 (YFind ≠ -1)
            ZText ＝ 取文本中间 (TempText, Find ＋ FNum, YFind － Find － FNum)
            .判断开始 (ZText ＝ “”)  ' 括号内无文本
                TempText ＝ 文本替换 (TempText, Find, FNum ＋ 1, )
            .默认
                RetText ＝ 运算_括号计算 (ZText)
                .如果真 (RetText ＝ “”)  ' 失败返回空文本
                    返回 (“”)
                .如果真结束
                .判断开始 (i ＝ 1)  ' 正弦
                    RetText ＝ 到文本 (求正弦 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))
                .判断 (i ＝ 2)  ' 余弦
                    RetText ＝ 到文本 (求余弦 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))
                .判断 (i ＝ 3)  ' 正切
                    RetText ＝ 到文本 (求正切 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))
                .默认
                    RetText ＝ 到文本 (1 ÷ 求正切 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))  ' 余切
                .判断结束
                .如果真 (是否运算正确 (到数值 (RetText)) ＝ 假)
                    返回 (“”)
                .如果真结束
                TempText ＝ 文本替换 (TempText, Find, 取文本长度 (ZText) ＋ FNum ＋ 1, RetText)
            .判断结束
        .如果真结束
        Find ＝ 寻找文本 (TempText, FText, , 假)
    .判断循环尾 ()
.计次循环尾 ()
返回 (运算_括号计算 (TempText))
.子程序 运算_括号计算, 文本型, 公开
.参数 Text, 文本型
.局部变量 i, 整数型
.局部变量 Zk, 整数型, , "0", 左括号位置数组
.局部变量 ZkNum, 整数型, , , Zk成员数量
.局部变量 SigText, 文本型, , , 单个文本
.局部变量 Asc, 整数型, , , 单个文本的Asc码
.局部变量 SwText, 文本型, , , 括号内文本
.局部变量 SwReText, 文本型, , , 括号内计算后文本
.局部变量 TempText, 文本型, , , 替换后的结果
TempText ＝ Text
i ＝ 1
.判断循环首 (i ≤ 取文本长度 (TempText))
    SigText ＝ 取文本中间 (TempText, i, 1)
    .判断开始 (SigText ＝ “(”)
        加入成员 (Zk, i)
        i ＝ i ＋ 1
    .判断 (SigText ＝ “)”)
        ZkNum ＝ 取数组成员数 (Zk)
        .如果 (ZkNum ＞ 0)  ' 是否存在左括号
            SwText ＝ 取文本中间 (TempText, Zk [ZkNum] ＋ 1, i － Zk [ZkNum] － 1)  ' 取出括号内文本
            SwReText ＝ 运算_内部计算 (SwText)  ' 计算括号内文本
            .如果真 (SwReText ＝ “”)  ' 失败返回空文本
                返回 (“”)
            .如果真结束
            TempText ＝ 文本替换 (TempText, Zk [ZkNum], 取文本长度 (“(” ＋ SwText ＋ “)”), SwReText)
            i ＝ Zk [ZkNum] ＋ 1
            删除成员 (Zk, ZkNum, )
        .否则
            TempText ＝ 文本替换 (TempText, i, 1, )  ' 去掉多余右括号
        .如果结束
    .判断 (Asc ＝ 92)
        TempText ＝ 文本替换 (TempText, i, 1, “\”)
        i ＝ i ＋ 1
    .默认
        Asc ＝ 取代码 (SigText, )
        .判断开始 ((Asc ＜ 46 或 Asc ＞ 57) 且 Asc ≠ 42 且 Asc ≠ 43 且 Asc ≠ 45 且 Asc ≠ 92 且 Asc ≠ 94)  ' 去掉非法字符
            TempText ＝ 文本替换 (TempText, i, 1, )
        .默认
            i ＝ i ＋ 1
        .判断结束
    .判断结束
.判断循环尾 ()
ZkNum ＝ 取数组成员数 (Zk)
.如果真 (ZkNum ＞ 0)  ' 去掉多余左括号
    .计次循环首 (ZkNum, i)
        TempText ＝ 文本替换 (TempText, Zk [ZkNum － i ＋ 1], 1, )  ' 从最后一个开始替换
    .计次循环尾 ()
.如果真结束
返回 (运算_内部计算 (TempText))
.子程序 运算_内部计算, 文本型, 公开, 加减乘除及乘方运算，失败返回空文本
.参数 Text, 文本型
.局部变量 i, 整数型
.局部变量 Sign, 整数型, , "0", 操作符号位置
.局部变量 SiNum, 整数型, , , Sign的数组成员数量
.局部变量 SigText, 文本型, , , 单个文本
.局部变量 TempText, 文本型
.局部变量 Js, 文本型, , "2", 计算的左边和右边
.局部变量 Result, 文本型, , , 单符号计算结果
.局部变量 len, 整数型
TempText ＝ Text
.如果真 (寻找文本 (TempText, “^”, , 假) ≠ -1)
    .判断循环首 (i ≤ 取文本长度 (TempText))  ' 计算乘方
        SigText ＝ 取文本中间 (TempText, i, 1)
        .判断开始 (SigText ＝ “+” 或 SigText ＝ “-” 且 i ＞ 1 或 SigText ＝ “*” 或 SigText ＝ “/”)
            加入成员 (Sign, i)
            i ＝ i ＋ 1
        .判断 (SigText ＝ “^”)
            SiNum ＝ 取数组成员数 (Sign)
            .判断开始 (SiNum ＞ 0)
                Js [1] ＝ 取文本中间 (TempText, Sign [SiNum] ＋ 1, i － Sign [SiNum] － 1)
                Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
                Result ＝ 到文本 (求次方 (到数值 (Js [1]), 到数值 (Js [2])))
                .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                    len ＝ len ＋ 1
                .判断循环尾 ()
                TempText ＝ 文本替换 (TempText, Sign [SiNum] ＋ 1, 取文本长度 (Js [1] ＋ “^” ＋ Js [2]) ＋ len, Result)
                i ＝ Sign [SiNum] ＋ 1
            .默认
                Js [1] ＝ 取文本左边 (TempText, i － 1)
                Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
                Result ＝ 到文本 (求次方 (到数值 (Js [1]), 到数值 (Js [2])))
                .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                    len ＝ len ＋ 1
                .判断循环尾 ()
                TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “^” ＋ Js [2]) ＋ len, Result)
                i ＝ 1
            .判断结束
        .默认
            i ＝ i ＋ 1
        .判断结束
    .判断循环尾 ()
.如果真结束
i ＝ 1
清除数组 (Sign)
.如果真 (寻找文本 (TempText, “*”, , 假) ≠ -1 或 寻找文本 (TempText, “/”, , 假) ≠ -1)
    .判断循环首 (i ≤ 取文本长度 (TempText))  ' 计算乘除
        SigText ＝ 取文本中间 (TempText, i, 1)
        .判断开始 (SigText ＝ “+” 或 SigText ＝ “-” 且 i ＞ 1)
            加入成员 (Sign, i)
            i ＝ i ＋ 1
        .判断 (SigText ＝ “*”)
            SiNum ＝ 取数组成员数 (Sign)
            .判断开始 (SiNum ＞ 0)
                Js [1] ＝ 取文本中间 (TempText, Sign [SiNum] ＋ 1, i － Sign [SiNum] － 1)
                Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
                Result ＝ 到文本 (到数值 (Js [1]) × 到数值 (Js [2]))
                .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                    len ＝ len ＋ 1
                .判断循环尾 ()
                TempText ＝ 文本替换 (TempText, Sign [SiNum] ＋ 1, 取文本长度 (Js [1] ＋ “*” ＋ Js [2]) ＋ len, Result)
                i ＝ Sign [SiNum] ＋ 1
            .默认
                Js [1] ＝ 取文本左边 (TempText, i － 1)
                Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
                Result ＝ 到文本 (到数值 (Js [1]) × 到数值 (Js [2]))
                .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                    len ＝ len ＋ 1
                .判断循环尾 ()
                TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “*” ＋ Js [2]) ＋ len, Result)
                i ＝ 1
            .判断结束
        .判断 (SigText ＝ “/”)
            SiNum ＝ 取数组成员数 (Sign)
            .判断开始 (SiNum ＞ 0)
                Js [1] ＝ 取文本中间 (TempText, Sign [SiNum] ＋ 1, i － Sign [SiNum] － 1)
                Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
                .如果真 (到数值 (Js [2]) ＝ 0)  ' 除数不能为0
                    返回 (“”)
                .如果真结束
                .如果 (到数值 (Js [1]) ＝ 0)  ' 避免出现被除数不能为0
                    Result ＝ “0”
                .否则
                    Result ＝ 到文本 (到数值 (Js [1]) ÷ 到数值 (Js [2]))
                .如果结束
                .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                    len ＝ len ＋ 1
                .判断循环尾 ()
                TempText ＝ 文本替换 (TempText, Sign [SiNum] ＋ 1, 取文本长度 (Js [1] ＋ “/” ＋ Js [2]) ＋ len, Result)
                i ＝ Sign [SiNum] ＋ 1
            .默认
                Js [1] ＝ 取文本左边 (TempText, i － 1)
                Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
                .如果真 (到数值 (Js [2]) ＝ 0)  ' 被除数不能为0
                    返回 (“”)
                .如果真结束
                .如果 (到数值 (Js [1]) ＝ 0)  ' 避免出现被除数不能为0
                    Result ＝ “0”
                .否则
                    Result ＝ 到文本 (到数值 (Js [1]) ÷ 到数值 (Js [2]))
                .如果结束
                .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                    len ＝ len ＋ 1
                .判断循环尾 ()
                TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “/” ＋ Js [2]) ＋ len, Result)
                i ＝ 1
            .判断结束
        .默认
            i ＝ i ＋ 1
        .判断结束
    .判断循环尾 ()
.如果真结束
i ＝ 1
.判断循环首 (i ≤ 取文本长度 (TempText))  ' 计算加减
    SigText ＝ 取文本中间 (TempText, i, 1)
    .判断开始 (SigText ＝ “+”)
        Js [1] ＝ 取文本左边 (TempText, i － 1)
        Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
        Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
        Result ＝ 到文本 (到数值 (Js [1]) ＋ 到数值 (Js [2]))
        .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
            len ＝ len ＋ 1
        .判断循环尾 ()
        TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “+” ＋ Js [2]) ＋ len, Result)
        i ＝ 1
    .判断 (SigText ＝ “-” 且 i ＞ 1)
        Js [1] ＝ 取文本左边 (TempText, i － 1)
        Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
        Js [2] ＝ 到文本 (到数值 (Js [2]))  ' 去掉后面的操作符
        Result ＝ 到文本 (到数值 (Js [1]) － 到数值 (Js [2]))
        .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
            len ＝ len ＋ 1
        .判断循环尾 ()
        TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “-” ＋ Js [2]) ＋ len, Result)
        i ＝ 1
    .默认
        i ＝ i ＋ 1
    .判断结束
.判断循环尾 ()
返回 (TempText)
.子程序 运算_取圆周率, 文本型, 公开, 返回小数最大1000位圆周率,实际上有10位计算就已很精确了
.参数 位数, 整数型, , 返回圆周率小数点后的位数
.局部变量 行1, 文本型
.局部变量 行2, 文本型
.局部变量 行3, 文本型
.局部变量 行4, 文本型
.局部变量 行5, 文本型
.局部变量 行6, 文本型
.局部变量 行7, 文本型
.局部变量 行8, 文本型
.局部变量 行9, 文本型
.局部变量 行10, 文本型
行1 ＝ “1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679”
行2 ＝ “8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196”
行3 ＝ “4428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273”
行4 ＝ “7245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094”
行5 ＝ “3305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912”
行6 ＝ “9833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132”
行7 ＝ “0005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235”
行8 ＝ “4201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859”
行9 ＝ “5024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303”
行10 ＝ “5982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989”
返回 (取文本左边 (“3.” ＋ 行1 ＋ 行2 ＋ 行3 ＋ 行4 ＋ 行5 ＋ 行6 ＋ 行7 ＋ 行8 ＋ 行9 ＋ 行10, 位数 ＋ 2))
.子程序 运算_求反正弦, 双精度小数型, 公开, 返回弧度值
.参数 正弦值, 双精度小数型, , -1到1，否则返回0
.如果真 (正弦值 ＜ -1 或 正弦值 ＞ 1)
    返回 (0)
.如果真结束
返回 (求反正切 (正弦值 ÷ 求平方根 (1 － 正弦值 × 正弦值)))
.子程序 运算_求反余弦, 双精度小数型, 公开, 返回弧度值
.参数 余弦值, 双精度小数型, , -1到1，否则返回0
.如果真 (余弦值 ＞ 1 或 余弦值 ＜ -1)
    返回 (0)
.如果真结束
返回 (#pi ÷ 2 － 运算_求反正弦 (余弦值))
.子程序 运算_颜色转换, 文本型, 公开, 将10进制的颜色值转到16进制的颜色值；   还原调用 网页_取十进制颜色值
.参数 待转换颜色值, 整数型
.局部变量 字节集, 字节集
.局部变量 十六进制颜色, 文本型
字节集 ＝ 到字节集 (待转换颜色值)
十六进制颜色 ＝ 取文本右边 (“00” ＋ 取十六进制文本 (字节集 [1]), 2)
十六进制颜色 ＝ 十六进制颜色 ＋ 取文本右边 (“00” ＋ 取十六进制文本 (字节集 [2]), 2)
十六进制颜色 ＝ 十六进制颜色 ＋ 取文本右边 (“00” ＋ 取十六进制文本 (字节集 [3]), 2)
返回 (十六进制颜色)
.子程序 运算_表达式计算, 文本型, 公开, 成功返回计算后的文本结果，失败返回空文本
.参数 Text, 文本型
.参数 单位, 逻辑型, , 函数计算时使用，真为弧度制，假为角度制
.局部变量 TempText, 文本型
TempText ＝ 运算_函数计算 (Text, 单位)
返回 (运算_括号计算 (TempText))
.子程序 运算_象素到厘米, 双精度小数型, 公开
.参数 象素值
.局部变量 厘米值, 双精度小数型
厘米值 ＝ 象素值 ÷ 28.346
返回 (厘米值)
.子程序 运算_厘米到象素, 双精度小数型, 公开
.参数 厘米值, 双精度小数型
.局部变量 象素值, 双精度小数型
象素值 ＝ 厘米值 × 28.346
返回 (象素值)
.子程序 运算_求直线距离, 双精度小数型, 公开, 返回两个点之间的直线距离,可以返回象素,也可以返回厘米
.参数 水平象素1, 整数型
.参数 垂直象素1, 整数型
.参数 水平象素2, 整数型
.参数 垂直象素2, 整数型
.参数 类型, 整数型, 可空, 1为返回象素,2为返回厘米
.局部变量 距离象素, 整数型
.局部变量 距离厘米, 小数型
距离象素 ＝ 求平方根 (求次方 (水平象素2 － 水平象素1, 2) ＋ 求次方 (垂直象素2 － 垂直象素1, 2))
.如果 (是否为空 (类型) ＝ 真 或 类型 ＝ 1)
    返回 (距离象素)
.否则
    距离厘米 ＝ 距离象素 ÷ 28
    返回 (距离厘米)
.如果结束
返回 (-1)
.子程序 运算_四舍六入五留双, 双精度小数型, 公开
.参数 欲修约值, 双精度小数型
.参数 保留位数, 整数型
.如果真 (欲修约值 × 求次方 (10, 保留位数) － 取整 (欲修约值 × 求次方 (10, 保留位数)) ≠ 0.5)
    返回 (四舍五入 (欲修约值, 保留位数))
.如果真结束
.如果真 (欲修约值 × 求次方 (10, 保留位数) － 取整 (欲修约值 × 求次方 (10, 保留位数)) ＝ 0.5)
    .如果真 (取整 (欲修约值 × 求次方 (10, 保留位数)) ％ 2 ＝ 0)
        返回 (四舍五入 (欲修约值 － 求次方 (10, 保留位数 × -1), 保留位数))
    .如果真结束
    .如果真 (取整 (欲修约值 × 求次方 (10, 保留位数)) ％ 2 ＝ 1)
        返回 (四舍五入 (欲修约值, 保留位数))
    .如果真结束
.如果真结束
返回 (0)
.子程序 运算_大小端转换, 整数型, 公开
.参数 需要转换的值, 整数型
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 c, 整数型
.局部变量 d, 整数型
a ＝ 位与 (需要转换的值, 255)
a ＝ Int_Shl (a, 24)
b ＝ 位与 (需要转换的值, 65280)
b ＝ Int_Shl (b, 8)
c ＝ 位与 (需要转换的值, 16711680)
c ＝ Int_Shr (c, 8)
d ＝ 位与 (需要转换的值, 4278190080)
d ＝ Int_Shr (d, 24)
返回 (位或 (a, b, c, d))
.子程序 Int_Shr, 整数型, , 无符号右移
.参数 int, 整数型
.参数 shiftCount, 字节型
置入代码 ({ 139, 69, 8, 138, 77, 12, 131, 225, 31, 211, 232, 201, 194, 8, 0 })
返回 (0)
.子程序 Int_Shl, 整数型, , 无符号左移
.参数 int, 整数型
.参数 shiftCount, 字节型
置入代码 ({ 139, 69, 8, 138, 77, 12, 131, 225, 31, 211, 224, 201, 194, 8, 0 })
返回 (0)
.程序集 类_系统信息, , 公开, http://msdn.microsoft.com/en-us/library/aa394239(v=vs.85).aspx
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 取建立号码, 整数型, 公开
返回 (查询类属性 (“Select BuildNumber From Win32_OperatingSystem”, “BuildNumber”).取数值 ())
.子程序 取引导设备, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select BootDevice From Win32_OperatingSystem”, “BootDevice”).取文本 ()))
.子程序 取内部版本类型, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select BuildType From Win32_OperatingSystem”, “BuildType”).取文本 ()))
.子程序 取标题, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Caption From Win32_OperatingSystem”, “Caption”).取文本 ()))
.子程序 取代码集, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select CodeSet From Win32_OperatingSystem”, “CodeSet”).取文本 ()))
.子程序 取国家代码, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select CountryCode From Win32_OperatingSystem”, “CountryCode”).取文本 ()))
.子程序 取最后服务包, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select CSDVersion From Win32_OperatingSystem”, “CSDVersion”).取文本 ()))
.子程序 取域名称, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select CSName From Win32_OperatingSystem”, “CSName”).取文本 ()))
.子程序 取当前时区, 整数型, 公开
返回 (查询类属性 (“Select CurrentTimeZone From Win32_OperatingSystem”, “CurrentTimeZone”).取数值 ())
.子程序 数据执行保护_是否有效, 逻辑型, 公开, 不支持2003系统。
返回 (查询类属性 (“Select DataExecutionPrevention_Available From Win32_OperatingSystem”, “DataExecutionPrevention_Available”).取逻辑值 ())
.子程序 数据执行保护_支持32位程序, 逻辑型, 公开, 不支持2003系统。
返回 (查询类属性 (“Select DataExecutionPrevention_32BitApplications From Win32_OperatingSystem”, “DataExecutionPrevention_32BitApplications”).取逻辑值 ())
.子程序 数据执行保护_设备正常, 逻辑型, 公开, 不支持2003系统。
返回 (查询类属性 (“Select DataExecutionPrevention_Drivers From Win32_OperatingSystem”, “DataExecutionPrevention_Drivers”).取逻辑值 ())
.子程序 数据执行保护_支持方式, 整数型, 公开, 不支持2003系统。
返回 (查询类属性 (“Select DataExecutionPrevention_SupportPolicy From Win32_OperatingSystem”, “DataExecutionPrevention_SupportPolicy”).取数值 ())
.子程序 是否支持调试, 逻辑型, 公开
返回 (查询类属性 (“Select Debug From Win32_OperatingSystem”, “Debug”).取逻辑值 ())
.子程序 取描述, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Description From Win32_OperatingSystem”, “Description”).取文本 ()))
.子程序 是否分布式系统, 逻辑型, 公开
返回 (查询类属性 (“Select Distributed From Win32_OperatingSystem”, “Distributed”).取逻辑值 ())
.子程序 取加密位数, 整数型, 公开
返回 (查询类属性 (“Select EncryptionLevel From Win32_OperatingSystem”, “EncryptionLevel”).取数值 ())
.子程序 前台程序加速, 整数型, 公开, 0表示无，1最小，2最大(默认)
返回 (查询类属性 (“Select ForegroundApplicationBoost From Win32_OperatingSystem”, “ForegroundApplicationBoost”).取数值 ())
.子程序 取剩余物理内存, 长整数型, 公开
返回 (查询类属性 (“Select FreePhysicalMemory From Win32_OperatingSystem”, “FreePhysicalMemory”).取数值 ())
.子程序 取可用页面文件, 长整数型, 公开
返回 (查询类属性 (“Select FreeSpaceInPagingFiles From Win32_OperatingSystem”, “FreeSpaceInPagingFiles”).取数值 ())
.子程序 取操作系统名称, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Caption From Win32_OperatingSystem”, “Caption”).取文本 ()))
.子程序 取可用虚拟内存, 长整数型, 公开
返回 (查询类属性 (“Select FreeVirtualMemory From Win32_OperatingSystem”, “FreeVirtualMemory”).取数值 ())
.子程序 取安装日期, 日期时间型, 公开
返回 (时间_WMI时间转日期 (删首尾空 (查询类属性 (“Select InstallDate From Win32_OperatingSystem”, “InstallDate”).取文本 ())))
.子程序 取最后关机时间, 日期时间型, 公开
返回 (时间_WMI时间转日期 (删首尾空 (查询类属性 (“Select LastBootUpTime From Win32_OperatingSystem”, “LastBootUpTime”).取文本 ())))
.子程序 取现行时间, 日期时间型, 公开
返回 (时间_WMI时间转日期 (删首尾空 (查询类属性 (“Select LocalDateTime From Win32_OperatingSystem”, “LocalDateTime”).取文本 ())))
.子程序 取语言环境, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Locale From Win32_OperatingSystem”, “Locale”).取文本 ()))
.子程序 取制造商, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Manufacturer From Win32_OperatingSystem”, “Manufacturer”).取文本 ()))
.子程序 取最大进程数, 整数型, 公开
返回 (查询类属性 (“Select MaxNumberOfProcesses From Win32_OperatingSystem”, “MaxNumberOfProcesses”).取数值 ())
.子程序 取最大进程内存, 长整数型, 公开
返回 (查询类属性 (“Select MaxProcessMemorySize From Win32_OperatingSystem”, “MaxProcessMemorySize”).取数值 ())
.子程序 取多国语言包, 整数型, 公开
.参数 返回语言包, 文本型, 数组, 变量储存返回值。
.局部变量 局_数量
.局部变量 局_变量, 变体型
.局部变量 局_计次
局_变量 ＝ 查询类属性 (“Select MUILanguages From Win32_OperatingSystem”, “MUILanguages”)
局_数量 ＝ 局_变量.取数组成员数 ()
.变量循环首 (1, 局_数量, 1, 局_计次)
    加入成员 (返回语言包, 局_变量.取变体型 (局_计次).取文本 ())
.变量循环尾 ()
返回 (局_数量)
.子程序 取授权用户数, 整数型
返回 (查询类属性 (“Select NumberOfLicensedUsers From Win32_OperatingSystem”, “NumberOfLicensedUsers”).取数值 ())
.子程序 取进程数, 整数型, 公开
返回 (查询类属性 (“Select NumberOfProcesses From Win32_OperatingSystem”, “NumberOfProcesses”).取数值 ())
.子程序 取用户会话数, 整数型, 公开
返回 (查询类属性 (“Select NumberOfUsers From Win32_OperatingSystem”, “NumberOfUsers”).取数值 ())
.子程序 取系统SKU, 整数型, 公开, 不支持，Windows Server 2003:返回值；0=未定；1=终极版；2=家庭基础版；3=家庭高级版；4=企业版；5=家庭基本版N版;6=商业版;7=标准服务器版;8=数据中心服务器版;9=小型企业服务器版;10=企业服务器版;11=入门版;12=数据中心服务器核心版;13=标准的服务器核心版;14=企业服务器核心版;15=企业服务器版itanium系统;16=企业版N版;17=Web服务器版;18=集群服务器版;19=家庭服务器版;20=存储Express服务器版;21=存储标准服务器版;22=存储工作组服务器版;23=存储企业服务器版;24=服务器为小型企业版;25=Small Business Server Premium Edition;29=Web Server, Server Core;39=Datacenter Edition without Hyper-V, Server Core;40=Standard Edition without Hyper-V, Server Core;41=Enterprise Edition without Hyper-V, Server Core;42=Hyper-V服务器。
返回 (查询类属性 (“Select OperatingSystemSKU From Win32_OperatingSystem”, “OperatingSystemSKU”).取数值 ())
.子程序 取国家, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Organization From Win32_OperatingSystem”, “Organization”).取文本 ()))
.子程序 取系统位数, 文本型, 公开, 不支持，Windows Server 2003:
返回 (删首尾空 (查询类属性 (“Select OSArchitecture From Win32_OperatingSystem”, “OSArchitecture”).取文本 ()))
.子程序 取系统语言, 整数型, 公开, 如2052表示，中文(简体)-中华人民共和国
返回 (查询类属性 (“Select OSLanguage From Win32_OperatingSystem”, “OSLanguage”).取数值 ())
.子程序 取系统套件, 整数型, 公开
返回 (查询类属性 (“Select OSProductSuite From Win32_OperatingSystem”, “OSProductSuite”).取数值 ())
.子程序 取系统类型, 整数型, 公开, 0=未知；1=其它；2=宏命令；3=ATTUNIX；4=DGUX；5=DECNT；
返回 (查询类属性 (“Select OSType From Win32_OperatingSystem”, “OSType”).取数值 ())
.子程序 是否为NT系统, 逻辑型, 公开
.局部变量 OSType
OSType ＝ 查询类属性 (“Select OSType From Win32_OperatingSystem”, “OSType”).取数值 ()
返回 (OSType ＝ 18)
.子程序 取其它类型描述, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select OtherTypeDescription From Win32_OperatingSystem”, “OtherTypeDescription”).取文本 ()))
.子程序 PAE是否启用, 逻辑型, 公开
返回 (查询类属性 (“Select PAEEnabled From Win32_OperatingSystem”, “PAEEnabled”).取逻辑值 ())
.子程序 取附加产品ID, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select PlusProductID From Win32_OperatingSystem”, “PlusProductID”).取文本 ()))
.子程序 取附加版本号, 整数型, 公开
返回 (查询类属性 (“Select PlusVersionNumber From Win32_OperatingSystem”, “PlusVersionNumber”).取数值 ())
.子程序 是否便携式系统, 逻辑型, 公开
返回 (查询类属性 (“Select PortableOperatingSystem From Win32_OperatingSystem”, “PortableOperatingSystem”).取逻辑值 ())
.子程序 是否主系统, 逻辑型, 公开
返回 (查询类属性 (“Select Primary From Win32_OperatingSystem”, “Primary”).取逻辑值 ())
.子程序 是否为服务器, 逻辑型, 公开
.局部变量 Producttype
Producttype ＝ 查询类属性 (“Select Producttype From Win32_OperatingSystem”, “Producttype”).取数值 ()
返回 (Producttype ＝ 3)
.子程序 取注册用户名, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select RegisteredUser From Win32_OperatingSystem”, “RegisteredUser”).取文本 ()))
.子程序 取序列号, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select SerialNumber From Win32_OperatingSystem”, “SerialNumber”).取文本 ()))
.子程序 取服务包主版本号, 整数型, 公开
返回 (查询类属性 (“Select ServicePackMajorVersion From Win32_OperatingSystem”, “ServicePackMajorVersion”).取数值 ())
.子程序 取服务包次版本号, 整数型, 公开
返回 (查询类属性 (“Select ServicePackMinorVersion From Win32_OperatingSystem”, “ServicePackMinorVersion”).取数值 ())
.子程序 取存储的分页大小, 长整数型, 公开
返回 (查询类属性 (“Select SizeStoredInPagingFiles From Win32_OperatingSystem”, “SizeStoredInPagingFiles”).取数值 ())
.子程序 取状态, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Status From Win32_OperatingSystem”, “Status”).取文本 ()))
.子程序 取嵌套掩码, 整数型, 公开
返回 (查询类属性 (“Select SuiteMask From Win32_OperatingSystem”, “SuiteMask”).取数值 ())
.子程序 取系统设备, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select SystemDevice From Win32_OperatingSystem”, “SystemDevice”).取文本 ()))
.子程序 取系统目录, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select SystemDirectory From Win32_OperatingSystem”, “SystemDirectory”).取文本 ()))
.子程序 取系统盘, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select SystemDrive From Win32_OperatingSystem”, “SystemDrive”).取文本 ()))
.子程序 取总交换空间, 长整数型, 公开
返回 (查询类属性 (“Select TotalSwapSpaceSize From Win32_OperatingSystem”, “TotalSwapSpaceSize”).取数值 ())
.子程序 取总虚拟内存, 长整数型, 公开
返回 (查询类属性 (“Select TotalVirtualMemorySize From Win32_OperatingSystem”, “TotalVirtualMemorySize”).取数值 ())
.子程序 取总物理内存, 长整数型, 公开
返回 (查询类属性 (“Select TotalVisibleMemorySize From Win32_OperatingSystem”, “TotalVisibleMemorySize”).取数值 ())
.子程序 取版本, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select Version From Win32_OperatingSystem”, “Version”).取文本 ()))
.子程序 取系统安装目录, 文本型, 公开
返回 (删首尾空 (查询类属性 (“Select WindowsDirectory From Win32_OperatingSystem”, “WindowsDirectory”).取文本 ()))
.子程序 是否为域控制器, 逻辑型, 公开
.局部变量 Producttype
Producttype ＝ 查询类属性 (“Select Producttype From Win32_OperatingSystem”, “Producttype”).取数值 ()
返回 (Producttype ＝ 2)
.子程序 是否为工作站, 逻辑型, 公开
.局部变量 Producttype
Producttype ＝ 查询类属性 (“Select Producttype From Win32_OperatingSystem”, “Producttype”).取数值 ()
返回 (Producttype ＝ 1)
.子程序 取当前用户, 文本型, 公开
.局部变量 Length
.局部变量 sbuffer, 文本型
sbuffer ＝ 取空白文本 (256)
.如果真 (GetUserNameA (sbuffer, 256) ＝ 1)
    返回 (sbuffer)
.如果真结束
返回 (“”)
.子程序 取时区, 文本型, 公开
.局部变量 szTimeZone, 文本型
.局部变量 m_timezone, 时区信息_
.局部变量 lRetVal1, 整数型
lRetVal1 ＝ GetTimeZoneInformation (m_timezone)
szTimeZone ＝ 编码_Unicode到Ansi (到字节集 (m_timezone.StandardName))
返回 (szTimeZone)
.子程序 取货币符号, 文本型, 公开
.局部变量 sbuffer, 文本型
sbuffer ＝ 取空白文本 (256)
GetLocaleInfo (0, 20, sbuffer, 256)
返回 (sbuffer)
.子程序 取日期格式, 文本型, 公开
.局部变量 sbuffer, 文本型
sbuffer ＝ 取空白文本 (256)
GetLocaleInfo (0, 32, sbuffer, 256)
返回 (sbuffer)
.子程序 取时间格式, 文本型, 公开
.局部变量 sbuffer, 文本型
sbuffer ＝ 取空白文本 (256)
GetLocaleInfo (0, 4099, sbuffer, 256)
返回 (sbuffer)
.程序集 类_磁盘信息, , 公开, MSDN:https://msdn.microsoft.com/en-us/library/aa394132(v=vs.85).aspx
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 _格式化文本, 文本型
.参数 文本1, 文本型
.局部变量 局_临时文本, 文本型
局_临时文本 ＝ 子文本替换 (文本1, “\”, “\\”, , , 真)
返回 (子文本替换 (“Select * From Win32_DiskDrive WHERE Name='{0}'”, “{0}”, 局_临时文本, , , 真))
.子程序 枚举硬盘, 整数型, 公开
.参数 磁盘名称, 文本型, 可空 数组, 变量储存返回值。
.局部变量 局_句柄, 整数型
.局部变量 局_返回值
.局部变量 局_下一对象
.局部变量 局_枚举对象
.局部变量 局_变体型, 变体型
.局部变量 pcFetched, 整数型
局_句柄 ＝ COM_连接命名空间 (“root\CIMV2”)
.如果真 (局_句柄 ＞ 0)
    局_返回值 ＝ IWbemServices_ExecQuery (局_句柄, COM_bstr_t (“WQL”), COM_bstr_t (“Select Name From Win32_DiskDrive”), 位或 (32, 16), 0, 局_枚举对象)
    .如果真 (局_返回值 ＝ 0)
        .循环判断首 ()
            局_返回值 ＝ IEnumWbemClassObject_Next (局_枚举对象, 2000, 1, 局_下一对象, pcFetched)
            .如果真 (局_返回值 ＝ 0)
                局_返回值 ＝ IWbemClassObject_Get (局_下一对象, COM_bstr_t (“Name”), 0, 取变体型指针 (局_变体型), 0, 0)
                .如果真 (局_返回值 ＝ 0)
                    加入成员 (磁盘名称, 局_变体型.取文本 ())
                    COM_Release (局_下一对象)
                .如果真结束
            .如果真结束
        .循环判断尾 (pcFetched ＝ 1)
    .如果真结束
    COM_Release (局_句柄)
.如果真结束
返回 (取数组成员数 (磁盘名称))
.子程序 取描述, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “Description”).取文本 ())
.子程序 取固件版本, 文本型, 公开, 这个属性不支持Server 2003系统。
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “FirmwareRevision”).取文本 ())
.子程序 取索引, 整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “index”).取数值 ())
.子程序 取接口类型, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “InterfaceType”).取文本 ())
.子程序 取制造商, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “Manufacturer”).取文本 ())
.子程序 是否加载媒体, 逻辑型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “MediaLoaded”).取逻辑值 ())
.子程序 取媒体类型, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “MediaType”).取文本 ())
.子程序 取型号, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “Model”).取文本 ())
.子程序 取分区数, 整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “Partitions”).取数值 ())
.子程序 取PNP设备ID, 文本型, 公开, Windows逻辑设备的即插即用设备标识符。
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “PNPDeviceID”).取文本 ())
.子程序 取SCSI总线, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “SCSIBus”).取文本 ())
.子程序 取SCSI逻辑单元, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “SCSILogicalUnit”).取文本 ())
.子程序 取SCSI端口, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “scsiport”).取文本 ())
.子程序 取SCSI目标ID, 文本型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “SCSITargetId”).取文本 ())
.子程序 取磁道扇区, 整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “SectorsPerTrack”).取数值 ())
.子程序 取序列号, 文本型, 公开, 这个属性不支持Server 2003系统。
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (删首尾空 (查询类属性 (_格式化文本 (硬盘名称), “SerialNumber”).取文本 ()))
.子程序 取特征字, 整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “Signature”).取数值 ())
.子程序 取总大小, 长整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “Size”).取数值 ())
.子程序 取总的柱面数, 长整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalCylinders”).取数值 ())
.子程序 取柱面磁道, 整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalHeads”).取数值 ())
.子程序 取总的扇区数, 长整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalSectors”).取数值 ())
.子程序 取总的磁道数, 长整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalTracks”).取数值 ())
.子程序 取扇区字节, 整数型, 公开
.参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。
返回 (查询类属性 (_格式化文本 (硬盘名称), “BytesPerSector”).取数值 ())
.程序集 注册表操作, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 _打开项, 整数型
.参数 项名称, 文本型
.参数 是否创建, 逻辑型, 可空, 默认为假:打开 真:如果项不存在则创建项
.局部变量 局_根句柄, 整数型
.局部变量 局_项句柄, 整数型
.局部变量 局_项文本, 文本型
.局部变量 局_位置, 整数型
.局部变量 b, 整数型
局_位置 ＝ 寻找文本 (项名称, “\”, , 假)
局_项文本 ＝ 取文本左边 (项名称, 局_位置 － 1)
局_项文本 ＝ 到大写 (局_项文本)
.判断开始 (局_项文本 ＝ “HKEY_CLASSES_ROOT”)
    局_根句柄 ＝ 2147483648
.判断 (局_项文本 ＝ “HKEY_CURRENT_USER”)
    局_根句柄 ＝ 2147483649
.判断 (局_项文本 ＝ “HKEY_LOCAL_MACHINE”)
    局_根句柄 ＝ 2147483650
.判断 (局_项文本 ＝ “HKEY_USERS”)
    局_根句柄 ＝ 2147483651
.判断 (文本比较 (局_项文本, “HKEY_CURRENT_CONFIG”, 假) ＝ 0)
    局_根句柄 ＝ 2147483653
.默认
    返回 (0)
.判断结束
.如果 (是否创建)
    b ＝ RegCreateKeyA (局_根句柄, 取文本右边 (项名称, 取文本长度 (项名称) － 局_位置), 局_项句柄)
.否则
    b ＝ RegOpenKeyA (局_根句柄, 取文本右边 (项名称, 取文本长度 (项名称) － 局_位置), 局_项句柄)
.如果结束
.如果真 (b ＝ 0)
    返回 (局_项句柄)
.如果真结束
返回 (0)
.子程序 枚举子项, 整数型, 公开, 枚举指定项名称下的子项(成功返回子项目数,失败返回-1)
.参数 项名称, 文本型
.参数 子项, 文本型, 可空 数组, 获取的子项数组
.局部变量 局_a, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_项名, 文本型
清除数组 (子项)
局_a ＝ _打开项 (项名称)
.如果真 (局_a ＝ 0)
    返回 (-1)
.如果真结束
局_项名 ＝ 取空白文本 (256)
.判断循环首 (RegEnumKeyA (局_a, 局_计次, 局_项名, 256) ＝ 0)
    加入成员 (子项, 局_项名)
    局_计次 ＝ 局_计次 ＋ 1
    处理事件 ()
.判断循环尾 ()
RegCloseKey (局_a)
返回 (取数组成员数 (子项))
.子程序 枚举键名, 整数型, 公开, 枚举指定项名称下的键名(成功返回键名数,失败返回-1)
.参数 项名称, 文本型
.参数 键名, 文本型, 可空 数组, 获取的键名数组
.参数 键值, 字节集, 可空 数组, 对应键名的键值
.参数 类型, 整数型, 可空 数组, 对应键值的类型
.局部变量 局_项句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 缓存键名, 文本型
.局部变量 缓存键值, 字节集
.局部变量 局_键值缓寸, 整数型
.局部变量 局_类型, 整数型
.局部变量 ftime, 文件时间
.局部变量 局_子键数量, 整数型
.局部变量 局_返回值
清除数组 (键名)
清除数组 (键值)
清除数组 (类型)
局_项句柄 ＝ _打开项 (项名称)
.如果真 (局_项句柄 ＝ 0)
    返回 (-1)
.如果真结束
局_返回值 ＝ RegQueryInfoKey (局_项句柄, 字符 (0), 字符 (0), 0, 0, 0, 0, 局_子键数量, 0, 0, 0, ftime)
.如果真 (局_返回值 ＝ 0)
    缓存键名 ＝ 取空白文本 (256)
    .变量循环首 (0, 局_子键数量 － 1, 1, 局_计次)
        RegEnumValueA (局_项句柄, 局_计次, 缓存键名, 256, 0, 局_类型, 缓存键值, 局_键值缓寸)
        缓存键值 ＝ 取空白字节集 (局_键值缓寸 ＋ 1)
        局_返回值 ＝ RegEnumValueA (局_项句柄, 局_计次, 缓存键名, 256, 0, 局_类型, 缓存键值, 局_键值缓寸)
        .如果真 (局_返回值 ＝ 0)
            加入成员 (键名, 缓存键名)
            加入成员 (键值, 缓存键值)
            加入成员 (类型, 局_类型)
        .如果真结束
    .变量循环尾 ()
.如果真结束
RegCloseKey (局_项句柄)
返回 (取数组成员数 (键名))
.子程序 取键名类型, 文本型, 公开, 失败返回空文本
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, 可空, 如：3600，留空将取第一个，(默认)
.局部变量 局_项句柄, 整数型
.局部变量 局_类型, 整数型
.局部变量 缓存键值, 字节集
.局部变量 局_键值缓寸, 整数型
.局部变量 局_计次, 整数型
.局部变量 缓存键名, 文本型
局_项句柄 ＝ _打开项 (项名称)
缓存键名 ＝ 取空白文本 (256)
.判断循环首 (RegEnumValueA (局_项句柄, 局_计次, 缓存键名, 256, 0, 局_类型, 缓存键值, 局_键值缓寸) ＝ 0)
    .如果真 (缓存键名 ＝ 键名)
        跳出循环 ()
    .如果真结束
    局_计次 ＝ 局_计次 ＋ 1
    局_类型 ＝ -1
.判断循环尾 ()
.判断开始 (局_类型 ＝ 0)
    返回 (“REG_NONE - 字节集，值为：” ＋ 到文本 (局_类型))
.判断 (局_类型 ＝ 1)
    返回 (“REG_SZ - 字符串值，值为：” ＋ 到文本 (局_类型))
.判断 (局_类型 ＝ 2)
    返回 (“REG_REG_EXPAND_SZ - 可扩充字符串值，值为：” ＋ 到文本 (局_类型))
.判断 (局_类型 ＝ 3)
    返回 (“REG_BINARY - 二进制，值为：” ＋ 到文本 (局_类型))
.判断 (局_类型 ＝ 4)
    返回 (“REG_DWORD - DWORD，值为：” ＋ 到文本 (局_类型))
.判断 (局_类型 ＝ 7)
    返回 (“REG_MULTI_SZ - 多字符串值，值为：” ＋ 到文本 (局_类型))
.默认
.判断结束
RegCloseKey (局_项句柄)
返回 (“”)
.子程序 是否存在, 逻辑型, 公开, 判断指定注册项名称(键名)是否存在(存在返回真,否则返回假)
.参数 项名称, 文本型, , 欲判断的项名称
.参数 键名, 文本型, 可空, 欲判断的键名.如果为空则只判断项名称是否存在
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 值, 字节集
a ＝ _打开项 (项名称)
.如果真 (是否为空 (键名))
    RegCloseKey (a)
    返回 (a ≠ 0)
.如果真结束
值 ＝ 取空白字节集 (256)
b ＝ RegQueryValueExA (a, 键名, 0, 0, 值, 256)
RegCloseKey (a)
返回 (b ＝ 0)
.子程序 刷新项, 逻辑型, 公开, 将对项和它的子项作出的改动实际写入磁盘
.参数 项名称, 文本型
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 值, 字节集
a ＝ _打开项 (项名称)
.如果真 (a ＝ 0)
    返回 (假)
.如果真结束
b ＝ RegFlushKey (a)
RegCloseKey (a)
返回 (b ＝ 0)
.子程序 写字节集, 逻辑型, 公开, [REG_NONE]
.参数 项名称, 文本型
.参数 键名, 文本型
.参数 欲写入值, 字节集
.参数 类型, 整数型, 可空, 可空：写入的类型
.局部变量 项句柄, 整数型
.局部变量 b, 整数型
.局部变量 值, 字节集
项句柄 ＝ _打开项 (项名称, 真)
.如果真 (项句柄 ＝ 0)
    返回 (假)
.如果真结束
b ＝ RegSetValueExA (项句柄, 键名, 0, 类型, 欲写入值, 取字节集长度 (欲写入值))
RegCloseKey (项句柄)
返回 (b ＝ 0)
.子程序 取字节集, 字节集, 公开, [REG_NONE]
.参数 项名称, 文本型
.参数 键名, 文本型
.参数 类型, 整数型, 参考 可空, 可空：取出数据的类型
.局部变量 项句柄, 整数型
.局部变量 项值, 整数型
.局部变量 值, 字节集
.局部变量 长, 整数型
项句柄 ＝ _打开项 (项名称)
.如果真 (项句柄 ＝ 0)
    返回 ({  })
.如果真结束
项值 ＝ RegQueryValueExA (项句柄, 键名, 0, 类型, 值, 长)
值 ＝ 取空白字节集 (长)
项值 ＝ RegQueryValueExA (项句柄, 键名, 0, 类型, 值, 长)
RegCloseKey (项句柄)
.如果真 (项值 ＝ 0)
    返回 (值)
.如果真结束
返回 ({  })
.子程序 写注册项Ex, 逻辑型, 公开, 用于写入带有斜杠的注册项
.参数 根目录, 整数型
.参数 注册表路径, 文本型
.参数 注册表子项名, 文本型
.参数 欲写入值, 字节集
.参数 写入类型, 整数型, 可空, #REG_
.局部变量 root, 整数型
.局部变量 hkey, 整数型
.局部变量 hsubkey, 整数型
.局部变量 ret, 逻辑型
.如果真 (是否为空 (写入类型))
    写入类型 ＝ 1
.如果真结束
root ＝ 多项选择 (根目录, -2147483648, -2147483643, -2147483647, -2147483646, -2147483645)
.如果真 (RegOpenKeyExA (root, “”, 0, 位或 (131097, 131078), hkey) ＝ 0)
    .如果真 (RegCreateKeyExA (hkey, 注册表路径, 0, 0, 0, 位或 (131097, 131078), 0, hsubkey, 0) ＝ 0)
        .如果真 (RegSetValueExA (hsubkey, 注册表子项名, 0, 写入类型, 欲写入值, 取字节集长度 (欲写入值)) ＝ 0)
            ret ＝ 真
        .如果真结束
        RegCloseKey (hsubkey)
    .如果真结束
    RegCloseKey (hkey)
.如果真结束
返回 (ret)
.子程序 写DWORD值, 逻辑型, 公开, [REG_DWORD]成功返回真,失败返回假
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
.参数 欲写入值, 整数型, , 如：0
返回 (写字节集 (项名称, 键名, 到字节集 (欲写入值), 4))
.子程序 取DWORD值, 整数型, 公开, [REG_DWORD]
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
返回 (取字节集数据 (取字节集 (项名称, 键名, 4), #整数型, ))
.子程序 写二进制值, 逻辑型, 公开, [REG_BINARY]成功返回真,失败返回假
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
.参数 欲写入值, 字节集
返回 (写字节集 (项名称, 键名, 欲写入值, 3))
.子程序 取二进制值, 字节集, 公开, [REG_BINARY]
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
返回 (取字节集 (项名称, 键名, 3))
.子程序 写字符串值, 逻辑型, 公开, [REG_SZ]成功返回真,失败返回假
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
.参数 欲写入值, 文本型
返回 (写字节集 (项名称, 键名, 到字节集 (欲写入值) ＋ { 0 }, 1))
.子程序 取字符串值, 文本型, 公开, [REG_SZ]
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
返回 (到文本 (取字节集 (项名称, 键名, 1)))
.子程序 写多字符串值, 逻辑型, 公开, [REG_MULTI_SZ]成功返回真,失败返回假
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
.参数 欲写入值, 文本型
返回 (写字节集 (项名称, 键名, 子字节集替换 (到字节集 (欲写入值), { 13, 10 }, { 0 }, , ) ＋ { 0, 0 }, 7))
.子程序 取多字符串值, 文本型, 公开, [REG_MULTI_SZ]
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
返回 (到文本 (子字节集替换 (取字节集 (项名称, 键名, 7), { 0 }, { 13, 10 }, , )))
.子程序 写可扩充字符串值, 逻辑型, 公开, [REG_EXPAND_SZ]成功返回真,失败返回假
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 键名, 文本型, , 如：3600
.参数 欲写入值, 文本型
返回 (写字节集 (项名称, 键名, 到字节集 (欲写入值) ＋ { 0 }, 2))
.子程序 取可扩充字符串值, 文本型, 公开, [REG_REG_EXPAND_SZ]
.参数 项名称, 文本型
.参数 键名, 文本型
返回 (到文本 (取字节集 (项名称, 键名, 2)))
.子程序 删除项, 逻辑型, 公开, 删除指定项名称以及它的所有子项与键值
.参数 项名称, 文本型, , 欲删除的项名称,尾部不要加"\"
.局部变量 a, 整数型
.局部变量 b, 整数型
.局部变量 c, 整数型
.局部变量 子项, 文本型, , "0"
.局部变量 局_计次, 整数型
.如果真 (取文本右边 (项名称, 1) ＝ “\”)
    返回 (假)
.如果真结束
c ＝ 倒找文本 (项名称, “\”, , 假)
a ＝ _打开项 (取文本左边 (项名称, c))
.如果真 (a ＝ 0)
    返回 (假)
.如果真结束
.计次循环首 (枚举子项 (项名称, 子项), 局_计次)
    删除项 (项名称 ＋ “\” ＋ 子项 [局_计次])
.计次循环尾 ()
b ＝ RegDeleteKeyA (a, 取文本右边 (项名称, 取文本长度 (项名称) － c))
RegCloseKey (a)
返回 (b ＝ 0)
.子程序 删除键名, 逻辑型, 公开, 删除指定项下的某个键名
.参数 项名称, 文本型, , 欲删除键名所在的项名称
.参数 键名, 文本型, , 欲删除的键名
.局部变量 a, 整数型
.局部变量 b, 整数型
a ＝ _打开项 (项名称)
.如果真 (a ＝ 0)
    返回 (假)
.如果真结束
b ＝ RegDeleteValueA (a, 键名)
RegCloseKey (a)
返回 (b ＝ 0)
.子程序 取字符串值_CMD, 文本型, 公开, 用CMD读取方式取指定字符串值
.参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
.参数 类型, 整数型, 可空, 如：#REG_SZ
.参数 键名, 文本型, , 如：3600
.局部变量 命令行, 文本型
.局部变量 Type, 文本型
' https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=14302857&pid=15062805
命令行 ＝ 系统_取DOS执行结果 (“REG QUERY ” ＋ 项名称 ＋ “ /v ” ＋ 键名 ＋ “ /reg:” ＋ 选择 (系统_是否64位操作系统 (), “64”, “32”))
.如果真 (类型 ≤ 0 且 类型 ＞ 7)
    类型 ＝ #REG_SZ
.如果真结束
Type ＝ 多项选择 (类型, “REG_SZ”, “REG_EXPAND_SZ”, “REG_BINARY”, “REG_DWORD”, “REG_DWORD_BIG_ENDIAN”, “REG_LINK”, “REG_MULTI_SZ”)
命令行 ＝ 文本_取出中间文本 (命令行, 键名 ＋ “    ” ＋ Type ＋ “    ”, #换行符, , )
返回 (命令行)
.程序集 注册表操作Ex, , 公开, 注册表操作,包括注册表的读,写.支持64位
.程序集变量 IsWow64, 逻辑型, , , 判断是否为64位系统,如果是则进行64位的读写操作
.程序集变量 m_Error, 整数型
.程序集变量 m_键句柄, 整数型, , , 记录句柄,在类销毁时释放
.程序集变量 m_是否已打开, 逻辑型
.程序集变量 m_当前键目录, 整数型
.程序集变量 m_当前键, 文本型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
m_当前键 ＝ “”
IsWow64Process (-1, IsWow64)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
关闭键Ex ()
.子程序 方法_置为64位Ex_作废, , , 该方法只能在64位系统中调用,调用之后,将读取64位的注册表,否则默认为32位注册表
m_当前键 ＝ “”
IsWow64 ＝ 真
.子程序 方法_置为32位Ex_作废, , , 置为读写32位的注册表
m_当前键 ＝ “”
IsWow64 ＝ 假
.子程序 关闭键Ex, 整数型, 公开, 关闭一个已经打开的键句柄,关闭之后需要重新调用打开键Ex才能进行其他操作,如果已经关闭则返回-1
.如果真 (m_是否已打开)
    m_Error ＝ RegCloseKey (m_键句柄)
    m_是否已打开 ＝ 假
    m_当前键 ＝ “”
    m_当前键目录 ＝ -1
    返回 (m_Error)
.如果真结束
返回 (-1)
.子程序 打开键Ex, 整数型, 公开, 如果键不存在,则失败.成功键的句柄,失败返回-1,通过取最后错误查看错误码;注意,使用该命令时,如果键已打开,则自动关闭键后在执行本操作
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.局部变量 局部_标志位, 整数型
.局部变量 临时_句柄, 整数型
.局部变量 重定向键, 文本型
.如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名 且 m_是否已打开)
    返回 (m_键句柄)
.如果真结束
关闭键Ex ()
.如果 (IsWow64)  ' ; 64位注册表
    局部_标志位 ＝ #KEY_WOW64_64KEY
.否则
    局部_标志位 ＝ #KEY_WOW64_32KEY
.如果结束
局部_标志位 ＝ 位或 (局部_标志位, #KEY_ALL_ACCESS)
' 注意:这里的samDesired 采用的是  #KEY_ALL_ACCESS  全部权限
.判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
    m_Error ＝ RegOpenCurrentUser (局部_标志位, 临时_句柄)
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_Error ＝ RegOpenKeyExA (临时_句柄, 全路径注册项名, 0, 局部_标志位, m_键句柄)
        RegCloseKey (临时_句柄)
    .如果真结束
.判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
    m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 局部_标志位, 临时_句柄)
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_Error ＝ RegOpenKeyExA (临时_句柄, 全路径注册项名, 0, 局部_标志位, m_键句柄)
        RegCloseKey (临时_句柄)
    .如果真结束
.默认
    m_Error ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 局部_标志位, m_键句柄)
.判断结束
.如果真 (m_Error ＝ #ERROR_SUCCESS)
    m_是否已打开 ＝ 真
    m_当前键目录 ＝ 键根目录
    m_当前键 ＝ 全路径注册项名
    返回 (m_键句柄)
.如果真结束
返回 (-1)
.子程序 创建并打开键Ex, 整数型, 公开, 如果键不存在,则创建一个键之后打开,如果键存在则直接打开;返回键的句柄,失败返回-1,通过取最后错误查看错误码;
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.局部变量 局部_标志位, 整数型
.局部变量 临时_句柄, 整数型
' REG_NONE                    ( 0 )   // No value type
' REG_SZ                      ( 1 )   // Unicode nul terminated string
' REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
' // (with environment variable references)
' REG_BINARY                  ( 3 )   // Free form binary
' REG_DWORD                   ( 4 )   // 32-bit number
' REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
' REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
' REG_LINK                    ( 6 )   // Symbolic Link (unicode)
' REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
' REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
' REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
' REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
' 上面这些信息是键的类型,暂时先留着备用.
.如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名)
    返回 (m_键句柄)
.如果真结束
关闭键Ex ()
局部_标志位 ＝ #KEY_ALL_ACCESS
.如果 (IsWow64)  ' ; 64位注册表
    局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_64KEY)
.否则
    局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_32KEY)
.如果结束
' 注意:这里的samDesired 采用的是  #KEY_ALL_ACCESS  全部权限
.判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
    m_Error ＝ RegOpenCurrentUser (局部_标志位, 临时_句柄)
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_Error ＝ RegCreateKeyExA (临时_句柄, 全路径注册项名, 0, 0, 1, 局部_标志位, #REG_OPTION_NON_VOLATILE, m_键句柄, 0)  ' 忽略最后一项
        RegCloseKey (临时_句柄)
    .如果真结束
.判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
    m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 局部_标志位, 临时_句柄)
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_Error ＝ RegCreateKeyExA (临时_句柄, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 局部_标志位, 0, m_键句柄, 0)  ' 忽略最后一项
        RegCloseKey (临时_句柄)
    .如果真结束
.默认
    m_Error ＝ RegCreateKeyExA (键根目录, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 局部_标志位, 0, m_键句柄, 0)  ' 忽略最后一项
.判断结束
.如果真 (m_Error ＝ #ERROR_SUCCESS)
    m_是否已打开 ＝ 真
    m_当前键目录 ＝ 键根目录
    m_当前键 ＝ 全路径注册项名
    返回 (m_键句柄)
.如果真结束
返回 (-1)
.子程序 枚举子项Ex, 整数型, 公开, 枚举指定项名称下的子项(成功返回子项目数,失败返回-1);
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 子项, 文本型, 参考 可空 数组, 获取的子项数组
.局部变量 局_计次, 整数型
.局部变量 局_项名, 文本型
.如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
    .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
        返回 (m_Error)
    .如果真结束
.如果真结束
清除数组 (子项)
局_项名 ＝ 取空白文本 (256)
m_Error ＝ RegEnumKeyA (m_键句柄, 局_计次, 局_项名, 256)
.如果真 (m_Error ≠ 0 且 m_Error ≠ #ERROR_NO_MORE_ITEMS)
    返回 (m_Error)
.如果真结束
.判断循环首 (m_Error ＝ 0)
    加入成员 (子项, 局_项名)
    局_计次 ＝ 局_计次 ＋ 1
    m_Error ＝ RegEnumKeyA (m_键句柄, 局_计次, 局_项名, 256)
.判断循环尾 ()
.如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
    m_Error ＝ 0
.如果真结束
返回 (取数组成员数 (子项))
.子程序 方法_取最后错误代码Ex, 整数型, 公开, 取出这个值后,可以根据GetlastError获取错误信息
返回 (m_Error)
.子程序 枚举键信息Ex, 整数型, 公开, 枚举指定项名称下的键信息(成功返回键名数,失败返回-1),需要先调用打开键Ex或打开键Ex2
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 注册表键信息, 注册表_键, 参考 数组, 作为返回值返回
.局部变量 局_计次, 整数型
.局部变量 局_键值缓冲区, 整数型
.局部变量 局_句柄
.局部变量 临时_注册表键信息, 注册表_键
.如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
    局_句柄 ＝ 打开键Ex (键根目录, 全路径注册项名)
    .如果真 (局_句柄 ＝ -1)
        返回 (m_Error)
    .如果真结束
    清除数组 (注册表键信息)
.如果真结束
临时_注册表键信息.键名称 ＝ 取空白文本 (256)
.判断循环首 (局_句柄 ≠ 0)
    RegEnumValueA (m_键句柄, 局_计次, 临时_注册表键信息.键名称, 256, 0, 临时_注册表键信息.类型, 临时_注册表键信息.键值, 局_键值缓冲区)
    临时_注册表键信息.键值 ＝ 取空白字节集 (局_键值缓冲区)
    m_Error ＝ RegEnumValueA (m_键句柄, 局_计次, 临时_注册表键信息.键名称, 256, 0, 临时_注册表键信息.类型, 临时_注册表键信息.键值, 局_键值缓冲区)
    .如果 (m_Error ＝ 0)
        加入成员 (注册表键信息, 临时_注册表键信息)
    .否则
        跳出循环 ()
    .如果结束
    局_计次 ＝ 局_计次 ＋ 1
.判断循环尾 ()
.如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
    m_Error ＝ 0
.如果真结束
返回 (取数组成员数 (注册表键信息))
.子程序 键是否存在Ex, 逻辑型, 公开, 判断键是否存在,亦可可以直接使用"打开键Ex"进行判断
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.局部变量 局部_标志位, 整数型
.局部变量 临时_句柄, 整数型
.局部变量 状态, 整数型
局部_标志位 ＝ #KEY_READ
.如果 (IsWow64)  ' ; 64位注册表
    局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_64KEY)
.否则
    局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_32KEY)
.如果结束
' 注意:这里的samDesired 采用的是  #KEY_READ  读取权限
状态 ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 局部_标志位, 临时_句柄)
RegCloseKey (临时_句柄)
.如果真 (状态 ＝ #ERROR_SUCCESS)
    返回 (真)
.如果真结束
返回 (假)
.子程序 读取键值Ex, 整数型, 公开, 成功返回0,失败返回错误码.需要先调用打开键Ex或打开键Ex2
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 键名称, 文本型, , 键的名称
.参数 项目信息_out, 注册表_键, 参考, 用于返回的
.局部变量 局_所需长度, 整数型
.如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
    .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
        返回 (m_Error)
    .如果真结束
.如果真结束
项目信息_out.键名称 ＝ 全路径注册项名
m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, {  }, 局_所需长度)
.如果真 (m_Error ＝ #ERROR_MORE_DATA)
    项目信息_out.键值 ＝ 取空白字节集 (局_所需长度)
    m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, 项目信息_out.键值, 局_所需长度)
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        项目信息_out.键值 ＝ 取字节集左边 (项目信息_out.键值, 取字节集长度 (项目信息_out.键值) － 1)
    .如果真结束
.如果真结束
返回 (m_Error)
.子程序 写入键值Ex_文本, 整数型, 公开, 成功返回0,失败返回错误码；注意，该函数只能写入文本型的值
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 键名称, 文本型, , 键的名称
.参数 欲写入值, 字节集, , 使用 到字节集()
.参数 写入类型, 整数型, , 只适用于：REG_SZ;REG_EXPAND_SZ;REG_MULTI_SZ;#REG_BINARY
.参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
.局部变量 bRet, 整数型
.如果真 (写入类型 ≠ #REG_SZ 且 写入类型 ≠ #REG_EXPAND_SZ 且 写入类型 ≠ #REG_MULTI_SZ 且 写入类型 ≠ #REG_BINARY)
    输出调试文本 (“写入的类型不正确，如果需要写入数值型，请调用【写入键值Ex_数值】”)
    返回 (-1)
.如果真结束
.如果真 (是否自动创建)
    m_当前键 ＝ “1”
.如果真结束
.如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
    .判断开始 (是否自动创建)
        bRet ＝ 创建并打开键Ex (键根目录, 全路径注册项名)  ' 自动创建这个键
    .默认
        bRet ＝ 打开键Ex (键根目录, 全路径注册项名)
    .判断结束
    .如果真 (bRet ＝ -1)
        返回 (m_Error)
    .如果真结束
.如果真结束
欲写入值 ＝ 欲写入值 ＋ { 0 }
m_Error ＝ RegSetValueExA (m_键句柄, 键名称, 0, 写入类型, 欲写入值, 取字节集长度 (欲写入值))
返回 (m_Error)
.子程序 写入键值Ex_数值, 整数型, 公开
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 键名称, 文本型, , 键的名称
.参数 欲写入值, 长整数型, , 注意。理论上：DWORD最大值为：4294967295  QWORD最大值为：18446744073709551615，但是QWORD最大值超过了整数型的最大长度，请谨慎使用
.参数 写入类型, 整数型, , 只适用于：#REG_DWORD;#REG_DWORD_BIG_ENDIAN;
.参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
.局部变量 bRet, 整数型
.局部变量 临时_写入数据, 字节集
.局部变量 临时_数据长度, 整数型
.如果真 (写入类型 ≠ #REG_DWORD 且 写入类型 ≠ #REG_DWORD_BIG_ENDIAN 且 写入类型 ≠ #REG_QWORD)
    输出调试文本 (“写入的类型不正确，如果需要写入文本值，请调用【写入键值Ex_文本】”)
    返回 (-1)
.如果真结束
.如果真 (是否自动创建)
    m_当前键 ＝ “1”
.如果真结束
.如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
    .判断开始 (是否自动创建)
        bRet ＝ 创建并打开键Ex (键根目录, 全路径注册项名)  ' 自动创建这个键
    .默认
        bRet ＝ 打开键Ex (键根目录, 全路径注册项名)
    .判断结束
    .如果真 (bRet ＝ -1)
        返回 (m_Error)
    .如果真结束
.如果真结束
临时_写入数据 ＝ 到字节集 (欲写入值)
临时_数据长度 ＝ 4
.如果真 (写入类型 ＝ #REG_QWORD)
    补充字节集长度 (临时_写入数据, 8)
    临时_数据长度 ＝ 8
.如果真结束
m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, 写入类型, 临时_写入数据, 临时_数据长度)
返回 (m_Error)
.子程序 写QWORD_64值, 逻辑型, 公开, 写入64位长整数值,成功返回真,失败返回假.源码由@pp25729391提供。
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 键名称, 文本型, , 键的名称
.参数 值_十六进制文本, 文本型
.局部变量 欲写入值, 字节集
.局部变量 i, 整数型
.如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
    创建并打开键Ex (键根目录, 全路径注册项名)  ' 自动创建这个键
.如果真结束
.变量循环首 (取文本长度 (值_十六进制文本), 1, -2, i)
    .如果真 (i ≠ 1)
        欲写入值 ＝ 欲写入值 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, i － 1, 2))), 1)
    .如果真结束
    .如果真 (i ＝ 1)
        欲写入值 ＝ 欲写入值 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, i, 1))), 1)
    .如果真结束
.变量循环尾 ()
补充字节集长度 (欲写入值, 8)
m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, #REG_QWORD, 欲写入值, 8)
返回 (m_Error ＝ 0)
.子程序 补充字节集长度
.参数 数据, 字节集
.参数 字节集的总长, 整数型
.局部变量 循环的次数, 整数型
.局部变量 计次, 整数型
.如果真 (字节集的总长 ＞ 取字节集长度 (数据))
    循环的次数 ＝ 字节集的总长 － 取字节集长度 (数据)
    .计次循环首 (循环的次数, 计次)
        数据 ＝ 数据 ＋ { 0 }
    .计次循环尾 ()
.如果真结束
返回 ()
.子程序 删除键值Ex, 整数型, 公开, 删除一个键值.
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.参数 键名, 文本型
.如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
    .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
        返回 (m_Error)
    .如果真结束
.如果真结束
m_Error ＝ RegDeleteValueA (m_键句柄, 键名)
返回 (m_Error)
.子程序 删除注册表项, 整数型, 公开, 删除整个项,项下面所有的键值将会被自动删除.
.参数 键根目录, 整数型, , #HKEY_*开头的常量
.参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
.局部变量 bRet, 整数型
.局部变量 临时_项目, 文本型
bRet ＝ 倒找文本 (全路径注册项名, “\”, , 假)
临时_项目 ＝ 取文本左边 (全路径注册项名, bRet － 1)
.如果真 (打开键Ex (键根目录, 临时_项目) ＝ -1)
    返回 (m_Error)
.如果真结束
临时_项目 ＝ 取文本右边 (全路径注册项名, 取文本长度 (全路径注册项名) － bRet)
m_Error ＝ RegDeleteKeyA (m_键句柄, 临时_项目)
返回 (m_Error)
.子程序 格式化键值类型, 文本型, 公开, 说明键值
.参数 键值, 整数型, , REG_*
.如果真 (键值 ＞ 11 或 键值 ≤ 0)
    返回 (“键值非法”)
.如果真结束
返回 (多项选择 (键值, “REG_SZ”, “REG_EXPAND_SZ”, “REG_BINARY”, “REG_DWORD”, “REG_DWORD_BIG_ENDIAN”, “REG_LINK”, “REG_MULTI_SZ”, “REG_RESOURCE_LIST”, “NULL”, “NULL”, “REG_QWORD”))
.程序集 类_邮槽服务端, , 公开, http://msdn.microsoft.com/en-us/library/windows/desktop/aa365147(v=vs.85).aspx
.程序集变量 hSlot, , , , 本类源码来自于SoftApiModule模块
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
CloseHandle (hSlot)
.子程序 创建, 逻辑型, 公开, 创建成功返回真，否则返回假。
.参数 邮槽名称, 文本型
hSlot ＝ CreateMailslot (“\\.\mailslot\” ＋ 邮槽名称, 0, -1, 0)  ' MAILSLOT_WAIT_FOREVER
返回 (hSlot ≠ 0)
.子程序 关闭, 逻辑型, 公开, 关闭邮槽服务器。
返回 (CloseHandle (hSlot))
.子程序 读数据, 逻辑型, 公开, 只能在服务器端从邮槽中取出数据。读取成功返回真，否则返回假。
.参数 数据, 字节集, 参考, 提供参数数据时只能提供变量。从向邮槽中读出的数据。
.局部变量 Status
.局部变量 cbMessage, 整数型
.局部变量 cMessage, 整数型
.局部变量 lpszBuffer
.局部变量 cbRead, 整数型
.局部变量 bool, 逻辑型
.如果真 (GetMailslotInfo (hSlot, 0, cbMessage, cMessage, 0))
    .如果真 (cbMessage ≠ -1)
        lpszBuffer ＝ HeapAlloc (GetProcessHeap (), 8, 1000)
        bool ＝ ReadFile_整数型 (hSlot, lpszBuffer, cbMessage, cbRead, 0)
        数据 ＝ 指针到字节集 (lpszBuffer, cbRead)
        HeapFree (GetProcessHeap (), 8, lpszBuffer)
    .如果真结束
    返回 (bool)
.如果真结束
返回 (假)
.程序集 类_任务栏, , 公开, http://msdn.microsoft.com/en-us/library/windows/desktop/bb774652(v=vs.85).aspx
.程序集变量 ppv
.程序集变量 objShell
.程序集变量 HotKeyStatus, 逻辑型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.局部变量 CLSID_TaskbarList, GUID
.局部变量 IID_ITaskbarList, GUID
.局部变量 CLSID_Shell, GUID
.局部变量 IID_IShellDispatch5, GUID
CLSID_TaskbarList ＝ COM_StringToCLSID (“{56FDF344-FD6D-11d0-958A-006097C9A090}”)
IID_ITaskbarList ＝ COM_StringtoIID (“{56FDF342-FD6D-11d0-958A-006097C9A090}”)
.如果真 (CoCreateInstance (CLSID_TaskbarList, 0, 1, IID_ITaskbarList, ppv) ＝ 0)
    COM_调用COM方法 (ppv, 3)  ' HrInit
.如果真结束
CLSID_Shell ＝ COM_StringToCLSID (“{13709620-C279-11CE-A49E-444553540000}”)
IID_IShellDispatch5 ＝ COM_StringtoIID (“{866738b9-6cf2-4de8-8767-f794ebe74f4e}”)
CoCreateInstance (CLSID_Shell, 0, 1, IID_IShellDispatch5, objShell)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.如果真 (ppv ≠ 0)
    COM_Release (ppv)
.如果真结束
.如果真 (objShell ≠ 0)
    COM_Release (objShell)
.如果真结束
.子程序 显示图标, 逻辑型, 公开
.参数 窗口句柄
返回 (COM_调用COM方法 (ppv, 4, 窗口句柄) ＝ 0)  ' AddTab
.子程序 隐藏图标, 逻辑型, 公开
.参数 窗口句柄
返回 (COM_调用COM方法 (ppv, 5, 窗口句柄) ＝ 0)  ' DeleteTab
.子程序 激活图标, 逻辑型, 公开, 激活任务栏指定图标，并非激活窗口。
.参数 窗口句柄
返回 (COM_调用COM方法 (ppv, 6, 窗口句柄) ＝ 0)  ' ActivateTab
.子程序 取消激活, 逻辑型, 公开, 取消指定激活指定图标。
.参数 窗口句柄
返回 (COM_调用COM方法 (ppv, 7, 窗口句柄) ＝ 0)  ' SetActiveAlt
.子程序 注册热键, , 公开
.参数 功能键, 整数型, , 1=Alt键；2=Ctrl键；4=Shift键；8=Win键，组合则相加。
.参数 主热键, , , 键代码，可以使用易语言中的键代码常量。
.参数 执行事件, 子程序指针
.局部变量 bool, 逻辑型
.局部变量 msg, MSG
HotKeyStatus ＝ 假
.如果真 (RegisterHotKey (0, 1268, 功能键, 主热键))
    .判断循环首 (GetMessageA (msg, 0, 0, 0))
        .判断开始 (msg.message ＝ 786)  ' #WM_HOTKEY
            程序_Call (到整数 (执行事件))
        .判断 (HotKeyStatus)
            跳出循环 ()
        .默认
        .判断结束
        TranslateMessage (msg)
        DispatchMessage (msg)
    .判断循环尾 ()
.如果真结束
.子程序 取消热键, 逻辑型, 公开
.如果真 (UnregisterHotKey (0, 1268))
    HotKeyStatus ＝ 真
    返回 (真)
.如果真结束
返回 (假)
.子程序 取句柄, 整数型, 公开
返回 (FindWindowA (“Shell_TrayWnd”, 字符 (0)))
.子程序 隐藏, 逻辑型, 公开
返回 (ShowWindow (取句柄 (), 0))
.子程序 显示, 逻辑型, 公开
返回 (ShowWindow (取句柄 (), 1))
.子程序 取高度, 整数型, 公开
.局部变量 ABD, 精易_任务相关
.局部变量 Ret, 整数型
.局部变量 屏幕高度, 整数型
SHAppBarMessage (5, ABD)
Ret ＝ SHAppBarMessage (4, ABD)
系统_取屏幕分辨率 (, , , 屏幕高度, )
返回 (屏幕高度 － ABD.rc.顶边)
.子程序 监视全屏, , 公开
.参数 窗口句柄, , , 第三方窗口无效，易中用 取窗口句柄()
.参数 处理程序, 子程序指针, , 参数1；事件类型【整数型】输出值：1全屏；0退出全屏
.局部变量 abd, 精易_任务相关
.局部变量 Subclass
abd.cbSize ＝ 36
abd.hwnd ＝ 窗口句柄
abd.uCallbackMessage ＝ 11286
SetPropA (abd.hwnd, “Callback AppBar”, 到整数 (处理程序))
SHAppBarMessage (0, abd)  ' #ABM_NEW
Subclass ＝ 类回调_取类地址 (15, 4)
SetPropA (abd.hwnd, “Callback Proc”, SetWindowLongA (abd.hwnd, -4, Subclass))
.子程序 WindowProc, 整数型
.参数 hwnd
.参数 wMsg
.参数 wParam
.参数 lParam
.局部变量 SubAddress
.局部变量 SubProc
.判断开始 (wMsg ＝ 11286)
    .如果真 (wParam ＝ 2)  ' #ABN_FULLSCREENAPP
        SubAddress ＝ GetPropA (hwnd, “Callback AppBar”)
        程序_Call (SubAddress, lParam)
    .如果真结束
.默认
.判断结束
SubProc ＝ GetPropA (hwnd, “Callback Proc”)
返回 (CallWindowProcA (SubProc, hwnd, wMsg, wParam, lParam))
.子程序 是否隐藏, 逻辑型, 公开, 判断任务栏是否隐藏状态。
.局部变量 ABD, 精易_任务相关
.局部变量 uState
uState ＝ SHAppBarMessage (4, ABD)  ' ABM_GETSTATE
返回 (选择 (uState ＝ 0 或 uState ＝ 2, 假, 真))
.子程序 自动隐藏, 逻辑型, 公开, 设置任务栏自动隐藏，成功返回真，失败返回假。
.参数 启用, 逻辑型
.局部变量 ABD, 精易_任务相关
.局部变量 code
ABD.lParam ＝ 选择 (启用, 1, 0)  ' #ABS_AUTOHIDE
code ＝ SHAppBarMessage (10, ABD)  ' ABM_SETSTATE
返回 (code ＝ 1)
.子程序 取矩形, 整数型, 公开, 成功返回1，失败返回错误代码。
.参数 矩形, 精易_矩形, , 变量储存返回值。
.局部变量 ABD, 精易_任务相关
.局部变量 code
code ＝ SHAppBarMessage (5, ABD)  ' ABM_GETTASKBARPOS
矩形 ＝ ABD.rc
返回 (code)
.子程序 取位置, 整数型, 公开, 返回任务栏位置，返回值：0=左部；1=顶部；2=右部；3=底部
.局部变量 pabd, 精易_任务相关
SHAppBarMessage (5, pabd)  ' ABM_GETTASKBARPOS
返回 (pabd.uEdge)
.子程序 全部最小化, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 14) ＝ 0)  ' MinimizeAll
.如果真结束
返回 (假)
.子程序 撤销全部最小化, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 15) ＝ 0)  ' UndoMinimizeALL
.如果真结束
返回 (假)
.子程序 层叠窗口, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 17) ＝ 0)  ' CascadeWindows
.如果真结束
返回 (假)
.子程序 堆叠显示窗口, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 19) ＝ 0)  ' TileHorizontally
.如果真结束
返回 (假)
.子程序 并排显示窗口, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 18) ＝ 0)  ' TileVertically
.如果真结束
返回 (假)
.子程序 显示桌面, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 41) ＝ 0)  ' ToggleDesktop
.如果真结束
返回 (假)
.子程序 属性, 逻辑型, 公开
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 24) ＝ 0)  ' TrayProperties
.如果真结束
返回 (假)
.子程序 切换窗口, 逻辑型, 公开, 最底平台Vista，类似于按下键盘alt+Tab
.如果真 (objShell ≠ 0)
    返回 (COM_调用COM方法 (objShell, 44) ＝ 0)  ' WindowSwitcher
.如果真结束
返回 (假)
.子程序 锁定, 逻辑型, 公开, 锁定任务栏禁止更改任务大小与移动。重启explorer或重启后生效。
.参数 开启, 逻辑型
.局部变量 hKey
.局部变量 Status
.局部变量 bool, 逻辑型
.局部变量 flag, 整数型
IsWow64Process (GetCurrentProcess (), bool)
flag ＝ 选择 (bool, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY)
Status ＝ RegOpenKeyExA (2147483649, “Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced”, 0, 位或 (flag, #KEY_ALL_ACCESS), hKey)
.如果真 (Status ＝ 0)
    Status ＝ RegSetValueExA (hKey, “TaskbarSizeMove”, 0, 4, 到字节集 (选择 (开启, 1, 0)), 4)  ' #REG_DWORD
    RegFlushKey (hKey)
    RegCloseKey (hKey)
    返回 (Status ＝ 0)
.如果真结束
返回 (假)
.程序集 类_环境存取, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
CoUninitialize ()
.子程序 读环境变量, 文本型, 公开, 返回文本，它关连于一个操作系统环境变量。成功时返回所取得的值，失败则返回空文本。
.参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
.参数 环境变量名称, 文本型
.局部变量 objcet, 对象
.局部变量 sysenv, 对象
.局部变量 text, 文本型
.局部变量 Length, 整数型
CoInitialize (0)
.如果真 (objcet.创建 (“WScript.Shell”, ))
    sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
    text ＝ sysenv.读文本属性 (“Item”, 环境变量名称)
    objcet.清除 ()
    .如果真 (text ＝ “”)
        text ＝ 取空白文本 (256)
        Length ＝ GetEnvironmentVariable (环境变量名称, text, 256)
        返回 (选择 (Length ＞ 0, text, “”))
    .如果真结束
    返回 (text)
.如果真结束
返回 (“”)
.子程序 写环境变量, 逻辑型, 公开, 修改或建立指定的操作系统环境变量。成功返回真，失败返回假。
.参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
.参数 环境变量名称, 文本型
.参数 欲写入内容, 文本型
.局部变量 objcet, 对象
.局部变量 sysenv, 对象
.局部变量 bool, 逻辑型
CoInitialize (0)
.如果真 (objcet.创建 (“WScript.Shell”, ))
    sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
    bool ＝ sysenv.写属性 (“Item”, 环境变量名称, 欲写入内容)
    objcet.清除 ()
    返回 (bool)
.如果真结束
返回 (假)
.子程序 删除环境变量, 逻辑型, 公开, 删除系统环境变量，成功返回真，失败返回假。
.参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
.参数 环境变量名称, 文本型
.局部变量 objcet, 对象
.局部变量 sysenv, 对象
.局部变量 bool, 逻辑型
CoInitialize (0)
.如果真 (objcet.创建 (“WScript.Shell”, ))
    sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
    bool ＝ sysenv.数值方法 (“Remove”, 环境变量名称) ＝ 0
    sysenv.清除 ()
    objcet.清除 ()
    返回 (bool)
.如果真结束
返回 (假)
.子程序 取环境变量数, 整数型, 公开, 返回当前用户环境变量数量，失败返回-1。
.参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
.局部变量 objcet, 对象
.局部变量 sysenv, 对象
.局部变量 length
CoInitialize (0)
.如果真 (objcet.创建 (“WScript.Shell”, ))
    sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
    length ＝ sysenv.读数值属性 (“length”, )
    sysenv.清除 ()
    objcet.清除 ()
    返回 (length)
.如果真结束
返回 (-1)
.子程序 枚举环境变量, 整数型, 公开, 成功返回环境系统或当前用户环境变量数量失败返回-1。
.参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
.参数 环境变量列表, 文本型, 数组, 变量储存返回值。
.局部变量 objcet, 对象
.局部变量 sysenv, 对象
.局部变量 NewEnum, 对象
.局部变量 Success
.局部变量 Variant, 变体型
.局部变量 pcFetched, 整数型
CoInitialize (0)
.如果真 (objcet.创建 (“WScript.Shell”, ))
    sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
    NewEnum ＝ sysenv.对象型方法 (“_NewEnum”, )
    .循环判断首 ()
        Success ＝ COM_调用COM方法 (取对象指针 (NewEnum), 3, 1, 取变体型指针 (Variant), 取指针整数_ (pcFetched), , , , , , , )
        .如果真 (pcFetched ＝ 1)
            加入成员 (环境变量列表, Variant.取文本 ())
        .如果真结束
        处理事件 ()
    .循环判断尾 (Success ＝ 0)
    sysenv.清除 ()
    objcet.清除 ()
    返回 (取数组成员数 (环境变量列表))
.如果真结束
返回 (-1)
.子程序 取命令行, 整数型, 公开, 本命令可以取出在启动易程序时附加在其可执行文件名后面的所有以空格分隔的命令行文本段
.参数 命令行数组, 文本型, 数组, 存放被取回命令行文本的数组变量,本变量数组内被顺序填入在启动易程序时附加在其可执行文件名后面的以空格分隔的命令行文本段
.局部变量 szArglist, 整数型
.局部变量 nArgs, 整数型
.局部变量 Command, 整数型, , "0"
.局部变量 Length, 整数型
.局部变量 i, 整数型
清除数组 (命令行数组)
szArglist ＝ CommandLineToArgvW (GetCommandLineW (), nArgs)
.如果真 (nArgs ＝ 1)
    返回 (0)
.如果真结束
重定义数组 (Command, 假, nArgs)
Length ＝ lstrlen (szArglist) × 2
RtlMoveMemory (取数据_通用型_数组 (Command), szArglist, Length)
.变量循环首 (2, nArgs, 1, i)
    加入成员 (命令行数组, 编码_Unicode到Ansi (指针到字节集 (Command [i], lstrlen (Command [i]) × 2)))
.变量循环尾 ()
LocalFree (szArglist)
返回 (取数组成员数 (命令行数组))
.子程序 取运行目录, 文本型, 公开, 取当前被执行的易程序文件所处的目录。
.局部变量 path, 文本型
.局部变量 Length
path ＝ 取空白文本 (255)
Length ＝ GetCurrentDirectory (255, path)
返回 (选择 (Length ＞ 0, path, “”))
.子程序 取执行文件名, 文本型, 公开, 取当前被执行的易程序文件的名称。
.参数 是否带路径, 逻辑型, 可空
.局部变量 sbuffer, 文本型
.局部变量 Length
sbuffer ＝ 取空白文本 (256)
Length ＝ GetModuleFileNameExA (GetCurrentProcess (), GetModuleHandleA (字符 (0)), sbuffer, 256)
.如果真 (Length ＞ 0)
    .如果 (是否带路径)
        返回 (sbuffer)
    .否则
        返回 (文件_取文件名 (sbuffer, 真))
    .如果结束
.如果真结束
返回 (“”)
.子程序 取CMD路径, 文本型, 公开
.局部变量 sbuffer, 文本型
.局部变量 Length
sbuffer ＝ 取空白文本 (256)
Length ＝ GetEnvironmentVariable (“COMSPEC”, sbuffer, 256)
返回 (选择 (Length ＞ 0, sbuffer, “”))
.程序集 类_CPU信息, , 公开
.程序集变量 InitializeSecurity, 逻辑型
.程序集变量 WbemLocator
.程序集变量 ppNamespace
.程序集变量 pEnumerator
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 Init, 逻辑型
.参数 Server, 文本型
.参数 WQL, 文本型
.局部变量 CLSID_WbemLocator, GUID
.局部变量 IID_IWbemLocator, GUID
.局部变量 hres, 整数型
CoUninitialize ()
CoInitializeEx (0, 0)
.如果真 (InitializeSecurity ＝ 假)
    CoInitializeSecurity (0, -1, 0, 0, 0, 3, 0, 0, 0)
    InitializeSecurity ＝ 真
.如果真结束
CLSID_WbemLocator ＝ COM_StringToCLSID (“{4590f811-1d3a-11d0-891f-00aa004b2e24}”)
IID_IWbemLocator ＝ COM_StringtoIID (“{dc12a687-737f-11cf-884d-00aa004b2e24}”)
hres ＝ CoCreateInstance (CLSID_WbemLocator, 0, 1, IID_IWbemLocator, WbemLocator)
.如果真 (hres ≠ 0)
    CoUninitialize ()
    返回 (假)
.如果真结束
hres ＝ COM_调用COM方法 (WbemLocator, 3, COM_bstr_t (Server), 0, 0, 0, 0, 0, 0, 取指针_通用型 (ppNamespace), , )  ' ConnectServer
.如果真 (hres ≠ 0)
    CoUninitialize ()
    返回 (假)
.如果真结束
hres ＝ CoSetProxyBlanket (ppNamespace, 10, 0, 0, 3, 3, 0, 0)
.如果真 (hres ≠ 0)
    CoUninitialize ()
    返回 (假)
.如果真结束
hres ＝ COM_调用COM方法 (ppNamespace, 20, COM_bstr_t (“WQL”), COM_bstr_t (WQL), 位或 (32, 16), 0, 取指针_通用型 (pEnumerator))  ' ExecQuery
.如果真 (hres ≠ 0)
    CoUninitialize ()
    返回 (假)
.如果真结束
返回 (真)
.子程序 Uninit
COM_Release (WbemLocator)
COM_Release (pEnumerator)
COM_Release (ppNamespace)
CoUninitialize ()
.子程序 取地址宽度, 整数型, 公开, 失败返回-1。
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 AddressWidth
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“AddressWidth”), 0, Variant, 0, 0)
            AddressWidth ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (AddressWidth)
.子程序 取架构, 整数型, 公开, 失败返回-1。返回值：0=x86；1=MiPs；2=Alpha；3=PowerPC；5=ARM；6=Itanium-based systems；9=x64
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Architecture
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“Architecture”), 0, Variant, 0, 0)
            Architecture ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (Architecture)
.子程序 取状态, 整数型, 公开, 失败返回-1。返回值；0=未知；1=启用；2=用户通过CPU禁用BIOS设置；3=CPU禁用BIOS(POST错误)；4=CPU空闲。
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Architecture
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“CpuStatus”), 0, Variant, 0, 0)
            Architecture ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (Architecture)
.子程序 取当前时钟速度, 整数型, 公开, 失败返回-1。
.参数 CPU索引, , 可空
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 CurrentClockSpeed
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“CurrentClockSpeed”), 0, Variant, 0, 0)
            CurrentClockSpeed ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (CurrentClockSpeed)
.子程序 取当前电压, 整数型, 公开, 失败返回-1。
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 CurrentVoltage
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“CurrentVoltage”), 0, Variant, 0, 0)
            CurrentVoltage ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (CurrentVoltage)
.子程序 取数据宽度, 整数型, 公开, 失败返回-1。
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 DataWidth
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“DataWidth”), 0, Variant, 0, 0)
            DataWidth ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (DataWidth)
.子程序 取描述, 文本型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Description
.局部变量 sbuffer, 文本型
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (“”)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“Description”), 0, Variant, 0, 0)
            Description ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Description, lstrlen (Description) × 3))
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (sbuffer)
.子程序 取设备编号, 文本型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 DeviceID
.局部变量 sbuffer, 文本型
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (“”)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“DeviceID”), 0, Variant, 0, 0)
            DeviceID ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (DeviceID, lstrlen (DeviceID) × 3))
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (sbuffer)
.子程序 取二级缓存, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 L2CacheSize
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“L2CacheSize”), 0, Variant, 0, 0)
            L2CacheSize ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (L2CacheSize)
.子程序 取三级缓存, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 L3CacheSize
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“L3CacheSize”), 0, Variant, 0, 0)
            L3CacheSize ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (L3CacheSize)
.子程序 取占用率, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 LoadPercentage
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“LoadPercentage”), 0, Variant, 0, 0)
            LoadPercentage ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (LoadPercentage)
.子程序 取制造商, 文本型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Manufacturer
.局部变量 sbuffer, 文本型
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (“”)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“Manufacturer”), 0, Variant, 0, 0)
            Manufacturer ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Manufacturer, lstrlen (Manufacturer) × 3))
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (sbuffer)
.子程序 最大时钟速度, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 MaxClockSpeed
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“MaxClockSpeed”), 0, Variant, 0, 0)
            MaxClockSpeed ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (MaxClockSpeed)
.子程序 取名称, 文本型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Name
.局部变量 sbuffer, 文本型
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (“”)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“Name”), 0, Variant, 0, 0)
            Name ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Name, lstrlen (Name) × 3))
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (sbuffer)
.子程序 取型号, 文本型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Name
.局部变量 sbuffer, 文本型
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (“”)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“Name”), 0, Variant, 0, 0)
            Name ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Name, lstrlen (Name) × 3))
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (sbuffer)
.子程序 取核心数, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 NumberOfCores
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“NumberOfCores”), 0, Variant, 0, 0)
            NumberOfCores ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (NumberOfCores)
.子程序 取线程数, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 NumberOfLogicalProcessors
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“NumberOfLogicalProcessors”), 0, Variant, 0, 0)
            NumberOfLogicalProcessors ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (NumberOfLogicalProcessors)
.子程序 取序列号, 文本型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 ProcessorId
.局部变量 sbuffer, 文本型
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (“”)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“ProcessorId”), 0, Variant, 0, 0)
            ProcessorId ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (ProcessorId, lstrlen (ProcessorId) × 3))
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (sbuffer)
.子程序 取处理器类型, 整数型, 公开, 失败返回-1。返回值；1=其它；2=未知；3=中央处理器；4=数学处理器；5=DSP处理器；6=视频处理器
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 ProcessorType
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“ProcessorType”), 0, Variant, 0, 0)
            ProcessorType ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (ProcessorType)
.子程序 取修订号, 整数型, 公开
.参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
.局部变量 Variant
.局部变量 pclsObj, 整数型
.局部变量 uReturn, 整数型
.局部变量 i, 整数型
.局部变量 Revision
.局部变量 hres, 整数型
.如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
    返回 (-1)
.如果真结束
Variant ＝ COM_bstr_t (取空白文本 (16))
CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
.计次循环首 (10, i)
    hres ＝ COM_调用COM方法 (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn))
    .如果 (uReturn ＝ 1)
        .如果真 (i ＝ CPU索引)
            COM_调用COM方法 (pclsObj, 4, COM_bstr_t (“Revision”), 0, Variant, 0, 0)
            Revision ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
        .如果真结束
        COM_Release (pclsObj)
    .否则
        跳出循环 ()
    .如果结束
    处理事件 ()
.计次循环尾 ()
Uninit ()
返回 (Revision)
.程序集 ADSL拨号类, , 公开
.程序集变量 集_链接句柄, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 _取本机IP, 整数型, 公开, 返回IP的个数，如2:本地IP和外网IP
.参数 IP数组, 文本型, 数组, 用于装载IP的文本数组
.局部变量 ulOutBufLen
.局部变量 AdapterInfo, IP_ADAPTER_INFO
.局部变量 pAdapterInfo
.局部变量 addr, 整数型
.局部变量 buf_ip, IP_ADDR_STRING
.局部变量 Success
.局部变量 pAdapter, 整数型
GetAdaptersInfo (0, ulOutBufLen)
pAdapterInfo ＝ GlobalAlloc (64, ulOutBufLen)
Success ＝ GetAdaptersInfo (pAdapterInfo, ulOutBufLen)
pAdapter ＝ pAdapterInfo
.如果真 (Success ＝ 0)
    .循环判断首 ()
        CopyMemory_ip_adapter_info (AdapterInfo, pAdapter, 640)
        加入成员 (IP数组, 到文本 (AdapterInfo.IpAddressList.IpAddress))
        pAdapter ＝ AdapterInfo.Next
    .循环判断尾 (pAdapter ≠ 0)
.如果真结束
GlobalFree (pAdapterInfo)
返回 (取数组成员数 (IP数组))
.子程序 取外网IP, 文本型, 公开, 获取本机的外网IP
返回 (网页_取外网IP ())
.子程序 重拨, 文本型, 公开, 重拨成功返回外网IP，失败返回空文本
.参数 连接名称, 文本型, 可空, 可空,默认为 宽带连接  已建立的拨号连接的名称
.参数 用户名, 文本型, , 用于拨号的用户名
.参数 密码, 文本型, , 用于拨号的密码
.局部变量 局_数组, 文本型, , "0"
.如果真 (是否为空 (连接名称))
    连接名称 ＝ “宽带连接”
.如果真结束
.如果真 (取连接状态 (连接名称))
    .如果真 (断开 () ＝ 假)
        断开_cmd (连接名称)
    .如果真结束
.如果真结束
.如果真 (拨号 (连接名称, 用户名, 密码) ＝ 0)
    返回 (“”)
.如果真结束
_取本机IP (局_数组)
.如果真 (取数组成员数 (局_数组) ≥ 2)
    返回 (局_数组 [2])
.如果真结束
返回 (“”)
.子程序 拨号, 整数型, 公开, 通过拨号建立网络连接，成功返回连接句柄，失败返回0
.参数 连接名称, 文本型, , 已建立的拨号连接的名称,一般为 宽带连接
.参数 用户名, 文本型, , 用于拨号的用户名
.参数 密码, 文本型, , 用于拨号的密码
.局部变量 ras, ADSL拨号0
集_链接句柄 ＝ 0
ras.结构的大小 ＝ 1052
RtlMoveMemory (取数据_通用型_数组 (ras.访问的入口名), 取指针_文本型 (连接名称), 取文本长度 (连接名称))
RtlMoveMemory (取数据_通用型_数组 (ras.指定用户名称), 取指针_文本型 (用户名), 取文本长度 (用户名))
RtlMoveMemory (取数据_通用型_数组 (ras.指定用户密码), 取指针_文本型 (密码), 取文本长度 (密码))
RasDialA (0, 0, ras, 0, 0, 集_链接句柄)
.如果真 (集_链接句柄 ＝ 0)
    RasDialA (0, 0, ras, 0, 0, 集_链接句柄)
.如果真结束
返回 (集_链接句柄)
.子程序 断开, 逻辑型, 公开, 断开当前拨号网络连接
返回 (RasHangUpA (集_链接句柄) ＝ 0)
.子程序 重拨_cmd, , 公开, 宽带重拨，cmd方式
.参数 宽带名称, 文本型, 可空, 可空。默认为“宽带连接”
.参数 用户名称, 文本型
.参数 用户密码, 文本型
.如果真 (是否为空 (宽带名称))
    宽带名称 ＝ “宽带连接”
.如果真结束
断开_cmd (宽带名称)
拨号_cmd (宽带名称, 用户名称, 用户密码)
.子程序 拨号_cmd, , 公开, CMD方式拨号
.参数 宽带名称, 文本型, 可空, 可空。默认为“宽带连接”
.参数 用户名称, 文本型
.参数 用户密码, 文本型
.如果真 (是否为空 (宽带名称))
    宽带名称 ＝ “宽带连接”
.如果真结束
运行 (“rasdial ” ＋ #引号 ＋ 宽带名称 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 用户名称 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 用户密码 ＋ #引号, 真, 1)
.子程序 断开_cmd, 逻辑型, 公开, 断开宽带连接，cmd方式。
.参数 连接名称, 文本型, 可空, 可空,默认为“宽带连接”。已建立的拨号连接的名称
.如果真 (删首尾空 (连接名称) ＝ “”)
    连接名称 ＝ “宽带连接”
.如果真结束
返回 (运行 (“rasphone -h ” ＋ #引号 ＋ 连接名称 ＋ #引号, 真, #隐藏窗口))  ' cmd断开连接方式
.子程序 取连接名称, 文本型, 公开, 利用索引取出电脑中拨号的连接名称，成功返回连接名称，失败返回空文本
.参数 连接索引, 整数型, , 欲取名称的连接索引 索引从1开始 最大到10 
.参数 所有名称数组, 文本型, 参考 可空 数组, 存放所有连接名称的文本数组
.局部变量 连接信息, 取连接信息用结构, , "99"
.局部变量 lpcb, 整数型
.局部变量 连接数, 整数型
.局部变量 i, 整数型
.如果真 (连接索引 ＞ 10 或 连接索引 ＜ 1)
    返回 (“”)
.如果真结束
连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
lpcb ＝ 连接信息 [1].内存大小 × 256
RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
.如果真 (是否为空 (所有名称数组))
    返回 (到文本 (连接信息 [连接索引].拨号连接名称))
.如果真结束
.计次循环首 (连接数, i)
    加入成员 (所有名称数组, 到文本 (连接信息 [i].拨号连接名称))
.计次循环尾 ()
.如果真 (连接索引 ＞ 0 且 连接索引 ≤ 取数组成员数 (所有名称数组))
    返回 (所有名称数组 [连接索引])
.如果真结束
返回 (“”)
.子程序 取连接数量, 整数型, 公开, 取系统中已经建立的连接数量
.局部变量 连接信息, 取连接信息用结构, , "99", 假设最多99个连接
.局部变量 lpcb, 整数型, , , 电话本名称,0
.局部变量 连接数, 整数型
连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
lpcb ＝ 连接信息 [1].内存大小 × 256
RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
返回 (连接数)
.子程序 取连接状态, 逻辑型, 公开, 判断指定的连接是否已连接，如果已连接返回真，否则返回假;
.参数 连接名称, 文本型, , 欲判断的连接名称
.局部变量 连接信息, 文本型
.局部变量 dwFlags, 整数型
.局部变量 sNameBuf, 文本型
.局部变量 lR, 整数型
sNameBuf ＝ 取空白文本 (513)
lR ＝ InternetGetConnectedStateEx (dwFlags, sNameBuf, 512, 0)
.如果真 (lR ≠ 1)  ' 无连接 (这个连接并不一定是通外网，可能是连接路由器等设备)
    返回 (假)
.如果真结束
.如果真 (连接名称 ≠ 删首尾空 (sNameBuf))
    返回 (假)
.如果真结束
返回 (真)
.子程序 连接是否存在, 逻辑型, 公开, 如果指定的连接名称存在返回真，否则返回假;
.参数 连接名称, 文本型, , 欲判断的连接名称
.局部变量 连接信息, 取连接信息用结构, , "99"
.局部变量 lpcb, 整数型
.局部变量 连接数, 整数型
.局部变量 局_计次, 整数型
连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
lpcb ＝ 连接信息 [1].内存大小 × 256
RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
.计次循环首 (连接数, 局_计次)
    .如果真 (到文本 (连接信息 [局_计次].拨号连接名称) ＝ 连接名称)
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 断开所有连接, , 公开
.局部变量 tmp, 文本型, , "0"
.局部变量 局_计次, 整数型
取连接名称 (1, tmp)
.计次循环首 (取数组成员数 (tmp), 局_计次)
    运行 (“rasphone -h ” ＋ tmp [局_计次], 假, #隐藏窗口)
.计次循环尾 ()
.子程序 创建新拨号连接, 逻辑型, 公开, 建立一个ADS拨号连接，成功反回真，失败返回假;
.参数 连接名称, 文本型, , 拨号连接的名称,可自定义,如"我的ADSL连接"
.参数 用户名, 文本型, 可空, 用于拨号的用户名
.参数 密码, 文本型, 可空, 用于拨号的密码
.参数 拨号类型, 整数型, 可空, 可空,默认为1  1=PPPoE虚拟拨号  2=电话拨号
.局部变量 re, 创建连接所用结构
.局部变量 sDeviceName, 文本型
.局部变量 sDeviceType, 文本型
.如果真 (是否为空 (拨号类型))
    拨号类型 ＝ 1
.如果真结束
sDeviceName ＝ “WAN 微型端口 (PPPOE)”  ' 设备名称  内容和系统盘下的 rasphone.pbk 文件相同
sDeviceType ＝ “PPPoE”  ' 设备类型
re.dwSize ＝ 2884
re.dwCountryCode ＝ 86
re.dwCountryID ＝ 86
re.dwDialExtraPercent ＝ 75
re.dbh5uy ＝ 120
re.dwDialMode ＝ 1
re.sdr5uyhbd ＝ 3
re.hr57hfb ＝ 4
re.dwfOptions ＝ 1024262928 － 256  ' 去掉托盘显示  RASEO_ModemLights As Long = &H100
re.dwfOptions2 ＝ 367
re.dwFramingProtocol ＝ 1
re.dwHangUpExtraPercent ＝ 10
re.dwHangUpExtraSampleSeconds ＝ 120
re.dwRedialCount ＝ 3  ' 重拨次数
re.dwRedialPause ＝ 5  ' 重拨间隔 5ms
re.dwType ＝ 选择 (拨号类型 ＝ 1, 5, 1)  ' 1为拨号连接,5为宽带虚拟拨号,4为连接管理器
RtlMoveMemory (取数据_通用型_数组 (re.szDeviceType), 取指针_文本型 (sDeviceType), 取文本长度 (sDeviceType))
RtlMoveMemory (取数据_通用型_数组 (re.szDeviceName), 取指针_文本型 (sDeviceName), 取文本长度 (sDeviceName))
.如果真 (RasSetEntryPropertiesA (0, 连接名称, re, re.dwSize, 0, 0) ＝ 0)
    .如果真 (是否为空 (用户名))  ' 如果没有提供用户名,即创建完成
        返回 (真)
    .如果真结束
    .如果真 (设置拨号连接 (连接名称, 用户名, 密码))  ' 提供了用户名,即用rc类型设置连接,rc中包含用户名密码结构
        返回 (真)
    .如果真结束
.如果真结束
返回 (假)
.子程序 设置拨号连接, 逻辑型, 公开, 设置已经存在的连接的用户名或密码
.参数 连接名称, 文本型, , 已建立的拨号连接的名称
.参数 用户名, 文本型, , 用于拨号的用户名,留空将不写入连接中
.参数 密码, 文本型, 可空, 用于拨号的密码
.局部变量 rc, 设置拨号所以结构
rc.dsubr ＝ 540
rc.dwMask ＝ 11
RtlMoveMemory (取数据_通用型_数组 (rc.szUserName), 取指针_文本型 (用户名), 取文本长度 (用户名))
RtlMoveMemory (取数据_通用型_数组 (rc.szPassword), 取指针_文本型 (密码), 取文本长度 (密码))
.如果 (RasSetCredentialsA (0, 连接名称, rc, 0) ＝ 0)
    返回 (真)
.否则
    返回 (假)
.如果结束
.子程序 删除拨号连接, , 公开
.参数 连接名称, 文本型
运行 (“rasphone -h ” ＋ 连接名称, 假, #隐藏窗口)  ' 先挂断连接
运行 (“rasphone -r ” ＋ 连接名称, 假, #隐藏窗口)  ' 删除连接
.子程序 取宽带用户名密码, 逻辑型, 公开, 成功返回真，失败返回假  注：只有ADSL拨号上网的才能取
.参数 连接名称, 文本型, 可空, 请提供一个文本变量,用于存放 连接名称
.参数 宽带用户名, 文本型, 可空, 请提供一个文本变量,用于存放 宽带用户名
.参数 宽带密码, 文本型, 可空, 请提供一个文本变量,用于存放 宽带密码
返回 (系统_取宽带用户名密码 (连接名称, 宽带用户名, 宽带密码))
.程序集 类_系统服务, , 公开, 使用例程 - http://bbs.125.la/thread-102354-1-1.html
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 取服务状态, 整数型, 公开, 返回值如下:1=已停止;2=开始;3=停止;4=正在运行;5=继续挂起;6=暂停挂起;7暂停.
.参数 服务名, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 Status, SERVICE_STATUS
.局部变量 CurrentState
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名, #GENERIC_READ)
    .如果真 (hService ≠ 0)
        .如果真 (QueryServiceStatus (hService, Status))
            CurrentState ＝ Status.dwCurrentState
        .如果真结束
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (CurrentState)
.子程序 取服务类型, 整数型, 公开, 返回值如下:1=设备驱动;2=文件系统驱动;16=进程;32=自己进程或其它服务;256=交互服务.
.参数 服务名, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 Status, SERVICE_STATUS
.局部变量 dwServiceType
.局部变量 pcbBytesNeeded, 整数型
.局部变量 lpServiceConfig
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名, #GENERIC_READ)
    .如果真 (hService ≠ 0)
        QueryServiceConfig (hService, 0, 0, pcbBytesNeeded)
        lpServiceConfig ＝ GlobalAlloc (64, pcbBytesNeeded)
        bresult ＝ QueryServiceConfig (hService, lpServiceConfig, pcbBytesNeeded, pcbBytesNeeded)
        .如果真 (bresult)
            dwServiceType ＝ 取字节集数据 (指针到字节集 (lpServiceConfig, 4), #整数型, )
        .如果真结束
        GlobalFree (lpServiceConfig)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (dwServiceType)
.子程序 取服务描述, 文本型, 公开, 成功返回服务描述文本，失败返回空！
.参数 服务名, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 cbBufSize, 整数型
.局部变量 hMem
.局部变量 Return, 文本型
.局部变量 lpBuffer, SERVICE_DESCRIPTION
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名, #SC_MANAGER_CONNECT)
    .如果真 (hService ≠ 0)
        QueryServiceConfig2 (hService, 1, 0, 0, cbBufSize)
        hMem ＝ HeapAlloc (GetProcessHeap (), 8, cbBufSize)  ' GlobalAlloc (64, cbBufSize)
        .如果真 (QueryServiceConfig2 (hService, 1, hMem, cbBufSize, cbBufSize))
            CopyMemory_SERVICE_DESCRIPTION (lpBuffer, hMem, 4)
            Return ＝ lpBuffer.lpDescription
        .如果真结束
        CloseServiceHandle (hService)
        HeapFree (GetProcessHeap (), 1, hMem)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (Return)
.子程序 置服务描述, 逻辑型, 公开, 修改指定系统服务描述，成功返回真，失败返回假。
.参数 服务名, 文本型, , 非显示名称。
.参数 新描述, 文本型
.局部变量 hSCManager
.局部变量 hService
.局部变量 sd
.局部变量 szDesc
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_EXECUTE)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名, #SERVICE_CHANGE_CONFIG)
    .如果真 (hService ≠ 0)
        szDesc ＝ lstrcpyn_文本型 (新描述, 新描述, 0)
        bresult ＝ ChangeServiceConfig2A (hService, 1, szDesc)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 取显示名称, 文本型, 公开, 根据系统服务数据库名称，获取显示名称。
.参数 服务名, 文本型
.局部变量 hSCManager, 整数型
.局部变量 sbuffer, 文本型
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    sbuffer ＝ 取空白文本 (255)
    bresult ＝ GetServiceDisplayName (hSCManager, 服务名, sbuffer, 255)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (选择 (bresult, sbuffer, “”))
.子程序 取服务名称, 文本型, 公开, 根据系统服务数据库名称，获取显示名称。
.参数 显示名称, 文本型
.局部变量 hSCManager, 整数型
.局部变量 sbuffer, 文本型
.局部变量 Length, 整数型
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    GetServiceKeyName (hSCManager, 显示名称, sbuffer, Length)
    sbuffer ＝ 取空白文本 (Length)
    bresult ＝ GetServiceKeyName (hSCManager, 显示名称, sbuffer, Length)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (选择 (bresult, sbuffer, “”))
.子程序 安装服务, 逻辑型, 公开, 创建一个系统服务项，成功返回真，失败返回假。
.参数 服务名称, 文本型, , 系统服务数据库中ID名称，不能为中文！
.参数 显示名称, 文本型
.参数 执行文件, 文本型, , 文件绝对路径
.参数 服务描述, 文本型, 可空
.参数 允许桌面交互, 逻辑型, 可空, 可为空,默认不允许与桌面进行交互.
.参数 服务类型, , 可空, 可为空,默认即进程.1=内核驱动;2=文件系统驱动;16=进程;32=其它服务.
.参数 启动类型, , 可空, 可为空,默认即手动,参数;2=自动;3=手动;4=禁用.
.参数 依存关系, 文本型, 可空, 某些服务依赖于其它服务,系统驱动程序或加载顺序组.
.参数 登录用户, 文本型, 可空, 非本地系统,登陆用户名.
.参数 登录密码, 文本型, 可空
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
服务类型 ＝ 选择 (是否为空 (服务类型), 16, 服务类型)
启动类型 ＝ 选择 (是否为空 (启动类型), 3, 启动类型)
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    .如果真 (允许桌面交互)
        服务类型 ＝ 位或 (服务类型, #SERVICE_INTERACTIVE_PROCESS)
    .如果真结束
    hService ＝ CreateService (hSCManager, 服务名称, 显示名称, #SERVICE_ALL_ACCESS, 服务类型, 启动类型, #SERVICE_ERROR_NORMAL, 执行文件, 字符 (0), 0, 依存关系, 登录用户, 登录密码)
    .如果真 (hService ≠ 0)
        置服务描述 (服务名称, 服务描述)
    .如果真结束
    CloseServiceHandle (hService)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (hService ≠ 0)
.子程序 卸载服务, 逻辑型, 公开, 如果服务正在运动会先停止服务然后再删除。成功返回真，失败返回假。
.参数 服务名称, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 Status, SERVICE_STATUS
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 位或 (16, 32, 65536))  ' DELETE
    .如果真 (hService ≠ 0)
        bresult ＝ DeleteService (hService)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 开始服务, 逻辑型, 公开, 开启一个系统服务，成功返回真，如果系统服务被禁用则返回假。
.参数 服务名, 文本型, , 需提供系统服务数据库名非显示名称
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名, #SERVICE_START)
    .如果真 (hService ≠ 0)
        bresult ＝ StartService (hService, 0, 0)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 停止服务, 逻辑型, 公开, 停止一个存在运行的系统服务，成功返回真，失败返回假。
.参数 服务名, 文本型, , 需提供服务名称非显示名称。
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 Status, SERVICE_STATUS
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 1)  ' 1
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名, 32)  ' 32
    .如果真 (hSCManager ≠ 0)  ' 判断打开的服务句柄，如果为0 返回假
        bresult ＝ ControlService (hService, 1, Status)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 暂停服务, 逻辑型, 公开, 暂停一个存在运行的系统服务，成功返回真，失败返回假。
.参数 服务名称, 文本型, , 需提供服务名称非显示名称。
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 Status, SERVICE_STATUS
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 983551)
    .如果真 (hService ≠ 0)
        bresult ＝ ControlService (hService, 2, Status)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 恢复服务, 逻辑型, 公开, 恢复被暂停的系统服务，成功返回真，失败返回假。
.参数 服务名称, 文本型, , 需提供服务名称非显示名称。
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 Status, SERVICE_STATUS
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 983551)
    .如果真 (hService ≠ 0)
        bresult ＝ ControlService (hService, 3, Status)  ' SERVICE_CONTROL_CONTINUE
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 是否存在, 逻辑型, 公开, 判断一个系统服务是否存在,存在返回真,否则返回假.
.参数 服务名称, 文本型, , 需提供服务名称非显示名称。
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, #GENERIC_READ)
    CloseServiceHandle (hService)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (hService ≠ 0)
.子程序 置启动类型, 逻辑型, 公开, 修改一个已有的系统服务启动类型，有些服务有权限是否允许操作，成功返回真，失败返回假。
.参数 服务名称, 文本型, , 提供服务名称非服务显示名称
.参数 启动类型, 整数型, , 启动类型以下选项：2=自动(延迟启动);3=手动;4=禁用
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 983103)  ' 983103
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 983551)  ' 983551
    .如果真 (hService ≠ 0)
        bresult ＝ ChangeServiceConfig (hService, 4294967295, 启动类型, 4294967295, 字符 (0), 字符 (0), 0, 字符 (0), 字符 (0), 字符 (0), 字符 (0))
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 取启动类型, 整数型, 公开, 获取指定系统服务启动类型，成功返回启动类型值;1=自动;2=自动(延迟启动);3=手动;4=禁用，失败返回-1。
.参数 服务名称, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 bresult, 逻辑型
.局部变量 dwBytesNeeded
.局部变量 lpsc, QUERY_SERVICE_CONFIG
.局部变量 hMem
.局部变量 dwStartType
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 1)
    .如果真 (hService ≠ 0)
        QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
        hMem ＝ GlobalAlloc (64, dwBytesNeeded)
        bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
        .如果真 (bresult)
            CopyMemory_QUERY_SERVICE_CONFIG (lpsc, hMem, 36)
            .判断开始 (lpsc.dwStartType ＝ 2 且 lpsc.dwServiceType ＝ 32)
                dwStartType ＝ 1  ' 返回 (“自动”)
            .判断 (lpsc.dwStartType ＝ 2 且 lpsc.dwServiceType ＝ 16)
                dwStartType ＝ 2  ' 返回 (“自动(延迟启动)”)
            .判断 (lpsc.dwStartType ＝ 3)
                dwStartType ＝ 3  ' 返回 (“手动”)
            .判断 (lpsc.dwStartType ＝ 4)
                dwStartType ＝ 4  ' 返回 (“禁用”)
            .默认
                dwStartType ＝ -1
            .判断结束
            处理事件 ()
        .如果真结束
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
    GlobalFree (hMem)
.如果真结束
返回 (dwStartType)
.子程序 取文件路径, 文本型, 公开, 获取指定系统服务可执行文件的路径，失败返回空文本。
.参数 服务名称, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 bresult, 逻辑型
.局部变量 dwBytesNeeded
.局部变量 lpsc, QUERY_SERVICE_CONFIG
.局部变量 hMem
.局部变量 dwStartType
.局部变量 lpBinaryPathName, 文本型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, #SC_MANAGER_CONNECT)
    .如果真 (hService ≠ 0)
        QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
        hMem ＝ GlobalAlloc (64, dwBytesNeeded)
        bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
        .如果真 (bresult)
            CopyMemory_QUERY_SERVICE_CONFIG (lpsc, hMem, 36)
            lpBinaryPathName ＝ 指针到文本 (lpsc.lpBinaryPathName)
        .如果真结束
        GlobalFree (hMem)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (选择 (bresult, lpBinaryPathName, “”))
.子程序 置文件路径, 逻辑型, 公开, 修改一个已有的系统服务可执行文件的路径，有些服务有权限是否允许操作，成功返回真，失败返回假。
.参数 服务名称, 文本型, , 提供服务名称非服务显示名称
.参数 文件路径, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 bresult, 逻辑型
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 983551)
    .如果真 (hService ≠ 0)
        bresult ＝ ChangeServiceConfig (hService, 4294967295, 4294967295, 4294967295, 文件路径, 字符 (0), 0, 字符 (0), 字符 (0), 字符 (0), 字符 (0))
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (bresult)
.子程序 取登录类型, 文本型, 公开, 获取指定服务登录类型,如,本地系统,本地服务或网络服务.
.参数 服务名称, 文本型
.局部变量 hSCManager, 整数型
.局部变量 hService, 整数型
.局部变量 bresult, 逻辑型
.局部变量 dwBytesNeeded
.局部变量 lpsc, QUERY_SERVICE_CONFIG
.局部变量 hMem
.局部变量 StartName, 文本型
.局部变量 Service, 文本型
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    hService ＝ OpenService (hSCManager, 服务名称, 1)
    .如果真 (hService ≠ 0)
        QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
        hMem ＝ GlobalAlloc (64, dwBytesNeeded)
        bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
        .如果真 (bresult)
            CopyMemory_QUERY_SERVICE_CONFIG (lpsc, hMem, 36)
            StartName ＝ 到大写 (指针到文本 (lpsc.lpServiceStartName))
            .判断开始 (寻找文本 (StartName, 到大写 (“localservice”), , 假) ≠ -1)
                Service ＝ “本地服务”
            .判断 (寻找文本 (StartName, 到大写 (“Networkservice”), , 假) ≠ -1)
                Service ＝ “网络服务”
            .判断 (寻找文本 (StartName, 到大写 (“localsystem”), , 假) ≠ -1)
                Service ＝ “本地系统”
            .默认
            .判断结束
            处理事件 ()
        .如果真结束
        GlobalFree (hMem)
        CloseServiceHandle (hService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (Service)
.子程序 枚举服务, 整数型, 公开, 枚举本机安装的系统服务，成功返回系统服务数量，失败返回0.
.参数 服务类型, , , 1、正在运行服务 2、未运行的服务  3、所有的服务
.参数 服务列表, 精易_系统服务列表, 数组, 储存返回值。
.局部变量 success, 逻辑型
.局部变量 hSCManager, 整数型
.局部变量 buffer, 整数型
.局部变量 cbRequired, 整数型
.局部变量 dwReturned, 整数型
.局部变量 hEnumResume, 整数型
.局部变量 hMem
.局部变量 i, 整数型
.局部变量 lpsc, ENUM_SERVICE_STATUS
.局部变量 lpServices, 字节集
.局部变量 lpServiceName, 字节集
.局部变量 hService, 整数型
.局部变量 dwBytesNeeded, 整数型
.局部变量 Bytes
.局部变量 Config, QUERY_SERVICE_CONFIG
.局部变量 StartName, 文本型
数组清零 (服务列表)
hSCManager ＝ OpenSCManagerA (0, 0, 983103)
.如果真 (hSCManager ≠ 0)
    success ＝ EnumServicesStatus (hSCManager, 48, 服务类型, 0, 0, cbRequired, dwReturned, hEnumResume)
    hMem ＝ HeapAlloc (GetProcessHeap (), 8, cbRequired)  ' GlobalAlloc (64, cbRequired)
    success ＝ EnumServicesStatus (hSCManager, 48, 服务类型, hMem, cbRequired, cbRequired, dwReturned, hEnumResume)
    .如果真 (success ＝ 假)
        返回 (0)
    .如果真结束
    重定义数组 (服务列表, 假, dwReturned)
    .变量循环首 (0, dwReturned － 1, 1, i)
        lpServices ＝ 指针到字节集 (hMem ＋ 36 × i, 36)
        CopyMemory_ENUM_SERVICE_STATUS (lpsc, lpServices, 36)
        服务列表 [i ＋ 1].服务名称 ＝ 指针到文本 (lpsc.lpServiceName)
        服务列表 [i ＋ 1].显示名称 ＝ 指针到文本 (lpsc.lpDisplayName)
        ' ' -----------------
        hService ＝ OpenService (hSCManager, 服务列表 [i ＋ 1].服务名称, 983551)
        .如果真 (hService ≠ 0)
            QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
            Bytes ＝ HeapAlloc (GetProcessHeap (), 8, dwBytesNeeded)  ' GlobalAlloc (64, dwBytesNeeded)
            success ＝ QueryServiceConfig (hService, Bytes, dwBytesNeeded, dwBytesNeeded)
            .如果真 (success)
                CopyMemory_QUERY_SERVICE_CONFIG (Config, Bytes, 36)
                服务列表 [i ＋ 1].描述 ＝ 取服务描述 (服务列表 [i ＋ 1].服务名称)
                服务列表 [i ＋ 1].服务状态 ＝ GetServiceState (lpsc.ServiceStatus.dwCurrentState)
                服务列表 [i ＋ 1].文件路径 ＝ 文本_指针到文本A (Config.lpBinaryPathName)
                .判断开始 (Config.dwStartType ＝ 2 且 lpsc.ServiceStatus.dwServiceType ＝ 32)
                    服务列表 [i ＋ 1].启动类型 ＝ “自动”
                .判断 (Config.dwStartType ＝ 2 且 lpsc.ServiceStatus.dwServiceType ＝ 16)
                    服务列表 [i ＋ 1].启动类型 ＝ “自动(延迟启动)”
                .判断 (Config.dwStartType ＝ 3)
                    服务列表 [i ＋ 1].启动类型 ＝ “手动”
                .判断 (Config.dwStartType ＝ 4)
                    服务列表 [i ＋ 1].启动类型 ＝ “禁用”
                .默认
                .判断结束
                StartName ＝ 到大写 (文本_指针到文本A (Config.lpServiceStartName))
                .判断开始 (寻找文本 (StartName, 到大写 (“LocalService”), , 假) ≠ -1)
                    服务列表 [i ＋ 1].登陆为 ＝ “本地服务”
                .判断 (寻找文本 (StartName, 到大写 (“NetworkService”), , 假) ≠ -1)
                    服务列表 [i ＋ 1].登陆为 ＝ “网络服务”
                .判断 (寻找文本 (StartName, 到大写 (“LocalSystem”), , 假) ≠ -1)
                    服务列表 [i ＋ 1].登陆为 ＝ “本地系统”
                .默认
                    服务列表 [i ＋ 1].登陆为 ＝ StartName
                .判断结束
            .如果真结束
            HeapFree (GetProcessHeap (), 1, Bytes)
            CloseServiceHandle (hService)
        .如果真结束
        处理事件 ()
    .变量循环尾 ()
    ' GlobalFree (cbRequired)
    HeapFree (GetProcessHeap (), 1, hMem)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (dwReturned)
.子程序 取服务数, 整数型, 公开, 枚举本机安装的系统服务，成功返回系统服务数量，失败返回0.
.参数 服务状态, , 可空, 1、正在运行服务 2、未运行的服务  3、所有的服务
.局部变量 bresult, 逻辑型
.局部变量 hSCManager, 整数型
.局部变量 buffer, 整数型
.局部变量 cbRequired, 整数型
.局部变量 dwReturned, 整数型
.局部变量 hEnumResume, 整数型
.局部变量 hMem
.局部变量 i, 整数型
.局部变量 lpsc, ENUM_SERVICE_STATUS
.局部变量 lpServices, 字节集
.局部变量 lpServiceName, 字节集
服务状态 ＝ 选择 (是否为空 (服务状态), 3, 服务状态)
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    EnumServicesStatus (hSCManager, 48, 服务状态, 0, 0, cbRequired, dwReturned, hEnumResume)
    hMem ＝ GlobalAlloc (64, cbRequired)
    bresult ＝ EnumServicesStatus (hSCManager, 48, 服务状态, hMem, cbRequired, cbRequired, dwReturned, hEnumResume)
    GlobalFree (hMem)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (dwReturned)
.子程序 取指定服务信息, , 公开
.参数 参_服务名称, 文本型
.参数 参_服务状态, 整数型, , 1、正在运行服务 2、未运行的服务  3、所有的服务
.参数 参_服务信息, 精易_系统服务列表Ex, 参考
.局部变量 数组, 精易_系统服务列表Ex, , "0"
.局部变量 枚举, 类_系统服务
.局部变量 i, 整数型
清除数组 (数组)
枚举.枚举服务Ex (参_服务状态, 数组)
.计次循环首 (取数组成员数 (数组), i)
    .如果真 (数组 [i].服务名称 ＝ 参_服务名称)
        参_服务信息 ＝ 数组 [i]
    .如果真结束
    系统_处理事件 ()
.计次循环尾 ()
.子程序 枚举服务Ex, 整数型, 公开, 枚举本机安装的系统服务，成功返回系统服务数量，失败返回0.
.参数 服务状态, , , 1、正在运行服务 2、未运行的服务  3、所有的服务
.参数 服务列表, 精易_系统服务列表Ex, 数组, 储存返回值。
.局部变量 hSCManager, 整数型
.局部变量 bresult, 逻辑型
.局部变量 cbBufSize, 整数型
.局部变量 cbRequired, 整数型
.局部变量 dwReturned, 整数型
.局部变量 hEnumResume, 整数型
.局部变量 lpServices
.局部变量 i, 整数型
.局部变量 ServiceProcess, ENUM_SERVICE_STATUS_PROCESS
.局部变量 sbuffer, 字节集
.局部变量 hService, 整数型
.局部变量 Bytes
.局部变量 Config, QUERY_SERVICE_CONFIG
.局部变量 dwBytesNeeded, 整数型
.局部变量 StartName, 文本型
数组清零 (服务列表)
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    EnumServicesStatusEx (hSCManager, 0, 48, 服务状态, 0, 0, cbRequired, dwReturned, hEnumResume, 字符 (0))
    lpServices ＝ GlobalAlloc (64, cbRequired)
    bresult ＝ EnumServicesStatusEx (hSCManager, 0, 48, 服务状态, lpServices, cbRequired, cbRequired, dwReturned, hEnumResume, 字符 (0))
    .如果真 (bresult)
        重定义数组 (服务列表, 假, dwReturned)
        .变量循环首 (0, dwReturned － 1, 1, i)
            sbuffer ＝ 指针到字节集 (lpServices ＋ 44 × i, 44)
            CopyMemory_enum_service_status_process (ServiceProcess, sbuffer, 44)
            服务列表 [i ＋ 1].服务名称 ＝ 指针到文本 (ServiceProcess.lpServiceName)
            服务列表 [i ＋ 1].显示名称 ＝ 指针到文本 (ServiceProcess.lpDisplayName)
            服务列表 [i ＋ 1].进程ID ＝ ServiceProcess.ServiceStatusProcess.dwProcessId
            ' ------------------
            hService ＝ OpenService (hSCManager, 指针到文本 (ServiceProcess.lpServiceName), 983551)
            bresult ＝ QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
            Bytes ＝ GlobalAlloc (64, dwBytesNeeded)
            bresult ＝ QueryServiceConfig (hService, Bytes, dwBytesNeeded, dwBytesNeeded)
            .如果真 (bresult)
                CopyMemory_QUERY_SERVICE_CONFIG (Config, Bytes, 36)
                服务列表 [i ＋ 1].描述 ＝ 取服务描述 (指针到文本 (ServiceProcess.lpServiceName))
                服务列表 [i ＋ 1].服务状态 ＝ GetServiceState (ServiceProcess.ServiceStatusProcess.dwCurrentState)
                服务列表 [i ＋ 1].文件路径 ＝ 指针到文本 (Config.lpBinaryPathName)
                .判断开始 (Config.dwStartType ＝ 2 且 ServiceProcess.ServiceStatusProcess.dwServiceType ＝ 32)
                    服务列表 [i ＋ 1].启动类型 ＝ “自动”
                .判断 (Config.dwStartType ＝ 2 且 ServiceProcess.ServiceStatusProcess.dwServiceType ＝ 16)
                    服务列表 [i ＋ 1].启动类型 ＝ “自动(延迟启动)”
                .判断 (Config.dwStartType ＝ 3)
                    服务列表 [i ＋ 1].启动类型 ＝ “手动”
                .判断 (Config.dwStartType ＝ 4)
                    服务列表 [i ＋ 1].启动类型 ＝ “禁用”
                .默认
                .判断结束
                StartName ＝ 到大写 (指针到文本 (Config.lpServiceStartName))
                .判断开始 (寻找文本 (StartName, 到大写 (“LocalService”), , 假) ≠ -1)
                    服务列表 [i ＋ 1].登陆为 ＝ “本地服务”
                .判断 (寻找文本 (StartName, 到大写 (“NetworkService”), , 假) ≠ -1)
                    服务列表 [i ＋ 1].登陆为 ＝ “网络服务”
                .判断 (寻找文本 (StartName, 到大写 (“LocalSystem”), , 假) ≠ -1)
                    服务列表 [i ＋ 1].登陆为 ＝ “本地系统”
                .默认
                    服务列表 [i ＋ 1].登陆为 ＝ StartName
                .判断结束
                GlobalFree (Bytes)
            .如果真结束
            CloseServiceHandle (hService)
        .变量循环尾 ()
    .如果真结束
    GlobalFree (lpServices)
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (dwReturned)
.子程序 枚举依赖服务, 整数型, , 有问题暂时不公开 
.参数 服务名称, 文本型
.参数 服务列表, 精易_系统服务列表, 数组, 变量储存返回值.
.局部变量 hSCManager, 整数型
.局部变量 schService, 整数型
.局部变量 lpDependencies, 整数型
.局部变量 dwBytesNeeded, 整数型
.局部变量 dwCount, 整数型
.局部变量 bresult, 逻辑型
.局部变量 i, 整数型
.局部变量 ess, ENUM_SERVICE_STATUS
.局部变量 Bytes, 字节集
.局部变量 hService, 整数型
.局部变量 Config, QUERY_SERVICE_CONFIG
.局部变量 StartName, 文本型
.局部变量 hMem
数组清零 (服务列表)
hSCManager ＝ OpenSCManagerA (0, 0, #SC_MANAGER_ALL_ACCESS)
.如果真 (hSCManager ≠ 0)
    schService ＝ OpenService (hSCManager, 服务名称, 4 ＋ 8 ＋ 32)  ' #SERVICE_STOP ＋ #SERVICE_QUERY_STATUS ＋ #SERVICE_ENUMERATE_DEPENDENTS
    .如果真 (schService ≠ 0)
        EnumDependentServices (schService, 3, lpDependencies, 0, dwBytesNeeded, dwCount)  ' #SERVICE_ACTIVE
        lpDependencies ＝ GlobalAlloc (64, dwBytesNeeded)
        bresult ＝ EnumDependentServices (schService, 3, lpDependencies, dwBytesNeeded, dwBytesNeeded, dwCount)
        .如果真 (bresult)
            重定义数组 (服务列表, 假, dwCount)
            .变量循环首 (0, dwCount － 1, 1, i)
                Bytes ＝ 指针到字节集 (lpDependencies ＋ 36 × i, 36)
                CopyMemory_ENUM_SERVICE_STATUS (ess, Bytes, 36)
                服务列表 [i ＋ 1].服务名称 ＝ 指针到文本 (ess.lpServiceName)
                服务列表 [i ＋ 1].显示名称 ＝ 指针到文本 (ess.lpDisplayName)
                ' -------------------
                hService ＝ OpenService (hSCManager, 指针到文本 (ess.lpServiceName), #GENERIC_READ)
                bresult ＝ QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
                hMem ＝ GlobalAlloc (64, dwBytesNeeded)
                bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
                .如果真 (bresult)
                    CopyMemory_QUERY_SERVICE_CONFIG (Config, hMem, 36)
                    服务列表 [i ＋ 1].描述 ＝ 取服务描述 (指针到文本 (ess.lpServiceName))
                    服务列表 [i ＋ 1].服务状态 ＝ GetServiceState (ess.ServiceStatus.dwCurrentState)
                    服务列表 [i ＋ 1].文件路径 ＝ 指针到文本 (Config.lpBinaryPathName)
                    .判断开始 (Config.dwStartType ＝ 2 且 ess.ServiceStatus.dwServiceType ＝ 32)
                        服务列表 [i ＋ 1].启动类型 ＝ “自动”
                    .判断 (Config.dwStartType ＝ 2 且 ess.ServiceStatus.dwServiceType ＝ 16)
                        服务列表 [i ＋ 1].启动类型 ＝ “自动(延迟启动)”
                    .判断 (Config.dwStartType ＝ 3)
                        服务列表 [i ＋ 1].启动类型 ＝ “手动”
                    .判断 (Config.dwStartType ＝ 4)
                        服务列表 [i ＋ 1].启动类型 ＝ “禁用”
                    .默认
                    .判断结束
                    StartName ＝ 到大写 (指针到文本 (Config.lpServiceStartName))
                    .判断开始 (寻找文本 (StartName, 到大写 (“LocalService”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “本地服务”
                    .判断 (寻找文本 (StartName, 到大写 (“NetworkService”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “网络服务”
                    .判断 (寻找文本 (StartName, 到大写 (“LocalSystem”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “本地系统”
                    .默认
                        服务列表 [i ＋ 1].登陆为 ＝ StartName
                    .判断结束
                    处理事件 ()
                .如果真结束
                CloseServiceHandle (hService)
                GlobalFree (hMem)
            .变量循环尾 ()
        .如果真结束
        CloseServiceHandle (schService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
返回 (dwCount)
.子程序 停止所有依赖服务, , , 有问题暂时不公开
.参数 服务名称, 文本型
.局部变量 hSCManager, 整数型
.局部变量 schService, 整数型
.局部变量 lpDependencies, 整数型
.局部变量 dwBytesNeeded, 整数型
.局部变量 dwCount, 整数型
.局部变量 bresult, 逻辑型
.局部变量 i, 整数型
.局部变量 ess, ENUM_SERVICE_STATUS
.局部变量 Bytes, 字节集
.局部变量 hDepService, 整数型
.局部变量 ssp, SERVICE_STATUS
.局部变量 dwStartTime, 整数型
.局部变量 dwTimeout, 整数型
dwStartTime ＝ 取启动时间 ()
dwTimeout ＝ 30000
hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
.如果真 (hSCManager ≠ 0)
    schService ＝ OpenService (hSCManager, 服务名称, 32 ＋ 4 ＋ 8)
    .如果真 (schService ≠ 0)
        EnumDependentServices (schService, 1, lpDependencies, 0, dwBytesNeeded, dwCount)
        lpDependencies ＝ GlobalAlloc (64, dwBytesNeeded)
        bresult ＝ EnumDependentServices (schService, 1, lpDependencies, dwBytesNeeded, dwBytesNeeded, dwCount)
        .如果真 (bresult)
            .变量循环首 (0, dwCount － 1, 1, i)
                Bytes ＝ 指针到字节集 (lpDependencies ＋ 36 × i, 36)
                CopyMemory_ENUM_SERVICE_STATUS (ess, Bytes, 36)
                hDepService ＝ OpenService (hSCManager, 指针到文本 (ess.lpServiceName), 位或 (32, 4))  ' SERVICE_STOP | SERVICE_QUERY_STATUS
                .如果真 (ControlService (hDepService, 1, ssp))
                    .判断循环首 (ssp.dwCurrentState ≠ 1)  ' SERVICE_STOPPED
                        延时 (ssp.dwWaitHint)
                        QueryServiceStatus (hDepService, ssp)
                        .判断开始 (ssp.dwCurrentState ＝ 1)
                            跳出循环 ()
                        .判断 (取启动时间 () － dwStartTime ＞ dwTimeout)
                            输出调试文本 (“停止服务失败，原因：超时！”)
                            跳出循环 ()
                        .默认
                        .判断结束
                        处理事件 ()
                    .判断循环尾 ()
                .如果真结束
                CloseServiceHandle (hDepService)
            .变量循环尾 ()
            GlobalFree (lpDependencies)
        .如果真结束
        CloseServiceHandle (schService)
    .如果真结束
    CloseServiceHandle (hSCManager)
.如果真结束
.子程序 GetServiceState, 文本型, , 系统服务_枚举系统服务
.参数 dwState
.判断开始 (dwState ＝ 1)
    返回 (“已停止”)
.判断 (dwState ＝ 2)
    返回 (“启动期间”)
.判断 (dwState ＝ 3)
    返回 (“停止期间”)
.判断 (dwState ＝ 4)
    返回 (“正运行”)
.判断 (dwState ＝ 5)
    返回 (“继续”)
.判断 (dwState ＝ 6)
    返回 (“暂停期间”)
.判断 (dwState ＝ 7)
    返回 (“已暂停”)
.默认
    返回 (“”)
.判断结束
.子程序 重启服务, 逻辑型, 公开, 重新启动系统服务，成功返回真，失败返回假
.参数 参_服务名, 文本型
.如果真 (停止服务 (参_服务名))
    返回 (开始服务 (参_服务名))
.如果真结束
返回 (假)
.程序集 类_托盘, , 公开
.程序集变量 集_重建句柄, 整数型
.程序集变量 集_通知结构, NOTIFYICONDATA
.程序集变量 集_回调指针, 整数型
.程序集变量 集_窗口句柄, 整数型
.程序集变量 集_托盘句柄, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
集_托盘句柄 ＝ 功能_取托盘区句柄 ()
集_重建句柄 ＝ RegisterWindowMessageA (“TaskbarCreated”)  ' 注册一个消息，任务栏重建时发送此消息，拦截此消息重新添加托盘图标。
.子程序 FindTrayWnd, 整数型
.局部变量 hWnd, 整数型
hWnd ＝ FindWindowA (“Shell_TrayWnd”, 字符 (0))
hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“TrayNotifyWnd”), 0)
hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“SysPager”), 0)
hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
返回 (hWnd)
.子程序 FindNotifyIconOverflowWindow, 整数型, , win7特有
.局部变量 hWnd, 整数型
hWnd ＝ FindWindowA (“NotifyIconOverflowWindow”, 字符 (0))
hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
返回 (hWnd)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
集_托盘句柄 ＝ 0
销毁 ()
.子程序 创建, 逻辑型, 公开, 创建一个托盘图标，成功返回真，失败返回假。
.参数 窗口句柄, , , 不能设为第三方窗口
.参数 图标数据, 字节集, 可空, 可为空，默认为自身图标。
.参数 提示信息, 文本型, 可空, 本参数指定当鼠标移动到图标上后显示的提示信息。如果省略本参数，默认为空文本。
.如果真 (IsWindow (窗口句柄) ＝ 1)
    集_窗口句柄 ＝ 窗口句柄
    .如果 (是否为空 (图标数据))
        集_通知结构.hIcon ＝ SendMessageA (窗口句柄, 127, 0, 0)
    .否则
        集_通知结构.hIcon ＝ 取图标句柄 (图标数据)
    .如果结束
    集_通知结构.cbSize ＝ 488
    集_通知结构.hWnd ＝ 窗口句柄
    集_通知结构.uID ＝ 1
    集_通知结构.uFlags ＝ 位或 (#NIF_ICON, #NIF_TIP, #NIF_INFO, #NIF_MESSAGE)
    集_通知结构.uCallbackMessage ＝ 11685
    集_通知结构.uTimeoutAndVersion ＝ 10000
    lstrcpy_bytes (集_通知结构.szTip, 提示信息)
    返回 (Shell_NotifyIcon (#NIM_ADD, 集_通知结构))
.如果真结束
返回 (假)
.子程序 销毁, 逻辑型, 公开
.如果真 (集_回调指针 ≠ 0)
    SetWindowLongA (集_窗口句柄, -4, 集_回调指针)
.如果真结束
连续赋值 (0, 集_窗口句柄, 集_回调指针)
集_通知结构.szInfo ＝ { 0 }
集_通知结构.szInfoTitle ＝ { 0 }
返回 (Shell_NotifyIcon (#NIM_DELETE, 集_通知结构))
.子程序 置提示信息, 逻辑型, 公开
.参数 提示信息, 文本型, , 限定128字符以内，超出默认被截断
.局部变量 m_szTip, 文本型
m_szTip ＝ 选择 (取文本长度 (提示信息) ＜ 128, 提示信息, 取文本左边 (提示信息, 128))
lstrcpy_bytes (集_通知结构.szTip, m_szTip)
返回 (Shell_NotifyIcon (#NIM_MODIFY, 集_通知结构))
.子程序 气泡提示, 逻辑型, 公开
.参数 提示标题, 文本型, , 限定64字符以内，超出默认被截断
.参数 提示内容, 文本型, , 限定256字符以内，超出默认被截断
.参数 提示图标, 整数型, 可空, 0.托盘图标_无图标,1.托盘图标_信息图标,2.托盘图标_警告图标,3.托盘图标_错误图标
.参数 显示时间, 整数型, 可空, 设置气泡提示的时间，单位：毫秒 可空 默认3秒
.局部变量 m_szInfo, 文本型
.局部变量 m_szInfoTitle, 文本型
集_通知结构.dwInfoFlags ＝ 提示图标
m_szInfoTitle ＝ 选择 (取文本长度 (提示标题) ≤ 64, 提示标题, 取文本左边 (提示标题, 64))
m_szInfo ＝ 选择 (取文本长度 (提示内容) ＜ 256, 提示内容, 取文本左边 (提示内容, 256))
lstrcpy_bytes (集_通知结构.szInfoTitle, m_szInfoTitle)
lstrcpy_bytes (集_通知结构.szInfo, m_szInfo)
.判断开始 (显示时间 ＝ 0)
    集_通知结构.uTimeoutAndVersion ＝ 3000
.默认
    集_通知结构.uTimeoutAndVersion ＝ 显示时间
.判断结束
返回 (Shell_NotifyIcon (#NIM_MODIFY, 集_通知结构))
.子程序 置图标数据, 逻辑型, 公开
.参数 图标数据, 字节集
.局部变量 hIcon, 整数型
hIcon ＝ 取图标句柄 (图标数据, 0)
.如果真 (hIcon ＝ 0)
    返回 (假)
.如果真结束
集_通知结构.uFlags ＝ 位或 (#NIF_ICON, #NIF_TIP, #NIF_INFO, #NIF_MESSAGE)
集_通知结构.hIcon ＝ hIcon
返回 (Shell_NotifyIcon (#NIM_MODIFY, 集_通知结构))
.子程序 取图标句柄, 整数型, , 凌晨孤星提供
.参数 图标数据, 字节集, , 图标文件信息
.参数 图标索引, 整数型, 可空, 从0开始
.参数 图标宽度, 整数型, 参考 可空
.参数 图标高度, 整数型, 参考 可空
.局部变量 IconDirEntry, IconDirEntry
.局部变量 图标句柄, 整数型
CopyMemory_IconDirEntry (IconDirEntry, 取字节集中间 (图标数据, 6 ＋ 图标索引 × 16 ＋ 1, 16), 16)
图标宽度 ＝ IconDirEntry.bWidth
图标高度 ＝ IconDirEntry.bHeight
图标句柄 ＝ CreateIconFromResource (取字节集中间 (图标数据, IconDirEntry.dwImageOffset ＋ 1, IconDirEntry.dwBytesInRes), IconDirEntry.dwBytesInRes, 真, 196608)
返回 (图标句柄)
.子程序 挂接事件, , 公开, 当托盘图标创建成功后可建立挂接事件。
.参数 执行事件, 子程序指针, 可空, 当用户用鼠标单击或双击本“托盘图标”后调用的子程序，该子程序应该有一个参数，传递事件类型，请参考“托盘事件_”开头的常量
.如果真 (IsWindow (集_窗口句柄) ＝ 1)
    集_回调指针 ＝ SetWindowLongA (集_窗口句柄, -4, 到整数 (&托盘消息回调))
    SetPropA (集_窗口句柄, “WinProc”, 集_回调指针)
    SetPropA (集_窗口句柄, “CallbackMessage”, 11685)
    SetPropA (集_窗口句柄, “TaskbarCreatedMessage”, 集_重建句柄)
    .如果真 (是否为空 (执行事件) ＝ 假)
        SetPropA (集_窗口句柄, “Exec Event”, 到整数 (执行事件))
    .如果真结束
.如果真结束
返回 ()
.子程序 刷新托盘, , 公开, 刷新系统托盘(清除死掉的图标)
.参数 隐藏区域, 逻辑型, 可空, 针对Win7以上系统有托盘隐藏区域，为真则刷新隐藏区域
.局部变量 Rect, 精易_矩形
.局部变量 i, 整数型
.局部变量 n, 整数型
.局部变量 TrayWnd, 整数型
TrayWnd ＝ 选择 (隐藏区域, FindNotifyIconOverflowWindow (), FindTrayWnd ())
GetClientRect (TrayWnd, Rect)
.计次循环首 (Rect.底边 ÷ 2, n)
    .计次循环首 (Rect.右边 ÷ 2, i)
        SendMessageA (TrayWnd, 512, n × 2, i × 2)
    .计次循环尾 ()
.计次循环尾 ()
.子程序 取图标ID, 整数型, 公开, 根据图标索引取图标的ID
.参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
.局部变量 hProcess, 整数型
.局部变量 Address, 字节集
.局部变量 Buffer, 整数型
.局部变量 TB, TBBUTTON
hProcess ＝ 进程_打开 (集_托盘句柄)
Address ＝ 取空白字节集 (24)
Buffer ＝ 内存_远程创建内存_字节集 (hProcess, Address)
SendMessageA (集_托盘句柄, #TB_GETBUTTON, 图标索引, Buffer)
ReadProcessMemory_BButton (hProcess, Buffer, TB, 24, 0)
内存_释放远程内存 (hProcess, Buffer)
进程_关闭 (hProcess)
返回 (TB.idCommand)
.子程序 取图标数, 整数型, 公开, 取托盘图标总数
返回 (SendMessageA (集_托盘句柄, #TB_BUTTONCOUNT, 0, 0))
.子程序 删除图标, 逻辑型, 公开, 删除托盘上的一个图标
.参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
返回 (SendMessageA (集_托盘句柄, #TB_DELETEBUTTON, 图标索引, 0) ≠ 0)
.子程序 隐藏图标, 逻辑型, 公开, 隐藏托盘图标
.参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
.局部变量 局_状态, 整数型
.局部变量 局_标识, 整数型
局_标识 ＝ 取图标ID (图标索引)
局_状态 ＝ SendMessageA (集_托盘句柄, #TB_GETSTATE, 局_标识, 0)
局_状态 ＝ 位或 (局_状态, #TBSTATE_HIDDEN)
返回 (SendMessageA (集_托盘句柄, #TB_SETSTATE, 局_标识, 局_状态) ≠ 0)
.子程序 显示图标, 逻辑型, 公开, 显示托盘图标
.参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
.局部变量 局_状态, 整数型
.局部变量 局_标识, 整数型
局_标识 ＝ 取图标ID (图标索引)
局_状态 ＝ SendMessageA (集_托盘句柄, #TB_GETSTATE, 局_标识, 0)
.如果真 (位与 (局_状态, #TBSTATE_HIDDEN) ≠ 0)
    局_状态 ＝ 位异或 (局_状态, #TBSTATE_HIDDEN)
.如果真结束
返回 (SendMessageA (集_托盘句柄, #TB_SETSTATE, 局_标识, 局_状态) ≠ 0)
.子程序 禁用图标, 逻辑型, 公开, 禁用指定图标
.参数 图标索引, 整数型
.局部变量 局_标识, 整数型
局_标识 ＝ 取图标ID (图标索引)
返回 (SendMessageA (集_托盘句柄, #TB_ENABLEBUTTON, 局_标识, 0) ≠ 0)
.子程序 启用图标, 逻辑型, 公开, 启用指定图标
.参数 图标索引, 整数型
.局部变量 局_标识, 整数型
局_标识 ＝ 取图标ID (图标索引)
返回 (SendMessageA (集_托盘句柄, #TB_ENABLEBUTTON, 局_标识, 1) ≠ 0)
.子程序 取图标标题, 文本型, 公开, 取回指定图标的标题文本
.参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
.局部变量 局_标识, 整数型
.局部变量 len, 整数型
.局部变量 Address, 字节集
.局部变量 Buffer, 整数型
.局部变量 hProcess, 整数型
局_标识 ＝ 取图标ID (图标索引)
len ＝ SendMessageA (集_托盘句柄, #TB_GETBUTTONTEXTA, 局_标识, 0)
hProcess ＝ 进程_打开 (集_托盘句柄)
Address ＝ 取空白字节集 (len)
Buffer ＝ 内存_远程创建内存_字节集 (hProcess, Address)
SendMessageA (集_托盘句柄, #TB_GETBUTTONTEXTA, 局_标识, Buffer)
ReadProcessMemory_字节集 (hProcess, Buffer, Address, len, 0)
内存_释放远程内存 (hProcess, Buffer)
进程_关闭 (hProcess)
返回 (到文本 (Address))
.程序集 输入法类, , 公开, 感谢坛友【xuweixxf21】提供
.程序集变量 缓存_输入法标识, 文本型, , "0"
.程序集变量 缓存_输入法名称, 文本型, , "0"
.程序集变量 缓存_输入法路径, 文本型, , "0"
.程序集变量 缓存_输入法句柄, 整数型, , "0"
.程序集变量 SystemPath, 文本型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
清除缓存数据 ()
SystemPath ＝ 读环境变量 (“systemroot”) ＋ “\System32\”
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 安装, 整数型, 公开, 安装指定输入法(成功返回输入法句柄,失败返回0)
.参数 输入法文件, 文本型, , 输入法文件的完整路径  没有注入文件的可以来这里下载：http://115.com/file/dizk13dt
.参数 输入法名称, 文本型, 可空, 输入法的名称,默认为“精易输入法”
.如果真 (是否为空 (输入法名称))
    输入法名称 ＝ “精易输入法”
.如果真结束
文件_复制 (输入法文件, SystemPath ＋ “imedllhost09.ime”)
返回 (ImmInstallIMEA (SystemPath ＋ “imedllhost09.ime”, 输入法名称))
.子程序 清除缓存数据
清除数组 (缓存_输入法标识)
清除数组 (缓存_输入法名称)
清除数组 (缓存_输入法路径)
.子程序 卸载, 逻辑型, 公开, 卸载已经安装的输入法(成功返回真,失败返回假)
.参数 输入法句柄, 整数型, , 欲卸载的输入法的句柄
.局部变量 注册表路径, 文本型, , "3"
.局部变量 输入法序号, 整数型
输入法序号 ＝ 取序号 (输入法句柄)
.如果真 (输入法序号 ＝ -1)
    返回 (假)
.如果真结束
注册表路径 [1] ＝ “Keyboard Layout\Preload\”
注册表路径 [2] ＝ “SYSTEM\CurrentControlSet\Control\Keyboard Layouts\”
注册表路径 [3] ＝ “S-1-5-21-1060284298-606747145-682003330-500\Keyboard Layout\Preload”
删除注册项 (#现行用户, 注册表路径 [1] ＋ 到文本 (输入法序号))
删除注册项 (#本地机器, 注册表路径 [2] ＋ 缓存_输入法标识 [输入法序号])
删除注册项 (#所有用户, 注册表路径 [3] ＋ 到文本 (输入法序号))
UnloadKeyboardLayout (输入法句柄)
删除文件 (SystemPath ＋ 缓存_输入法路径 [输入法序号])
文件_删除 (SystemPath ＋ “imedllhost09.ime”)
清除缓存数据 ()
返回 (真)
.子程序 取序号, 整数型, 公开, 取输入法序号
.参数 输入法句柄, 整数型
.局部变量 临时整数, 整数型
.局部变量 是否取得, 逻辑型
.局部变量 输入法总数, 整数型
.局部变量 局部_输入法, 整数型, , "0"
输入法总数 ＝ 取输入法个数2 ()
取全部输入法句柄 (局部_输入法)
.变量循环首 (1, 输入法总数, 1, 临时整数)
    .如果 (输入法句柄 ＝ 局部_输入法 [临时整数])
        是否取得 ＝ 真
        跳出循环 ()
    .否则
    .如果结束
.变量循环尾 ()
.如果 (是否取得 ＝ 假)
    临时整数 ＝ -1
.否则
.如果结束
返回 (临时整数)
.子程序 取输入法个数2, 整数型, , 取全部输入法，成功则返回结果数量，失败返回0。
.局部变量 注册表路径, 文本型, , "2"
.局部变量 输入法总数, 整数型
.局部变量 临时整数, 整数型
.局部变量 标识, 文本型
.局部变量 名称, 文本型
.局部变量 路径, 文本型
注册表路径 [1] ＝ “Keyboard Layout\Preload\”
注册表路径 [2] ＝ “SYSTEM\CurrentControlSet\Control\Keyboard Layouts\”
清除缓存数据 ()
输入法总数 ＝ 取输入法个数 ()  ' GetKeyboardLayoutList (0, 0)
.变量循环首 (1, 输入法总数, 1, 临时整数)
    标识 ＝ 取文本注册项 (#现行用户, 注册表路径 [1] ＋ 到文本 (临时整数), )
    名称 ＝ 取文本注册项 (#本地机器, 注册表路径 [2] ＋ 标识 ＋ “\Layout Text”, )
    路径 ＝ 取文本注册项 (#本地机器, 注册表路径 [2] ＋ 标识 ＋ “\Ime File”, )
    加入成员 (缓存_输入法标识, 标识)
    加入成员 (缓存_输入法名称, 名称)
    加入成员 (缓存_输入法路径, 路径)
.变量循环尾 ()
返回 (输入法总数)
.子程序 取全部输入法句柄, 整数型, 公开, 取全部输入法句柄，返回取得的数量。
.参数 输入法句柄, 整数型, 数组
.局部变量 输入法总数, 整数型
.局部变量 临时整数, 整数型
.局部变量 句柄, 整数型
输入法总数 ＝ 取输入法个数2 ()
.变量循环首 (1, 输入法总数, 1, 临时整数)
    句柄 ＝ LoadKeyboardLayoutA (缓存_输入法标识 [临时整数], 0)
    加入成员 (输入法句柄, 句柄)
.变量循环尾 ()
返回 (输入法总数)
.子程序 注入, 整数型, 公开, 通过输入法注入文件(成功返回输入法句柄,失败返回0)
.参数 欲注入的文件, 文本型, , 欲注入文件的完整路径
.参数 输入法注入文件, 文本型, , 没有注入文件的可以来这里下载：http://pan.baidu.com/s/1eRDCRVO
.参数 输入法名称, 文本型, 可空, 输入法的名称,默认为“精易输入法”
.局部变量 句柄, 整数型
.局部变量 Address, 整数型
.如果真 (是否为空 (输入法名称))
    输入法名称 ＝ “精易输入法”
.如果真结束
句柄 ＝ 安装 (输入法注入文件, 输入法名称)
程序_延时 (25)
IMESetPubString (欲注入的文件, 0, 0, 0, 0, 0)
返回 (句柄)
.子程序 停止注入, 逻辑型, 公开, 停止注入(成功返回真,失败返回假)
返回 (IMEClearPubString ())
.子程序 激活, , 公开, 激活指定输入法(无返回值)
.参数 窗口句柄, 整数型, , 在指定的窗口激活输入法
.参数 输入法句柄, 整数型, , 欲激活的输入法的句柄
' ActivateKeyboardLayout (输入法句柄, 0)
SendMessageA (窗口句柄, 80, 1, 输入法句柄)
返回 ()
.子程序 取名称, 文本型, 公开, 成功返回输入法名称
.参数 序号, 整数型
.局部变量 i, 整数型
取输入法个数2 ()
返回 (缓存_输入法名称 [序号])
.子程序 取句柄, 整数型, 公开, 成功返回句柄
.参数 序号, 整数型
.局部变量 句柄数组, 整数型, , "0"
.局部变量 数量, 整数型
.局部变量 n, 整数型
取输入法个数2 ()
取全部输入法句柄 (句柄数组)
返回 (句柄数组 [序号])
.子程序 取输入法个数, 整数型, 公开
.局部变量 输入法总数, 整数型
.局部变量 pList, , , "20"
输入法总数 ＝ GetKeyboardLayoutList (20, pList)
返回 (输入法总数)
.子程序 显示属性, 逻辑型, 公开, 显示输入法属性窗口,成功返回真，失败返回假
.参数 输入法句柄
返回 (ImmConfigureIME (输入法句柄, GetActiveWindow (), 1, 0))  ' #IME_CONFIG_GENERAL
.程序集 类_模块枚举, , 公开
.程序集变量 Is64, 逻辑型
.程序集变量 集_错误信息, 文本型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
是否位64位进程 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 是否位64位进程, 逻辑型, 公开
Is64 ＝ Is64System ()
返回 (Is64)
.子程序 Is64System, 逻辑型
返回 (读环境变量 (“CommonProgramW6432”) ≠ “”)
.子程序 Unicode转Ansi, 文本型
.参数 Unicode, 字节集
.参数 目标编码, 整数型, 可空
.局部变量 ll, 整数型
.局部变量 len, 整数型
.局部变量 ansi, 文本型
.如果真 (Unicode ＝ {  })
    返回 (“”)
.如果真结束
.如果真 (是否为空 (目标编码))
    目标编码 ＝ 936
.如果真结束
ll ＝ 取字节集长度 (Unicode) ÷ 2
len ＝ WideCharToMultiByte (目标编码, 0, 取指针_字节集型 (Unicode), ll, 取指针_文本型 (ansi), 0, 0, 0)
ansi ＝ 取空白文本 (len)
WideCharToMultiByte (目标编码, 0, 取指针_字节集型 (Unicode), ll, 取指针_文本型 (ansi), len, 0, 0)
返回 (ansi)
.子程序 十到十六, 文本型
.参数 十进制数, 长整数型
.局部变量 HexText, 文本型
HexText ＝ 取空白文本 (255)
wvsprintf (HexText, “0x%016I64X”, 十进制数)
返回 (HexText)
.子程序 枚举64位进程模块, 逻辑型, 公开, 返回假可调用  取最后错误 来获取错误信息
.参数 进程ID, 整数型
.参数 模块, 模块信息, 参考 数组
.局部变量 pbi, PROCESS_BASIC_INFORMATION64
.局部变量 Ldr, PEB_LDR_DATA
.局部变量 局_缓冲区, 字节集
.局部变量 局_临时地址, 长整数型
.局部变量 局_Flink地址, 长整数型
.局部变量 局_结构信息, LDR_DATA_TABLE_ENTRY64
.局部变量 局_模块路径, 文本型
.局部变量 局_32位进程, 逻辑型
.局部变量 hSnapShot, 整数型
.局部变量 End, 整数型
.局部变量 Process, 整数型
.局部变量 局_临时模块, 模块信息
Process ＝ OpenProcess (1040, 0, 进程ID)
.如果真 (Process ＝ 0)
    集_错误信息 ＝ “打开目标进程失败,无法枚举进程模块!”
    返回 (假)
.如果真结束
.如果真 (Is64)
    ' ==============枚举64位进程模块=========================
    .如果真 (NtWow64QueryInformationProcess64 (Process, 0, pbi, 48, 0) ≠ 0)
        集_错误信息 ＝ “查询进程信息失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 (假)
    .如果真结束
    ' 得到PEB64结构的地址
    .如果真 (pbi.PebBaseAddress ＝ 0)
        集_错误信息 ＝ “获取PEB64结构地址失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 (假)
    .如果真结束
    ' 获取Ldr64结构地址
    .如果真 (NtWow64ReadVirtualMemory64_LDR (Process, pbi.PebBaseAddress, Ldr, 40, 0) ≠ 0)
        集_错误信息 ＝ “获取Ldr64结构地址失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 (假)
    .如果真结束
    ' 获取Ldr64.InLoadOrderModuleList.Flink地址
    局_缓冲区 ＝ 取空白字节集 (8)
    .如果真 (NtWow64ReadVirtualMemory64_bin (Process, Ldr.Ldr ＋ 16, 局_缓冲区, 8, 0) ≠ 0)
        集_错误信息 ＝ “获取Ldr64.InLoadOrderModuleList.Flink地址失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 (假)
    .如果真结束
    局_临时地址 ＝ 取字节集数据 (局_缓冲区, #长整数型, 1)  ' 得到Ldr64.InLoadOrderModuleList.Flink地址
    局_Flink地址 ＝ 局_临时地址
    ' 开始遍历链表
    .循环判断首 ()
        局_缓冲区 ＝ 取空白字节集 (104)  ' LDR_DATA_TABLE_ENTRY64 结构的大小是 104
        .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_临时地址, 局_缓冲区, 104, 0) ＝ 0)
            RtlMoveMemory_LDR_DATA_TABLE_ENTRY64 (局_结构信息, 局_缓冲区, 104)
            .如果真 (局_结构信息.DllBase ＝ 0)
                跳出循环 ()
            .如果真结束
            ' 链表中第一个模块地址是程序本身 把它过滤掉
            .如果真 (局_Flink地址 ＝ 局_临时地址)
                局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
                ' 跳出循环 ()
            .如果真结束
            ' 读取64位的模块路径
            局_缓冲区 ＝ 取空白字节集 (局_结构信息.FullDllName.Length)
            .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_结构信息.FullDllName.Buffer, 局_缓冲区, 局_结构信息.FullDllName.Length, 0) ＝ 0)
                局_模块路径 ＝ Unicode转Ansi (局_缓冲区)
                局_临时模块.模块句柄 ＝ 十到十六 (局_结构信息.DllBase)
                局_临时模块.模块路径 ＝ 局_模块路径
                加入成员 (模块, 局_临时模块)
            .如果真结束
            局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
        .如果真结束
    .循环判断尾 (局_结构信息.DllBase ≠ 0)
    返回 (真)
.如果真结束
CloseHandle (Process)
返回 (假)
.子程序 枚举32位进程模块, 逻辑型, 公开, 返回假可调用  取最后错误 来获取错误信息
.参数 进程ID, 整数型
.参数 模块, 模块信息, 参考 数组
.局部变量 pbi, PROCESS_BASIC_INFORMATION64
.局部变量 Ldr, PEB_LDR_DATA
.局部变量 局_缓冲区, 字节集
.局部变量 局_临时地址, 长整数型
.局部变量 局_Flink地址, 长整数型
.局部变量 局_结构信息, LDR_DATA_TABLE_ENTRY64
.局部变量 局_模块路径, 文本型
.局部变量 局_32位进程, 逻辑型
.局部变量 hSnapShot, 整数型
.局部变量 Mod, 精易_模块信息
.局部变量 End, 整数型
.局部变量 Process, 整数型
.局部变量 局_临时模块, 模块信息
Process ＝ OpenProcess (1040, 0, 进程ID)
.如果真 (Process ＝ 0)
    集_错误信息 ＝ “打开目标进程失败,无法枚举进程模块!”
    返回 (假)
.如果真结束
IsWow64Process (Process, 局_32位进程)
.如果真 (Is64 ＝ 假 或 局_32位进程)
    hSnapShot ＝ CreateToolhelp32Snapshot (8, 进程ID)
    .如果真 (hSnapShot ＞ 0)
        ' 编辑框.加入文本 (#换行符 ＋ “--------------------以下是32位模块信息---------------------------------” ＋ #换行符 ＋ #换行符)
        Mod.size ＝ 1024
        End ＝ Module32First (hSnapShot, Mod)
        .判断循环首 (End ≠ 0)
            ' 由于32位进程在64位系统中运行 存在系统目录的重定向问题 所以要修正一下路径
            ' 比如 C:\Windows\System32 其实指向的路径是 C:\Windows\SysWOW64
            局_模块路径 ＝ 到文本 (Mod.模块完整路径)
            .如果真 (Is64)
                局_模块路径 ＝ 子文本替换 (局_模块路径, “C:\Windows\System32”, “C:\Windows\SysWOW64”, , 1, 假)
            .如果真结束
            局_临时模块.模块句柄 ＝ 取十六进制文本 (Mod.模块句柄)
            局_临时模块.模块路径 ＝ 局_模块路径
            加入成员 (模块, 局_临时模块)
            End ＝ Module32Next (hSnapShot, Mod)
        .判断循环尾 ()
        返回 (真)
    .如果真结束
    CloseHandle (hSnapShot)
.如果真结束
CloseHandle (Process)
返回 (假)
.子程序 枚举进程模块, , 公开, 自动判断64或32
.参数 进程ID, 整数型
.参数 模块, 模块信息, 参考 数组
.局部变量 pbi, PROCESS_BASIC_INFORMATION64
.局部变量 Ldr, PEB_LDR_DATA
.局部变量 局_缓冲区, 字节集
.局部变量 局_临时地址, 长整数型
.局部变量 局_Flink地址, 长整数型
.局部变量 局_结构信息, LDR_DATA_TABLE_ENTRY64
.局部变量 局_模块路径, 文本型
.局部变量 局_32位进程, 逻辑型
.局部变量 hSnapShot, 整数型
.局部变量 Mod, 精易_模块信息
.局部变量 End, 整数型
.局部变量 Process, 整数型
.局部变量 局_临时模块, 模块信息
Process ＝ OpenProcess (1040, 0, 进程ID)
.如果真 (Process ＝ 0)
    集_错误信息 ＝ “打开目标进程失败,无法枚举进程模块!”
    返回 ()
.如果真结束
.如果真 (Is64)
    ' ==============枚举64位进程模块=========================
    .如果真 (NtWow64QueryInformationProcess64 (Process, 0, pbi, 48, 0) ≠ 0)
        集_错误信息 ＝ “查询进程信息失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 ()
    .如果真结束
    ' 得到PEB64结构的地址
    .如果真 (pbi.PebBaseAddress ＝ 0)
        集_错误信息 ＝ “获取PEB64结构地址失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 ()
    .如果真结束
    ' 获取Ldr64结构地址
    .如果真 (NtWow64ReadVirtualMemory64_LDR (Process, pbi.PebBaseAddress, Ldr, 40, 0) ≠ 0)
        集_错误信息 ＝ “获取Ldr64结构地址失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 ()
    .如果真结束
    ' 获取Ldr64.InLoadOrderModuleList.Flink地址
    局_缓冲区 ＝ 取空白字节集 (8)
    .如果真 (NtWow64ReadVirtualMemory64_bin (Process, Ldr.Ldr ＋ 16, 局_缓冲区, 8, 0) ≠ 0)
        集_错误信息 ＝ “获取Ldr64.InLoadOrderModuleList.Flink地址失败,无法枚举进程64位模块!”
        CloseHandle (Process)
        返回 ()
    .如果真结束
    局_临时地址 ＝ 取字节集数据 (局_缓冲区, #长整数型, 1)  ' 得到Ldr64.InLoadOrderModuleList.Flink地址
    局_Flink地址 ＝ 局_临时地址
    ' 开始遍历链表
    .循环判断首 ()
        局_缓冲区 ＝ 取空白字节集 (104)  ' LDR_DATA_TABLE_ENTRY64 结构的大小是 104
        .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_临时地址, 局_缓冲区, 104, 0) ＝ 0)
            RtlMoveMemory_LDR_DATA_TABLE_ENTRY64 (局_结构信息, 局_缓冲区, 104)
            .如果真 (局_结构信息.DllBase ＝ 0)
                跳出循环 ()
            .如果真结束
            ' 链表中第一个模块地址是程序本身 把它过滤掉
            .如果真 (局_Flink地址 ＝ 局_临时地址)
                局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
                ' 跳出循环 ()
            .如果真结束
            ' 读取64位的模块路径
            局_缓冲区 ＝ 取空白字节集 (局_结构信息.FullDllName.Length)
            .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_结构信息.FullDllName.Buffer, 局_缓冲区, 局_结构信息.FullDllName.Length, 0) ＝ 0)
                局_模块路径 ＝ Unicode转Ansi (局_缓冲区)
                局_临时模块.模块句柄 ＝ 十到十六 (局_结构信息.DllBase)
                局_临时模块.模块路径 ＝ 局_模块路径
                加入成员 (模块, 局_临时模块)
            .如果真结束
            局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
        .如果真结束
    .循环判断尾 (局_结构信息.DllBase ≠ 0)
    IsWow64Process (Process, 局_32位进程)
.如果真结束
.如果真 (Is64 ＝ 假 或 局_32位进程)
    hSnapShot ＝ CreateToolhelp32Snapshot (8, 进程ID)
    .如果真 (hSnapShot ＞ 0)
        Mod.size ＝ 1024
        End ＝ Module32First (hSnapShot, Mod)
        .判断循环首 (End ≠ 0)
            ' 由于32位进程在64位系统中运行 存在系统目录的重定向问题 所以要修正一下路径
            ' 比如 C:\Windows\System32 其实指向的路径是 C:\Windows\SysWOW64
            局_模块路径 ＝ 到文本 (Mod.模块完整路径)
            .如果真 (Is64)
                局_模块路径 ＝ 子文本替换 (局_模块路径, “C:\Windows\System32”, “C:\Windows\SysWOW64”, , 1, 假)
            .如果真结束
            局_临时模块.模块句柄 ＝ 取十六进制文本 (Mod.base)
            局_临时模块.模块路径 ＝ 局_模块路径
            加入成员 (模块, 局_临时模块)
            End ＝ Module32Next (hSnapShot, Mod)
        .判断循环尾 ()
    .如果真结束
    CloseHandle (hSnapShot)
.如果真结束
CloseHandle (Process)
.子程序 取最后错误, 文本型, 公开
返回 (集_错误信息)
.子程序 取文件名, 文本型, 公开
.参数 文件路径, 文本型
.局部变量 文本, 文本型
文本 ＝ 文件路径
.判断循环首 (真)
    .如果真 (寻找文本 (文本, “\”, , 假) ＝ -1)
        跳出循环 ()
    .如果真结束
    文本 ＝ 取文本右边 (文本, 取文本长度 (文本) － 寻找文本 (文本, “\”, , 假))
.判断循环尾 ()
返回 (文本)
.子程序 模块名取句柄, 文本型, 公开, 返回十六进制文本
.参数 进程ID, 整数型
.参数 模块名, 文本型
.局部变量 模块, 模块信息, , "0"
.局部变量 i, 整数型
枚举64位进程模块 (进程ID, 模块)
.计次循环首 (取数组成员数 (模块), i)
    .如果真 (取文件名 (模块 [i].模块路径) ＝ 模块名)
        返回 (模块 [i].模块句柄)
    .如果真结束
.计次循环尾 ()
返回 (“”)
.程序集 COM
.子程序 COM_bstr_t, 整数型, 公开
.参数 _bstr_t, 文本型
返回 (SysAllocString (编码_Ansi到Unicode (_bstr_t)))
.子程序 COM_QueryInterface, 整数型, 公开
.参数 this_, 整数型
.参数 refiid_, 整数型
.参数 pvoid_, 整数型, 参考
.局部变量 index, 整数型
index ＝ 0
置入代码 (#COM调用)
返回 (0)
.子程序 COM_AddRef, 整数型, 公开
.参数 this_, 整数型
.局部变量 index, 整数型
index ＝ 1
置入代码 (#COM调用)
返回 (0)
.子程序 COM_Release, 整数型, 公开
.参数 this_, 整数型
.局部变量 index, 整数型
index ＝ 2
置入代码 (#COM调用)
返回 (0)
.子程序 _GetMethodAddr, 整数型
.参数 Instance, 整数型
.参数 index, 整数型, , 索引从0开始
.局部变量 var, 整数型
var ＝ 取字节集数据 (指针到字节集 (Instance, 4), #整数型, )
var ＝ var ＋ index × 4
var ＝ 取字节集数据 (指针到字节集 (var, 4), #整数型, )
返回 (var)
.子程序 COM_调用COM方法, 整数型, 公开
.参数 pThis, 整数型
.参数 Index, 整数型, , 索引从1开始
.参数 arg1, 整数型, 可空
.参数 arg2, 整数型, 可空
.参数 arg3, 整数型, 可空
.参数 arg4, 整数型, 可空
.参数 arg5, 整数型, 可空
.参数 arg6, 整数型, 可空
.参数 arg7, 整数型, 可空
.参数 arg8, 整数型, 可空
.参数 arg9, 整数型, 可空
.参数 arg10, 整数型, 可空
.局部变量 参数数组, 整数型, , "0"
加入成员 (参数数组, pThis)
.计次循环首 (1, )
    .如果 (是否为空 (arg1))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg1)
    .如果结束
    .如果 (是否为空 (arg2))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg2)
    .如果结束
    .如果 (是否为空 (arg3))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg3)
    .如果结束
    .如果 (是否为空 (arg4))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg4)
    .如果结束
    .如果 (是否为空 (arg5))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg5)
    .如果结束
    .如果 (是否为空 (arg6))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg6)
    .如果结束
    .如果 (是否为空 (arg7))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg7)
    .如果结束
    .如果 (是否为空 (arg8))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg8)
    .如果结束
    .如果 (是否为空 (arg9))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg9)
    .如果结束
    .如果 (是否为空 (arg10))
        跳出循环 ()
    .否则
        加入成员 (参数数组, arg10)
    .如果结束
.计次循环尾 ()
返回 (CallWindowProcA (取指针_字节集型 (#动态调用代码), _GetMethodAddr (pThis, Index), 取数据_通用型_数组 (参数数组), 取数组成员数 (参数数组), 0))
.子程序 COM_StringToCLSID, GUID, 公开
.参数 参数_文本, 文本型
.局部变量 局部_clsid, GUID
CLSIDFromString_GUID (编码_Ansi到Unicode (参数_文本, ), 局部_clsid)
返回 (局部_clsid)
.子程序 COM_StringtoIID, GUID, 公开, 把COM中的接口名转换成接口标识GUID结构
.参数 接口类型, 文本型
.局部变量 iid, GUID
.局部变量 dwError
dwError ＝ IIDFromString (编码_Ansi到Unicode (接口类型), iid)
返回 (iid)
.子程序 取对象指针, 整数型, 公开
.参数 对象数据, 对象
.局部变量 pThisF, 整数型
CopyMemory_objcet2int (pThisF, 对象数据, 4)
返回 (pThisF)
.子程序 取变体型指针, 整数型, 公开
.参数 变体型, 变体型
返回 (lstrcat_int2variant (变体型, 0))
.子程序 COM_连接命名空间, 整数型, 公开, 成功返回一个IWbemServices类指针，失败返回零。
.参数 名字空间, 文本型, , 如“root\CIMV2”
.局部变量 CLSID_WbemLocator, GUID
.局部变量 IID_IWbemLocator, GUID
.局部变量 hresult, 整数型
.局部变量 WbemLocator, 整数型
.局部变量 ppNamespace, 整数型
.局部变量 strNetworkResource
CoInitializeEx (0, 0)
CoInitializeSecurity (0, -1, 0, 0, 0, 3, 0, 0, 0)
CLSID_WbemLocator ＝ COM_StringToCLSID (“{4590f811-1d3a-11d0-891f-00aa004b2e24}”)
IID_IWbemLocator ＝ COM_StringtoIID (“{dc12a687-737f-11cf-884d-00aa004b2e24}”)
hresult ＝ CoCreateInstance (CLSID_WbemLocator, 0, 1, IID_IWbemLocator, WbemLocator)
.如果真 (hresult ＝ 0)
    strNetworkResource ＝ COM_bstr_t (名字空间)
    hresult ＝ IWbemLocator_ConnectServer (WbemLocator, strNetworkResource, 0, 0, 0, 0, 0, 0, ppNamespace)
    SysFreeString (strNetworkResource)
    .如果 (hresult ＝ 0)
        hresult ＝ CoSetProxyBlanket (ppNamespace, 10, 0, 0, 3, 3, 0, 0)
        COM_Release (WbemLocator)
        返回 (ppNamespace)
    .否则
        输出调试文本 (“Windows Management Instrumentation 服务已禁用，请启动后重试！”)
    .如果结束
.如果真结束
CoUninitialize ()
返回 (0)
.子程序 IWbemLocator_ConnectServer, 整数型
.参数 this
.参数 strNetworkResource
.参数 strUser
.参数 strPassword
.参数 strLocale
.参数 lSecurityFlags
.参数 strAuthority
.参数 pCtx
.参数 ppNamespace, , 参考
.局部变量 index
index ＝ 3
置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
返回 (0)
.子程序 IEnumVARIANT_Next, 整数型
.参数 this
.参数 celt
.参数 rgvar
.参数 pceltFetched, , 参考
.局部变量 index
index ＝ 3
置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
返回 (0)
.子程序 IWbemServices_ExecQuery, 整数型
.参数 This, , , __RPC__in IWbemServices
.参数 strQueryLanguage, , , /* [in] */ __RPC__in const BSTR
.参数 strQuery, , , /* [in] */ __RPC__in const BSTR 
.参数 lFlags, , , /* [in] */ long
.参数 pCtx, , , /* [in] */ __RPC__in_opt IWbemContext
.参数 ppEnum, , 参考, /* [out] */ __RPC__deref_out_opt IEnumWbemClassObject
.局部变量 index
index ＝ 20
置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
返回 (0)
.子程序 IEnumWbemClassObject_Next, 整数型
.参数 This, , , __RPC__in IEnumWbemClassObject
.参数 lTimeout, , , /* [in] */ long
.参数 uCount, , , /* [in] */ ULONG
.参数 apObjects, , 参考, /* [length_is][size_is][out] */ __RPC__out_ecount_part(uCount, *puReturned) IWbemClassObject 
.参数 puReturned, , 参考, /* [out] */ __RPC__out ULONG
.局部变量 index
index ＝ 4
置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
返回 (0)
.子程序 IWbemClassObject_Get, 整数型
.参数 This, , , IWbemClassObject
.参数 wszName, , , /* [string][in] */ LPCWSTR
.参数 lFlags, , , /* [in] */ long
.参数 pVal, , , /* [unique][in][out] */
.参数 pType, , 参考, /* [unique][in][out] */ CIMTYPE
.参数 plFlavor, , 参考, /* [unique][in][out] */
.局部变量 index
index ＝ 4
置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
返回 (0)
.子程序 查询类属性, 变体型, , ExecQuery
.参数 wSql语句, 文本型, , 如“Select * From Win32_OperatingSystem”
.参数 属性名称, 文本型, , 如属性名“BuildNumber”
.局部变量 pWbemServices, 整数型
.局部变量 hresult, 整数型
.局部变量 ppObject, 整数型
.局部变量 pEnumerator, 整数型
.局部变量 var, 变体型
.局部变量 pcFetched, 整数型
.局部变量 strQueryLanguage, 整数型, , , /* [in] */ __RPC__in const BSTR
.局部变量 strQuery, 整数型, , , /* [in] */ __RPC__in const BSTR 
.局部变量 wszName, 整数型
pWbemServices ＝ COM_连接命名空间 (“root\CIMV2”)
.如果真 (pWbemServices ＞ 0)
    strQueryLanguage ＝ COM_bstr_t (“WQL”)
    strQuery ＝ COM_bstr_t (wSql语句)
    hresult ＝ IWbemServices_ExecQuery (pWbemServices, strQueryLanguage, strQuery, 位或 (32, 16), 0, pEnumerator)
    .如果真 (hresult ＝ 0)
        .循环判断首 ()
            hresult ＝ IEnumWbemClassObject_Next (pEnumerator, 2000, 1, ppObject, pcFetched)
            .如果真 (hresult ＝ 0)
                wszName ＝ COM_bstr_t (属性名称)
                hresult ＝ IWbemClassObject_Get (ppObject, wszName, 0, 取变体型指针 (var), 0, 0)
                SysFreeString (wszName)
                COM_Release (ppObject)
            .如果真结束
        .循环判断尾 (pcFetched ＝ 1)
        COM_Release (pEnumerator)
    .如果真结束
    COM_Release (pWbemServices)
    SysFreeString (strQueryLanguage)
    SysFreeString (strQuery)
.如果真结束
返回 (var)
.程序集 集_音乐音量, , , 该类仅支持同线程下使用 
.子程序 音乐_时长, 整数型, 公开, 获取音乐文件时长，获取总毫秒数
.参数 文件路径, 文本型, , 音乐文件的完整路径
.局部变量 总时间, 文本型
总时间 ＝ 取空白文本 (255)
mciSendStringA (“open ” ＋ #引号 ＋ 文件路径 ＋ #引号 ＋ “ alias tmpMusiczxczzcx”, 字符 (0), 0, 0)
mciSendStringA (“status ” ＋ “tmpMusiczxczzcx” ＋ “ length”, 总时间, 128, 0)  ' 取总时间
mciSendStringA (“close ” ＋ “tmpMusiczxczzcx”, 字符 (0), 0, 0)  ' 取总时间
返回 (到整数 (总时间))
.子程序 音乐_进度, 整数型, 公开, 播放后用线程或者时钟 实时获取当前播放长度
.参数 标识, 文本型
.局部变量 进度, 文本型
进度 ＝ 取空白文本 (255)
mciSendStringA (“status ” ＋ 标识 ＋ “ position”, 进度, 256, 0)
返回 (到整数 (进度))
.子程序 音乐_播放, 逻辑型, 公开, 真=播放成功,假=播放失败。可用于同时播放多首音乐，只要标识不同
.参数 文件名, 文本型, , 支持格式:mp3,wav,其他格式没有测试..也可以是网络地址
.参数 标识, 文本型, , 不可以含有空格，用于标识播放了哪个歌曲,可用来控制该音乐。比如:mysong
.参数 是否等待播放完毕, 逻辑型, 可空, 默认为假，不等待播放完毕直接返回，如果为真，则等待播放完毕后才会返回。
mciSendStringA (“close ” ＋ 标识, “0”, 0, 0)
mciSendStringA (“open ” ＋ #引号 ＋ 文件名 ＋ #引号 ＋ “ alias ” ＋ 标识, “0”, 0, 0)
返回 (mciSendStringA (“play ” ＋ 标识 ＋ 选择 (是否等待播放完毕 ＝ 真, “ wait”, “”), “0”, 0, 0) ＝ 0)
.子程序 音乐_暂停, 逻辑型, 公开, 暂时后，可调用 音乐_播放() 继续播放
.参数 标识, 文本型, , 音乐_播放中使用的标识
返回 (mciSendStringA (“pause ” ＋ 标识, “0”, 0, 0) ＝ 0)
.子程序 音乐_停止, 逻辑型, 公开, 禁止指定标识正在播放的音乐
.参数 标识, 文本型, , 音乐_播放中使用的标识，即使播放完毕也记得调用一次
返回 (mciSendStringA (“close ” ＋ 标识, “0”, 0, 0) ＝ 0)
.子程序 音量_置声道, , 公开, 设置左右声道的音量，从0～100
.参数 左声道音量, 整数型, , 0～100
.参数 右声道音量, 整数型, , 0～100
.局部变量 音量, 整数型
.局部变量 左, 整数型
.局部变量 右, 整数型
左 ＝ (100 － 左声道音量) ÷ 100 × 256
右 ＝ (100 － 右声道音量) ÷ 100 × 256
音量 ＝ (257 － 左) × 255 ＋ 16711680 × (257 － 右)
waveOutSetVolume (0, 音量)
.子程序 音量_取声道, , 公开, 取出左右声道的音量，用参考变量，0～100
.参数 左声道音量, 整数型, 参考, 装载左声道音量的变量
.参数 右声道音量, 整数型, 参考, 装载右声道音量的变量
.局部变量 音量值, 整数型
.如果真 (waveOutGetVolume (0, 音量值) ＝ 0)  ' 成功
    左声道音量 ＝ 位与 (位或 (音量值, 4294901760), 65535) ＼ 256
    左声道音量 ＝ 左声道音量 × 100 ÷ 256
    右声道音量 ＝ 位与 (位或 (音量值, 65535), 4294901760) ÷ 65536 ＼ 256
    右声道音量 ＝ 右声道音量 × 100 ÷ 256
    .如果真 (右声道音量 ＜ 0)
        .如果真 (右声道音量 ＝ -50)
            右声道音量 ＝ 0
        .如果真结束
        右声道音量 ＝ 49 ＋ 取绝对值 (50 ＋ 右声道音量)
    .如果真结束
.如果真结束
.子程序 音量_静音, , 公开, 设置静音或解除静音,如果已经静音就解除，否则静音
.参数 窗口句柄, 整数型, , 可以通过“取窗口句柄（）”获得
SendMessageA (窗口句柄, 793, 2100912, 524288)
.子程序 音量_增加, , 公开, 控制声卡方式增加音量
.参数 窗口句柄, 整数型, , 可以通过“取窗口句柄（）”获得
SendMessageA (窗口句柄, 793, 197266, 655360)
.子程序 音量_减少, , 公开, 控制声卡方式减少音量
.参数 窗口句柄, 整数型, , 可以通过“取窗口句柄（）”获得
SendMessageA (窗口句柄, 793, 197266, 589824)
.程序集 集_易语言相关
.子程序 易语言_取易语言安装目录, 文本型, 公开, 成功返回路径,不需要文件名时,路径以\结尾,失败返回空文本
.参数 是否需要文件名, 逻辑型, 可空, 默认为假,即为不需要留文件名
.局部变量 path, 文本型
.局部变量 hkey, 整数型
.局部变量 port, 字节集
.局部变量 size, 整数型
.局部变量 ret, 整数型
RegOpenKeyA (#HKEY_CURRENT_USER, “Software\FlySky\E\Install”, hkey)
size ＝ #MAX_PATH
port ＝ 取空白字节集 (size)
ret ＝ RegQueryValueExA (hkey, “Path”, #NULL, #NULL, port, size)
RegCloseKey (hkey)
.如果真 (ret ＝ #ERROR_SUCCESS)
    path ＝ 到文本 (port)
    path ＝ 取文本左边 (path, 取文本长度 (path) － 4)  ' lib\
    .如果真 (是否需要文件名)
        path ＝ path ＋ “e.exe”
    .如果真结束
.如果真结束
返回 (path)
.子程序 易语言_加快捷方式到IE浏览器, 逻辑型, 公开
.参数 图标所在路径文件名, 文本型, , 用于加载到IE浏览器快捷按钮上所用原始图标的路径文件名,以ICO结束,如:"e.ico"
.参数 提示文字, 文本型, , 用于在IE浏览器中用于提示的文字,如:“易语言3.6”
.参数 添加还是清除, 逻辑型
.局部变量 路径, 文本型
.如果真 (文件是否存在 (图标所在路径文件名) ＝ 假)
    返回 (假)
.如果真结束
路径 ＝ 取文本注册项 (#现行用户, “Software\FlySky\E\Install\Path”, “”)
路径 ＝ 取文本左边 (路径, 取文本长度 (路径) － 4)
.如果真 (路径 ≠ “”)
    写到文件 (路径 ＋ “e.ico”, 读入文件 (图标所在路径文件名))
.如果真结束
.如果 (添加还是清除 ＝ 真)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”, 提示文字)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”, “{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}”)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”, “Yes”)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”, 路径 ＋ “e.exe”)  ' 程序位置(路径)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”, 路径 ＋ “e.ico”)  ' 点燃图标
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”, 路径 ＋ “e.ico”)  ' 程序图标
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”, 提示文字)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”, 提示文字)
.否则
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”)  ' 程序位置(路径)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”)  ' 点燃图标
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”)  ' 程序图标
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”)
    删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}”)
.如果结束
返回 (真)
.子程序 易语言_引用易模块, , 公开, 必须编译出来才行,因为在调试状态下,易语言不允许添加模块的
.参数 模块路径, 文本型, , 如：C:\精易模块.ec
.局部变量 局_模块句柄, 整数型
.局部变量 局_模块对话框, 整数型
.局部变量 局_打开按钮句柄, 整数型
.局部变量 局_Edit句柄, 整数型
.局部变量 局_树型框, 外部树型框
.局部变量 局_计次, 整数型
.局部变量 局_超时返回, 整数型
局_模块句柄 ＝ 窗口_取句柄_模糊 (“易语言 - ”, “ENewFrame”)
.如果真 (局_模块句柄 ≤ 0)
    提示框 (“易语言未打开,无法引用模块”)
    返回 ()
.如果真结束
窗口_置焦点 (局_模块句柄)
局_模块句柄 ＝ 功能_取模块引用表句柄 (局_模块句柄)
.如果真 (局_模块句柄 ≤ 0)
    提示框 (“引用表提取失败”)
    返回 ()
.如果真结束
局_树型框.初始化 (局_模块句柄)
.计次循环首 (局_树型框.取项目数 (), 局_计次)
    .如果真 (局_树型框.取项目文本 (局_计次 － 1) ＝ “模块引用表”)
        局_树型框.置现行选中项 (局_计次 － 1)
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
程序_延时 (10)
鼠标_消息 (局_模块句柄, 185, 13, 2)  ' 发送鼠标右键消息
程序_延时 (10)
投递消息整数 (局_模块句柄, 256, #I键, 0)  ' 发送消息点击菜单上的添加模块引用
局_超时返回 ＝ 取启动时间 ()
.判断循环首 (0 ＜ 1)
    局_模块对话框 ＝ 窗口_取句柄 (, , “#32770”, “请选择欲加入易模块文件:”)
    .判断开始 (局_模块对话框 ＞ 0)
        局_Edit句柄 ＝ 窗口_取句柄 (局_模块对话框, , “Edit”, )
        局_打开按钮句柄 ＝ 窗口_取句柄 (局_模块对话框, , “Button”, “打开(&O)”)
        窗口_置控件内容 (局_Edit句柄, 模块路径)
        程序_延时 (10)
        .如果真 (窗口_取控件内容 (局_Edit句柄) ≠ 模块路径)
            窗口_置控件内容 (局_Edit句柄, 模块路径)
        .如果真结束
        鼠标_消息 (局_打开按钮句柄, 5, 5)  ' 发送消息点击打开按钮
        跳出循环 ()
    .判断 (取启动时间 () － 局_超时返回 ＞ 5000)
        提示框 (“超时,引用失败”)
        跳出循环 ()
    .默认
    .判断结束
.判断循环尾 ()
.子程序 功能_取模块引用表句柄, 整数型
.参数 顶级句柄, 整数型
.局部变量 局_1级句柄, 整数型
.局部变量 局_2级句柄, 整数型
.局部变量 局_3级句柄, 整数型
.局部变量 局_4级句柄, 整数型
.局部变量 局_5级句柄, 整数型
.局部变量 子窗口数组, 整数型, , "0"
局_1级句柄 ＝ 窗口_取句柄 (顶级句柄, , “AfxControlBar42s”, “工作夹”)
.如果真 (局_1级句柄 ≤ 0)
    返回 (0)
.如果真结束
局_2级句柄 ＝ 窗口_取句柄 (局_1级句柄, , “Afx:400000:8:10011:1900015:0”, “工作夹”)
.如果真 (局_2级句柄 ≤ 0)
    返回 (0)
.如果真结束
局_3级句柄 ＝ 窗口_取句柄 (局_2级句柄, , “#32770”, )
.如果真 (局_3级句柄 ≤ 0)
    返回 (0)
.如果真结束
局_4级句柄 ＝ 窗口_取句柄 (局_3级句柄, , “SysTabControl32”, “Tab1”)
.如果真 (局_4级句柄 ≤ 0)
    返回 (0)
.如果真结束
.如果真 (窗口_枚举子窗口 (局_4级句柄, 子窗口数组, “SysTreeView32”) ＝ 2)
    返回 (子窗口数组 [2])
.如果真结束
返回 (0)
.程序集 集_杂合________
.程序集变量 FLSAList, Stroks, , "0"
.子程序 ADD__, 整数型, , 加法指令 返回值=操作数1+操作数2+操作数3
.参数 操作数1, 整数型
.参数 操作数2, 整数型
.参数 操作数3, 整数型, 可空
' 0045E3BF      8B45 0C       mov     eax, dword ptr [ebp+C]
' 0045E3C2      0345 10       add     eax, dword ptr [ebp+10]
' 0045E3C5      0145 08       add     dword ptr [ebp+8], eax
' 8B 45 0C 03 45 10 01 45 08
置入代码 ({ 139, 69, 12, 3, 69, 16, 1, 69, 8 })
返回 (操作数1)
.子程序 取字节集指针, 整数型
.参数 参_字节集, 字节集, 参考
置入代码 ({ 139, 69, 8, 139, 0, 131, 248, 0, 116, 3, 131, 192, 8, 201, 194, 4, 0 })
返回 (0)
.子程序 SUB__, 整数型, , 减法指令 返回值=操作数1-操作数2-操作数3
.参数 操作数1, 整数型
.参数 操作数2, 整数型
.参数 操作数3, 整数型, 可空
' 0045E379      8B45 0C       mov     eax, dword ptr [ebp+C]
' 0045E37C      0345 10       add     eax, dword ptr [ebp+10]
' 0045E37F      2945 08       sub     dword ptr [ebp+8], eax
' 8B 45 0C 03 45 10 29 45 08
置入代码 ({ 139, 69, 12, 3, 69, 16, 41, 69, 8 })
返回 (操作数1)
.子程序 递增, 整数型, , 对提供的整数型变量值+1,注意:不支持字节型,短整数型,长整数型等的操作
.参数 整数变量, 整数型, 参考, 此参数必须为整数型变量,会被+1保存回去.显示为符号整数型
' 0040113B    51              push    ecx
' 0040113C    B8 01000000     mov     eax, 1
' 00401141    8B4D 08         mov     ecx, dword ptr [ebp+8]
' 00401144    F0:0FC101       lock xadd dword ptr [ecx], eax
' 00401148    40              inc     eax
' 00401149    59              pop     ecx
' 0040114A    C9              leave
' 0040114B    C2 0400         retn    4
' 51 B8 01 00 00 00 8B 4D 08 F0 0F C1 01 40 59 C9 C2 04 00
置入代码 ({ 81, 184, 1, 0, 0, 0, 139, 77, 8, 240, 15, 193, 1, 64, 89, 201, 194, 4, 0 })
返回 (0)
' 004034A8    F0:FF00               lock inc dword ptr [eax]
.子程序 递减, 整数型, , 对提供的整数型变量值-1,注意:不支持字节型,短整数型,长整数型等的操作
.参数 整数变量, 整数型, 参考, 此参数必须为整数型变量,会被-1保存回去.显示为符号整数型
' 0040113B    51              push    ecx
' 0040113C    B8 FFFFFFFF     mov     eax, -1
' 00401141    8B4D 08         mov     ecx, dword ptr [ebp+8]
' 00401144    F0:0FC101       lock xadd dword ptr [ecx], eax
' 00401148    48              dec     eax
' 00401149    59              pop     ecx
' 0040114A    C9              leave
' 0040114B    C2 0400         retn    4
' 51 B8 FF FF FF FF 8B 4D 08 F0 0F C1 01 48 59 C9 C2 04 00
置入代码 ({ 81, 184, 255, 255, 255, 255, 139, 77, 8, 240, 15, 193, 1, 72, 89, 201, 194, 4, 0 })
返回 (0)
' 004034A8    F0:FF08               lock dec dword ptr [eax]
.子程序 转换_转数据大小为标准显示, 文本型, 公开, '最高支持pb位 以科学的方式显示文件大小 不清楚在32位下的反应 注意返回虽然是kbtb什么的 但实际是kib mib 进制为1024 1000是标准的kb mb的进制位 KiB  一共四种 1Kb表示1000个bit 1Kib表示1024个bit 1KB表示1000个Byte字节 KiB表示1024个Byte字节
.参数 b, 文本型, , ‘文本型的b大小 不是bit比特 是Byte字节 如取文件大小返回的就是byte
.局部变量 小数文本, 双精度小数型
.局部变量 预处理数, 双精度小数型
' 源码采纳地址：https://bbs.125.la/thread-14311769-1-1.html
' 1024=1kb
' 1048576=1mb
' 1073741824=1gb
' 1099511627776=1tb
' 1.1259e+15=1pb
' 1024  kb
' 1024*1024 mb
' 1024*1024*1024 gb
' 1024*1024*1024*1024 tb
' 1024*1024*1024*1024*1024 pb
' 1024*1024*1024*1024*1024*1024 eb
' 先判断是否大于 大于则按文本处理转换后返回
.如果真 (取文本长度 (b) ＞ 19 或 到整数 (取文本左边 (b, 10)) ＞ 9223372036 或 到整数 (取文本右边 (b, 9)) ＞ 854775807)  ' 超过小数最大尾数会出错 或处理结果超过最大长整数
    .如果 (取文本长度 (b) ＝ 19)  ' 如果是19位但超过了最大长整数就除10处理 文本处理方式
        小数文本 ＝ 到数值 (取文本左边 (b, 18) ＋ “.” ＋ 取文本右边 (b, 1))
        预处理数 ＝ 小数文本 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024
        返回 (到文本 (四舍五入 (预处理数 × 10, 2)) ＋ “eb”)
    .否则
        小数文本 ＝ 到数值 (取文本左边 (b, 19) ＋ “.” ＋ 取文本右边 (b, 取文本长度 (b) － 19))  ' 转换到双精度小数型
        预处理数 ＝ 小数文本 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024
        .计次循环首 (取文本长度 (b) － 19, )
            预处理数 ＝ 预处理数 × 10
        .计次循环尾 ()
        返回 (到文本 (四舍五入 (预处理数, 2)) ＋ “eb”)
    .如果结束
.如果真结束
' 正式按整数处理
.如果真 (到长整数 (b) ＜ 1024)  ' 小于这个则为  b
    返回 (b ＋ “b”)
.如果真结束
.如果真 (到长整数 (b) ＜ 1048576)  ' 小于这个则为  kb
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024, 2)) ＋ “kb”)
.如果真结束
.如果真 (到长整数 (b) ＜ 1073741824)  ' 小于这个则为 mb
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024, 2)) ＋ “mb”)
.如果真结束
.如果真 (到长整数 (b) ＜ 1099511627776)  ' 小于这个则为  gb
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “gb”)
.如果真结束
.如果真 (到长整数 (b) ＜ 1.1259e+015)  ' 小于这个则为  tb
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “tb”)
.如果真结束
.如果真 (到长整数 (b) ＜ 1.1529e+018)  ' 小于这个则为  pb
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “pb”)
.如果真结束
返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “eb”)
.子程序 控制台_快速编辑模式, , 公开, 禁用快速编辑模式可以防止鼠标点击暂停控制台程序
.参数 参_是否禁止, 逻辑型, 可空, 默认禁止
.局部变量 局_句柄, 整数型
.局部变量 局_标志值, 整数型
局_句柄 ＝ GetStdHandle (-10)
GetConsoleMode (局_句柄, 取变量地址_整数 (局_标志值))
.如果真 (是否为空 (参_是否禁止))
    参_是否禁止 ＝ 真
.如果真结束
.如果 (参_是否禁止)
    局_标志值 ＝ 位与 (局_标志值, 位取反 (位与 (2147483647, 96)))
.否则
    局_标志值 ＝ 位或 (局_标志值, 96)
.如果结束
SetConsoleMode (局_句柄, 局_标志值)
.子程序 取错误信息文本_API, 文本型, 公开, GetLastError
.参数 错误码, 整数型, 可空
.局部变量 nSize, 整数型
.局部变量 Buffer, 文本型
.局部变量 hlocal, 整数型
.局部变量 dwError, 整数型
.如果 (是否为空 (错误码))
    dwError ＝ GetLastError ()
.否则
    dwError ＝ 错误码
.如果结束
nSize ＝ FormatMessageA (位或 (#FORMAT_MESSAGE_FROM_SYSTEM, #FORMAT_MESSAGE_IGNORE_INSERTS, #FORMAT_MESSAGE_ALLOCATE_BUFFER), #NULL, dwError, #NULL, 取指针整数_ (hlocal), 0, #NULL)
.如果真 (nSize ＞ 0)
    Buffer ＝ 取空白文本 (nSize)
    RtlMoveMemory (取指针_文本型 (Buffer), hlocal, nSize)
    LocalFree (hlocal)
    返回 (“错误码：” ＋ 到文本 (dwError) ＋ “│” ＋ 删首尾空 (Buffer))
.如果真结束
返回 (“找不到信息！”)
.子程序 类_取内部方法地址, 整数型, 公开, 返回方法地址，只能类内部使用
.参数 方法序号, 整数型, , 方法序号,从1开始,_初始化是1,_销毁是2
.局部变量 方法地址, 整数型
' 方法地址 ＝ HeapAlloc (GetProcessHeap (), 0, 14)
方法地址 ＝ VirtualAlloc (0, 4096, #MEM_COMMIT, #PAGE_EXECUTE_READWRITE)
置入代码 ({ 139, 69, 0, 139, 64, 8, 139, 200, 139, 93, 8, 75, 107, 219, 4, 139, 0, 139, 0, 3, 195, 139, 24, 139, 69, 252, 102, 199, 0, 91, 184, 137, 88, 2, 198, 64, 6, 104, 137, 72, 7, 102, 199, 64, 11, 83, 255, 198, 64, 13, 224 })
返回 (方法地址)
.子程序 类_释放内部方法地址, 逻辑型, 公开
.参数 方法地址, 整数型, , 取类内部方法地址（）的返回值
' 返回 (HeapFree (GetProcessHeap (), 0, 方法地址) ≠ 0)
返回 (VirtualFree (方法地址, 0, #MEM_RELEASE) ≠ 0)
.子程序 整数转浮点数, 文本型, 公开, 整数数值转为十六进制浮点数文本带空格
.参数 局_整数参数, 整数型, , 整数参数
.局部变量 局_浮点数, 双精度小数型
.局部变量 局_浮点数据地址, 整数型
.局部变量 局_汇编转进制, 汇编类
.局部变量 局_浮点数字节集, 字节集
局_浮点数 ＝ 到数值 (局_整数参数)
局_浮点数据地址 ＝ 取变量地址_整数 (局_浮点数)
局_浮点数字节集 ＝ 指针到字节集 (局_浮点数据地址, 8)
返回 (局_汇编转进制.转为十六进制 (局_浮点数字节集))
.子程序 __set, 整数型, 公开, 请确保指针的合法性,写到内存
.参数 lpAddr, 整数型, , 内存地址
.参数 offset, 整数型, , 偏移
.参数 value, 整数型, , 写入值
置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 25, 139, 85, 16, 137, 20, 25, 201, 194, 12, 0 })
' mov ebx,[ebp+8]
' mov ecx,[ebp+12]
' mov eax,[ebx+ecx]
' mov edx,[ebp+16]
' mov [ebx+ecx],edx
' leave
' ret 12
返回 (0)
.子程序 __get, 整数型, 公开, 请确保指针的合法性,读取内存
.参数 lpAddr, 整数型, , 内存地址
.参数 offset, 整数型, , 偏移
置入代码 ({ 139, 69, 8, 139, 93, 12, 139, 4, 24, 201, 194, 8, 0 })
' mov eax,[ebp+8]
' mov ebx,[ebp+12]
' mov eax,[eax+ebx]
' leave
' ret 8
返回 (0)
.子程序 __query_bit, 逻辑型, 公开, 查询一个整数 32位中的某一位是否为 1  @福仔
.参数 num, 整数型
.参数 bit, 字节型, , 只支持 0 - 31, 越界返回假
置入代码 ({ 138, 77, 12, 51, 192, 128, 249, 32, 115, 14, 139, 69, 8, 133, 192, 116, 7, 51, 219, 67, 211, 227, 35, 195, 201, 194, 8, 0 })
' mov cl, [ebp+12]
' xor eax,eax
' cmp cl, 32
' jae exit    ; 位数大于等于32则返回
' mov eax, [ebp+8]
' test eax,eax
' jz exit     ; 参数1位0返回0
' mov ebx, 1
' shl ebx, cl
' and eax, ebx
' exit:
' leave
' ret 8
' 返回 (位与 (a, 左移 (1, offset)) ≠ 0)' 与上面的汇编效果差不多
返回 (假)
.子程序 __set_bit_on, 整数型, 公开, 设置一个整数 32位中的某一位为1, 返回设置后的值  @福仔
.参数 num, 整数型
.参数 bit, 字节型, , 只支持 0 - 31, 越界返回0
置入代码 ({ 138, 77, 12, 51, 192, 128, 249, 32, 115, 10, 139, 69, 8, 51, 219, 67, 211, 227, 11, 195, 201, 194, 8, 0 })
' mov cl,[ebp+12]
' xor eax, eax
' cmp cl, 32
' jae exit
' mov eax,[ebp+8]
' xor ebx,ebx
' inc ebx
' shl ebx, cl
' or eax, ebx
' exit:
' leave
' ret 8
返回 (0)
.子程序 __set_bit_off, 整数型, 公开, 设置一个整数 32位中的某一位为0, 返回设置后的值  @福仔
.参数 num, 整数型
.参数 bit, 字节型, , 只支持 0 - 31, 越界返回0
置入代码 ({ 138, 77, 12, 51, 192, 128, 249, 32, 115, 12, 139, 69, 8, 51, 219, 67, 211, 227, 247, 211, 35, 195, 201, 194, 8, 0 })
' mov cl,[ebp+12]
' xor eax, eax
' cmp cl, 32
' jae exit
' mov eax,[ebp+8]
' xor ebx,ebx
' inc ebx
' shl ebx, cl
' not ebx
' and eax, ebx
' exit:
' leave
' ret 8
返回 (0)
.子程序 __make_list, 整数型, , 根据上一个函数栈地址生成一个list数据, 返回的数据需要调用free释放
.局部变量 ebp, 整数型
.局部变量 list, 整数型
.局部变量 i, 整数型
.局部变量 offset, 整数型
.局部变量 pAddr, 整数型
.局部变量 data, 整数型
.局部变量 size, 整数型
.局部变量 len, 整数型
ebp ＝ 0
置入代码 ({ 62, 139, 69, 0, 62, 137, 69, 252 })
' mov eax, dword ptr ds:[ebp]
' mov dword ptr ds:[ebp-4], eax
.如果真 (ebp ＝ 0)
    返回 (0)
.如果真结束
ebp ＝ ebp ＋ 12  ' 指向第一个参数
list ＝ malloc (200)  ' 缓冲区给大点无所谓
.计次循环首 (20, i)
    ' 这里的ebp结构为,每个成员占4字节
    ' 有可空标志的在栈里占用8个字节,前4个是参数,后4个标记是否为空,1为非空 0为空
    ' +0 参数地址
    ' +4 参数是否不为空, 1=不为空, 0=为空
    offset ＝ (i － 1) × 8
    .如果真 (__get (ebp, offset ＋ 4) ＝ 0)  ' 参数为空,不继续取后面的参数
        跳出循环 ()
    .如果真结束
    ' 走到这里表示参数不为空,取出参数的栈地址
    pAddr ＝ __get (ebp, offset)  ' 这里取到的是栈地址
    data ＝ __get (pAddr, 0)  ' 如果这个数据恰巧是整数, 而且也是一个指针, 那就会误判了
    .' 如果真 (IsBadCodePtr (data) ＝ 假)  ' 指针有效, 有效就校验里面的数据, 数组格式是n,0,0,0, 字节集就是字节数组
        ' ' 没法获取变量数据类型, 只能用第一个成员来判断是否为数组/字节集
        ' len ＝ __get (data, 0)
        ' 如果真 (len ＜ 10)  ' 最多10维数组
        ' data ＝ data ＋ len × 4 ＋ 4  ' 指向数据起始位置, len=维数
    .如果真结束
    __set (list, (i － 1) × 4, data)  ' 把参数数据写入参数列表里
.计次循环尾 ()
返回 (list)
.子程序 __set_byte, 整数型, 公开, 请确保指针的合法性,写到内存
.参数 lpAddr, 整数型, , 内存地址
.参数 offset, 整数型, , 偏移
.参数 value, 字节型, , 写入值
置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 11, 138, 85, 16, 136, 20, 11, 201, 194, 12, 0 })
' mov ebx,[ebp+8]
' mov ecx,[ebp+12]
' mov eax,[ecx+ebx]
' mov dl,[ebp+16]
' mov [ecx+ebx],dl
' leave
' ret 12
返回 (0)
.子程序 __get_byte, 字节型, 公开, 请确保指针的合法性,读取内存
.参数 lpAddr, 整数型, , 内存地址
.参数 offset, 整数型, , 偏移
置入代码 ({ 139, 69, 8, 139, 93, 12, 139, 4, 24, 201, 194, 8, 0 })
' mov eax,[ebp+8]
' mov ebx,[ebp+12]
' mov eax,[eax+ebx]
' leave
' ret 8
返回 (0)
.子程序 CallObject, 整数型, 公开, 调用对象
.参数 对象指针, 整数型
.参数 方法索引, 整数型
.参数 附加参数1, 整数型, 可空
.参数 附加参数2, 整数型, 可空
.参数 附加参数3, 整数型, 可空
.参数 附加参数4, 整数型, 可空
.参数 附加参数5, 整数型, 可空
.参数 附加参数6, 整数型, 可空
.参数 附加参数7, 整数型, 可空
.参数 附加参数8, 整数型, 可空
.参数 附加参数9, 整数型, 可空
.局部变量 pThis, 整数型
.如果真 (取反 (IsBadReadPtr (对象指针, 4)))
    指针到变量 (对象指针, pThis)
    .如果真 (取反 (IsBadCodePtr (pThis)))
        返回 (调用子程序_ (__get (pThis, 方法索引 × 4), 对象指针, 附加参数1, 附加参数2, 附加参数3, 附加参数4, 附加参数5, 附加参数6, 附加参数7, 附加参数8, 附加参数9))
    .如果真结束
.如果真结束
返回 (0)
.子程序 SafeRelease, 整数型, 公开, 释放对象,调用对象的第二个方法
.参数 pObj, 整数型, 参考, 释放后把原来的对象清0
.局部变量 index, 整数型
.局部变量 pThis, 整数型
.局部变量 ret, 整数型
.如果真 (pObj ≠ 0)
    ret ＝ CallObject (pObj, 2, , , , , , , , , )  ' 调用对象的第二个方法
    pObj ＝ 0
.如果真结束
返回 (ret)
' index ＝ 2   '精易模块的调用方法,应该都一样,这个变量请放在第一个位置,还有参数的参考要去掉
' 置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
' 返回 (0)
.子程序 调用子程序_, 整数型, 公开, call
.参数 调用地址, 整数型
.参数 参数1, 整数型, 可空
.参数 参数2, 整数型, 可空
.参数 参数3, 整数型, 可空
.参数 参数4, 整数型, 可空
.参数 参数5, 整数型, 可空
.参数 参数6, 整数型, 可空
.参数 参数7, 整数型, 可空
.参数 参数8, 整数型, 可空
.参数 参数9, 整数型, 可空
.参数 参数10, 整数型, 可空
.参数 参数11, 整数型, 可空
.参数 参数12, 整数型, 可空
.参数 参数13, 整数型, 可空
.参数 参数14, 整数型, 可空
.参数 参数15, 整数型, 可空
.如果真 (IsBadCodePtr (调用地址))
    返回 (0)
.如果真结束
置入代码 ({ 86, 190, 15, 0, 0, 0, 141, 77, 8, 141, 76, 241, 252, 139, 65, 4, 133, 192, 116, 2, 255, 49, 78, 131, 233, 8, 133, 246, 117, 239, 255, 85, 8, 94, 201, 194, 124, 0 })
返回 (0)
.子程序 取数据_通用型, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样,注意: 字节集数据需要+8,前8位是标准,字节集型数据建议使用 取指针_字节集型()
.参数 数据, 通用型, 参考, 不建议传递字节集型变量
置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
返回 (0)
.子程序 取指针_通用型, 整数型, 公开, 取到的是变量在栈中的地址,和 取变量地址() 一样
.参数 变量, 通用型, 参考, 基本支持所有类型
置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
返回 (0)
.子程序 取指针_通用型_数组, 整数型, 公开, 取到的是变量在栈中的地址,和 取变量地址() 一样
.参数 变量, 通用型, 参考 数组
置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
返回 (0)
.子程序 取指针_文本型, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样
.参数 文本, 文本型, 参考
置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
返回 (0)
.子程序 取指针_字节集型, 整数型, 公开, 取到的是变量堆地址,和 取变量数据地址() 一样
.参数 字节集, 字节集, 参考
置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 15, 132, 3, 0, 0, 0, 131, 192, 8, 201, 194, 4, 0 })
返回 (0)
.子程序 取数据_通用型_数组, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样
.参数 数据, 通用型, 参考 数组, 基本支持所有类型
置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 10, 139, 24, 193, 227, 2, 131, 192, 4, 1, 216, 201, 194, 4, 0 })
返回 (0)
.子程序 指针到变量, , 公开, 本函数用于指针转基本数据类型.(字节,短整数,整数,小数,逻辑,子程序指针).请确保指针的合法性
.参数 指针, 整数型
.参数 变量, 通用型, 参考
置入代码 ({ 139, 93, 8, 139, 69, 12, 255, 51, 143, 0, 201, 194, 8, 0 })
.子程序 指针转移, 整数型, 公开, 设置将第一个参数转移到第二个同类型的变量去处理,此时操作第二个变量相当于操作第一个变量,功能类似于核心库的 事件转移(),成功返回还原指针时需要的地址,调用此函数后在必须调用 指针还原() 来还原指针,否则90%以上的几率会崩溃,调用后在没有还原指针之前不能操作第一个变量
.参数 源指针, 整数型, , 被操作的指针,一般是exe传给dll的,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
.参数 转移到, 整数型, , 把源指针转移到这里,这样操作这个变量相当于操作源变量,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
.局部变量 pMem, 整数型
pMem ＝ 指针_到整数 (转移到)  ' 记录第二个变量原来的数据地址,在还原时要把这个地址还原回去
__set (转移到, 0, 指针_到整数 (源指针))  ' 把源指针放到局部变量里,让局部变量指向源指针
返回 (pMem)
.子程序 指针还原, , 公开, 调用此函数前必须先调用 指针转移() 
.参数 源指针, 整数型, , 被操作的指针,一般是exe传给dll的,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
.参数 转移到, 整数型, , 把源指针转移到这里,这样操作这个变量相当于操作源变量,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
.参数 还原指针, 整数型, , 指针转移() 函数返回的指针
__set (源指针, 0, 指针_到整数 (转移到))  ' 因为操作后局部变量的指针会发生改变,所以要重新取一下地址,放到源指针里,这样的话源指针指向的是局部变量修改后的地址
__set (转移到, 0, 还原指针)  ' 把原来的局部变量数据还原,因为局部变量在子程序执行完后会释放,把原来的指针还回去,让他释放原来的指针
.子程序 A2W, 字节集, , ansi转unicode,
.参数 转换文本, 文本型
.参数 代码, 整数型, 可空, 默认936 中文
.局部变量 uLen, 整数型
.局部变量 bin, 字节集
.局部变量 dwLen, 整数型
.如果真 (转换文本 ＝ “”)
    返回 ({ 0, 0 })
.如果真结束
.如果真 (是否为空 (代码))
    代码 ＝ 936
.如果真结束
dwLen ＝ 取文本长度 (转换文本)
uLen ＝ MultiByteToWideChar (代码, 0, 取指针_文本型 (转换文本), dwLen, 0, 0) × 2
bin ＝ 取空白字节集 (uLen ＋ 2)
.如果真 (uLen ＞ 0)
    MultiByteToWideChar (代码, 0, 取指针_文本型 (转换文本), dwLen, 取指针_字节集型 (bin), uLen)
.如果真结束
返回 (bin)
.子程序 A2W_指针, 整数型, , 返回的指针需要释放
.参数 A, 整数型, , 窄字符指针
.参数 Alen, 整数型, , 窄字符长度(如需返回0,0结尾的传入Alen+1)或者-1
.参数 CodePage, 整数型, , #CP_
.参数 Wlen, 整数型, 参考, 宽字符长度
.局部变量 W, 整数型
连续赋值 (0, Wlen)
Wlen ＝ MultiByteToWideChar (CodePage, 0, A, Alen, W, 0)
W ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Wlen × 2)
.如果真 (W ＝ 0)
    返回 (0)
.如果真结束
MultiByteToWideChar (CodePage, 0, A, Alen, W, Wlen)
返回 (W)
.子程序 W2A_指针, 整数型, , 返回的指针需要释放
.参数 W, 整数型, , 宽字符指针
.参数 Wlen, 整数型, , 宽字符长度
.参数 CodePage, 整数型, , #CP_
.参数 Alen, 整数型, 参考, 窄字符长度
.局部变量 A, 整数型
连续赋值 (0, Alen)
Alen ＝ WideCharToMultiByte (CodePage, 0, W, Wlen, 0, 0, 0, 0)
A ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Alen)
.如果真 (A ＝ 0)
    返回 (0)
.如果真结束
WideCharToMultiByte (CodePage, 0, W, Wlen, A, Alen, 0, 0)
返回 (A)
.子程序 到窄文本, 文本型, , 把U码转换成A码
.参数 源宽文本, 字节集
.局部变量 长度, 整数型
.局部变量 TEMP, 字节集
.如果 (SEH_安装简单SEH ())
    长度 ＝ 取字节集长度 (源宽文本)
    TEMP ＝ 取空白字节集 (长度)
    WideCharToMultiByte (0, 0, 取指针_字节集型 (源宽文本), 长度 ＼ 2, 取指针_字节集型 (TEMP), 长度, 0, 0)
.否则
    TEMP ＝ {  }
.如果结束
SEH_删除简单SEH ()
返回 (到文本 (TEMP))
.子程序 SEH_安装简单SEH, 逻辑型, , 如果真(SEH_简单SEH())   配对函数 SEH_删除SEH()
.参数 保留参数, 子程序指针, 可空
保留参数 ＝ &SEH_简单SEH接口
' 0042866B    8B45 08               mov     eax, dword ptr [ebp+8]           ; EAX=简单SEH接口
' 0042866E    C9                    leave                                    ; 平衡堆栈
' 0042866F    83EC 60               sub     esp, 60                          ; 申请浮点寄存器
' 00428672    9C                    pushfd                                   ; 保存标志寄存器
' 00428673    60                    pushad                                   ; 保存通用寄存器
' 00428674    FFB424 84000000       push    dword ptr [esp+84]               ; 保存安装返回
' 0042867B    6A 00                 push    0                                ; 保存用户接口
' 0042867D    50                    push    eax                              ; SEH_接口
' 0042867E    DD7424 30             fsave   (108-byte) ptr [esp+30]          ; 备份浮点寄存器
' 77EC2FD4    9B                    wait
' 00428682    64:FF35 00000000      push    dword ptr fs:[0]                 ; 保存 原SEH栈
' 00428689    64:8925 00000000      mov     dword ptr fs:[0], esp            ; 设置 现SEH栈
' 00428690    B8 01000000           mov     eax, 1                           ; EAX=1=安装成功
' 00428695    FF6424 0C             jmp     dword ptr [esp+C]                ; 安装 SEH 返回
' 8B 45 08 C9 83 EC 60 9C 60 FF B4 24 84 00 00 00 6A 00 50 DD 74 24 30 9B 64 FF 35 00 00 00 00 64 89
' 25 00 00 00 00 B8 01 00 00 00 FF 64 24 0C
置入代码 ({ 139, 69, 8, 201, 131, 236, 96, 156, 96, 255, 180, 36, 132, 0, 0, 0, 106, 0, 80, 221, 116, 36, 48, 155, 100, 255, 53, 0, 0, 0, 0, 100, 137, 37, 0, 0, 0, 0, 184, 1, 0, 0, 0, 255, 100, 36, 12 })
返回 (真)
.子程序 SEH_简单SEH接口, 整数型, , 该子程序供  如果真(SEH_安装简单SEH(&SEH_SEH简单处理))  使用
.参数 异常代码, 整数型
.参数 堆栈结构, 整数型
.参数 线程环境, 整数型
.参数 调度环境, 整数型, , DispatcherContext
' 00401095    8B45 08                mov     eax, dword ptr [ebp+8]           ; 接口 参数1 异常结构
' 00401098    8138 250000C0          cmp     dword ptr [eax], C0000025        ; 不可处理异常?
' 0040109E    74 45                  je      short 004010E5                   ; 不可处理  跳
' 004010A0    8378 04 00             cmp     dword ptr [eax+4], 0             ; 可处理异常?
' 004010A4    75 3F                  jnz     short 004010E5                   ; 不可处理 跳
' 004010A6    E8 00000000            call    004010AB                         ; 计算2次处理偏移
' 004010AB    58                     pop     eax                              ; 计算2次处理偏移
' 004010AC    83C0 06                add     eax, 6                           ; 计算2次处理偏移
' 004010AF    EB 1C                  jmp     short 004010CD                   ; 转到1次处理
' 004010B1    64:8925 00000000       mov     dword ptr fs:[0], esp            ; 2次处理代码
' 004010B8    83C4 10                add     esp, 10                          ; 2次处理代码
' 004010BB    61                     popad                                    ; 2次处理代码
' 004010BC    9D                     popfd                                    ; 2次处理代码
' 004010BD    DD2424                 frstor  (108-byte) ptr [esp]             ; 2次处理代码
' 77EC2FD4    9B                     wait
' 004010C0    64:8B25 00000000       mov     esp, dword ptr fs:[0]            ; 2次处理代码
' 004010C7    33C0                   xor     eax, eax                         ; 2次处理  安装假
' 004010C9    FF6424 0C              jmp     dword ptr [esp+C]                ; 2次处理完成返回
' 004010CD    51                     push    ecx                              ; 1次处理 备份ECX
' 004010CE    8B4D 10                mov     ecx, dword ptr [ebp+10]          ; 接口 参数3 线程环境
' 004010D1    8981 B8000000          mov     dword ptr [ecx+B8], eax          ; 新EIP = 2次处理
' 004010D7    8B45 0C                mov     eax, dword ptr [ebp+C]           ; 接口 参数2 异常堆栈
' 004010DA    8981 C4000000          mov     dword ptr [ecx+C4], eax          ; 新ESP =现异常栈
' 004010E0    59                     pop     ecx                              ; 1次处理 恢复ECX
' 004010E1    33C0                   xor     eax, eax                         ; EAX=0 异常已处理
' 004010E3    EB 05                  jmp     short 004010EA                   ; 跳到  返回
' 004010E5    B8 01000000            mov     eax, 1                           ; EAX=1 异常未处理
' 77682FDA    8945 08                mov     dword ptr [ebp+8], eax           ; 保存返回值
' 8B 45 08 81 38 25 00 00 C0 74 46 83 78 04 00 75 40 E8 00 00 00 00 58 83 C0 06 EB 1D 64 89 25 00
' 00 00 00 83 C4 10 61 9D DD 24 24 9B 64 8B 25 00 00 00 00 33 C0 FF 64 24 0C 51 8B 4D 10 89 81 B8
' 00 00 00 8B 45 0C 89 81 C4 00 00 00 59 33 C0 EB 05 B8 01 00 00 00 89 45 08
置入代码 ({ 139, 69, 8, 129, 56, 37, 0, 0, 192, 116, 70, 131, 120, 4, 0, 117, 64, 232, 0, 0, 0, 0, 88, 131, 192, 6, 235, 29, 100, 137, 37, 0, 0, 0, 0, 131, 196, 16, 97, 157, 221, 36, 36, 155, 100, 139, 37, 0, 0, 0, 0, 51, 192, 255, 100, 36, 12, 81, 139, 77, 16, 137, 129, 184, 0, 0, 0, 139, 69, 12, 137, 129, 196, 0, 0, 0, 89, 51, 192, 235, 5, 184, 1, 0, 0, 0, 137, 69, 8 })
返回 (异常代码)
.子程序 SEH_删除简单SEH, , , 与 SEH_安装简单SEH() 配对使用
.参数 保留参数, 子程序指针, 可空
保留参数 ＝ &SEH_简单SEH接口
' 00401106    51                    push    ecx                              ; 备份 寄存器
' 00401107    64:8B0D 00000000      mov     ecx, dword ptr fs:[0]            ; 指向现异常栈
' 0040110E    81F9 FFFF0000         cmp     ecx, 0FFFF                       ; 是否有效栈址
' 00401114    7E 2A                 jle     short 0040113F                   ; 无效栈址 跳
' 00401116    8B41 04               mov     eax, dword ptr [ecx+4]           ; 获取异常接口
' 00401119    3B45 08               cmp     eax, dword ptr [ebp+8]           ; 判断异常接口
' 0040111C    74 04                 je      short 00401122                   ; 简单接口 跳
' 0040111E    8B09                  mov     ecx, dword ptr [ecx]             ; 下个异常栈指
' 00401120  ^ EB EC                 jmp     short 0040110E                   ; 继续循环判断
' 00401122    8B45 04               mov     eax, dword ptr [ebp+4]           ; EAX=返回地址
' 00401125    8BE1                  mov     esp, ecx                         ; ESP=本层SEH栈
' 00401127    64:8F05 00000000      pop     dword ptr fs:[0]                 ; 恢复上层SEH栈
' 0040112E    83C4 0C               add     esp, 0C                          ; ESP  指向备份
' 00401131    894424 1C             mov     dword ptr [esp+1C], eax          ; 保存返回地址
' 00401135    61                    popad                                    ; 恢复通用寄存器
' 00401136    9D                    popfd                                    ; 恢复标志寄存器
' 00401137    DD2424                frstor  (108-byte) ptr [esp]             ; 恢复浮点寄存器
' 77EC2FD4    9B                    wait
' 0040113A    83C4 6C               add     esp, 6C                          ; 弹掉浮点栈数据
' 0040113D  ^ FFE0                  jmp     eax                              ; 主要代码段返回
' 0040113F    59                    pop     ecx                              ; 恢复 寄存器
' 00401140    90                    nop                                      ; 无符合接口 返回
' 51 64 8B 0D 00 00 00 00 81 F9 FF FF 00 00 7E 2A 8B 41 04 3B 45 08 74 04 8B 09 EB EC 8B 45 04 8B
' E1 64 8F 05 00 00 00 00 83 C4 0C 89 44 24 1C 61 9D DD 24 24 9B 83 C4 6C FF E0 59 90
置入代码 ({ 81, 100, 139, 13, 0, 0, 0, 0, 129, 249, 255, 255, 0, 0, 126, 42, 139, 65, 4, 59, 69, 8, 116, 4, 139, 9, 235, 236, 139, 69, 4, 139, 225, 100, 143, 5, 0, 0, 0, 0, 131, 196, 12, 137, 68, 36, 28, 97, 157, 221, 36, 36, 155, 131, 196, 108, 255, 224, 89, 144 })
.子程序 提示框, 整数型, 公开, 跟系统自带的信息框()一样，不同的是 窗口“总在最前”属性设置为真也能显示出来；
.参数 提示信息, 文本型, 可空
.参数 按钮, 整数型, 可空, 可空：默认为 #确认钮；0、#确认钮； 1、#确认取消钮； 2、#放弃重试忽略钮； 3、#取消是否钮； 4、#是否钮； 5、#重试取消钮；16、#错误图标； 32、#询问图标； 48、#警告图标； 64、#信息图标；524288、#文本右对齐
.参数 窗口标题, 文本型, 可空, 可空：默认为“友情提醒”；
.参数 父窗口句柄, 整数型, 可空, 可空:默认为自动程序
.参数 超时时间, 整数型, 可空, 超过指定的时间后，信息框将自动关闭。可空：默认为5秒超时，单位为毫秒。
.局部变量 局_返回值, 整数型
' 0、#确认钮； 1、#确认取消钮； 2、#放弃重试忽略钮； 3、#取消是否钮；     4、#是否钮； 5、#重试取消钮
' 16、#错误图标； 32、#询问图标； 48、#警告图标； 64、#信息图标
' 0、#程序等待； 4096、#系统等待
' 65536、#位于前台； 524288、#文本右对齐
.如果真 (是否为空 (父窗口句柄))
    父窗口句柄 ＝ 进程_ID取窗口句柄 (GetCurrentProcessId (), , , 1000, )
.如果真结束
.如果真 (是否为空 (窗口标题))
    窗口标题 ＝ “友情提醒”
.如果真结束
.如果真 (是否为空 (按钮))
    按钮 ＝ #确认钮
.如果真结束
.如果真 (是否为空 (超时时间))
    超时时间 ＝ 5000
.如果真结束
局_返回值 ＝ MessageBoxTimeoutA (父窗口句柄, 提示信息, 窗口标题, 按钮, 0, 超时时间)
返回 (局_返回值 － 1)
.子程序 E数据库_快速查询, , 公开, 在易数据库已打开的情况下,对某字段进行快速查询,勤快的人可把记录分成两个数组，用多线程分开查询，应该更快。把记录添加完了在显示控件，这样就快多了
.参数 查询的字段名, 文本型, , 必须为文本型字段
.参数 查询内容, 文本型, 可空, 可以为空,为空即为查询空记录
.参数 返回记录号数组名, 整数型, 数组, 本数据内容将直接返回结果
.局部变量 次数, 整数型
.局部变量 数组, 文本型, , "3"
.局部变量 数组1, 整数型, , "3"
到首记录 ()
.计次循环首 (取记录数 (), )
    加入成员 (数组, 读 (查询的字段名))
    加入成员 (数组1, 取记录号 ())
    跳过 ()
.计次循环尾 ()
次数 ＝ 1
.计次循环首 (取数组成员数 (数组), 次数)
    .如果真 (数组 [次数] ＝ 查询内容)
        输出调试文本 (数组 [次数])
        加入成员 (返回记录号数组名, 数组1 [次数])
    .如果真结束
.计次循环尾 ()
.子程序 E数据库_修复易数据库, 逻辑型, 公开, 修复一个被破坏的易语言数据库
.参数 易数据库名, 文本型, , 易数据库全路径文件名
.参数 错误信息, 文本型, 可空, 如果修复失败，返回对应的错误文本。如果本参数为空，则不记录错误信息。
.局部变量 备份文件, 文本型
.局部变量 记录数1, 长整数型
.局部变量 记录数2, 长整数型
.局部变量 文件号, 整数型
.局部变量 可否打开, 逻辑型
.局部变量 当前库, 文本型, , , 已经打开的当前数据库。
' 非正常关机时，常常可能导致易数据库损坏，其出错信息一般为：数据库尺寸错误。具体指：数据库文件头的记录数与数据库实际的记录数不相符，一般是相差一个记录（前者>后者）。所以尝试做这个模块，通过修改数据库文件头记录的记录数来修复损坏的数据库。
' 一开始，只是简单地修复了一下，没有成功，还以为是模块的问题，后来，看到银戒指修复的数据库，损失了6个记录，才意识到，可能损坏的数据库，其所记录的记录数与实际记录数可能相差不止一个，于是用了一个循环，果然修好了，呵呵。
' 在此还劝大家在使用易数据库时，使用到数据库时再打开，用完立即关闭数据库，这样可确保不会因为长时间打开数据库，一旦有断电、死机、重启等发生时产生易数据库损坏。并且要定期备份重要的数据库。
当前库 ＝ 取当前库 ()  ' 取出当前数据库名称，用于修复数据库后重置当前库。
可否打开 ＝ 打开 (易数据库名, “要用模块修复的数据库”, , , , , )  ' 使用较长的别名，是为了防止与调用模块的程序的当前库有冲突。下同。
.如果真 (可否打开)
    关闭 (“要用模块修复的数据库”)
    置当前库 (当前库)  ' 重置原来的当前数据库。
    返回 (真)
.如果真结束
.如果真 (取错误码 () ≠ -48)
    .如果真 (是否为空 (错误信息) ＝ 假)
        错误信息 ＝ “指定文件非数据库，或数据库损坏类型不是数据库文件尺寸错误，不能用本模块修复。”
    .如果真结束
    返回 (假)
.如果真结束
备份文件 ＝ 取临时文件名 ()
复制文件 (易数据库名, 备份文件)  ' 备份数据库，如果修复失败则恢复它。
.判断循环首 (可否打开 ＝ 假)  ' 循环修复，将文件头中记录的记录数递减，直到数据库能正确打开。
    文件号 ＝ 打开文件 (易数据库名, , )
    .如果真 (文件号 ＝ 0)
        .如果真 (是否为空 (错误信息) ＝ 假)
            错误信息 ＝ “读取数据库文件失败。”
            复制文件 (备份文件, 易数据库名)  ' 用备份的数据库文件恢复被修改过的数据库文件。
        .如果真结束
        返回 (假)
    .如果真结束
    移动读写位置 (文件号, #文件首, 16)
    记录数1 ＝ 取字节集数据 (读入字节集 (文件号, 4), #长整数型)  ' 从第17位开始读取，共4位。
    .如果真 (记录数1 ＝ 0)  ' 如果经过递减，记录数为0时仍不能打开，说明修复失败，返回假。
        .如果真 (是否为空 (错误信息) ＝ 假)
            错误信息 ＝ “修复数据库未成功，原因未知。”
            复制文件 (备份文件, 易数据库名)
        .如果真结束
        返回 (假)
    .如果真结束
    移动读写位置 (文件号, #文件首, 20)
    记录数2 ＝ 取字节集数据 (读入字节集 (文件号, 4), #长整数型)  ' 从第21位开始读取，共4位。
    记录数1 ＝ 记录数1 － 1  ' 记录数1递减1。
    记录数2 ＝ 记录数2 － 1  ' 记录数2递减1。
    移动读写位置 (文件号, #文件首, 16)
    写出字节集 (文件号, 取字节集左边 (到字节集 (记录数1) ＋ { 0, 0, 0, 0 }, 4))  ' 将记录数递减1，写出至数据库文件头，并确保写出字节集长度为4位，下同。
    移动读写位置 (文件号, #文件首, 20)
    写出字节集 (文件号, 取字节集左边 (到字节集 (记录数2) ＋ { 0, 0, 0, 0 }, 4))  ' 将记录数递减1，并写出至数据库文件头。
    关闭文件 (文件号)
    可否打开 ＝ 打开 (易数据库名, “要用模块修复的数据库”, , , , , )
.判断循环尾 ()
关闭 (“要用模块修复的数据库”)
置当前库 (当前库)  ' 重置原来的当前数据库。
.如果真 (是否为空 (错误信息) ＝ 假)
    错误信息 ＝ “”
.如果真结束
返回 (真)  ' 如果能跳出循环，说明打开数据库成功，数据库被修复。将其关闭后，返回真。
.子程序 取默认目录, 文本型
.如果真 (目录_是否存在 (取运行目录 () ＋ “\data”) ＝ 假)
    目录_创建 (取运行目录 () ＋ “\data”)
.如果真结束
返回 (取运行目录 () ＋ “\data\setsoft.ini”)
.子程序 内部_对比, 逻辑型
.参数 对比原文本, 文本型
.参数 对比文本, 文本型
.局部变量 局_数组, 文本型, , "0"
.局部变量 局_计次, 整数型
清除数组 (局_数组)
局_数组 ＝ 分割文本 (对比原文本, “|”, )
.计次循环首 (取数组成员数 (局_数组), 局_计次)
    .如果真 (文本比较 (局_数组 [局_计次], 对比文本, 真) ＝ 0)
        返回 (假)
    .如果真结束
.计次循环尾 ()
返回 (真)
.子程序 批量_单选框_保存配置, 整数型, 公开, 保存窗口上所有选择框的选中状态!与"批量_单选框_读取配置()"命令一起用的!  返回被操作的单选框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 单选框
.局部变量 局_组件数量, 整数型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “单选框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
        写配置项 (配置文件名, “单选框”, 取组件名称 (局_组件), 到文本 (局_组件.选中))
    .如果真结束
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_单选框_读取配置, 整数型, 公开, 与"批量_单选框_保存配置()"命令一起用的!  返回被操作的单选框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 单选框
.局部变量 局_组件数量, 整数型
.局部变量 局_临时文本, 文本型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “单选框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    局_临时文本 ＝ 读配置项 (配置文件名, “单选框”, 取组件名称 (局_组件), )
    .如果真 (局_临时文本 ＝ “”)
        到循环尾 ()
    .如果真结束
    局_组件.选中 ＝ 选择 (局_临时文本 ＝ “假”, 假, 真)
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_选择框_保存配置, 整数型, 公开, 保存窗口上所有选择框的选中状态!与"批量_选择框_读取配置()"命令一起用的!  返回被操作的选择框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 选择框
.局部变量 局_组件数量, 整数型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “选择框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
        写配置项 (配置文件名, “选择框”, 取组件名称 (局_组件), 到文本 (局_组件.选中))
    .如果真结束
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_选择框_读取配置, 整数型, 公开, 与"批量_选择框_保存配置()"命令一起用的!  返回被操作的选择框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 选择框
.局部变量 局_组件数量, 整数型
.局部变量 局_临时文本, 文本型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “选择框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    局_临时文本 ＝ 读配置项 (配置文件名, “选择框”, 取组件名称 (局_组件), )
    .如果真 (局_临时文本 ＝ “”)
        到循环尾 ()
    .如果真结束
    局_组件.选中 ＝ 选择 (局_临时文本 ＝ “假”, 假, 真)
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_编辑框_保存配置, 整数型, 公开, 保存窗口上所有编辑框的内容!与"批量_编辑框_读取配置()"命令一起用的!  返回被操作的编辑框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 编辑框
.局部变量 局_临时文本, 文本型
.局部变量 局_组件数量, 整数型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “编辑框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
        局_临时文本 ＝ 子文本替换 (局_组件.内容, #换行符, “><br><”, , , 真)
        局_临时文本 ＝ 子文本替换 (局_临时文本, #引号, “#引号”, , , 真)
        写配置项 (配置文件名, “编辑框”, 取组件名称 (局_组件), 局_临时文本)
    .如果真结束
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_编辑框_读取配置, 整数型, 公开, 与"批量_编辑框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 编辑框
.局部变量 局_组件数量, 整数型
.局部变量 局_临时文本, 文本型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “编辑框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    局_临时文本 ＝ 读配置项 (配置文件名, “编辑框”, 取组件名称 (局_组件), )
    .如果真 (局_临时文本 ＝ “”)
        到循环尾 ()
    .如果真结束
    局_临时文本 ＝ 子文本替换 (局_临时文本, “><br><”, #换行符, , , 真)
    局_组件.内容 ＝ 子文本替换 (局_临时文本, “#引号”, #引号, , , 真)
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_组合框_保存配置, 整数型, 公开, 保存窗口上所有组合框的内容!与"批量_组合框_读取配置()"命令一起用的!  返回被操作的组合框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 组合框
.局部变量 局_临时文本, 文本型
.局部变量 局_组件数量, 整数型
.局部变量 局_组合框计次, 整数型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_临时文本 ＝ “”
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
        .计次循环首 (局_组件.取项目数 (), 局_组合框计次)
            局_临时文本 ＝ 局_临时文本 ＋ 局_组件.取项目文本 (局_组合框计次 － 1) ＋ “<|>” ＋ 到文本 (局_组件.取项目数值 (局_组合框计次 － 1)) ＋ “<||>”
        .计次循环尾 ()
        局_临时文本 ＝ 局_临时文本 ＋ 到文本 (局_组件.现行选中项) ＋ “<|>” ＋ 局_组件.内容
        局_临时文本 ＝ 子文本替换 (局_临时文本, #引号, “#引号”, , , 真)
        写配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), 局_临时文本)
    .如果真结束
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_组合框_读取配置, 整数型, 公开, 与"批量_组合框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 组合框
.局部变量 局_临时文本, 文本型
.局部变量 局_组件数量, 整数型
.局部变量 局_组合框计次, 整数型
.局部变量 局_临时数组, 文本型, , "0"
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    局_临时文本 ＝ 读配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), “”)
    局_临时文本 ＝ 子文本替换 (局_临时文本, “#引号”, #引号, , , 真)
    .如果真 (局_临时文本 ＝ “”)
        到循环尾 ()
    .如果真结束
    局_组件.清空 ()
    局_临时数组 ＝ 分割文本 (局_临时文本, “<||>”, )
    .计次循环首 (取数组成员数 (局_临时数组) － 1, 局_组合框计次)
        局_组件.加入项目 (文本_取左边 (局_临时数组 [局_组合框计次], “<|>”), 到数值 (文本_取右边 (局_临时数组 [局_组合框计次], “<|>”)))
    .计次循环尾 ()
    .如果真 (取数组成员数 (局_临时数组) ＞ 0)
        局_组件.现行选中项 ＝ 到数值 (文本_取左边 (局_临时数组 [取数组成员数 (局_临时数组)], “<|>”))
        局_组件.内容 ＝ 文本_取右边 (局_临时数组 [取数组成员数 (局_临时数组)], “<|>”)
    .如果真结束
    清除数组 (局_临时数组)
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_日期框_保存配置, 整数型, 公开, 保存窗口上所有日期框的内容!与"批量_日期框_读取配置()"命令一起用的!  返回被操作的日期框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 日期框
.局部变量 局_临时文本, 文本型
.局部变量 局_组件数量, 整数型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “日期框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_临时文本 ＝ “”
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
        局_临时文本 ＝ 时间到文本 (局_组件.今天, )
        写配置项 (配置文件名, “日期框”, 取组件名称 (局_组件), 局_临时文本)
    .如果真结束
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 批量_日期框_读取配置, 整数型, 公开, 与"批量_日期框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
.参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
.参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
.局部变量 局_寻找句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_组件, 日期框
.局部变量 局_临时文本, 文本型
.局部变量 局_组件数量, 整数型
.如果真 (配置文件名 ＝ “”)
    配置文件名 ＝ 取默认目录 ()
.如果真结束
局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “日期框”, , )
局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
.计次循环首 (局_组件数量, 局_计次)
    局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
    局_临时文本 ＝ 读配置项 (配置文件名, “日期框”, 取组件名称 (局_组件), “”)
    局_组件.今天 ＝ 到时间 (局_临时文本)
.计次循环尾 ()
清除组件寻找句柄 (局_寻找句柄)
返回 (局_组件数量)
.子程序 OCX_注册, , 公开, 注册OCX组件
.参数 OCX文件路径, 文本型
运行 (“regsvr32 ” ＋ OCX文件路径 ＋ “ /s”, 假, 1)
.子程序 OCX_卸载, , 公开, 卸载OCX组件
.参数 OCX文件路径, 文本型
运行 (“regsvr32 ” ＋ OCX文件路径 ＋ “ /u”, 假, 1)
.子程序 文件拖放_回调函数, 整数型, , [文件拖放]
.参数 hwnd, 整数型
.参数 iMsg, 整数型
.参数 hDrop, 整数型
.参数 lParam, 整数型
.局部变量 sFileName, 文本型
.局部变量 IReturn, 整数型
.局部变量 nCount, 整数型
.局部变量 局_计次, 整数型
.局部变量 数组位置, 整数型
.局部变量 文件后缀名, 文本型
.局部变量 局_窗口过程
.局部变量 局_函数指针
局_窗口过程 ＝ GetPropA (hwnd, “NewWindowsProc”)
局_函数指针 ＝ GetPropA (hwnd, “Subaddress”)
.判断开始 (iMsg ＝ 563)
    nCount ＝ DragQueryFileA (hDrop, -1, “”, 0)
    .计次循环首 (nCount, 局_计次)
        sFileName ＝ 取空白文本 (260)
        IReturn ＝ DragQueryFileA (hDrop, 局_计次 － 1, sFileName, 260)
        .如果真 (IReturn ＞ 0)
            文件后缀名 ＝ 取文本右边 (sFileName, 取文本长度 (sFileName) － 倒找文本 (sFileName, “.”, , 假))
            CallWindowProcA (局_函数指针, nCount, 局_计次, 取指针_文本型 (sFileName), 取指针_文本型 (文件后缀名))
        .如果真结束
    .计次循环尾 ()
    DragFinish (hDrop)
    返回 (1)
.默认
.判断结束
返回 (CallWindowProcA (局_窗口过程, hwnd, iMsg, hDrop, lParam))
.子程序 子_字节型数组到文本, 文本型
.参数 字节, 字节型, 数组
.局部变量 局_计次, 整数型
.局部变量 局_ret, 文本型
局_ret ＝ “”
.计次循环首 (取数组成员数 (字节), 局_计次)
    .如果 (字节 [局_计次] ≠ 0)
        局_ret ＝ 局_ret ＋ 字符 (字节 [局_计次])
    .否则
        跳出循环 ()
    .如果结束
.计次循环尾 ()
返回 (局_ret)
.子程序 子_文本到字节型数组
.参数 字节, 字节型, 参考 数组
.参数 文本, 文本型
.局部变量 局_计次, 整数型
局_计次 ＝ 取文本长度 (文本)
重定义数组 (字节, 假, 局_计次 ＋ 2)
.计次循环首 (取数组成员数 (字节), 局_计次)
    字节 [局_计次] ＝ 取代码 (取文本中间 (文本, 局_计次, 1), )
.计次循环尾 ()
.子程序 子_GetRasEntryCount, 整数型, , 获取RAS项计数
.局部变量 局_SizeOfRasEntryName, 整数型
.局部变量 局_Ret, 整数型
.局部变量 局_Count, 整数型
.局部变量 局_RasEntry, 取连接信息用结构
局_SizeOfRasEntryName ＝ GlobalSize_取连接信息用结构 (局_RasEntry)
局_RasEntry.内存大小 ＝ 局_SizeOfRasEntryName
局_Ret ＝ RasEnumEntrie (0, 0, 局_RasEntry, 局_SizeOfRasEntryName, 局_Count)
.如果 (局_Ret ＝ 603 或 局_Ret ＝ 0)
    重定义数组 (FLSAList, 假, 局_Count)
    局_Ret ＝ 局_Count
.否则
    局_Ret ＝ 0
.如果结束
返回 (局_Ret)
.子程序 子_GetLSAPasswords, , , 获取LSA的密码
.局部变量 局_PrivateData, LSA_UNICODE_STRING
.如果真 (子_GetLsaData (4, “RasDialParams!” ＋ 子_GetLocalSid () ＋ “#0”, 局_PrivateData))
    子_ProcessLSABuffer (局_PrivateData.缓冲区, 局_PrivateData.长度)
    LsaFreeMemory (局_PrivateData.缓冲区)
.如果真结束
.如果真 (子_GetLsaData (4, “L$_RasDefaultCredentials#0”, 局_PrivateData))
    子_ProcessLSABuffer (局_PrivateData.缓冲区, 局_PrivateData.长度)
    LsaFreeMemory (局_PrivateData.缓冲区)
.如果真结束
.子程序 子_GetLocalSid, 文本型, , 获取本地SID
.局部变量 局_sUserName, 文本型
.局部变量 局_iResult, 整数型
.局部变量 局_bUserSid, 字节集
.局部变量 局_iUserSIDSize, 整数型
.局部变量 局_sDomainName, 文本型
.局部变量 局_iDomainNameLength, 整数型
.局部变量 局_iSIDType, 整数型
.局部变量 局_sUserSid, 文本型
.局部变量 局_hUserSid, 整数型
局_sUserName ＝ 取空白文本 (256)
GetUserNameA (局_sUserName, 255)
局_bUserSid ＝ 取空白字节集 (255)
局_iResult ＝ LookupAccountName (取空白文本 (0), 局_sUserName, 局_bUserSid, 局_iUserSIDSize, 局_sDomainName, 局_iDomainNameLength, 局_iSIDType)
局_sDomainName ＝ 取空白文本 (局_iDomainNameLength)
局_bUserSid ＝ 取空白字节集 (局_iUserSIDSize)
局_iResult ＝ LookupAccountName (取空白文本 (0), 局_sUserName, 局_bUserSid, 局_iUserSIDSize, 局_sDomainName, 局_iDomainNameLength, 局_iSIDType)
.如果真 (IsValidSid (取指针地址_字节集型 (局_bUserSid)) ＝ 0)
    返回 (“”)
.如果真结束
局_iResult ＝ ConvertSidToStringSid (局_bUserSid, 局_hUserSid)
.如果真 (局_iResult ≠ 0)
    局_iResult ＝ lstrlen (局_hUserSid)
    .如果真 (局_iResult ＞ 0)
        局_sUserSid ＝ 取空白文本 (局_iResult × 2)
        局_bUserSid ＝ 取空白字节集 (局_iResult × 2)
        RtlMoveMemory (取指针地址_字节集型 (局_bUserSid), 局_hUserSid, 局_iResult × 2)
        局_sUserSid ＝ 编码_Unicode到Ansi (局_bUserSid)
    .如果真结束
.如果真结束
返回 (局_sUserSid)
.子程序 子_GetLsaData, 逻辑型, , 获取LSA的数据
.参数 Policy, 整数型
.参数 KeyName, 文本型
.参数 OutData, LSA_UNICODE_STRING, 参考
.局部变量 局_LsaObjectAttribs, LSA_OBJECT_ATTRIBUTES
.局部变量 局_LsaHandle, 整数型
.局部变量 局_LsaKeyName, LSA_UNICODE_STRING
.局部变量 局_LsaPrivateData, 整数型
.局部变量 局_status, 整数型
.局部变量 局_temp1, 字节集
.局部变量 局_temp2, 整数型
.如果真 (LsaOpenPolicy (0, 局_LsaObjectAttribs, Policy, 局_LsaHandle) ＞ 0)
    返回 (假)
.如果真结束
子_AnsiStringToLsaStr (KeyName, 局_LsaKeyName)
局_status ＝ LsaRetrievePrivateData (局_LsaHandle, 局_LsaKeyName, 局_LsaPrivateData)
.如果真 (局_status ＝ 0)
    局_temp1 ＝ 指针到字节集 (局_LsaPrivateData, 8)
    RtlMoveMemory_LSA_UNICODE_STRING (OutData, 局_temp1, 8)
    局_temp1 ＝ 取字节集右边 (局_temp1, 4)
    局_temp2 ＝ 取字节集数据 (局_temp1, #整数型, )
    OutData.缓冲区 ＝ 指针到字节集 (局_temp2, OutData.长度)
    LsaClose (局_LsaHandle)
    返回 (真)
.如果真结束
返回 (假)
.子程序 子_AnsiStringToLsaStr, , , ANSI字符串str中的LSA
.参数 AValue, 文本型
.参数 LStr, LSA_UNICODE_STRING, 参考
LStr.长度 ＝ 取文本长度 (AValue) × 2
LStr.最大长度 ＝ LStr.长度 ＋ 2
LStr.缓冲区 ＝ 编码_Ansi到Unicode (AValue)
.子程序 子_ProcessLSABuffer, , , LSA的缓冲过程
.参数 Buffer, 字节集
.参数 BufLen, 整数型
.局部变量 局_c, 字节集
.局部变量 局_记录, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_SPos, 整数型
.局部变量 局_S, 字节集
.局部变量 局_BookID, 文本型
.局部变量 局_用户名, 文本型
.局部变量 局_密码, 文本型
局_记录 ＝ 1
.变量循环首 (1, BufLen, 2, 局_计次)
    局_c ＝ 取字节集中间 (Buffer, 局_计次, 2)
    .如果 (局_c ＝ { 0, 0 })
        局_SPos ＝ 局_SPos ＋ 1
        .判断开始 (局_SPos ＝ 1)
            局_BookID ＝ 编码_Unicode到Ansi (局_S)
        .判断 (局_SPos ＝ 6)
            局_用户名 ＝ 编码_Unicode到Ansi (局_S)
        .判断 (局_SPos ＝ 7)
            局_密码 ＝ 编码_Unicode到Ansi (局_S)
            .如果真 (取数组成员数 (FLSAList) ＜ 局_记录)
                重定义数组 (FLSAList, 真, 局_记录)
            .如果真结束
            FLSAList [局_记录].名字 ＝ 局_BookID
            FLSAList [局_记录].值 ＝ 局_密码
            FLSAList [局_记录].用户 ＝ 局_用户名
        .默认
        .判断结束
        局_S ＝ {  }
    .否则
        局_S ＝ 局_S ＋ 局_c
    .如果结束
    .如果真 (局_SPos ＝ 9)
        局_记录 ＝ 局_记录 ＋ 1
        局_BookID ＝ “”
        局_SPos ＝ 0
    .如果真结束
.变量循环尾 ()
.子程序 内部_线程, , , 线程池相关
.参数 数据传递指针, 整数型, , 单位为：毫秒
.局部变量 lpNumberOfBytesTransferred, 整数型
.局部变量 IOCP句柄, 整数型
.局部变量 线程池状态, 逻辑型
.局部变量 处理函数, 整数型
.局部变量 超时时间, 整数型
.局部变量 处理状态, 整数型
' 地址结构依次为：
' 完成端口IOCP句柄
' 线程池状态。 1运行，0停止
' 处理函数。到整数(子程序指针)
' 超时时间
IOCP句柄 ＝ 指针_到整数 (数据传递指针)
' 线程池状态 ＝ 指针_到整数 (数据传递指针 ＋ 4) ＝ 1  ' 暂时废弃 退出时发送一个退出的消息给循环，让循环退出
线程池状态 ＝ 真
处理函数 ＝ 指针_到整数 (数据传递指针 ＋ 8)
超时时间 ＝ 指针_到整数 (数据传递指针 ＋ 12)
HeapFree (GetProcessHeap (), 0, 数据传递指针)
.判断循环首 (线程池状态)
    .如果 (GetQueuedCompletionStatus (IOCP句柄, lpNumberOfBytesTransferred, 处理状态, 0, -1) ＝ 1)
        .判断开始 (处理状态 ＝ 0)
            ' 输出调试文本 (lpNumberOfBytesTransferred)
            call (处理函数, lpNumberOfBytesTransferred)
        .判断 (处理状态 ＝ -999)
            返回 ()  ' 退出线程
        .默认
        .判断结束
    .否则
        ' GetLastError ()
        ' GetLastError ()
        跳出循环 ()  ' 错误后跳出，避免CPU增涨
    .如果结束
.判断循环尾 ()
输出调试文本 (“线程退出”)
.子程序 call, 整数型, , 线程池相关
.参数 参数一, 整数型
.参数 参数二, 整数型
置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
返回 (0)
.子程序 ___RAR解压_测试, , , ---------
.子程序 RAR_解压文件, 逻辑型, 公开, 解压 RAR 档案的所有文件或指定文件，成功返回真，失败返回假。本命令需要unrar.dll的支持,下载地址:http://www.rarlab.com/rar_add.htm
.参数 待解压文件, 文本型, , 欲解压文件的压缩档案全路径名称
.参数 解压密码, 文本型, 可空, 欲解压文件的压缩档案密码，无密码时为空
.参数 解压路径, 文本型, 可空, 指定解压文件的路径，为空表示解压到压缩档案所在目录
.如果真 (是否为空 (解压路径) 或 解压路径 ＝ “”)
    解压路径 ＝ 文件_取目录 (待解压文件)
.如果真结束
返回 (RAR_操作档案文件 (2, 待解压文件, 解压密码, 解压路径))  ' 文件数据 中保存符合条件且被成功处理的文件信息列表，如果需要可将其返回。（如转为 压缩文件信息 自定义类型返回）
.子程序 RAR_测试压缩文件, 逻辑型, 公开, 测试RAR压缩文件是否无误，如：压缩包损坏将返回假，否则返回真。
.参数 待测试压缩文件, 文本型, , 欲解压文件的压缩档案全路径名称
.参数 解压密码, 文本型, 可空, 欲解压文件的压缩档案密码，无密码时为空
返回 (RAR_操作档案文件 (0, 待测试压缩文件, 解压密码))
.子程序 RAR_操作档案文件, 逻辑型, , 操作 RAR 档案文件，如获取信息、文件列表、测试文件、解压文件等，成功返回真，失败返回假。
.参数 操作方式, 整数型, , RAR_SKIP/RAR_TEST/RAR_EXTRACT，分别用于 信息获取/测试/解压
.参数 待解压文件, 文本型, , 欲进行的压缩档案全路径名称
.参数 解压密码, 文本型, 可空, 可空。欲进行操作的压缩档案密码，无密码时为空
.参数 解压路径, 文本型, 可空, 可空。留空将解压在当前目录。 指定解压文件的路径
.局部变量 档案数据, RAROpenArchiveDataEx
.局部变量 打开句柄, 整数型
.局部变量 读取结果, 整数型
.局部变量 处理结果, 整数型
.局部变量 临时数据, RARHeaderData
.局部变量 临时名称, 文本型, , , 该名称由于要传递指针，应单独使用不再赋值后再次修改
.局部变量 文件有效, 逻辑型
.局部变量 是否解压成功, 短整数型
档案数据.ArcName ＝ 待解压文件
档案数据.OpenMode ＝ 选择 (操作方式 ＝ 0, 2, 1)
打开句柄 ＝ RAROpenArchiveEx (档案数据)
.如果真 (档案数据.OpenResult ≠ 0)  ' 函数执行失败
    返回 (假)
.如果真结束
.如果真 (是否为空 (解压密码) ＝ 假 且 解压密码 ≠ “”)
    RARSetPassword (打开句柄, 解压密码)
.如果真结束
.判断循环首 (真)  ' 无限循环
    读取结果 ＝ RARReadHeader (打开句柄, 临时数据)
    .判断开始 (读取结果 ＝ 0)  ' 成功
        临时名称 ＝ 到文本 (临时数据.FileName)
        RARSetCallback (打开句柄, &RAR_档案回调函数, 取指针地址_文本型 (临时名称))  ' 设置回调函数
        .如果 (操作方式 ＝ 0)
            文件有效 ＝ 真  ' 测试压缩包
        .否则
            文件有效 ＝ 是否匹配文件 (临时名称, “*.*”)  ' 解压
        .如果结束
        处理结果 ＝ RARProcessFile (打开句柄, 选择 (文件有效, 操作方式, 0), 选择 (操作方式 ＝ 2, 解压路径, “”), “”)
        .如果 (处理结果 ＝ 0)  ' 成功执行处理函数
            .如果真 (文件有效)
                是否解压成功 ＝ 是否解压成功 ＋ 1
            .如果真结束
        .否则
            RARCloseArchive (打开句柄)
            返回 (假)
        .如果结束
    .判断 (读取结果 ＝ 10)  ' 到达档案末尾
        跳出循环 ()
    .默认
        RARCloseArchive (打开句柄)
        返回 (假)
    .判断结束
.判断循环尾 ()
RARCloseArchive (打开句柄)
返回 (是否解压成功 ＞ 0)
.子程序 RAR_档案回调函数, 整数型
.参数 信息, 整数型
.参数 用户数据, 整数型
.参数 参数一, 整数型
.参数 参数二, 整数型
返回 (0)
.子程序 是否匹配文件, 逻辑型, , 文件名辅助处理函数,判断指定文件名是否符合过滤器
.参数 文件名, 文本型, , 欲判断的文件名，可以包含路径
.参数 过滤器, 文本型, , 允许，多个过滤器以 ; 间隔,支持通配符 */?
.参数 区分大小写, 逻辑型, 可空, 是否区分大小写, 默认不区分
.局部变量 过滤数组, 文本型, , "0"
.局部变量 计次, 整数型
.局部变量 字符, 文本型
.如果真 (过滤器 ＝ “”)
    返回 (假)
.如果真结束
.如果真 (过滤器 ＝ “*.*”)
    返回 (真)
.如果真结束
文件名 ＝ PathFindFileNameA (文件名)
.如果真 (区分大小写)
    .变量循环首 (65, 122, 1, 计次)  ' A~Z,a~z
        .如果真 (计次 ≥ 91 且 计次 ≤ 96)  ' [ \ ] ^ _ ` 不转换
            到循环尾 ()
        .如果真结束
        字符 ＝ 字符 (计次)
        文件名 ＝ 子文本替换 (文件名, 字符, 到全角 (字符), , , 真)
        过滤器 ＝ 子文本替换 (过滤器, 字符, 到全角 (字符), , , 真)
    .变量循环尾 ()
.如果真结束
过滤数组 ＝ 分割文本 (过滤器, “;”, )
.计次循环首 (取数组成员数 (过滤数组), 计次)
    .如果真 (PathMatchSpec (文件名, 过滤数组 [计次]))
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 取指针文本_, 整数型, 公开
.参数 参数_文本, 文本型
置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
' mov eax,[ebp+8]
' mov eax,[eax]
' leave
' retn 04
返回 (0)
.子程序 取指针整数_, 整数型, 公开
.参数 参数_整数, 整数型, 参考
置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
' mov eax,[ebp+8]
' leave
' retn 04
返回 (0)
.子程序 取指针小数_, 整数型, 公开
.参数 参数_小数, 小数型, 参考
置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
' mov eax,[ebp+8]
' leave
' retn 04
返回 (0)
.子程序 取指针双精度_, 整数型, 公开
.参数 参数_双精度小数, 双精度小数型, 参考
置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
' mov eax,[ebp+8]
' leave
' retn 04
返回 (0)
.子程序 取指针字节集_, 整数型, 公开
.参数 参数_字节集, 字节集
置入代码 ({ 139, 69, 8, 139, 0, 5, 8, 0, 0, 0, 201, 194, 4, 0 })
' mov eax,[ebp+08]
' mov eax,[eax]
' add eax,08
' leave
' retn 04
返回 (0)
.子程序 键盘钩子_过程_局部, 整数型
.参数 nCode, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 局_键状态, 整数型
.如果真 (nCode ＝ #HC_ACTION)  ' 判断是否是有效按键
    局_键状态 ＝ 选择 (右移 (GetAsyncKeyState (wParam), 16) ＝ -1, #WM_KEYDOWN, #WM_KEYUP)
    程序_执行整数子程序 (全_钩子相关.键盘钩子回调函数, 局_键状态, wParam, 0)
.如果真结束
返回 (CallNextHookEx (全_钩子相关.键盘钩子句柄, nCode, wParam, lParam))
.子程序 键盘钩子_过程, 整数型
.参数 nCode, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 Struct, KBDLLHOOKSTRUCT
.如果真 (nCode ＝ #HC_ACTION)  ' 判断是否是有效按键
    RtlMoveMemory (取数据_通用型 (Struct), lParam, 20)
    .如果真 (wParam ＝ #WM_KEYDOWN 或 wParam ＝ #WM_KEYUP 或 wParam ＝ #WM_CHAR)  ' 按下, 放开
        程序_执行整数子程序 (全_钩子相关.键盘钩子回调函数, wParam, Struct.vkCode, 0)
    .如果真结束
.如果真结束
返回 (CallNextHookEx (全_钩子相关.键盘钩子句柄, nCode, wParam, lParam))
.子程序 鼠标钩子_过程, 整数型
.参数 nCode, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 mouse, MOUSEHOOKSTRUCT
.局部变量 局_键代码, 整数型
.局部变量 局_键状态, 整数型
.局部变量 局_偏移, 整数型
.如果真 (nCode ≥ 0)
    CopyMemory_Mouse (mouse, lParam, 20)
    .判断开始 (mouse.hwnd ＝ 7864320)
        局_键代码 ＝ 4
        局_键状态 ＝ 4
        ' 输出调试文本 (“滚轮向上”)
    .判断 (mouse.hwnd ＝ -7864320)
        局_键代码 ＝ 4
        局_键状态 ＝ 5
        ' 输出调试文本 (“滚轮向下”)
    .判断 (wParam ＝ 513)
        局_键代码 ＝ 1
        局_键状态 ＝ 1
        ' 输出调试文本 (“鼠标左键按下”)
    .判断 (wParam ＝ 514)
        局_键代码 ＝ 1
        局_键状态 ＝ 2
        ' 输出调试文本 (“鼠标左键放开”)
    .判断 (wParam ＝ 515)
        局_键代码 ＝ 1
        局_键状态 ＝ 3
        ' 输出调试文本 (“鼠标左键双击”)
    .判断 (wParam ＝ 516)
        局_键代码 ＝ 2
        局_键状态 ＝ 1
        ' 输出调试文本 (“鼠标右键按下”)
    .判断 (wParam ＝ 517)
        局_键代码 ＝ 2
        局_键状态 ＝ 2
        ' 输出调试文本 (“鼠标右键放开”)
    .判断 (wParam ＝ 518)
        局_键代码 ＝ 2
        局_键状态 ＝ 3
        ' 输出调试文本 (“鼠标右键双击”)
    .判断 (wParam ＝ 519)
        局_键代码 ＝ 3
        局_键状态 ＝ 1
        ' 输出调试文本 (“鼠标中键按下”)
    .判断 (wParam ＝ 520)
        局_键代码 ＝ 3
        局_键状态 ＝ 2
        ' 输出调试文本 (“鼠标中键放开”)
    .判断 (wParam ＝ 521)
        局_键代码 ＝ 3
        局_键状态 ＝ 3
        ' 输出调试文本 (“鼠标中键双击”)
    .判断 (wParam ＝ 523)  ' 鼠标侧键
        局_偏移 ＝ 右移 (mouse.hwnd, 16)
        .判断开始 (局_偏移 ＝ 2)
            局_键代码 ＝ 5
            局_键状态 ＝ 1
            ' 输出调试文本 (“侧键上被按下”)
        .判断 (局_偏移 ＝ 1)
            局_键代码 ＝ 6
            局_键状态 ＝ 1
            ' 输出调试文本 (“侧键下被按下”)
        .默认
        .判断结束
    .判断 (wParam ＝ 524)  ' 鼠标侧键
        局_偏移 ＝ 右移 (mouse.hwnd, 16)
        .判断开始 (局_偏移 ＝ 2)
            局_键代码 ＝ 5
            局_键状态 ＝ 2
            ' 输出调试文本 (“侧键上被放开”)
        .判断 (局_偏移 ＝ 1)
            局_键代码 ＝ 6
            局_键状态 ＝ 2
            ' 输出调试文本 (“侧键下被放开”)
        .默认
        .判断结束
    .默认
    .判断结束
    程序_执行整数子程序 (全_钩子相关.鼠标钩子回调函数, 局_键代码, 局_键状态, 0)
.如果真结束
返回 (CallNextHookEx (全_钩子相关.鼠标钩子句柄, nCode, wParam, lParam))
.子程序 MyGetOpenFileNameA, 整数型
.参数 参数, 整数型, , 这里获得OpenFilename这个结构的地址
.局部变量 指针地址, 整数型
指针地址 ＝ 取字节集数据 (指针到字节集 (参数 ＋ 28, 4), #整数型, 1)  ' 结构地址偏移28的地址取整数是文件名的在内存中的地址
写到内存 (编码_Ansi到Unicode (全_文本), 指针地址, )  ' 写入新的文件名
返回 (1)
.子程序 系统_取宽带用户名密码, 逻辑型, 公开, 成功返回真,失败返回假  注：只有ADSL拨号上网的才能取
.参数 连接名称, 文本型, 可空, 请提供一个文本变量,用于存放 连接名称
.参数 宽带用户名, 文本型, 可空, 请提供一个文本变量,用于存放 宽带用户名
.参数 宽带密码, 文本型, 可空, 请提供一个文本变量,用于存放 宽带密码
.局部变量 局_RasArraySize, 整数型
.局部变量 局_信息, 整数型
.局部变量 局_RasCount, 整数型
.局部变量 局_RasArray, 取连接信息用结构, , "0"
.局部变量 局_图书1, 文本型
.局部变量 局_图书2, 文本型
.局部变量 局_osi, OSVersionInfo
.局部变量 局_计次, 整数型
.局部变量 局_RasParams, ADSL拨号0
.局部变量 局_RasEntryProperties, RasEntry
.局部变量 局_名字1, 字节集
.局部变量 局_名字2, 字节集
.局部变量 局_DialParamsUID, 整数型
局_RasCount ＝ 子_GetRasEntryCount ()
.如果真 (局_RasCount ＝ 0)
    返回 (假)
.如果真结束
重定义数组 (局_RasArray, 假, 局_RasCount)
.如果真 (取数组成员数 (局_RasArray) ≥ 1)
    局_RasArray [1].内存大小 ＝ GlobalSize_取连接信息用结构 (局_RasArray [1])
    局_RasArraySize ＝ 局_RasCount × 局_RasArray [1].内存大小
.如果真结束
.如果真 (RasEnumEntries (0, 0, 局_RasArray, 局_RasArraySize, 局_RasCount) ≠ 0)
    返回 (假)
.如果真结束
' 局_osi.版本信息大小 ＝ 148
' 局_osi.CSD版本 ＝ 取空白文本 (128)
' API_GetVersionEx (局_osi)
.' 如果真 (局_osi.平台标识符 ＝ 2 且 局_osi.主版本 ≥ 5)
    局_图书1 ＝ 取空白文本 (255)
    局_图书2 ＝ 取空白文本 (255)
    .如果真 (SHGetSpecialFolderPath (0, 局_图书1, 26, 假))
        局_图书1 ＝ 局_图书1 ＋ “\Microsoft\Network\Connections\pbk\rasphone.pbk”
    .如果真结束
    .如果真 (SHGetSpecialFolderPath (0, 局_图书2, 35, 假))
        局_图书2 ＝ 局_图书2 ＋ “\Microsoft\Network\Connections\pbk\rasphone.pbk”
    .如果真结束
    子_GetLSAPasswords ()
.如果真结束
.计次循环首 (取数组成员数 (局_RasArray), 局_计次)
    局_RasParams.结构的大小 ＝ GlobalSize_RASDIALPARAMS (局_RasParams)
    RtlMoveMemory_字节型_数组 (局_RasParams.访问的入口名, 局_RasArray [局_计次].拨号连接名称, 255)
    RasGetEntryDialParams (“”, 局_RasParams, 真)
    局_RasArraySize ＝ GlobalSize_RASENTRY (局_RasEntryProperties)
    局_RasEntryProperties.dwSize ＝ 局_RasArraySize
    RasGetEntryProperties (“”, 局_RasArray [局_计次].拨号连接名称, 局_RasEntryProperties, 局_RasArraySize, “”, 局_信息)
    .如果真 (局_图书1 ≠ “” 或 局_图书2 ≠ “”)
        局_名字1 ＝ 到字节集 (子_字节型数组到文本 (局_RasParams.访问的入口名)) ＋ { 0 }
        局_名字2 ＝ 编码_Ansi到Utf8 (子_字节型数组到文本 (局_RasParams.访问的入口名)) ＋ { 0 }
        局_DialParamsUID ＝ GetPrivateProfileInt (局_名字1, “DialParamsUID”, 0, 局_图书1)
        .如果真 (局_DialParamsUID ＝ 0)
            局_DialParamsUID ＝ GetPrivateProfileInt (局_名字1, “DialParamsUID”, 0, 局_图书2)
        .如果真结束
        .如果真 (局_DialParamsUID ＝ 0)
            局_DialParamsUID ＝ GetPrivateProfileInt (局_名字2, “DialParamsUID”, 0, 局_图书1)
        .如果真结束
        .如果真 (局_DialParamsUID ＝ 0)
            局_DialParamsUID ＝ GetPrivateProfileInt (局_名字2, “DialParamsUID”, 0, 局_图书2)
        .如果真结束
        .如果真 (局_DialParamsUID ＞ 0)
            .计次循环首 (取数组成员数 (FLSAList), 局_计次)
                .如果真 (FLSAList [局_计次].名字 ＝ 到文本 (局_DialParamsUID) 且 FLSAList [局_计次].值 ≠ “”)
                    子_文本到字节型数组 (局_RasParams.指定用户名称, FLSAList [局_计次].用户)
                    子_文本到字节型数组 (局_RasParams.指定用户密码, FLSAList [局_计次].值)
                .如果真结束
            .计次循环尾 ()
        .如果真结束
    .如果真结束
    连接名称 ＝ 子_字节型数组到文本 (局_RasParams.访问的入口名)
    宽带用户名 ＝ 子_字节型数组到文本 (局_RasParams.指定用户名称)
    宽带密码 ＝ 子_字节型数组到文本 (局_RasParams.指定用户密码)
.计次循环尾 ()
返回 (删首尾空 (宽带用户名) ≠ “”)
.子程序 取_类_函数地址, 整数型
.参数 this
.参数 index, , , 从1开始,[_初始化][_销毁],[xx]
.局部变量 函数数组
index ＝ index － 1
函数数组 ＝ 取指针内容_整数 (this)
返回 (取指针内容_整数 (函数数组 ＋ index × 4))
.子程序 到数值_从子程序指针, 整数型
.参数 proc, 子程序指针
.局部变量 ret, 整数型
置入代码 ({ 139, 69, 8, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
返回 (ret)
.子程序 到子程序指针_从数值, 子程序指针
.参数 val, 整数型
.局部变量 ret, 子程序指针
置入代码 ({ 139, 69, 8, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
返回 (ret)
.子程序 取上层函数首参, 整数型
.局部变量 ret
置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 137, 69, 252 })
' 置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 137, 69, 252 })
返回 (ret)
.子程序 get_retn_code, 整数型
.局部变量 static_ptr, , 静态
.局部变量 data, 字节集
.如果真 (static_ptr ≠ 0)
    返回 (static_ptr)
.如果真结束
' mov     edx, dword ptr [ebp-4]
' mov     ebx, dword ptr [ebp-8]
' mov     esi, dword ptr [ebp-C]
' mov     edi, dword ptr [ebp-10]
' fldcw   word ptr [ebp-14]
' mov     esp, ebp
' pop     ebp
' pop     ecx
' add     esp, edx
' jmp     ecx
data ＝ { 139, 77, 252, 139, 93, 248, 139, 117, 244, 139, 125, 240, 217, 109, 236, 139, 229, 93, 141, 100, 12, 4, 247, 217, 139, 76, 12, 252, 255, 225 }
static_ptr ＝ DumpCode (data)
返回 (static_ptr)
.子程序 辅_生成_方法回调, 整数型, , [不需要fcw复位]
.参数 回调地址
.参数 参数个数, , 可空
.参数 push_ecx, 逻辑型, 可空, 当有[附加参数1]附加到第二个参数，当没有[附加参数1]时附加到第一个参数;默认为假
.参数 cdecl方式, 逻辑型, 可空, 默认为假
.参数 附加参数1, , 可空, 附加到第一个的参数.不为0则附加
.局部变量 data, 字节集
.局部变量 arg_length
.局部变量 ret_len_WORD, 短整数型
.如果真 (回调地址 ＝ 0)
    输出调试文本 (“[辅_生成_方法回调][失败]：回调地址错误”)
    返回 (0)
.如果真结束
.如果 (cdecl方式)
    ret_len_WORD ＝ 0
.否则
    ret_len_WORD ＝ 参数个数 × 4
.如果结束
arg_length ＝ 参数个数 × 4
.如果真 (arg_length ＞ 512 或 arg_length ＜ 0)
    输出调试文本 (“[辅_生成_方法回调]局部变量长度错误”)
    返回 (0)
.如果真结束
data ＝ {  }
data ＝ data ＋ { 85 }  ' push ebp;
data ＝ data ＋ { 139, 236 }  ' mov ebp,esp;
data ＝ data ＋ { 106 } ＋ 到字节集_从字节 (ret_len_WORD)  ' push [retn_size]; // [ebp-04]
data ＝ data ＋ { 83 }  ' push ebx; // [ebp-08]
data ＝ data ＋ { 86 }  ' push esi; // [ebp-0C]
data ＝ data ＋ { 87 }  ' push edi; // [ebp-10]
data ＝ data ＋ { 106 } ＋ { 0 }  ' push 0; // [ebp-14]
data ＝ data ＋ { 217, 60, 36 }  ' fstcw [esp];
data ＝ data ＋ { 219, 227 }  ' finit;
' ////////////////////////////////////////////////////////////////////////////
.如果真 (参数个数 ≠ 0)
    data ＝ data ＋ { 185 } ＋ 到字节集_从整数_ (arg_length)  ' mov ecx,arg_length;
    data ＝ data ＋ { 43, 225 }  ' sub esp,ecx;
    data ＝ data ＋ { 141, 117, 8 }  ' lea esi,[ebp+8];
    data ＝ data ＋ { 141, 60, 36 }  ' lea edi,[esp];
    data ＝ data ＋ { 252 }  ' cld;
    data ＝ data ＋ { 243, 164 }  ' rep movsb;
    data ＝ data ＋ { 139, 77, 248 }  ' mov ecx,[ebp-8];
    data ＝ data ＋ { 139, 117, 244 }  ' mov esi.[ebp-C];
    data ＝ data ＋ { 139, 125, 240 }  ' mov edi,[ebp-10];
.如果真结束
.如果真 (push_ecx)
    data ＝ data ＋ { 81 }  ' push ecx;
.如果真结束
.如果真 (附加参数1 ≠ 0)
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (附加参数1)  ' push arg_1
.如果真结束
data ＝ data ＋ { 184 } ＋ 到字节集_从整数_ (回调地址)  ' mov eax,addr;
data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (get_retn_code ())  ' push arg_1; //retn to static code
data ＝ data ＋ { 255, 224 }  ' jmp eax
返回 (DumpCode (data))
.子程序 类回调_取类地址, 整数型, 公开, [只能在类里调用]
.参数 函数序号, , , 从1开始,[_初始化][_销毁],[xx]
.参数 参数个数, , 可空
.参数 push_ecx, 逻辑型, 可空, 附加到第一个参数;默认为假
.参数 cdecl方式, 逻辑型, 可空, 默认为假
.局部变量 this
.局部变量 回调地址
.局部变量 data, 字节集
.局部变量 arg_length
.局部变量 sizeof_int
.局部变量 ret_len_WORD, 短整数型
this ＝ 取指针内容_整数 (取上层函数首参 ())
回调地址 ＝ 取_类_函数地址 (this, 函数序号)
.如果真 (回调地址 ≤ 0)
    输出调试文本 (“[辅_生成_类回调_易][失败]：回调地址错误”)
    返回 (0)
.如果真结束
sizeof_int ＝ 4  ' #sizeof_int
.如果 (cdecl方式)
    ret_len_WORD ＝ 0
.否则
    ret_len_WORD ＝ 参数个数 × sizeof_int
.如果结束
arg_length ＝ 参数个数 × sizeof_int
.如果真 (arg_length ＞ 512 或 arg_length ＜ 0)
    输出调试文本 (“[辅_生成_类回调_易]局部变量长度错误”)
    返回 (0)
.如果真结束
data ＝ {  }
data ＝ data ＋ { 85 }  ' push ebp;
data ＝ data ＋ { 139, 236 }  ' mov ebp,esp;
data ＝ data ＋ { 106 } ＋ 到字节集_从字节 (ret_len_WORD)  ' push [retn_size]; // [ebp-04]
data ＝ data ＋ { 83 }  ' push ebx; // [ebp-8]
data ＝ data ＋ { 86 }  ' push esi; // [ebp-0C]
data ＝ data ＋ { 87 }  ' push edi; // [ebp-10]
data ＝ data ＋ { 106 } ＋ { 0 }  ' push 0; // [ebp-14]
data ＝ data ＋ { 217, 60, 36 }  ' fstcw [esp];
data ＝ data ＋ { 219, 227 }  ' finit;
data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (this)  ' push dwThis;
data ＝ data ＋ { 139, 196 }  ' mov eax,esp
.如果真 (参数个数 ≠ 0)
    data ＝ data ＋ { 185 } ＋ 到字节集_从整数_ (arg_length)  ' mov ecx,arg_length;
    data ＝ data ＋ { 43, 225 }  ' sub esp,ecx;
    data ＝ data ＋ { 141, 117, 8 }  ' lea esi,[ebp+8];
    data ＝ data ＋ { 141, 60, 36 }  ' lea edi,[esp];
    data ＝ data ＋ { 252 }  ' cld;
    data ＝ data ＋ { 243, 164 }  ' rep movsb;
    data ＝ data ＋ { 139, 77, 248 }  ' mov ecx,[ebp-8];
    data ＝ data ＋ { 139, 117, 244 }  ' mov esi.[ebp-C];
    data ＝ data ＋ { 139, 125, 240 }  ' mov edi,[ebp-10];
.如果真结束
.如果真 (push_ecx)
    data ＝ data ＋ { 81 }  ' push ecx;
.如果真结束
data ＝ data ＋ { 80 }  ' push eax;  // push &(this)
data ＝ data ＋ { 184 } ＋ 到字节集_从整数_ (回调地址)  ' mov eax,addr;
data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (get_retn_code ())  ' push arg_1; //retn to static code
data ＝ data ＋ { 255, 224 }  ' jmp eax
返回 (DumpCode (data))
.子程序 类回调_释放回调, , 公开, 用于释放生成代码后的返回指针，若你确定你的回调已经停用了才能释放
.参数 ptr
VirtualFreeEx (GetCurrentProcess (), ptr, 0, 32768)
.子程序 DumpCode, 整数型
.参数 data, 字节集
.局部变量 hMem
.局部变量 Ptr
.局部变量 len
len ＝ 取字节集长度 (data)
hMem ＝ VirtualAlloc (0, len, 4096, 64)
CopyMemory_Bytes2int (hMem, data, len)
返回 (hMem)
.子程序 取指针内容_整数, 整数型
.参数 内存地址
.局部变量 ret
置入代码 ({ 139, 69, 8, 139, 0, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov eax,[eax] | mov [ebp-4],eax”)
返回 (ret)
.子程序 到字节集_从整数_, 字节集
.参数 欲转换的数值, 整数型, 参考
.局部变量 ptr
ptr ＝ 取变量地址_整数 (欲转换的数值)
返回 (指针到字节集 (ptr, 4))
.子程序 到字节集_从短整数_, 字节集
.参数 欲转换的数值, 短整数型, 参考
.局部变量 ptr
ptr ＝ 取变量地址_短整数 (欲转换的数值)
返回 (指针到字节集 (ptr, 2))
.子程序 到字节集_从字节, 字节集
.参数 欲转换的数值, 短整数型, 参考
.局部变量 ptr
ptr ＝ 取变量地址_短整数 (欲转换的数值)
返回 (指针到字节集 (ptr, 1))
.子程序 取变量地址_字节, 整数型
.参数 变量, 字节型, 参考
.局部变量 reuslt
置入代码 ({ 139, 69, 8, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
返回 (reuslt)
.子程序 取变量堆栈地址_字节集, 整数型, 公开
.参数 字节集变量, 字节集
置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
返回 (0)
.子程序 取变量地址_整数, 整数型
.参数 var, 整数型, 参考
.局部变量 ptr
置入代码 ({ 139, 69, 8, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
返回 (ptr)
.子程序 取变量地址_短整数, 整数型
.参数 变量, 短整数型, 参考
.局部变量 reuslt
置入代码 ({ 139, 69, 8, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
返回 (reuslt)
.子程序 辅_取字节集长度, 整数型
.参数 v, 字节集
.局部变量 len
.如果真 (v ＝ {  })
    返回 (0)
.如果真结束
置入代码 ({ 139, 69, 8, 139, 0, 139, 64, 4, 137, 69, 252 })
' 置入代码 (“mov eax,[ebp+8] | mov eax,[eax] | mov eax,[eax+4] | mov [ebp-4],eax ”)
返回 (len)
.子程序 托盘消息回调, 整数型
.参数 hwnd
.参数 uMsg
.参数 wParam
.参数 lParam
.局部变量 pointer
.局部变量 Message
.局部变量 TaskbarCreated
.局部变量 Event
pointer ＝ GetPropA (hwnd, “WinProc”)
Message ＝ GetPropA (hwnd, “CallbackMessage”)
TaskbarCreated ＝ GetPropA (hwnd, “TaskbarCreatedMessage”)
Event ＝ GetPropA (hwnd, “Exec Event”)
.判断开始 (uMsg ＝ Message)
    .如果真 (Event ≠ 0)
        程序_Call (Event, lParam)
        返回 (0)
    .如果真结束
.判断 (uMsg ＝ TaskbarCreated)
    .如果真 (Event ≠ 0)
        程序_Call (Event, 1120)
        返回 (0)
    .如果真结束
.判断 (uMsg ＝ 2)
    .如果真 (Event ≠ 0)
        程序_Call (Event, 1130)
    .如果真结束
.默认
.判断结束
返回 (CallWindowProcA (pointer, hwnd, uMsg, wParam, lParam))
.子程序 逻辑左移, 整数型, , （逻辑左移） （算术左移） 
.参数 欲移动的整数, 整数型
.参数 欲被移动的位数, 字节型
置入代码 ({ 81, 139, 69, 8, 138, 77, 12, 211, 224, 89, 139, 229, 93, 194, 8, 0 })
返回 (-1)
.子程序 逻辑右移, 整数型, , （逻辑右移） （算术右移） 寄存器，1
.参数 欲移动的整数, 整数型
.参数 欲被移动的位数, 字节型
置入代码 ({ 81, 139, 69, 8, 138, 77, 12, 211, 232, 89, 139, 229, 93, 194, 8, 0 })
返回 (-1)
.子程序 地址_取API地址, 整数型, 公开, 返回API地址
.参数 动态链接库名, 文本型
.参数 函数名, 文本型
.局部变量 模块句柄, 整数型
.局部变量 是否加载模块, 逻辑型
.局部变量 返回值, 整数型
模块句柄 ＝ GetModuleHandleA (动态链接库名)  ' 获取动态库句柄(如果已被加载)
.如果真 (模块句柄 ＝ 0)
    是否加载模块 ＝ 真
    模块句柄 ＝ LoadLibraryA (动态链接库名)  ' 加载动态库并获取句柄
.如果真结束
.如果真 (模块句柄 ＝ 0)
    返回 (0)
.如果真结束
返回值 ＝ GetProcAddress (模块句柄, 函数名)
.如果真 (是否加载模块 ＝ 真)
    FreeLibrary (模块句柄)
.如果真结束
返回 (返回值)
.子程序 调用子程序_数组, 整数型, 公开
.参数 调用地址, 整数型
.参数 参数数组, 整数型, 可空 数组
.参数 是否为C调用, 逻辑型, 可空
.如果真 (IsBadCodePtr (调用地址))
    返回 (0)
.如果真结束
置入代码 ({ 131, 236, 8, 86, 62, 139, 117, 12, 139, 54, 139, 118, 4, 141, 78, 255, 133, 201, 124, 18, 139, 69, 12, 139, 0, 141, 68, 136, 8, 65, 255, 48, 131, 232, 4, 73, 117, 248, 255, 85, 8, 137, 69, 252, 139, 69, 20, 133, 192, 116, 10, 62, 141, 4, 181, 0, 0, 0, 0, 3, 224, 139, 69, 252, 94, 139, 229, 93, 194, 20, 0 })
返回 (0)
.子程序 整数_有符号转无符号, 长整数型, 公开
.参数 arglist, 整数型
.局部变量 arg1, 文本型
arg1 ＝ 取空白文本 (11)
wvsprintfA_整数型 (取指针_文本型 (arg1), “%u”, arglist)
返回 (到长整数 (arg1))
.程序集 内存共享, , 公开
.程序集变量 集_内存数组, 整数型, , "0"
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
全部释放 ()
.子程序 申请, 整数型, 公开, 申请指定大小的内存空间,返回内存地址
.参数 内存大小, 整数型, , 要申请的内存空间大小
.局部变量 lpdata, 整数型
lpdata ＝ LocalAlloc (0, 内存大小)
增加地址 (lpdata)
返回 (lpdata)
.子程序 写入, 整数型, 公开, 如果指定的内存地址不存在,将自动申请并返回新内存地址,否则将返回原来的内存地址
.参数 地址, 整数型, 可空, 指定写入地址,如果为空将自动创建
.参数 数据, 字节集, 参考, 欲写入的字节集数据
.局部变量 length, 整数型, , , 数据长度
length ＝ 取字节集长度 (数据)
.如果真 (length ＝ 0)
    返回 (0)
.如果真结束
.如果真 (地址 ＝ 0)
    地址 ＝ 申请 (length)
.如果真结束
RtlMoveMemory_字节集 (地址, 数据, length)
返回 (地址)
.子程序 读取, 字节集, 公开, 读取地址数据！！注意，也可以调用核心库方法 指针到字节集(地址,内存共享.取内存长度(地址)) 来同样取得数据
.参数 地址, 整数型, , 由内存映射返回的地址
.参数 读取位置, 整数型, 可空, 从1开始到结束,如果留空则从首地址开始,超出作用范围将指定0
.参数 长度, 整数型, 可空, 若读取位置+长度超过总数据长度,将自动指定0
.局部变量 数据, 字节集, , , 指定缓冲区,如果缓冲区长度不够或超出将自动匹配,如果包含数据将自动清空
.局部变量 length, 整数型
.局部变量 offset, 整数型, , , 偏移,位置
length ＝ LocalSize (地址)
.如果真 (length ＝ 0)  ' 无效地址或空数据
    返回 ({  })
.如果真结束
长度 ＝ 选择 (长度 ＝ 0, LocalSize (地址) － 读取位置, 长度)
数据 ＝ 选择 (长度 ≤ 0, 选择 (length ≠ 取字节集长度 (数据), 取空白字节集 (length), {  }), 取空白字节集 (长度))
offset ＝ 选择 (读取位置 ＜ 0 或 读取位置 ＋ 长度 ＞ length, 0, 读取位置)
RtlMoveMemory_int2Bytes (数据, 地址 ＋ offset, 长度)
返回 (数据)
.子程序 释放, 逻辑型, 公开, 释放指定的内存
.参数 内存地址, 整数型, , 由内存映射返回的地址
删除地址 (内存地址)
返回 (LocalFree (内存地址) ＝ 0)
.子程序 取内存长度, 整数型, 公开, 取指定内存地址的长度
.参数 地址, 整数型, , 内存地址
返回 (LocalSize (地址))
.子程序 全部释放, , 公开, 释放所有申请的内存
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (集_内存数组), 局_计次)
    LocalFree (集_内存数组 [局_计次])
.计次循环尾 ()
清除数组 (集_内存数组)
.子程序 增加地址
.参数 地址, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_记录, 整数型
.计次循环首 (取数组成员数 (集_内存数组), 局_计次)
    .如果真 (集_内存数组 [局_计次] ≠ 地址)
        局_记录 ＝ 局_记录 ＋ 1
    .如果真结束
.计次循环尾 ()
.如果真 (局_记录 ＝ 取数组成员数 (集_内存数组))
    加入成员 (集_内存数组, 地址)
.如果真结束
.子程序 删除地址
.参数 内存地址, 整数型
.局部变量 局_计次, 整数型
.计次循环首 (取数组成员数 (集_内存数组), 局_计次)
    .如果真 (集_内存数组 [局_计次] ＝ 内存地址)
        删除成员 (集_内存数组, 局_计次, 1)
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
.程序集 字节流, , 公开
.程序集变量 内存指针, 整数型
.程序集变量 字节流对象, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
释放字节流 ()
.子程序 创建字节流, 整数型, 公开, 创建一个字节集流,并返回字节流对象指针
.参数 字节集, 字节集, 可空
.局部变量 局_指针, 整数型
.局部变量 局_字节集长度, 整数型
释放字节流 ()
.如果 (是否为空 (字节集))
    内存指针 ＝ GlobalAlloc (2, 0)  ' GMEM_MOVEABLE=2
    CreateStreamOnHGlobal (内存指针, 真, 字节流对象)
.否则
    局_字节集长度 ＝ 取字节集长度 (字节集)
    内存指针 ＝ GlobalAlloc (0, 局_字节集长度)  ' GMEM_FIXED=0
    局_指针 ＝ GlobalLock (内存指针)
    写到内存 (字节集, 局_指针, 局_字节集长度)
    GlobalUnlock (内存指针)
    CreateStreamOnHGlobal (内存指针, 假, 字节流对象)
.如果结束
返回 (字节流对象)
.子程序 释放字节流, , 公开, 释放字节集流,使用后释放掉内存空间
.如果真 (字节流对象 ≠ 0)
    COM_Release (字节流对象)
    字节流对象 ＝ 0
.如果真结束
.如果真 (内存指针 ≠ 0)
    GlobalFree (内存指针)
    内存指针 ＝ 0
.如果真结束
.子程序 取字节流指针, 整数型, 公开, 返回字节流对象指针
返回 (字节流对象)
.子程序 取字节流尺寸, 整数型, 公开, 返回字节流的字节集尺寸
返回 (GlobalSize (内存指针))
.子程序 取出字节集, 字节集, 公开, 取出字节流中的字节集数据
.局部变量 局_字节集, 字节集
.局部变量 局_指针, 整数型
.局部变量 局_字节流尺寸, 整数型
局_字节流尺寸 ＝ 取字节流尺寸 ()
局_指针 ＝ GlobalLock (内存指针)
局_字节集 ＝ 指针到字节集 (局_指针, 局_字节流尺寸)
GlobalUnlock (内存指针)
返回 (局_字节集)
.程序集 类_数据报
.程序集变量 数据报句柄, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.局部变量 StartupData, 套接字信息
' StartupData.版本 ＝ 1
' StartupData.高版本 ＝ 2
.如果真 (WSAStartup (2, StartupData) ≠ 0)
    输出调试文本 (“初始化失败”)
.如果真结束
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
关闭 ()
WSACleanup ()
.子程序 配置, 逻辑型, 公开, 配置网络数据报,成功返回真，失败返回假。
.参数 端口, 整数型, , 初始值为“0”。数据报监视的端口。
.局部变量 地址信息, 套接字地址
.如果真 (数据报句柄 ＞ 0)
    关闭 ()
.如果真结束
数据报句柄 ＝ socket (#PF_INET, #SOCK_DGRAM, #IPPROTO_UDP)
.如果真 (数据报句柄 ＝ -1)
    返回 (假)
.如果真结束
地址信息.端口 ＝ htons (端口)
地址信息.常量 ＝ #PF_INET
地址信息.地址 ＝ inet_addr (“0.0.0.0”)
.如果真 (地址信息.地址 ＝ -1 或 地址信息.端口 ＝ -1)
    关闭 ()
    返回 (假)
.如果真结束
.如果真 (bind (数据报句柄, 地址信息, 16) ＝ -1)
    关闭 ()
    返回 (假)
.如果真结束
返回 (真)
.子程序 关闭, 逻辑型, 公开,  关闭网络数据报，成功返回真，失败返回假。
.如果真 (closesocket (数据报句柄) ＝ -1)
    返回 (假)
.如果真结束
数据报句柄 ＝ 0
返回 (真)
.子程序 接收, 字节集, 公开, 接收来自网络服务器的数据,出错返回空字节集,每次接受的最大长度为20480个字节。
.参数 对方信息, 地址信息, 参考, 提供参数数据时只能提供变量。获得对方的IP及端口信息。
.局部变量 临时变量, 字节集
.局部变量 实际接收字节数, 整数型
.局部变量 地址信息2, 套接字地址
.局部变量 信息长度, 整数型
临时变量 ＝ 取空白字节集 (20480)
实际接收字节数 ＝ recvfrom (数据报句柄, 临时变量, 20480, 0, 地址信息2, 16)
.如果真 (实际接收字节数 ＜ 1)
    返回 ({  })
.如果真结束
对方信息.地址 ＝ 指针到文本 (inet_ntoa (地址信息2.地址))
对方信息.端口 ＝ ntohs (地址信息2.端口)
返回 (取字节集左边 (临时变量, 实际接收字节数))
.子程序 发送, 逻辑型, 公开, 向指定网络服务器发送数据。
.参数 对方信息, 地址信息, , 接收方IP及端口信息。
.参数 数据, 字节集, , 准备发送的数据。
.局部变量 实际发送字节数, 整数型
.局部变量 地址信息2, 套接字地址
地址信息2.端口 ＝ htons (对方信息.端口)
地址信息2.地址 ＝ inet_addr (对方信息.地址)
.如果真 (地址信息2.地址 ＝ -1 或 地址信息2.端口 ＝ -1)
    返回 (假)
.如果真结束
地址信息2.常量 ＝ #PF_INET
实际发送字节数 ＝ sendto (数据报句柄, 数据, 取字节集长度 (数据), 0, 地址信息2, 16)
.如果真 (实际发送字节数 ＝ -1)
    返回 (假)
.如果真结束
返回 (真)
.子程序 取本机端口, 整数型, 公开, 取本机对外端口,成功返回本机端口，失败返回-1。
.局部变量 本地地址信息, 套接字地址
GetsockName (数据报句柄, 本地地址信息, 16)
返回 (ntohs (本地地址信息.端口))
.程序集 类_内存, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 置属性, 整数型, 公开
.参数 进程句柄, 整数型, , 目标进程句柄,用 进程_打开() 命令取得
.参数 内存地址, 整数型
.参数 内存属性, 整数型, , 2 = 只读; 4 = 可读写
.局部变量 虚拟保护, 精易_内存属性
.局部变量 原保护, 整数型
.局部变量 返回, 整数型
.如果真 (VirtualQueryEx (进程句柄, 内存地址, 虚拟保护, 28) ≠ 0)
    返回 ＝ VirtualProtectEx (进程句柄, 虚拟保护.区域地址, 虚拟保护.区域长度, 内存属性, 虚拟保护.当前属性)
.如果真结束
返回 (返回)
.子程序 取属性, 逻辑型, 公开, 取内存属性信息;成功返回真,失败返回假;
.参数 进程句柄, 整数型, , 目标进程句柄,用 进程_打开() 命令取得
.参数 内存地址, 整数型, , 要取内存属性的内存地址;
.参数 内存属性, 精易_内存属性, 参考, 内存属性.当前属性 0=未分配,不可访问=1,2=可读,读写=4,可写与拷贝=8,可运行=16,可运行与可读=32,可运行可读写=64,可运行读写拷贝=128,guard=256,非物理内存=512
返回 (VirtualQueryEx (进程句柄, 内存地址, 内存属性, 28) ≠ 0)
.子程序 搜索, 整数型, 公开, 某些情况，需提升权限(返回结果数目,失败返回0)
.参数 进程ID, 整数型, , 进程ID
.参数 搜索内容, 字节集, , 欲搜索的内容  其他类型-需自行转换为字节集类型
.参数 结果数组, 整数型, 参考 数组, 用来保存搜索的结果
.局部变量 长度, 整数型
.局部变量 操作句柄, 整数型
.局部变量 内存地址, 整数型
.局部变量 内存块信息, 精易_内存属性
.局部变量 数据缓冲区, 字节集
.局部变量 读取结果, 逻辑型
.局部变量 找到地址, 整数型
清除数组 (结果数组)
长度 ＝ 取字节集长度 (搜索内容)
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
.判断循环首 (VirtualQueryEx (操作句柄, 内存地址, 内存块信息, 28) ≠ 0)  ' 取得内存块信息
    .如果真 (内存块信息.当前属性 ≠ 16 且 内存块信息.当前属性 ≠ 1 且 内存块信息.当前属性 ≠ 512)  ' 判断保护状态
        数据缓冲区 ＝ 取空白字节集 (内存块信息.区域长度)
        读取结果 ＝ ReadProcessMemory_字节集 (操作句柄, 内存地址, 数据缓冲区, 内存块信息.区域长度, 0)
        .判断循环首 (读取结果 ≠ 假)
            找到地址 ＝ 寻找字节集 (数据缓冲区, 搜索内容, 找到地址)  ' 查找是否有要搜索的数据
            .如果 (找到地址 ＝ -1)  ' 跳出 进行下次循环
                跳出循环 ()
            .否则
                加入成员 (结果数组, 到数值 (内存地址 ＋ 找到地址 － 1))
            .如果结束
            找到地址 ＝ 找到地址 ＋ 长度
        .判断循环尾 ()
    .如果真结束
    内存地址 ＝ 内存地址 ＋ 内存块信息.区域长度  ' 搜索下一内存块
    处理事件 ()
.判断循环尾 ()
CloseHandle (操作句柄)
返回 (取数组成员数 (结果数组))
.子程序 读小数, 小数型, 公开, 失败返回0。
.参数 进程ID, 整数型
.参数 内存地址, 整数型
.局部变量 临时整数, 小数型
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_小数型 (操作句柄, 内存地址, 临时整数, 4, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 临时整数, 0))
.子程序 写小数, 逻辑型, 公开
.参数 进程ID, 整数型, , 进程ID
.参数 内存地址, 整数型, , 内存地址
.参数 要写入的值, 小数型, , 写入数据
.局部变量 局_进程句柄, 整数型
.局部变量 bool, 逻辑型
.局部变量 局_长度, 整数型
局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
bool ＝ WriteProcessMemory_小数型 (局_进程句柄, 内存地址, 要写入的值, 4, 0)
CloseHandle (局_进程句柄)
返回 (bool)
.子程序 读文本, 文本型, 公开, 读取文本型数据(返回文本 失败返回空文本)
.参数 进程ID, 整数型
.参数 内存地址, 整数型
.参数 长度, 整数型, 可空, 默认为20 欲读取的长度字节
.局部变量 临时字节集, 字节集
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
.如果真 (长度 ＝ 0)
    长度 ＝ 20
.如果真结束
' --读文本---------------------------------
临时字节集 ＝ 取空白字节集 (长度)
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_字节集 (操作句柄, 内存地址, 临时字节集, 长度, 长度)
CloseHandle (操作句柄)
返回 (选择 (bool, 到文本 (临时字节集), “”))
.子程序 读文本1, 文本型, 公开, 读取文本型数据(返回文本 失败返回空文本)
.参数 进程句柄, 整数型, , 进程句柄
.参数 内存地址, 整数型
.参数 长度, 整数型, 可空, 默认为20 欲读取的长度字节
.局部变量 临时文本, 文本型
.局部变量 bool, 逻辑型
.如果真 (长度 ＝ 0)
    长度 ＝ 20
.如果真结束
' --读文本---------------------------------
临时文本 ＝ 取空白文本 (长度)
bool ＝ ReadProcessMemory_文本型 (进程句柄, 内存地址, 临时文本, 长度, 长度)
返回 (选择 (bool, 临时文本, “”))
.子程序 写文本, 逻辑型, 公开, 写入文本数据(成功返回真,失败返回假)
.参数 进程ID, 整数型, , 进程ID
.参数 内存地址, 整数型, , 内存地址
.参数 要写入的数据, 文本型, , 写入数据
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
bool ＝ WriteProcessMemory_文本型 (操作句柄, 内存地址, 要写入的数据, 取文本长度 (要写入的数据), 0)
CloseHandle (操作句柄)
返回 (bool)
.子程序 读整数, 整数型, 公开, 读取整数型数据(返回整数内容 失败返回0) 
.参数 进程ID, 整数型
.参数 内存地址, 整数型
.局部变量 临时整数, 整数型
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_整数型 (操作句柄, 内存地址, 临时整数, 4, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 临时整数, 0))
.子程序 读整数1, 整数型, 公开, 读取整数型数据(返回整数内容 失败返回0) 
.参数 进程句柄, 整数型, , 进程句柄
.参数 内存地址, 整数型
.局部变量 临时整数, 整数型
.局部变量 bool, 逻辑型
bool ＝ ReadProcessMemory_整数型 (进程句柄, 内存地址, 临时整数, 4, 0)
返回 (选择 (bool, 临时整数, 0))
.子程序 读短整数, 短整数型, 公开, 读取短整数型数据(返回整数内容 失败返回0)
.参数 进程ID, 整数型
.参数 内存地址, 整数型
.局部变量 临时整数, 短整数型
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_短整数型 (操作句柄, 内存地址, 临时整数, 2, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 临时整数, 0))
.子程序 读短整数1, 短整数型, 公开, 读取短整数型数据(返回整数内容 失败返回0)
.参数 进程句柄, 整数型, , 进程句柄
.参数 内存地址, 整数型
.局部变量 临时整数, 整数型
.局部变量 bool, 逻辑型
bool ＝ ReadProcessMemory_短整数型 (进程句柄, 内存地址, 临时整数, 2, 0)
返回 (选择 (bool, 临时整数, 0))
.子程序 读长整数, 长整数型, 公开, 失败返回0
.参数 进程ID, 整数型
.参数 内存地址, 整数型
.局部变量 临时整数, 长整数型
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_长整数型 (操作句柄, 内存地址, 临时整数, 8, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 临时整数, 0))
.子程序 读长整数1, 长整数型, 公开, 失败返回0
.参数 进程句柄, 整数型, , 进程句柄
.参数 内存地址, 整数型
.局部变量 临时整数, 长整数型
.如果真 (ReadProcessMemory_长整数型 (进程句柄, 内存地址, 临时整数, 8, 0))
    返回 (临时整数)
.如果真结束
返回 (0)
.子程序 写整数, 逻辑型, 公开, 写入四字节数据(成功返回真,失败返回假) 
.参数 进程ID, 整数型, , 进程ID
.参数 内存地址, 整数型, , 内存地址
.参数 要写入的值, 整数型, , 写入数据
.参数 写入类型, 整数型, 可空, 默认为1  0=短整数型 1=整数型 2=长整数型
.局部变量 局_进程句柄, 整数型
.局部变量 bool, 逻辑型
.局部变量 局_长度, 整数型
.如果 (是否为空 (写入类型))
    局_长度 ＝ 4
.否则
    .判断开始 (写入类型 ＝ 0)
        局_长度 ＝ 2
    .判断 (写入类型 ＝ 1)
        局_长度 ＝ 4
    .判断 (写入类型 ＝ 2)
        局_长度 ＝ 8
    .默认
    .判断结束
.如果结束
局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
bool ＝ WriteProcessMemory_整数3 (局_进程句柄, 内存地址, 要写入的值, 局_长度, 0)
CloseHandle (局_进程句柄)
返回 (bool)
.子程序 读字节, 字节型, 公开, 读取字节型数据(返回整数内容 失败返回0) 
.参数 进程ID, 整数型
.参数 内存地址, 整数型
.局部变量 临时整数, 字节型
.局部变量 长度, 整数型
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
' ---读整数----------------------------------
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_字节型 (操作句柄, 内存地址, 临时整数, 1, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 临时整数, 0))
.子程序 写字节, 逻辑型, 公开, 写入1字节数据(成功返回真,失败返回假) 
.参数 进程ID, 整数型, , 进程ID
.参数 内存地址, 整数型, , 内存地址
.参数 要写入的数据, 字节型, , 写入数据
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
bool ＝ WriteProcessMemory_写字节 (操作句柄, 内存地址, 要写入的数据, 1, 0)
CloseHandle (操作句柄)
返回 (bool)
.子程序 读字节集, 字节集, 公开, 读取字节集数据(返回字节集 失败返回空) 
.参数 进程ID, 整数型, , 进程ID
.参数 内存地址, 整数型, , 内存地址
.参数 长度, 整数型, 可空, 可空。留空将智能读取长度
.局部变量 变量, 字节集, , , 保存读取数据的变量
.局部变量 操作句柄, 整数型
.局部变量 内存块信息, 精易_内存属性
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
.如果真 (长度 ＝ 0)
    VirtualQueryEx (操作句柄, 内存地址, 内存块信息, 28)
    长度 ＝ 内存块信息.区域长度 ＋ 内存块信息.区域地址 － 内存地址
.如果真结束
变量 ＝ 取空白字节集 (长度)
bool ＝ ReadProcessMemory_字节集 (操作句柄, 内存地址, 变量, 长度, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 变量, {  }))
.子程序 写字节集, 逻辑型, 公开, 写入字节集数据(成功返回真,失败返回假)
.参数 进程ID, 整数型, , 进程ID
.参数 内存地址, 整数型, , 内存地址
.参数 要写入的数据, 字节集, , 写入数据
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
bool ＝ WriteProcessMemory_字节集 (操作句柄, 内存地址, 要写入的数据, 取字节集长度 (要写入的数据), 0)
CloseHandle (操作句柄)
返回 (bool)
.子程序 读日期时间, 日期时间型, 公开, 从内存中读取日期时间型数据,失败将返回100年1月1日
.参数 进程ID, 整数型, , 进程ID
.参数 地址, 整数型, , 内存地址
.局部变量 局_变量, 字节集, , , 保存读取数据的变量
.局部变量 局_进程句柄, 整数型
.局部变量 bool, 逻辑型
.局部变量 局_长度, 整数型
局_长度 ＝ 8
局_变量 ＝ 取空白字节集 (局_长度)
局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_字节集 (局_进程句柄, 地址, 局_变量, 局_长度, 0)
CloseHandle (局_进程句柄)
.如果真 (bool ＝ 假)
    返回 (到时间 (0))
.如果真结束
返回 (取字节集数据 (局_变量, #日期时间型, ))
.子程序 读子程序指针, 子程序指针, 公开, 从内存中读取子程序指针,失败返回空指针
.参数 进程ID, 整数型, , 进程ID
.参数 地址, 整数型, , 内存地址
.局部变量 空指针, 子程序指针
.局部变量 变量, 字节集, , , 保存读取数据的变量
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
.局部变量 长度, 整数型
长度 ＝ 4
变量 ＝ 取空白字节集 (长度)
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_字节集 (操作句柄, 地址, 变量, 长度, 0)
CloseHandle (操作句柄)
.如果真 (bool ＝ 假)
    返回 (空指针)
.如果真结束
返回 (取字节集数据 (变量, #子程序指针型, ))
.子程序 读双精度小数, 双精度小数型, 公开, 从内存中读取双精度小数型数据,失败返回0
.参数 进程ID, 整数型, , 进程ID
.参数 地址, 整数型, , 内存地址
.局部变量 变量, 字节集, , , 保存读取数据的变量
.局部变量 操作句柄, 整数型
.局部变量 bool, 逻辑型
.局部变量 长度, 整数型
长度 ＝ 8
变量 ＝ 取空白字节集 (长度)
操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)  ' 取得操作句柄
bool ＝ ReadProcessMemory_字节集 (操作句柄, 地址, 变量, 长度, 0)
CloseHandle (操作句柄)
返回 (选择 (bool, 取字节集数据 (变量, #双精度小数型, ), 0))
.子程序 写代码, 逻辑型, 公开, 写内存整数型,写内存字节集。[坛友：“啄啄”提供]
.参数 进程ID, 整数型, , 要操作的进程ID
.参数 地址表达式, 文本型, , 比如“0A1574D+1D45+547=999”
.局部变量 局部_写入的值, 文本型
.局部变量 局部_一级分割, 文本型, , "0"
.局部变量 局部_二级分割, 文本型, , "0"
.局部变量 局部_计次, 整数型
.局部变量 局部_读取的值, 整数型
局部_一级分割 ＝ 分割文本 (地址表达式, “=”, )
局部_写入的值 ＝ 局部_一级分割 [2]
局部_二级分割 ＝ 分割文本 (局部_一级分割 [1], “+”, )
.判断开始 (取文本左边 (局部_写入的值, 1) ＝ “{”)
    .计次循环首 (取数组成员数 (局部_二级分割), 局部_计次)
        .判断开始 (局部_计次 ＝ 取数组成员数 (局部_二级分割))
            局部_读取的值 ＝ 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值
        .默认
            局部_读取的值 ＝ 到整数 (读字节集 (进程ID, 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值, ))
        .判断结束
    .计次循环尾 ()
    返回 (写字节集 (进程ID, 局部_读取的值, 字节集_十六进制到字节集 (局部_写入的值)))
.默认
    .计次循环首 (取数组成员数 (局部_二级分割), 局部_计次)
        .判断开始 (局部_计次 ＝ 取数组成员数 (局部_二级分割))
            局部_读取的值 ＝ 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值
        .默认
            局部_读取的值 ＝ 读整数 (进程ID, 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值)
        .判断结束
    .计次循环尾 ()
    返回 (写整数 (进程ID, 局部_读取的值, 到整数 (局部_写入的值)))
.判断结束
.子程序 读代码_整数, 整数型, 公开, 读内存整数型。[坛友：“啄啄”提供]
.参数 进程ID, 整数型, , 要操作的进程ID
.参数 地址表达式, 文本型, , 比如“0A1574D+1D45+547”
.局部变量 局部_计次, 整数型
.局部变量 局部_读取的值, 整数型
.局部变量 局部_分割, 文本型, , "0"
局部_分割 ＝ 分割文本 (地址表达式, “+”, )
.计次循环首 (取数组成员数 (局部_分割), 局部_计次)
    .判断开始 (局部_计次 ＝ 取数组成员数 (局部_分割))
        局部_读取的值 ＝ 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值
    .默认
        局部_读取的值 ＝ 读整数 (进程ID, 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值)
    .判断结束
.计次循环尾 ()
返回 (读整数 (进程ID, 局部_读取的值))
.子程序 读代码_字节集, 字节集, 公开, 读内存字节集。[坛友：“啄啄”提供]
.参数 进程ID, 整数型, , 要操作的进程ID
.参数 地址表达式, 文本型, , 比如“0A1574D+1D45+547”
.局部变量 局部_计次, 整数型
.局部变量 局部_读取的值, 整数型
.局部变量 局部_分割, 文本型, , "0"
局部_分割 ＝ 分割文本 (地址表达式, “+”, )
.计次循环首 (取数组成员数 (局部_分割), 局部_计次)
    .判断开始 (局部_计次 ＝ 取数组成员数 (局部_分割))
        局部_读取的值 ＝ 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值
    .默认
        局部_读取的值 ＝ 读整数 (进程ID, 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值)
    .判断结束
.计次循环尾 ()
返回 (读字节集 (进程ID, 局部_读取的值, ))
.子程序 读字节集_64, 字节集, 公开, 成功返回字节集数据，如果失败返回空字节集。不同类型的内存值可用 取字节集数据(字节集，#整数型) 取得对应的内存值。
.参数 PID, 整数型, , 进程PID
.参数 表达式地址, 文本型, , 如：141FF33E8+170+7EC
.参数 读入长度, 长整数型, , 4，一般内存地址都是4个字节为一个地址{xxx,xxx,xxx,xxx}
.局部变量 分割的文本, 文本型, , "0"
.局部变量 成员数, 整数型
.局部变量 n, 整数型
.局部变量 进程句柄, 整数型
.局部变量 返回字节集, 字节集
.局部变量 指针, 长整数型
.局部变量 地址, 长整数型
' 该命令收录自：https://bbs.125.la/thread-14405734-1-1.html
分割的文本 ＝ 分割文本 (表达式地址, “+”, )
成员数 ＝ 取数组成员数 (分割的文本)
.计次循环首 (成员数, n)
    .判断开始 (n ＝ 成员数)
        进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID)
        返回字节集 ＝ 取空白字节集 (读入长度)
        地址 ＝ 进制_十六到十 (分割的文本 [n])
        指针 ＝ 指针 ＋ 地址
        ZwWow64ReadVirtualMemory64 (进程句柄, 指针, 返回字节集, 读入长度, 0)
        CloseHandle (进程句柄)
        返回 (返回字节集)
    .默认
        进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID)  ' 打开进程，返回进程句柄，每次打开都回返回不同句柄
        返回字节集 ＝ 取空白字节集 (读入长度)  ' 得先初始化，不然读内存传参不过来
        地址 ＝ 进制_十六到十 (分割的文本 [n])
        指针 ＝ 指针 ＋ 地址
        ZwWow64ReadVirtualMemory64 (进程句柄, 指针, 返回字节集, 读入长度, 0)
        CloseHandle (进程句柄)  ' 读完一次内存，及时关闭进程句柄，防止对象没关闭照成程序崩溃
        指针 ＝ 取字节集数据 (返回字节集, #长整数型, )  ' 有偏移的内存地址，中间过程都是返回地址的，所以要取出字节集数据，得到偏移后的指针
        .如果真 (指针 ＝ 0)  ' 通常指针为0就是取不出来了
            ' 调试输出 (分割的文本 [n], 指针, n, “此处失败”)
            返回 ({  })
        .如果真结束
    .判断结束
.计次循环尾 ()
返回 ({  })
.子程序 写字节集_64, 整数型, 公开, 写内存字节集，失败返回-1，成功非-1
.参数 PID, 整数型, , 进程PID
.参数 表达式地址, 文本型, , 如：141FF33E8+170+7EC
.参数 写入长度, 长整数型, , 4，一般内存地址都是4个字节为一个地址{xxx,xxx,xxx,xxx}
.参数 写入数据, 字节集, , 用法：如果写入整数型数据→到字节集(123) 文本型数据→到字节集（“123”）。
.局部变量 分割的文本, 文本型, , "0"
.局部变量 成员数, 整数型
.局部变量 n, 整数型
.局部变量 进程句柄, 整数型
.局部变量 返回字节集, 字节集
.局部变量 指针, 长整数型
.局部变量 地址, 长整数型
.局部变量 结果, 整数型
分割的文本 ＝ 分割文本 (表达式地址, “+”, )
成员数 ＝ 取数组成员数 (分割的文本)
.计次循环首 (成员数, n)
    .判断开始 (n ＝ 成员数)
        进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID)
        返回字节集 ＝ 取空白字节集 (写入长度)
        地址 ＝ 进制_十六到十 (分割的文本 [n])
        指针 ＝ 指针 ＋ 地址
        结果 ＝ ZwWow64WriteVirtualMemory64 (进程句柄, 指针, 写入数据, 写入长度, 0)
        CloseHandle (进程句柄)
        返回 (结果)
    .默认
        进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID)  ' 打开进程，返回进程句柄，每次打开都回返回不同句柄
        返回字节集 ＝ 取空白字节集 (写入长度)  ' 得先初始化，不然读内存传参不过来
        地址 ＝ 进制_十六到十 (分割的文本 [n])
        指针 ＝ 指针 ＋ 地址
        ZwWow64ReadVirtualMemory64 (进程句柄, 指针, 返回字节集, 写入长度, 0)
        CloseHandle (进程句柄)  ' 读完一次内存，及时关闭进程句柄，防止对象没关闭照成程序崩溃
        指针 ＝ 取字节集数据 (返回字节集, #长整数型, )  ' 有偏移的内存地址，中间过程都是返回地址的，所以要取出字节集数据，得到偏移后的指针
        .如果真 (指针 ＝ 0)  ' 通常指针为0就是取不出来了
            ' 调试输出 (分割的文本 [n], 指针, n, “此处失败”)
            返回 (-1)
        .如果真结束
    .判断结束
.计次循环尾 ()
返回 (-1)
.程序集 类_ODBC数据库, , 公开, 此类为易友 校长小猪猪 提供。
.程序集变量 m_hENV, 整数型
.程序集变量 m_hDBC, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
SQLAllocHandle (#SQL_HANDLE_ENV, #SQL_NULL_HANDLE, m_hENV)  ' 申请环境句柄
SQLSetEnvAttr (m_hENV, #SQL_ATTR_ODBC_VERSION, #SQL_OV_ODBC3, #SQL_IS_INTEGER)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
关闭 ()
SQLFreeHandle (#SQL_HANDLE_ENV, m_hENV)
.子程序 取数据库句柄, 整数型, 公开
返回 (m_hDBC)
.子程序 置数据库句柄, , 公开
.参数 参数_数据库句柄, 整数型
m_hDBC ＝ 参数_数据库句柄
.子程序 连接, 逻辑型, 公开
.参数 参数_连接字符串, 文本型
.局部变量 局部_实际长度, 整数型
.局部变量 局部_输出, 文本型
.局部变量 局部_长度, 整数型
.局部变量 ret, 短整数型
.如果真 (m_hDBC ＝ 0)
    ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC)  ' 申请连接句柄
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (假)
    .如果真结束
.如果真结束
局部_长度 ＝ 取文本长度 (参数_连接字符串)
局部_输出 ＝ 取空白文本 (1024)
ret ＝ SQLDriverConnect (m_hDBC, 0, 参数_连接字符串, 局部_长度, 局部_输出, 1024, 局部_实际长度, #SQL_DRIVER_NOPROMPT)
返回 (ret ＝ #SQL_SUCCESS 或 ret ＝ #SQL_SUCCESS_WITH_INFO)
.子程序 连接SQLServer, 逻辑型, 公开
.参数 参数_服务器名, 文本型
.参数 参数_数据库, 文本型
.参数 参数_用户名, 文本型, 可空, 为空默认以Windows账户登录
.参数 参数_密码, 文本型, 可空, 为空默认以Windows账户登录
.局部变量 局_连接字符串, 文本型
局_连接字符串 ＝ “driver={sql server};server=” ＋ 参数_服务器名 ＋ “;database=” ＋ 参数_数据库 ＋ “;uid=” ＋ 参数_用户名 ＋ “;pwd=” ＋ 参数_密码
.如果真 (是否为空 (参数_用户名) 且 是否为空 (参数_密码))
    局_连接字符串 ＝ “Driver=SQL Server;Server=” ＋ 参数_服务器名 ＋ “;Database=” ＋ 参数_数据库 ＋ “;Trusted_Connection=Yes;Connect Timeout=90”
.如果真结束
返回 (连接 (局_连接字符串))
.子程序 连接Access, 逻辑型, 公开, 连接mdb或accdb数据库
.参数 参数_文件名, 文本型, , 本参数提供Access数据库文件的完整路径名。
.参数 参数_密码, 文本型, 可空, 本参数提供Access数据库的访问密码。可以为空，若为空，表示Access数据库没有密码。
.参数 参数_Accdb, 逻辑型, 可空, 数据库类型。默认为假=mdb，真=accdb。
.局部变量 局_连接语句, 文本型
.如果 (参数_Accdb)
    局_连接语句 ＝ “ODBC;DSN=MS Access Database;DBQ=” ＋ 参数_文件名 ＋ “;Driver={Microsoft Access Driver (*.mdb, *.accdb)};;DriverId=25;FIL=MS Access;MaxBufferSize=2048;PageTimeout=5;PWD=” ＋ 参数_密码
.否则
    局_连接语句 ＝ “DBQ=” ＋ 参数_文件名 ＋ “;Pwd=” ＋ 参数_密码 ＋ “;DRIVER={Microsoft Access Driver (*.mdb)};”
.如果结束
返回 (连接 (局_连接语句))
.子程序 关闭, 逻辑型, 公开
.局部变量 ret, 短整数型
ret ＝ SQLDisconnect (m_hDBC)
.如果真 (ret ≠ #SQL_SUCCESS)
    返回 (假)
.如果真结束
ret ＝ SQLFreeHandle (#SQL_HANDLE_DBC, m_hDBC)
m_hDBC ＝ 0
返回 (真)
.子程序 执行SQL, 逻辑型, 公开
.参数 参数_SQL语句, 文本型
.参数 参数_影响行, 整数型, 参考 可空
.局部变量 ret, 短整数型
.局部变量 hSTMT, 整数型
ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
.如果真 (ret ≠ #SQL_SUCCESS)
    返回 (假)
.如果真结束
ret ＝ SQLExecDirect (hSTMT, 参数_SQL语句, 取文本长度 (参数_SQL语句))
.如果真 (是否为空 (参数_影响行) ＝ 假)
    SQLRowCount (hSTMT, 参数_影响行)
.如果真结束
SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 执行, 逻辑型, 公开
.参数 参数_SQL语句, 文本型, , 语句中的第几个“?”，表示参数几
.参数 参数_影响行, 整数型, 参考 可空
.参数 参数一, 字节集, 可空
.参数 参数二, 字节集, 可空
.参数 参数三, 字节集, 可空
.参数 参数四, 字节集, 可空
.参数 参数五, 字节集, 可空
.局部变量 ret, 短整数型
.局部变量 hSTMT, 整数型
.局部变量 len, 整数型, , "5"
ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
.如果真 (ret ≠ #SQL_SUCCESS)
    返回 (假)
.如果真结束
ret ＝ SQLPrepare (hSTMT, 参数_SQL语句, #SQL_NTS)
.如果真 (ret ≠ #SQL_SUCCESS)
    SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
    返回 (假)
.如果真结束
.计次循环首 (1, )
    .如果真 (是否为空 (参数一))
        跳出循环 ()
    .如果真结束
    len [1] ＝ 取字节集长度 (参数一)
    ret ＝ SQLBindParameter (hSTMT, 1, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [1], 0, 参数一, len [1], len [1])
    .如果真 (是否为空 (参数二))
        跳出循环 ()
    .如果真结束
    len [2] ＝ 取字节集长度 (参数二)
    ret ＝ SQLBindParameter (hSTMT, 2, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [2], 0, 参数二, len [2], len [2])
    .如果真 (是否为空 (参数三))
        跳出循环 ()
    .如果真结束
    len [3] ＝ 取字节集长度 (参数三)
    ret ＝ SQLBindParameter (hSTMT, 3, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [3], 0, 参数三, len [3], len [3])
    .如果真 (是否为空 (参数四))
        跳出循环 ()
    .如果真结束
    len [4] ＝ 取字节集长度 (参数四)
    ret ＝ SQLBindParameter (hSTMT, 4, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [4], 0, 参数四, len [4], len [4])
    .如果真 (是否为空 (参数五))
        跳出循环 ()
    .如果真结束
    len [5] ＝ 取字节集长度 (参数五)
    ret ＝ SQLBindParameter (hSTMT, 5, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [5], 0, 参数五, len [5], len [5])
.计次循环尾 ()
ret ＝ SQLExecute (hSTMT)
.如果真 (是否为空 (参数_影响行) ＝ 假)
    SQLRowCount (hSTMT, 参数_影响行)
.如果真结束
SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 查询, 整数型, 公开, 返回记录集句柄。此时记录集位置在首记录前
.参数 参数_SQL语句, 文本型
.参数 参数_光标类型, 整数型, 可空, “光标类型_”开头常量。默认为“光标类型_键集”
.局部变量 ret, 短整数型
.局部变量 hSTMT, 整数型
ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
.如果真 (ret ≠ #SQL_SUCCESS)
    返回 (0)
.如果真结束
.如果真 (是否为空 (参数_光标类型))
    参数_光标类型 ＝ #光标类型_键集
.如果真结束
ret ＝ SQLSetStmtAttr (hSTMT, #SQL_ATTR_CURSOR_TYPE, 参数_光标类型, 0)
ret ＝ SQLExecDirect (hSTMT, 参数_SQL语句, 取文本长度 (参数_SQL语句))
.如果真 (ret ≠ #SQL_SUCCESS)
    SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
    返回 (0)
.如果真结束
返回 (hSTMT)
.子程序 置SQL语句, 整数型, 公开, 准备一条SQL语句，此时并没有执行。返回记录集句柄
.参数 参数_SQL语句, 文本型
.参数 参数_光标类型, 整数型, 可空, “光标类型_”开头常量。默认为“光标类型_向前”
.局部变量 ret, 短整数型
.局部变量 hSTMT, 整数型
ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
.如果真 (ret ≠ #SQL_SUCCESS)
    返回 (0)
.如果真结束
.如果真 (是否为空 (参数_光标类型))
    参数_光标类型 ＝ #光标类型_键集
.如果真结束
ret ＝ SQLSetStmtAttr (hSTMT, #SQL_ATTR_CURSOR_TYPE, 参数_光标类型, 0)
ret ＝ SQLPrepare (hSTMT, 参数_SQL语句, #SQL_NTS)
.如果真 (ret ≠ #SQL_SUCCESS)
    SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
    返回 (0)
.如果真结束
返回 (hSTMT)
.子程序 执行记录集, 逻辑型, 公开, 执行由“置SQL语句”返回的记录集。
.参数 参数_记录集句柄, 整数型
.局部变量 ret, 短整数型
ret ＝ SQLExecute (参数_记录集句柄)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 绑定参数, 逻辑型, 公开, 给记录集绑定参数。
.参数 参数_记录集句柄, 整数型
.参数 参数_参数索引, 整数型, , 表示第几个参数，索引从1开始
.参数 参数_字节集, 字节集
.局部变量 len, 整数型
.局部变量 ret, 短整数型
len ＝ 取字节集长度 (参数_字节集)
ret ＝ SQLBindParameter (参数_记录集句柄, 参数_参数索引, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len, 0, 参数_字节集, len, len)
返回 (ret ≠ #SQL_SUCCESS)
.子程序 释放记录集, 逻辑型, 公开
.参数 参数_记录集句柄, 整数型
返回 (SQLFreeHandle (#SQL_HANDLE_STMT, 参数_记录集句柄) ＝ #SQL_SUCCESS)
.子程序 到下一条, 逻辑型, 公开, 如果到最后一行，返回假
.参数 参数_记录集句柄, 整数型
.局部变量 ret, 短整数型
ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_NEXT, 0)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 到上一条, 逻辑型, 公开
.参数 参数_记录集句柄, 整数型
.局部变量 ret, 短整数型
ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_PRIOR, 0)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 到首记录, 逻辑型, 公开
.参数 参数_记录集句柄, 整数型
.局部变量 ret, 短整数型
ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_FIRST, 0)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 到尾记录, 逻辑型, 公开
.参数 参数_记录集句柄, 整数型
.局部变量 ret, 短整数型
ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_LAST, 0)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 移到, 逻辑型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_行号, 整数型
.局部变量 ret, 短整数型
ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_ABSOLUTE, 参数_行号)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 字段名到序号, 整数型
.参数 参数_记录集句柄, 整数型
.参数 参数_字段名, 文本型
.局部变量 i, 整数型
.计次循环首 (取字段数 (参数_记录集句柄), i)
    .如果真 (取字段名 (参数_记录集句柄, i － 1) ＝ 参数_字段名)
        返回 (i － 1)
    .如果真结束
.计次循环尾 ()
返回 (-1)
.子程序 读字段文本, 文本型, 公开, 用字段名读
.参数 参数_记录集句柄, 整数型
.参数 参数_字段名, 文本型
.局部变量 局部_序号, 整数型
局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
.如果真 (局部_序号 ＝ -1)
    返回 (“”)
.如果真结束
返回 (读文本 (参数_记录集句柄, 局部_序号))
.子程序 读字段字节集, 字节集, 公开, 用字段名读
.参数 参数_记录集句柄, 整数型
.参数 参数_字段名, 文本型
.局部变量 局部_序号, 整数型
局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
.如果真 (局部_序号 ＝ -1)
    返回 ({  })
.如果真结束
返回 (读字节集 (参数_记录集句柄, 局部_序号))
.子程序 读字段整数, 整数型, 公开, 用字段名读
.参数 参数_记录集句柄, 整数型
.参数 参数_字段名, 文本型
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 局部_整数, 整数型
.局部变量 局部_序号, 整数型
局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
.如果真 (局部_序号 ＝ -1)
    返回 (0)
.如果真结束
ret ＝ SQLGetData (参数_记录集句柄, 局部_序号 ＋ 1, #SQL_C_LONG, 取指针整数_ (局部_整数), 4, 局部_实际长度)
返回 (局部_整数)
.子程序 读字段单精度, 小数型, 公开, 用字段名读
.参数 参数_记录集句柄, 整数型
.参数 参数_字段名, 文本型
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 value, 小数型
.局部变量 局部_序号, 整数型
局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
.如果真 (局部_序号 ＝ -1)
    返回 (0)
.如果真结束
ret ＝ SQLGetData (参数_记录集句柄, 局部_序号 ＋ 1, #SQL_C_FLOAT, 取指针小数_ (value), 4, 局部_实际长度)
返回 (value)
.子程序 读字段双精度, 双精度小数型, 公开, 用字段名读
.参数 参数_记录集句柄, 整数型
.参数 参数_字段名, 文本型
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 value, 双精度小数型
.局部变量 局部_序号, 整数型
局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
.如果真 (局部_序号 ＝ -1)
    返回 (0)
.如果真结束
ret ＝ SQLGetData (参数_记录集句柄, 局部_序号 ＋ 1, #SQL_C_DOUBLE, 取指针双精度_ (value), 8, 局部_实际长度)
返回 (value)
.子程序 读文本, 文本型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 索引从0开始
.局部变量 局部_实际长度, 整数型
.局部变量 buffer, 文本型
.局部变量 ret, 短整数型
.局部变量 局部_返回值, 文本型
.如果真 (参数_记录集句柄 ＝ 0)
    返回 (“”)
.如果真结束
局部_实际长度 ＝ 255
.循环判断首 ()
    buffer ＝ 取空白文本 (局部_实际长度)
    ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_CHAR, 取指针文本_ (buffer), 局部_实际长度, 局部_实际长度)
    .如果真 (ret ＝ #SQL_ERROR 或 ret ＝ #SQL_INVALID_HANDLE 或 局部_实际长度 ＝ -1)
        返回 (“”)
    .如果真结束
    局部_返回值 ＝ 局部_返回值 ＋ 取文本左边 (buffer, 局部_实际长度)
.循环判断尾 (ret ＝ #SQL_SUCCESS_WITH_INFO)
返回 (局部_返回值)
.子程序 读字节集, 字节集, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 索引从0开始
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 buffer, 字节集
.局部变量 局部_返回值, 字节集
.如果真 (参数_记录集句柄 ＝ 0)
    返回 ({  })
.如果真结束
局部_实际长度 ＝ 10240
.循环判断首 ()
    buffer ＝ 取空白字节集 (局部_实际长度)
    ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_BINARY, 取指针字节集_ (buffer), 局部_实际长度, 局部_实际长度)
    .如果真 (ret ＝ #SQL_ERROR 或 ret ＝ #SQL_INVALID_HANDLE 或 局部_实际长度 ＝ -1)
        返回 ({  })
    .如果真结束
    局部_返回值 ＝ 局部_返回值 ＋ 取字节集左边 (buffer, 局部_实际长度)
.循环判断尾 (ret ＝ #SQL_SUCCESS_WITH_INFO)
返回 (局部_返回值)
.子程序 读整数, 整数型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 索引从0开始
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 局部_整数, 整数型
.如果真 (参数_记录集句柄 ＝ 0)
    返回 (0)
.如果真结束
ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_LONG, 取指针整数_ (局部_整数), 4, 局部_实际长度)
返回 (局部_整数)
.子程序 读单精度, 小数型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 索引从0开始
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 value, 小数型
.如果真 (参数_记录集句柄 ＝ 0)
    返回 (0)
.如果真结束
ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_FLOAT, 取指针小数_ (value), 4, 局部_实际长度)
返回 (value)
.子程序 读双精度, 双精度小数型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 索引从0开始
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 value, 双精度小数型
.如果真 (参数_记录集句柄 ＝ 0)
    返回 (0)
.如果真结束
ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_DOUBLE, 取指针双精度_ (value), 8, 局部_实际长度)
返回 (value)
.子程序 取字段名, 文本型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 列号从0开始
.局部变量 局部_字段名, 文本型
局部_字段名 ＝ 取空白文本 (255)
.如果 (SQLDescribeCol (参数_记录集句柄, 参数_列号 ＋ 1, 局部_字段名, 255, 0, 0, 0, 0, 0) ≠ #SQL_SUCCESS)
    返回 (“”)
.否则
    返回 (局部_字段名)
.如果结束
.子程序 取字段数, 整数型, 公开
.参数 参数_记录集句柄, 整数型
.局部变量 ColumnCount, 整数型
SQLNumResultCols (参数_记录集句柄, ColumnCount)
返回 (ColumnCount)
.子程序 取字段类型, 整数型, 公开, 返回“SQL_”开头常量
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 列号从0开始
.局部变量 局部_类型, 整数型
.如果 (SQLDescribeCol (参数_记录集句柄, 参数_列号 ＋ 1, 字符 (0), 0, 0, 局部_类型, 0, 0, 0) ≠ #SQL_SUCCESS)
    返回 (0)
.否则
    返回 (局部_类型)
.如果结束
.子程序 取字段定义长度, 整数型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_列号, 整数型, , 列号从0开始
.局部变量 局部_长度, 整数型
.如果 (SQLDescribeCol (参数_记录集句柄, 参数_列号 ＋ 1, 字符 (0), 0, 0, 0, 局部_长度, 0, 0) ≠ #SQL_SUCCESS)
    返回 (0)
.否则
    返回 (局部_长度)
.如果结束
.子程序 字段是否可空, 逻辑型, 公开
.参数 参数_记录集句柄, 整数型
.参数 参数_字段序号, 整数型, , 列号从0开始
.局部变量 局部_是否为空, 整数型
.如果 (SQLDescribeCol (参数_记录集句柄, 参数_字段序号 ＋ 1, 字符 (0), 0, 0, 0, 0, 0, 局部_是否为空) ≠ #SQL_SUCCESS)
    返回 (假)
.否则
    返回 (局部_是否为空 ≠ 0)
.如果结束
.子程序 取记录数, 整数型, 公开
.参数 参数_表名, 文本型
.参数 参数_条件, 文本型, 可空
.局部变量 sql, 文本型
.局部变量 局部_行数, 整数型
.局部变量 res, 整数型
sql ＝ “select count(1) from ” ＋ 参数_表名 ＋ “ ”
.如果真 (是否为空 (参数_条件) ＝ 假)
    sql ＝ sql ＋ 参数_条件
.如果真结束
res ＝ 查询 (sql, #光标类型_向前)
到下一条 (res)
局部_行数 ＝ 读整数 (res, 0)
SQLFreeHandle (#SQL_HANDLE_STMT, res)
返回 (局部_行数)
.子程序 开始事务, 逻辑型, 公开
.局部变量 ret, 短整数型
ret ＝ SQLSetConnectAttr (m_hDBC, #SQL_ATTR_AUTOCOMMIT, #SQL_AUTOCOMMIT_OFF, #SQL_IS_UINTEGER)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 回滚事务, 逻辑型, 公开
.局部变量 ret, 短整数型
ret ＝ SQLEndTran (#SQL_HANDLE_DBC, m_hDBC, #SQL_ROLLBACK)
SQLSetConnectAttr (m_hDBC, #SQL_ATTR_AUTOCOMMIT, #SQL_AUTOCOMMIT_ON, #SQL_IS_UINTEGER)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 提交事务, 逻辑型, 公开
.局部变量 ret, 短整数型
ret ＝ SQLEndTran (#SQL_HANDLE_DBC, m_hDBC, #SQL_COMMIT)
SQLSetConnectAttr (m_hDBC, #SQL_ATTR_AUTOCOMMIT, #SQL_AUTOCOMMIT_ON, #SQL_IS_UINTEGER)
返回 (ret ＝ #SQL_SUCCESS)
.子程序 设超时时间, 逻辑型, 公开
.参数 参数_要设置的时间, 整数型
.局部变量 ret, 短整数型
.如果真 (m_hDBC ＝ 0)
    ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC)  ' 申请连接句柄
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (假)
    .如果真结束
.如果真结束
返回 (SQLSetConnectAttr (m_hDBC, #SQL_ATTR_CONNECTION_TIMEOUT, 取指针整数_ (参数_要设置的时间), 0) ＝ #SQL_SUCCESS)
.子程序 取超时时间, 整数型, 公开
.局部变量 ret, 短整数型
.局部变量 value, 整数型
.如果真 (m_hDBC ＝ 0)
    ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC)  ' 申请连接句柄
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (0)
    .如果真结束
.如果真结束
ret ＝ SQLGetConnectAttr (m_hDBC, #SQL_ATTR_CONNECTION_TIMEOUT, 取指针整数_ (value), #SQL_IS_UINTEGER, 0)
返回 (value)
.子程序 取最后错误, 整数型, 公开, 返回错误号。
.参数 参数_错误状态, 文本型, 参考 可空
.参数 参数_错误描述, 文本型, 参考 可空
.局部变量 局部_实际长度, 整数型
.局部变量 ret, 短整数型
.局部变量 state, 文本型
.局部变量 message, 文本型
.局部变量 index, 整数型
.局部变量 error, 整数型
.循环判断首 ()
    index ＝ index ＋ 1
    state ＝ 取空白文本 (6)
    message ＝ 取空白文本 (#SQL_MAX_MESSAGE_LENGTH)
    ret ＝ SQLGetDiagRec (#SQL_HANDLE_DBC, m_hDBC, index, state, error, message, #SQL_MAX_MESSAGE_LENGTH, 局部_实际长度)
    .如果真 (ret ＝ #SQL_ERROR 或 ret ＝ #SQL_INVALID_HANDLE 或 局部_实际长度 ＝ -1)
        返回 (0)
    .如果真结束
    参数_错误状态 ＝ 参数_错误状态 ＋ state
    参数_错误描述 ＝ 参数_错误描述 ＋ 取文本左边 (message, 局部_实际长度)
.循环判断尾 (ret ≠ #SQL_NO_DATA)
返回 (error)
.子程序 取查询信息, 文本型
.参数 参_查询参数, 文本型
.局部变量 ret, 整数型
.局部变量 szConnStrOut, 文本型
.局部变量 sConnStrOut, 整数型
.如果真 (m_hDBC ＝ 0)
    ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC)  ' 申请连接句柄
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (“”)
    .如果真结束
.如果真结束
szConnStrOut ＝ 取空白文本 (2048)
SQLBrowseConnect (m_hDBC, 参_查询参数, #SQL_NTS, szConnStrOut, 2048, sConnStrOut)
返回 (删首尾空 (szConnStrOut))
.子程序 枚举SQL服务器, 整数型, 公开, 枚举局域网内中SQL服务器，成功返回服务器名称数量，失败返回0
.参数 参_服务列表, 文本型, 数组, 变量储存返回值
.局部变量 szConnStrOut, 文本型
.局部变量 strText, 文本型
szConnStrOut ＝ 取查询信息 (“Driver={SQL Server}”)
.如果真 (szConnStrOut ＝ “”)
    返回 (0)
.如果真结束
清除数组 (参_服务列表)
.如果真 (寻找文本 (szConnStrOut, “SERVER:”, , 假) ＝ -1)
    返回 (0)
.如果真结束
strText ＝ 文本_取出中间文本 (szConnStrOut, “={”, “}”)
参_服务列表 ＝ 分割文本 (strText, “,”, )
返回 (取数组成员数 (参_服务列表))
.子程序 枚举SQL数据库, 整数型, 公开, 枚举指定SQL服务器的数据库，成功返回数据列表数量，失败返回0
.参数 参_服务器, 文本型
.参数 参_登录用户名, 文本型
.参数 参_登录密码, 文本型
.参数 参_数据库列表, 文本型, 数组, 变量储存返回值
.局部变量 szConnStrOut, 文本型
.局部变量 strText, 文本型
szConnStrOut ＝ 取查询信息 (“Driver={SQL Server};SERVER=” ＋ 参_服务器 ＋ “;UID=” ＋ 参_登录用户名 ＋ “;PWD=” ＋ 参_登录密码)
.如果真 (szConnStrOut ＝ “”)
    返回 (0)
.如果真结束
清除数组 (参_数据库列表)
.如果真 (寻找文本 (szConnStrOut, “DATABASE”, , 假) ＝ -1)
    返回 (0)
.如果真结束
strText ＝ 文本_取出中间文本 (szConnStrOut, “={”, “}”)
参_数据库列表 ＝ 分割文本 (strText, “,”, )
返回 (取数组成员数 (参_数据库列表))
.程序集 类_APIHOOK, , 公开
.程序集变量 集_HOOK, 数据_APIHOOK类, , "0"
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
清除数组 (集_HOOK)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
卸载全部 ()
.子程序 安装, 逻辑型, 公开
.参数 动态链接库名, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
.参数 API命令名, 文本型, , 要拦截的函数名，如：FindWindowA
.参数 现子程序指针, 子程序指针, , 回调子程序
.局部变量 局_模块句柄, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_成员数, 整数型
.局部变量 局_HOOK, 数据_APIHOOK类
动态链接库名 ＝ 选择 (取文本右边 (到小写 (动态链接库名), 3) ≠ “dll”, 动态链接库名 ＋ “.dll”, 动态链接库名)
局_成员数 ＝ 取数组成员数 (集_HOOK)
.计次循环首 (局_成员数, 局_计次)  ' 判断是否已经HOOKAPI过了
    .如果真 (到小写 (集_HOOK [局_计次].API命令名) ＝ 到小写 (动态链接库名 ＋ API命令名))
        继续 (动态链接库名, API命令名)
        返回 (真)
    .如果真结束
.计次循环尾 ()
' ========================================
局_模块句柄 ＝ GetModuleHandleA (动态链接库名)  ' 取模块句柄
.如果真 (局_模块句柄 ＝ 0)
    局_模块句柄 ＝ LoadLibraryA (动态链接库名)  ' 装载DLL
.如果真结束
.如果真 (局_模块句柄 ＝ 0)
    返回 (假)
.如果真结束
局_HOOK.命令标识 ＝ 到小写 (动态链接库名 ＋ API命令名)
局_HOOK.原函数地址 ＝ GetProcAddress (局_模块句柄, API命令名)
局_HOOK.原字节 ＝ 指针到字节集 (局_HOOK.原函数地址, 8)
局_HOOK.新函数地址 ＝ 到字节集 (到整数 (现子程序指针))
.如果 (修改虚拟保护 (真, 局_HOOK))
    局_HOOK.继续暂停 ＝ “继续”
    加入成员 (集_HOOK, 局_HOOK)
    返回 (真)
.否则
    返回 (假)
.如果结束
返回 (真)
.子程序 修改虚拟保护, 逻辑型, , 成功返回真，失败返回假
.参数 参_是否HOOK, 逻辑型, , 否则还原
.参数 参_HOOK, 数据_APIHOOK类, 参考
.局部变量 局_原地址, 字节集
.局部变量 虚拟信息, 精易_内存属性
.局部变量 结果, 逻辑型
.局部变量 局_保护值, 整数型
.如果真 (参_HOOK.原函数地址 ＝ 0)
    返回 (假)
.如果真结束
.如果 (参_是否HOOK)
    局_保护值 ＝ VirtualQueryEx (-1, 参_HOOK.原函数地址, 虚拟信息, 28)  ' 取内存保护值属性
    .如果真 (局_保护值 ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (VirtualProtectEx (-1, 虚拟信息.区域地址, 8, 64, 虚拟信息.当前属性) ＝ 0)  ' 修改内存属性'
        返回 (假)
    .如果真结束
    参_HOOK.原保护值 ＝ 虚拟信息.当前属性
    参_HOOK.区域地址 ＝ 虚拟信息.区域地址
    局_原地址 ＝ { 184 } ＋ 参_HOOK.新函数地址 ＋ { 255, 224 }
    结果 ＝ WriteProcessMemory_字节集 (-1, 参_HOOK.原函数地址, 局_原地址, 取字节集长度 (局_原地址), 0)
.否则
    结果 ＝ WriteProcessMemory_字节集 (-1, 参_HOOK.原函数地址, 参_HOOK.原字节, 取字节集长度 (参_HOOK.原字节), 0)
.如果结束
返回 (结果)
.子程序 继续, 逻辑型, 公开, 继续拦截指定的函数名，成功返回真，失败返回假。
.参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
.参数 函数名, 文本型, , 要继续HOOK的函数名 如：FindWindowA
.局部变量 局_计次, 整数型
动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
.计次循环首 (取数组成员数 (集_HOOK), 局_计次)  ' 判断是否已经HOOKAPI过了
    .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
        .如果真 (集_HOOK [局_计次].继续暂停 ＝ “继续”)
            返回 (真)
        .如果真结束
        修改虚拟保护 (真, 集_HOOK [局_计次])
        集_HOOK [局_计次].继续暂停 ＝ “继续”
        返回 (真)
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 是否已安装, 逻辑型, 公开, 判断此HOOK函数是否已安装，真=已安装，假=未安装。
.参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
.参数 函数名, 文本型, , 要暂停HOOK的函数名 如：FindWindowA
.局部变量 局_计次, 整数型
动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
.计次循环首 (取数组成员数 (集_HOOK), 局_计次)  ' 判断是否已经HOOKAPI过了3
    .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
        返回 (真)
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 暂停, 逻辑型, 公开, 暂停拦截指定的函数名，成功返回真，失败返回假。
.参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
.参数 函数名, 文本型, , 要暂停HOOK的函数名 如：FindWindowA
.局部变量 局_计次, 整数型
动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
.计次循环首 (取数组成员数 (集_HOOK), 局_计次)  ' 判断是否已经HOOKAPI过了
    .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
        .如果真 (集_HOOK [局_计次].继续暂停 ＝ “暂停”)
            返回 (真)
        .如果真结束
        修改虚拟保护 (假, 集_HOOK [局_计次])
        集_HOOK [局_计次].继续暂停 ＝ “暂停”
        返回 (真)
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 取地址, 整数型, 公开, 取指定函数名原始数据地址，回调原指针时使用。成功返回地址，失败返回-1。
.参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
.参数 函数名, 文本型, , 要取出地址的函数名 如：FindWindowA
.局部变量 局_成员数, 整数型
.局部变量 局_计次, 整数型
动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
局_成员数 ＝ 取数组成员数 (集_HOOK)
.计次循环首 (局_成员数, 局_计次)  ' 判断是否已经HOOKAPI过了
    .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
        返回 (集_HOOK [局_计次].区域地址)
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (-1)
.子程序 卸载, 逻辑型, 公开, 卸载指定的函数名的APIHOOK，成功返回真，失败返回假。
.参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
.参数 函数名, 文本型, , 要卸载HOOK的函数名 如：FindWindowA
.局部变量 局_计次, 整数型
动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
.计次循环首 (取数组成员数 (集_HOOK), 局_计次)  ' 判断是否已经HOOKAPI过了
    .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
        WriteProcessMemory_字节集 (-1, 集_HOOK [局_计次].原函数地址, 集_HOOK [局_计次].原字节, 取字节集长度 (集_HOOK [局_计次].原字节), 0)
        VirtualProtectEx (-1, 集_HOOK [局_计次].区域地址, 8, 32, 集_HOOK [局_计次].原保护值)  ' 改回只读模式
        删除成员 (集_HOOK, 局_计次, 1)
        返回 (真)
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
返回 (假)
.子程序 卸载全部, , 公开, 卸载全部的HOOK，程序关闭时，本命令会被自动调用
.局部变量 局_计次, 整数型
.' 计次循环首 (取数组成员数 (集_HOOK), 局_计次)  ' 判断是否已经HOOKAPI过了
    ' WriteProcessMemory_字节集 (-1, 集_HOOK [局_计次].原函数地址, 集_HOOK [局_计次].原字节, 取字节集长度 (集_HOOK [局_计次].原字节), 0)
    ' VirtualProtectEx (-1, 集_HOOK [局_计次].区域地址, 8, 32, 集_HOOK [局_计次].原保护值)  ' 改回只读模式
    ' 删除成员 (集_HOOK, 局_计次, 1)
.' 计次循环尾 ()
.变量循环首 (取数组成员数 (集_HOOK), 1, -1, 局_计次)
    WriteProcessMemory_字节集 (-1, 集_HOOK [局_计次].原函数地址, 集_HOOK [局_计次].原字节, 取字节集长度 (集_HOOK [局_计次].原字节), 0)
    VirtualProtectEx (-1, 集_HOOK [局_计次].区域地址, 8, 32, 集_HOOK [局_计次].原保护值)  ' 改回只读模式
    删除成员 (集_HOOK, 局_计次, 1)
.变量循环尾 ()
.程序集 汇编类, , 公开, 注：本来源于网络，只是整合到精易模块，方便大家使用
.程序集变量 汇编代码, 字节集
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 取库程序地址, 整数型, 公开, 取子程序地址，成功返回子程序地址，失败返回0。
.参数 库文件名, 文本型, , 库文件名称
.参数 方法名称, 文本型, , 欲调用的方法的名称
.局部变量 动态库句柄
.局部变量 取得函数, 整数型
动态库句柄 ＝ LoadLibraryA (库文件名)  ' 动态加载dll
取得函数 ＝ GetProcAddress1 (动态库句柄, 方法名称)  ' 获取我们规定的接口函数
.如果真 (取得函数 ＝ 0)  ' 为0表示不存在我们规定的接口，返回
    FreeLibrary (动态库句柄)  ' 释放加载的文件
    返回 (0)
.如果真结束
FreeLibrary (动态库句柄)  ' 释放加载的文件
返回 (取得函数)
.子程序 到子程序指针, 子程序指针, 公开, 将整数型指针转换成易自己的子程序指针类型。
.参数 整数指针, 整数型
返回 (lstrcpynA_指针 (整数指针, 整数指针, 0))
.子程序 转为十六进制, 文本型, 公开, 字节集转到十六进制文本。
.参数 字节集, 字节集, , 用于转换的字节集
.局部变量 返回值, 文本型
.局部变量 i, 整数型
.计次循环首 (取字节集长度 (字节集), i)
    .判断开始 (字节集 [i] ＜ 16)
        返回值 ＝ 返回值 ＋ “ 0” ＋ 取十六进制文本 (字节集 [i])
    .默认
        返回值 ＝ 返回值 ＋ “ ” ＋ 取十六进制文本 (字节集 [i])
    .判断结束
.计次循环尾 ()
返回 (删首空 (返回值))
.子程序 置入汇编代码, , 公开, 置入汇编代码
.参数 代码内容, 字节集, 可空
.参数 追加模式, 逻辑型, 可空, 可为空，默认为追加模式。
.如果 (是否为空 (追加模式) 或 追加模式)
    汇编代码 ＝ 汇编代码 ＋ 代码内容
.否则
    汇编代码 ＝ 代码内容
.如果结束
.子程序 取出汇编代码, 字节集, 公开, 取出汇编代码：重要说明：如未执行->运行汇编代码 时，请不进行清空汇编代码
.参数 是否清空, 逻辑型, 可空, 取出时是否进行清空
.局部变量 汇编码, 字节集
.如果真 (是否为空 (是否清空))
    是否清空 ＝ 假
.如果真结束
.如果 (是否清空)
    汇编码 ＝ 汇编代码
    汇编代码 ＝ {  }
.否则
    汇编码 ＝ 汇编代码
.如果结束
返回 (汇编码)
.子程序 运行汇编代码, 整数型, 公开, 执行->运行汇编代码 时，将清空汇编代码
.参数 参数个数, 整数型, 可空
.参数 参数数组, 整数型, 可空 数组
.局部变量 首地址, 整数型
.局部变量 指令长度, 整数型
.局部变量 返回值, 整数型
.局部变量 代码, 字节集
.局部变量 bin, 字节集
代码 ＝ 取出汇编代码 (真)
指令长度 ＝ 取字节集长度 (代码)
首地址 ＝ GlobalAlloc (0, 指令长度)
写到内存 (代码, 首地址, )
bin ＝ { 85, 139, 236, 86, 139, 117, 16, 141, 78, 255, 133, 201, 124, 21, 139, 69, 12, 141, 4, 136, 65, 139, 16, 137, 85, 16, 255, 117, 16, 131, 232, 4, 73, 117, 242, 255, 85, 8, 137, 69, 12, 139, 69, 20, 133, 192, 116, 13, 141, 4, 181, 0, 0, 0, 0, 137, 69, 16, 3, 101, 16, 139, 69, 12, 94, 93, 194, 16, 0 }
返回值 ＝ CallWindowProcA (取指针_字节集型 (bin), 首地址, 取数据_通用型_数组 (参数数组), 参数个数, 0)
GlobalFree (首地址)
返回 (返回值)
.子程序 转到十六进制, 文本型, 公开
返回 (转为十六进制 (取出汇编代码 ()))
.子程序 取指定字节集, 字节集
.参数 指令参数, 整数型
返回 (取字节集左边 (到字节集 (指令参数), 1))
.子程序 ADD_EAX_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 1, 208 }
.子程序 MOV_EAX_PTR, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (常数)
.子程序 PUSH_参常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 104 } ＋ 到字节集 (常数)
.子程序 POP_ECX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 89 }
.子程序 POP_EBP, , 公开
汇编代码 ＝ 汇编代码 ＋ { 93 }
.子程序 JMP_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 255, 224 }
.子程序 CALL_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 255, 208 }
.子程序 RET_参数数, , 公开
.参数 参数数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 194 } ＋ 取字节集左边 (到字节集 (到整数 (1 × 4)), 1) ＋ { 0 }
.子程序 MOV_EDX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 208 }
.子程序 MOV_EBP_ESP, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 236 }
.子程序 MOV_EAX_PTR_EBP加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 69 } ＋ 取字节集左边 (到字节集 (字节), 1)
.子程序 ADD_EAX_常数, , 公开, 加法指令
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 5 } ＋ 到字节集 (常数)
.子程序 SUB_EAX_常数, , 公开, 减法指令
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 45 } ＋ 到字节集 (常数)
.子程序 IMUL_EAX_常数, , 公开, 乘法指令
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 105, 192 } ＋ 到字节集 (常数)
.子程序 IDIV_ECX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 247, 249 }
.子程序 CMP_PTR_常数, , 公开
.参数 地址, 整数型
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 131, 61 } ＋ 到字节集 (地址) ＋ 取字节集左边 (到字节集 (常数), 1)
.子程序 SHL_EAX_常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 193, 224 } ＋ 取字节集左边 (到字节集 (常数), 1)
.子程序 SHR_EAX_常数, , 公开, 右移
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 193, 232 } ＋ 取字节集左边 (到字节集 (常数), 1)
.子程序 PUSHAD, , 公开, 对应指令PUSHAD
汇编代码 ＝ 汇编代码 ＋ { 96 }
.子程序 PUSH_EAX, , 公开, 对应指令PUSH EAX
汇编代码 ＝ 汇编代码 ＋ { 80 }
.子程序 POP_EAX, , 公开, 对应指令POP EAX
汇编代码 ＝ 汇编代码 ＋ { 88 }
.子程序 POPAD, , 公开, 对应指令POPAD
汇编代码 ＝ 汇编代码 ＋ { 97 }
.子程序 PUSH_EBX, , 公开, 对应指令PUSH_EBX
汇编代码 ＝ 汇编代码 ＋ { 83 }
.子程序 PUSH_ECX, , 公开, 对应指令PUSH_ECX
汇编代码 ＝ 汇编代码 ＋ { 81 }
.子程序 PUSH_EDX, , 公开, 对应指令PUSH_EDX
汇编代码 ＝ 汇编代码 ＋ { 82 }
.子程序 PUSH_ESI, , 公开, 对应指令PUSH_ESI
汇编代码 ＝ 汇编代码 ＋ { 86 }
.子程序 PUSH_EDI, , 公开, 对应指令PUSH_EDI
汇编代码 ＝ 汇编代码 ＋ { 87 }
.子程序 PUSH_EBP, , 公开, 对应指令PUSH_EBP
汇编代码 ＝ 汇编代码 ＋ { 85 }
.子程序 PUSH_ESP, , 公开, 对应指令PUSH_ESP
汇编代码 ＝ 汇编代码 ＋ { 84 }
.子程序 PUSH_常数, , 公开, 对应指令PUSH_常数
汇编代码 ＝ 汇编代码 ＋ { 106 }
.子程序 MOV_EAX_常数, , 公开, MOV_EAX_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 184 } ＋ 到字节集 (参数)
.子程序 MOV_EBX_常数, , 公开, MOV_EBX_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 187 } ＋ 到字节集 (参数)
.子程序 MOV_ECX_常数, , 公开, MOV_ECX_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 185 } ＋ 到字节集 (参数)
.子程序 MOV_EDX_常数, , 公开, MOV_EDX_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 186 } ＋ 到字节集 (参数)
.子程序 MOV_ESI_常数, , 公开, MOV_ESI_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 190 } ＋ 到字节集 (参数)
.子程序 MOV_EDI_常数, , 公开, MOV_EDI_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 191 } ＋ 到字节集 (参数)
.子程序 MOV_EBP_常数, , 公开, MOV_EBP_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 189 } ＋ 到字节集 (参数)
.子程序 MOV_ESP_常数, , 公开, MOV_ESP_常数
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 188 } ＋ 到字节集 (参数)
.子程序 MOV_EAX_PRT, , 公开, 对应指令MOV EAX []
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (参数)
.子程序 MOV_EBX_PRT, , 公开, 对应指令MOV EBX []
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 29 } ＋ 到字节集 (参数)
.子程序 MOV_ECX_PRT, , 公开, 对应指令MOV ECX []
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 139, 13 } ＋ 到字节集 (参数)
.子程序 MOV_EDX_PRT, , 公开, 对应指令MOV EDX []
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 139, 21 } ＋ 到字节集 (参数)
.子程序 MOV_ESI_PRT, , 公开, 对应指令MOV ESI,[]
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 139, 53 } ＋ 到字节集 (参数)
.子程序 MOV_EDI_PRT, , 公开, 对应指令MOV EDI,[]
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 139, 61 } ＋ 到字节集 (参数)
.子程序 MOV_EBP_PRT, , 公开, 对应指令MOV EBP,[]
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 139, 45 } ＋ 到字节集 (参数)
.子程序 MOV_ESP_PRT, , 公开, 对应指令MOV ESP,[]
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 139, 37 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_EAX, , 公开, 对应指令MOV [],EAX
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 5 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_EBX, , 公开, 对应指令MOV [],EBX
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 29 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_ECX, , 公开, 对应指令MOV [],ECX
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 13 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_EDX, , 公开, 对应指令MOV [],EDX
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 21 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_ESI, , 公开, 对应指令MOV [],ESI
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 53 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_EDI, , 公开, 对应指令MOV [],EDI
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 61 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_EBP, , 公开, 对应指令MOV [],EBP
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 45 } ＋ 到字节集 (参数)
.子程序 MOV_PRT_ESP, , 公开, 对应指令MOV [],ESP
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 137, 37 } ＋ 到字节集 (参数)
.子程序 JMP, , 公开, 对应指令JMP
.参数 参数
汇编代码 ＝ 汇编代码 ＋ { 233, 92, 199, 191, 255 } ＋ 到字节集 (参数)
.子程序 CALL_EBX, , 公开, CALL_EBX
汇编代码 ＝ 汇编代码 ＋ { 255, 211 }
.子程序 CALL_, , , CALL 地址 未成功---------原
.参数 偏移地址
汇编代码 ＝ 汇编代码 ＋ { 232, 92, 199, 191, 255 } ＋ 到字节集 (偏移地址)
.子程序 CALL, , 公开, CALL 地址
.参数 偏移地址
汇编代码 ＝ 汇编代码 ＋ { 232 } ＋ 到字节集 (偏移地址)
.子程序 RET, , 公开, RET
汇编代码 ＝ 汇编代码 ＋ { 195 }
.子程序 ADD_EBX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 3, 216 }
.子程序 ADD_EBX_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 3, 29 } ＋ 到字节集 (地址)
.子程序 ADD_EBX_字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 131, 195 } ＋ 取指定字节集 (字节)
.子程序 ADD_ECX_常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 129, 193 } ＋ 到字节集 (常数)
.子程序 ADD_EDX_字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 131, 194 } ＋ 取指定字节集 (字节)
.子程序 ADD_ESI_常数, , 公开, 加法指令
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 129, 198 } ＋ 到字节集 (常数)
.子程序 ADD_ESP_字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 131, 196 } ＋ 取指定字节集 (字节)
.子程序 AND_EAX_整数, , 公开, 位与运算
.参数 数值, 整数型
汇编代码 ＝ 汇编代码 ＋ { 37 } ＋ 到字节集 (数值)
.子程序 CALL_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 255, 21 } ＋ 到字节集 (地址)
.子程序 CMP_EAX_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 59, 194 }
.子程序 CMP_EAX_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 59, 5 } ＋ 到字节集 (地址)
.子程序 CMP_EAX_常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 61 } ＋ 到字节集 (常数)
.子程序 DEC_EAX, , 公开, 递减1指令
汇编代码 ＝ 汇编代码 ＋ { 72 }
.子程序 DEC_EBX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 75 }
.子程序 DEC_ECX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 73 }
.子程序 DEC_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 74 }
.子程序 IDIV_EBX, , 公开, 除法指令
汇编代码 ＝ 汇编代码 ＋ { 247, 251 }
.子程序 IMUL_EAX_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 15, 175, 194 }
.子程序 IN_AL_DX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 236 }
.子程序 IN_AL_端口号, , 公开
.参数 端口号, 整数型
汇编代码 ＝ 汇编代码 ＋ { 228 } ＋ 取指定字节集 (端口号)
.子程序 IN_AX_DX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 237 }
.子程序 IN_AX_端口号, , 公开
.参数 端口号, 整数型
汇编代码 ＝ 汇编代码 ＋ { 229 } ＋ 取指定字节集 (端口号)
.子程序 INC_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 64 }
.子程序 INC_ECX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 65 }
.子程序 INC_EDI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 71 }
.子程序 INC_ESI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 70 }
.子程序 INC_PTR, , 公开, 递增1指令
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 255, 5 } ＋ 到字节集 (地址)
.子程序 INC_PTR_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 255, 0 }
.子程序 INC_PTR_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 255, 2 }
.子程序 JE_整数, 整数型, , 等于则转移指令
汇编代码 ＝ 汇编代码 ＋ { 15, 132, 0, 0, 0, 0 }
返回 (0)
.子程序 JE_字节, 整数型, , 等于则转移指令
汇编代码 ＝ 汇编代码 ＋ { 116, 0 }
返回 (0)
.子程序 JG_整数, 整数型, , 大于则转移
汇编代码 ＝ 汇编代码 ＋ { 15, 143, 0, 0, 0, 0 }
返回 (0)
.子程序 JG_字节, 整数型, , 大于则转移
汇编代码 ＝ 汇编代码 ＋ { 127, 0 }
返回 (0)
.子程序 JGE_字节, 整数型, , 大于或等于则转移
汇编代码 ＝ 汇编代码 ＋ { 125, 0 }
返回 (0)
.子程序 JL_字节, 整数型, , 小于则转移
汇编代码 ＝ 汇编代码 ＋ { 124, 0 }
返回 (0)
.子程序 JLE_字节, 整数型, , 小于或等于则转移
汇编代码 ＝ 汇编代码 ＋ { 126, 0 }
返回 (0)
.子程序 JMP_字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 235, 0 }
返回 (0)
.子程序 JNE_字节, 整数型, , 不等于则转移指令
汇编代码 ＝ 汇编代码 ＋ { 117, 0 }
返回 (0)
.子程序 LEA_EAX_PTR_EAX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 141, 64 } ＋ 取指定字节集 (字节)
.子程序 LEA_ECX_PTR_EAX加整数, , 公开
.参数 数值, 整数型
汇编代码 ＝ 汇编代码 ＋ { 141, 136 } ＋ 到字节集 (数值)
.子程序 LEA_ECX_PTR_ESI加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 141, 78 } ＋ 取指定字节集 (字节)
.子程序 LEA_ECX_PTR_ESP加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 141, 76, 36 } ＋ 取指定字节集 (字节)
.子程序 LEAVE, , 公开
汇编代码 ＝ 汇编代码 ＋ { 201 }
.子程序 LOOP, , , 以ECX计次循环指令,ECX不为零时循环,每次循环ECX递减1
.参数 编号, 整数型
.子程序 LOOPNZ, , , 不等于则循环,ECX不为零且标志Z=0时循环
.参数 编号, 整数型
.子程序 LOOPZ, , , 等于则循环,ECX不为零且标志Z=1时循环.
.参数 编号, 整数型
汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (编号)
.子程序 MOV_EAX_EBX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 195 }
.子程序 MOV_EAX_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 194 }
.子程序 MOV_EAX_ESI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 198 }
.子程序 MOV_EAX_PTR_DS整数, , 公开, 等于MOV_EAX_PTR
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (地址)
.子程序 MOV_EAX_PTR_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 0 }
.子程序 MOV_EAX_PTR_EAX加整数, , 公开
.参数 数值, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 128 } ＋ 到字节集 (数值)
.子程序 MOV_EAX_PTR_EAX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 64 } ＋ 取指定字节集 (字节)
.子程序 MOV_EAX_PTR_EBX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 3 }
.子程序 MOV_EAX_PTR_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 2 }
.子程序 MOV_EAX_PTR_EDX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 66 } ＋ 取指定字节集 (字节)
.子程序 MOV_EAX_PTR_ESP加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 68 } ＋ 取指定字节集 (字节)
.子程序 MOV_EBX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 216 }
.子程序 MOV_EBX_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 218 }
.子程序 MOV_EBX_PTR_EAX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 88 } ＋ 取指定字节集 (字节)
.子程序 MOV_ECX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 200 }
.子程序 MOV_ECX_EDI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 207 }
.子程序 MOV_ECX_ESI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 206 }
.子程序 MOV_ECX_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 13 } ＋ 到字节集 (地址)
.子程序 MOV_ECX_PTR_EAX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 72 } ＋ 取指定字节集 (字节)
.子程序 MOV_ECX_PTR_EBX加整数, , 公开
.参数 数值, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 139 } ＋ 到字节集 (数值)
.子程序 MOV_ECX_PTR_ECX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 73 } ＋ 取指定字节集 (字节)
.子程序 MOV_ECX_PTR_EDX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 74 } ＋ 取指定字节集 (字节)
.子程序 MOV_EDI_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 248 }
.子程序 MOV_EDX_PTR_ECX加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 81 } ＋ 取指定字节集 (字节)
.子程序 MOV_EDX_PTR_EDI加整数, , 公开
.参数 数值, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 151 } ＋ 到字节集 (数值)
.子程序 MOV_EDX_PTR_EDI加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 87 } ＋ 取指定字节集 (字节)
.子程序 MOV_ESI_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 240 }
.子程序 MOV_ESI_EBX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 243 }
.子程序 MOV_ESI_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 53 } ＋ 到字节集 (地址)
.子程序 MOV_ESI_PTR_EBP加字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 139, 117 } ＋ 取指定字节集 (字节)
.子程序 MOV_ESP_EBP, , 公开
汇编代码 ＝ 汇编代码 ＋ { 139, 229 }
.子程序 MOV_PTR_EAX, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 163 } ＋ 到字节集 (地址)
.子程序 MOV_PTR_EBX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 137, 3 }
.子程序 MOV_PTR_ECX加字节_EAX, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 231 } ＋ 取指定字节集 (字节)
.子程序 MOV_PTR_EDX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 137, 2 }
.子程序 MOV_PTR_常数, , 公开
.参数 地址, 整数型
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 199, 5 } ＋ 到字节集 (地址) ＋ 到字节集 (常数)
.子程序 NOP, , 公开, 空指令
汇编代码 ＝ 汇编代码 ＋ { 144 }
.子程序 NOT_EAX, , 公开, 取反指令
汇编代码 ＝ 汇编代码 ＋ { 247, 208 }
.子程序 OUT_DX_AL, , 公开
汇编代码 ＝ 汇编代码 ＋ { 238 }
.子程序 OUT_端口号_AX, , 公开
.参数 端口号, 整数型
汇编代码 ＝ 汇编代码 ＋ { 231 } ＋ 取指定字节集 (端口号)
.子程序 POP_EBX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 91 }
.子程序 POP_EDX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 90 }
.子程序 POP_ESI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 94 }
.子程序 PUSH_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 43, 5 } ＋ 到字节集 (地址)
.子程序 SHL_EBX_常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 193, 227 } ＋ 取指定字节集 (常数)
.子程序 SHR_EBX_常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 193, 235 } ＋ 取指定字节集 (常数)
.子程序 SUB_EAX_PTR, , 公开
.参数 地址, 整数型
汇编代码 ＝ 汇编代码 ＋ { 43, 5 } ＋ 到字节集 (地址)
.子程序 SUB_EBX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 43, 216 }
.子程序 SUB_EDX_字节, , 公开
.参数 字节, 整数型
汇编代码 ＝ 汇编代码 ＋ { 131, 234 } ＋ 取指定字节集 (字节)
.子程序 TEST_EAX_EAX, , 公开
汇编代码 ＝ 汇编代码 ＋ { 133, 192 }
.子程序 TEST_EAX_常数, , 公开
.参数 常数, 整数型
汇编代码 ＝ 汇编代码 ＋ { 169 } ＋ 到字节集 (常数)
.子程序 XOR_EAX_EBX, , 公开, 异或运算
汇编代码 ＝ 汇编代码 ＋ { 51, 195 }
.子程序 XOR_EDI_EDI, , 公开
汇编代码 ＝ 汇编代码 ＋ { 51, 255 }
.程序集 类_HOOK_Send, , 公开
.程序集变量 集_函数地址, 整数型
.程序集变量 集_原保护值, 整数型
.程序集变量 集_原字节, 字节集
.程序集变量 集_原地址, 整数型
.程序集变量 集_操作句柄, 整数型
.程序集变量 集_已经提升, 逻辑型
.程序集变量 集_新字节, 字节集
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 安装, 逻辑型, , 安装APIHOOK
.参数 参_动态链接库路径, 文本型, , 欲截获的函数名所在动态链接库的路径
.参数 参_函数名, 文本型, , 欲截获的函数名
.参数 参_新函数地址, 整数型, , 回调子程序指针地址.可以用 到整数(子程序指针) 获得
.局部变量 局_模块句柄, 整数型
.如果真 (集_函数地址 ≠ 0)
    返回 (真)
.如果真结束
局_模块句柄 ＝ GetModuleHandleA (参_动态链接库路径)
.如果真 (局_模块句柄 ＝ 0)
    局_模块句柄 ＝ LoadLibraryA (参_动态链接库路径)
.如果真结束
.如果真 (局_模块句柄 ＝ 0)
    返回 (假)
.如果真结束
集_函数地址 ＝ GetProcAddress (局_模块句柄, 参_函数名)  ' 获取API函数地址
.如果真 (集_函数地址 ＝ 0)
    返回 (假)
.如果真结束
.如果真 (VirtualProtect (集_函数地址, 5, #PAGE_EXECUTE_READWRITE, 集_原保护值) ＝ 假)
    返回 (假)
.如果真结束
集_原字节 ＝ 指针到字节集 (集_函数地址, 5)  ' 保存API入口前5个字节
集_新字节 ＝ { 233 } ＋ 到字节集 (到整数 (参_新函数地址 － (集_函数地址 ＋ 5)))
写到内存 (集_新字节, 集_函数地址, 5)  ' 修改API入口前5字节
集_原字节 ＝ 集_原字节 ＋ { 233, 0, 0, 0, 0 }
集_原地址 ＝ lstrcpynA_Bin (集_原字节, 集_原字节, 0)
写到内存 (到整数 (集_函数地址 ＋ 5 － (集_原地址 ＋ 10)), 集_原地址 ＋ 6, 4)
FreeLibrary (局_模块句柄)
返回 (真)
.子程序 安装send, 逻辑型, 公开, 安装send     
.参数 新函数地址, 子程序指针, , 回调子程序指针  该子程序有三个整型参数与一个整型返回值,封包接口(套接字,数据指针,长度指针) 返回 0=放行,-1=拦截
返回 (安装 (“ws2_32.dll”, “send”, 到整数 (新函数地址)))
.子程序 继续send, , 公开, 取消暂停,继续进行拦截send
写到内存 (集_新字节, 集_函数地址, 5)
.子程序 暂停send, , 公开, 暂停现在的拦截send
写到内存 (集_原字节, 集_函数地址, 5)
.子程序 发送send, 整数型, 公开
.参数 参_套接字, 整数型
.参数 参_数据地址, 整数型
.参数 参_数据长度, 整数型
返回 (send (参_套接字, 参_数据地址, 参_数据长度, 0))
.子程序 取地址, 整数型, 公开, 取原始数据地址,回调原指针时使用
返回 (集_原地址)
.子程序 卸载send, 逻辑型, 公开, 卸载send (本命令会在类变量被销毁时自动被调用)
.局部变量 temp, 整数型
.如果真 (集_函数地址 ＝ 0)
    返回 (假)
.如果真结束
写到内存 (集_原字节, 集_函数地址, 5)
VirtualProtect (集_函数地址, 5, 集_原保护值, temp)
集_函数地址 ＝ 0
集_原字节 ＝ {  }
集_原地址 ＝ 0
返回 (真)
.程序集 类_HOOK_EX, , 公开
.程序集变量 集_回调地址, 整数型
.程序集变量 集_回调指针, 整数型
.程序集变量 集_回调指针ex, 整数型
.程序集变量 集_原代码, 字节集
.程序集变量 集_原长度, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
' 本类收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14327228
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
卸载 ()
.子程序 安装, 逻辑型, 公开, 将某个地址指向某个新地址，俗称hook。如果hook api 新地址参数必须全部为指针型(即整数型)，否则会有不可预知的错误。    如hook指令(即任意位置，非函数。此情况注意新地址取真实地址，否则状态可能被更改，和堆栈平衡。)，请勿使用静态回调功能。    开启回调：调用方法 回调() 或 回调ex() 即可全静态回调原函数，无需频繁安装与卸载，减少资源浪费CPU消耗。
.参数 参_源地址, 整数型
.参数 参_新地址, 整数型
.参数 参_关闭回调, 逻辑型, 可空, 默认为假，开启静态回调 【非hook函数头部请勿开启。。用于不需要频繁安装与卸载的情况下，如果需要频繁安装与卸载，请关闭。】如果开启可使用方法 回调() 或者 回调ex()  直接回调
.局部变量 局_回调代码, 字节集
.局部变量 局_原代码, 字节集
.局部变量 局_函数代码, 字节集
.局部变量 局_理想长度, 整数型
.局部变量 局_新代码, 字节集
.局部变量 局_回调头部, 字节集
.局部变量 局_参数个数, 整数型
.局部变量 局_回调参数入栈, 字节集
.局部变量 局_回调参数修改, 字节集
.局部变量 i, 整数型
.局部变量 局_回调开栈, 字节集
.局部变量 局_回调保存, 字节集
.局部变量 局_回调计数, 字节集
.局部变量 局_回调源地址, 字节集
.局部变量 局_回调写入加恢复, 字节集
.局部变量 局_返回地址入栈, 字节集
.局部变量 局_函数清栈加返回, 字节集
.如果真 (集_回调地址 ＞ 0)
    返回 (假)
.如果真结束
局_新代码 ＝ { 104 } ＋ 到字节集 (参_新地址) ＋ { 195 }
局_函数代码 ＝ 指针到字节集 (参_源地址, 12)
.如果真 (参_关闭回调)  ' 未开启回调直接修改。
    集_原长度 ＝ 6
    集_回调地址 ＝ 参_源地址 ＋ 6
    集_原代码 ＝ 取字节集左边 (局_函数代码, 6)
    返回 (内存_修改内存 (参_源地址, 局_新代码, 6))
.如果真结束
局_理想长度 ＝ 内存_取指令对其长度 (6, 局_函数代码)
.如果真 (局_理想长度 ＜ 6)
    返回 (假)
.如果真结束
局_原代码 ＝ 取字节集左边 (局_函数代码, 局_理想长度)
局_原代码 ＝ 内存_跳转偏移处理 (局_原代码, 参_源地址)
集_原长度 ＝ 局_理想长度
集_回调地址 ＝ 参_源地址 ＋ 局_理想长度
集_原代码 ＝ 局_原代码
局_回调代码 ＝ { 97, 201, 201 } ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
集_回调指针 ＝ 内存_拷贝字节集 (局_回调代码)
集_回调指针ex ＝ 内存_拷贝字节集 (取空白字节集 (1024))
局_参数个数 ＝ 程序_取参数个数 (参_新地址)
.判断开始 (局_参数个数 ＞ 0)
    局_回调头部 ＝ { 97, 201 }
    局_回调开栈 ＝ { 129, 236 } ＋ 到字节集 (到整数 (局_参数个数 × 4))  ' { 129, 196, 16, 0, 0, 0 }
    局_回调保存 ＝ { 81, 87, 86 }
    局_回调计数 ＝ { 199, 193 } ＋ 到字节集 (局_参数个数)  ' {199,193,4,0,0,0}
    局_回调源地址 ＝ { 141, 188, 36, 12, 0, 0, 0 }  ' { 141, 188, 36, 12, 0, 0, 0 }
    局_回调写入加恢复 ＝ { 141, 181, 8, 0, 0, 0, 243, 165, 94, 95, 89 }
    局_返回地址入栈 ＝ { 104 } ＋ 到字节集 (到整数 (集_回调指针ex ＋ 512))
    局_回调代码 ＝ 局_回调头部 ＋ 局_回调开栈 ＋ 局_回调保存 ＋ 局_回调计数 ＋ 局_回调源地址 ＋ 局_回调写入加恢复 ＋ 局_返回地址入栈 ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
    内存_写到内存 (集_回调指针ex, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
    ' 恢复代码
    局_回调源地址 ＝ { 141, 180, 36, 12, 0, 0, 0 }
    局_回调写入加恢复 ＝ { 141, 189, 8, 0, 0, 0, 243, 165, 94, 95, 89 }
    局_函数清栈加返回 ＝ { 129, 196 } ＋ 到字节集 (到整数 (局_参数个数 × 4)) ＋ { 194, 4, 0 }
    局_回调代码 ＝ 局_回调开栈 ＋ 局_回调保存 ＋ 局_回调计数 ＋ 局_回调源地址 ＋ 局_回调写入加恢复 ＋ 局_函数清栈加返回
    内存_写到内存 (集_回调指针ex ＋ 512, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
.默认
    局_回调头部 ＝ { 97, 201 }
    局_返回地址入栈 ＝ { 104 } ＋ 到字节集 (到整数 (集_回调指针ex ＋ 512))
    局_回调代码 ＝ 局_回调头部 ＋ 局_返回地址入栈 ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
    内存_写到内存 (集_回调指针ex, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
    ' 返回代码
    局_回调代码 ＝ { 194, 4, 0 }
    内存_写到内存 (集_回调指针ex ＋ 512, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
.判断结束
返回 (内存_修改内存 (参_源地址, 局_新代码, 6))
' 调用前：
' sub esp,10
' push ecx
' push edi
' push esi
' mov ecx,4
' lea edi,[esp+0xc]
' lea esi,[ebp+8]
' rep movsd
' pop esi
' pop edi
' pop ecx
' push 0
' 调用后:
' sub esp,10
' push ecx
' push edi
' push esi
' mov ecx,4
' lea esi,[esp+0xc]
' lea edi,[ebp+8]
' rep movsd
' pop esi
' pop edi
' pop ecx
' add esp,10
' retn
.子程序 卸载, , 公开, 对象被销毁前自动调用,无特殊情况无需使用。
.如果真 (集_回调地址 ＞ 0)
    内存_修改内存 (集_回调地址 － 集_原长度, 集_原代码, 6)
    集_回调地址 ＝ 0
    集_回调指针 ＝ 0
    集_原代码 ＝ {  }
    集_原长度 ＝ 0
.如果真结束
.子程序 回调, , 公开, 【静态回掉，需在安装时开启了回调功能。仅适用于函数hook】使用该方法后 将忽略该调用该方法处往后的一切代码 包括返回值。  如果对返回值和参数有要求可使用 回调ex()
置入代码 ({ 96 })
到整数 (集_回调指针)
置入代码 ({ 80, 195 })
.子程序 回调ex, 整数型, 公开, 【静态回调，需在安装时开启了回调功能。仅适用于函数hook】使用该方法后，返回值为原函数返回值，如原函数返回的非整数型，那么此返回值可能是一个指针。如原函数会改动参数，那么改动后的参数便是函数内的参数，直接读取即可。 如果对返回值和参数无要求可使用 回调()
置入代码 ({ 96 })
到整数 (集_回调指针ex)
置入代码 ({ 80, 195 })
返回 (0)
.子程序 取原代码, 字节集, 公开, 返回原始代码。
返回 (集_原代码)
.程序集 集_修复堆内存重释放
.程序集变量 hook, 类_HOOK_EX
.子程序 收录说明
' 本程序集名收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14327228
.子程序 内存_修复堆内存重释放, 逻辑型, 公开, 由于重释放会产生崩溃，因此修复
返回 (hook.安装 (程序_取函数地址_API (“kernel32”, “HeapFree”), 程序_取子程序地址 (&hook), 假))
.子程序 hook, 整数型
.参数 参_堆句柄, 整数型
.参数 参_无用值, 整数型, , 一般为0 锁内存。。
.参数 参_内存指针, 整数型
.局部变量 局_返回值, 整数型
局_返回值 ＝ HeapSize (参_堆句柄, 0, 参_内存指针)
.判断开始 (局_返回值 ＝ -1)
    返回 (1)  ' 返回真，让它以为释放了。。
.默认
    返回 (hook.回调ex ())
.判断结束
.子程序 程序_取函数地址_API, 整数型, 公开, 取得函数地址，api版
.参数 参_模块名, 文本型
.参数 参_命令名, 文本型
返回 (GetProcAddress (LoadLibraryA (参_模块名), 参_命令名))
.子程序 内存_修改内存, 逻辑型, 公开, 非高段地址可使用 内存_写到内存（） 或 内存_写到内存_dw
.参数 参_目的地址, 整数型, , 目的地址的缓冲区长度需大于或等于长度
.参数 参_字节集, 字节集, , 用于写入到目的地址的 数据
.参数 参_长度, 整数型, , 需要写入的长度
.局部变量 局_保护值, 整数型
.局部变量 局_虚拟信息, 精易_内存属性
局_保护值 ＝ VirtualQueryEx (-1, 参_目的地址, 局_虚拟信息, 28)  ' 取内存保护值属性
.如果真 (局_保护值 ＝ 0)
    返回 (假)
.如果真结束
.如果真 (VirtualProtectEx (-1, 局_虚拟信息.区域地址, 6, 64, 局_虚拟信息.当前属性) ＝ 0)  ' 修改内存属性'
    返回 (假)
.如果真结束
内存_写到内存 (参_目的地址, 取指针_字节集型 (参_字节集), 参_长度)
返回 (真)
.子程序 内存_写到内存, , 公开, 高段地址可使用 内存_修改内存（）
.参数 参_目的地址, 整数型, , 目的地址的缓冲区长度需大于或等于长度
.参数 参_源地址, 整数型, , 用于写入到目的地址的 数据的指针
.参数 参_长度, 整数型, , 需要写入的长度
置入代码 ({ 96, 139, 77, 16, 139, 125, 8, 139, 117, 12, 243, 164, 97 })
.子程序 内存_取指令对其长度, 整数型, 公开, 返回大于或等于给定长度的理想值。
.参数 参_预算长度, 整数型
.参数 参_被扫描的字节集, 字节集
.局部变量 局_扫描表, 字节集
.局部变量 局_长度, 整数型
.局部变量 i, 整数型
.局部变量 局_字节, 字节型
.局部变量 局_记录值, 整数型
.局部变量 局_理想长度, 整数型
局_长度 ＝ 取字节集长度 (参_被扫描的字节集)
.如果真 (局_长度 ≤ 参_预算长度)
    返回 (0)
.如果真结束
局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 }  ' 256
局_记录值 ＝ 0
.计次循环首 (局_长度, i)
    局_记录值 ＝ 局_记录值 － 1
    .如果真 (局_记录值 ＞ -1)  ' 跳过下面记录的次数 延长i .  理想长度
        到循环尾 ()
    .如果真结束
    局_字节 ＝ 参_被扫描的字节集 [i]
    局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]  ' 从1开始
    局_理想长度 ＝ i ＋ 局_记录值
    .如果真 (局_理想长度 ≥ 参_预算长度)
        返回 (局_理想长度)
    .如果真结束
.计次循环尾 ()
返回 (0)
.子程序 内存_跳转偏移处理, 字节集, 公开, 返回 偏移call  jmp  转成成绝对call  jmp后的代码集 
.参数 参_字节集, 字节集
.参数 参_函数地址, 整数型, , 函数基址
.局部变量 局_长度, 整数型
.局部变量 局_扫描表, 字节集
.局部变量 局_记录值, 整数型
.局部变量 i, 整数型
.局部变量 局_字节, 字节型
.局部变量 局_返回字节集, 字节集
.局部变量 局_偏移缓冲, 字节集
.局部变量 局_替换缓冲, 字节集
.局部变量 局_绝对地址, 整数型
.局部变量 局_尾部, 字节集
.局部变量 局_替换长度, 整数型
.局部变量 局_替换位置, 整数型
.局部变量 局_替换增加, 整数型
.局部变量 局_绝对跳转代码, 字节集
局_长度 ＝ 取字节集长度 (参_字节集)
局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 }  ' 256
局_返回字节集 ＝ 参_字节集
局_偏移缓冲 ＝ 取空白字节集 (4)
局_记录值 ＝ 0
.计次循环首 (局_长度, i)
    局_记录值 ＝ 局_记录值 － 1
    .如果真 (局_记录值 ＞ -1)  ' 跳过下面记录的次数 延长i .
        到循环尾 ()
    .如果真结束
    局_字节 ＝ 参_字节集 [i]
    局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]  ' 从1开始 记录代码后面跟随的字节宽度 再跳过。
    ' 逆出绝对地址： 偏移call 或 jmp指令位置-1 +5(一个完整偏移call5字节) +偏移(call后面的数) +函数基址 =绝对地址
    .判断开始 (局_字节 ＝ 232)  ' 偏移call 4
        局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
        局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
        局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
        局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
        局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
        局_尾部 ＝ { 255, 208 }
        局_替换长度 ＝ 5
    .判断 (局_字节 ＝ 233)  ' 偏移jmp 4
        局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
        局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
        局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
        局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
        局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
        局_尾部 ＝ { 255, 224 }
        局_替换长度 ＝ 5
    .判断 (局_字节 ＝ 235)  ' 偏移jmp 1
        局_偏移缓冲 ＝ 到字节集 (到整数 (参_字节集 [i ＋ 1] × 1))
        局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 1 ＋ 取字节集数据 (局_偏移缓冲, 3, )
        ' 调试输出 (绝对地址)
        ' 调试输出 (函数地址)
        ' 调试输出 (取字节集数据 (偏移缓冲, 3, ))
        局_尾部 ＝ { 255, 224 }
        局_替换长度 ＝ 2
    .默认
        到循环尾 ()  ' 非call jmp 不处理。
    .判断结束
    局_绝对跳转代码 ＝ { 199, 192 } ＋ 到字节集 (局_绝对地址) ＋ 局_尾部
    局_替换位置 ＝ 局_替换增加 ＋ i
    局_返回字节集 ＝ 字节集替换 (局_返回字节集, 局_替换位置, 局_替换长度, 局_绝对跳转代码)
    局_替换增加 ＝ 局_替换增加 ＋ 取字节集长度 (局_绝对跳转代码) － 局_替换长度  ' ----替换位置偏移
.计次循环尾 ()
返回 (局_返回字节集)
.子程序 内存_拷贝字节集, 整数型, 公开, 拷贝一段字节集并返回内存指针,自动释放（申请内存与写到内存的结合。）
.参数 参_字节集, 字节集, , 需要拷贝的字节集
.局部变量 局_内存地址, 整数型
局_内存地址 ＝ 内存_申请内存 (取字节集长度 (参_字节集))
内存_写到内存 (局_内存地址, 取指针_字节集型 (参_字节集), 取字节集长度 (参_字节集))
返回 (局_内存地址)
.子程序 内存_申请内存, 整数型, 公开, 返回指针  自动释放，属性：不使用连续加填充0
.参数 参_长度, 整数型, , 字节
返回 (HeapAlloc (GetProcessHeap (), 9, 参_长度))
.子程序 程序_取参数个数, 整数型, 公开, 【扫描函数 勿频繁】取得函数参数个数，4字节对齐。特殊情况下，个数不等同于实际个数。仅用于计算栈平衡数值。
.参数 参_被扫描函数指针, 整数型
.局部变量 局_扫描表, 字节集
.局部变量 局_字节集, 字节集
.局部变量 i, 整数型
.局部变量 局_字节, 字节型
.局部变量 局_记录值, 整数型
局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 }  ' 256
局_字节集 ＝ { 0 }
局_记录值 ＝ 0
.判断循环首 (i ＞ -1)
    局_记录值 ＝ 局_记录值 － 1
    .如果真 (局_记录值 ＞ -1)  ' 跳过下面记录的次数 延长i .  理想长度
        i ＝ i ＋ 1
        到循环尾 ()
    .如果真结束
    内存_写到内存 (取指针_字节集型 (局_字节集), 参_被扫描函数指针 ＋ i, 1)
    局_字节 ＝ 局_字节集 [1]
    局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]
    i ＝ i ＋ 1
    .判断开始 (局_字节 ＝ 195)
        返回 (0)
    .默认
        .如果真 (局_字节 ＝ 194)
            局_字节集 ＝ { 0, 0, 0, 0 }
            内存_写到内存 (取指针_字节集型 (局_字节集), 参_被扫描函数指针 ＋ i, 2)
            返回 (取字节集数据 (局_字节集, 3, ) ÷ 4)
        .如果真结束
    .判断结束
.判断循环尾 ()
返回 (0)
.子程序 程序_取子程序地址, 整数型, 公开, 【扫描函数 勿频繁】动态扫描子程序真实地址，勿频繁调用  失败返回0
.参数 参_子程序指针, 子程序指针
.局部变量 局_字节集, 字节集
.局部变量 局_存放数组, 整数型, , "0"
.局部变量 局_伪造数组, 整数型, , "0"
.局部变量 i, 整数型
.局部变量 局_头部字节, 字节集
.局部变量 局_伪造数组2, 整数型, , "0"
局_字节集 ＝ 取子程序字节集代码 (参_子程序指针)
内存_取calljmp地址 (局_字节集, 到整数 (参_子程序指针), 局_存放数组)
.计次循环首 (取数组成员数 (局_存放数组), i)
    局_头部字节 ＝ 指针到字节集 (局_存放数组 [i], 3)
    .如果真 (局_头部字节 ＝ { 85, 139, 236 })
        加入成员 (局_伪造数组, 局_存放数组 [i])
    .如果真结束
.计次循环尾 ()
.如果真 (取数组成员数 (局_伪造数组) ＝ 1)
    返回 (局_伪造数组 [1])
.如果真结束
.计次循环首 (取数组成员数 (局_伪造数组), i)
    局_字节集 ＝ 取子程序字节集代码 (参_子程序指针)
    内存_取calljmp地址 (局_字节集, 到整数 (参_子程序指针), 局_存放数组)
    .计次循环首 (取数组成员数 (局_存放数组), i)
        局_头部字节 ＝ 指针到字节集 (局_存放数组 [i], 3)
        .如果真 (局_头部字节 ＝ { 85, 139, 236 })
            加入成员 (局_伪造数组2, 局_存放数组 [i])
        .如果真结束
    .计次循环尾 ()
.计次循环尾 ()
.如果真 (取数组成员数 (局_伪造数组2) ＝ 1)
    返回 (局_伪造数组2 [1])
.如果真结束
返回 (0)
.子程序 内存_取calljmp地址, 整数型, 公开, 将代码集中的偏移地址 转成绝对地址保存在数组里  并 返回成员数 
.参数 参_字节集, 字节集
.参数 参_函数地址, 整数型, , 函数基址
.参数 参_存放数组, 整数型, 参考 数组, 存放已经转为绝对地址的偏移地址
.局部变量 局_长度, 整数型
.局部变量 局_扫描表, 字节集
.局部变量 局_记录值, 整数型
.局部变量 i, 整数型
.局部变量 局_字节, 字节型
.局部变量 局_返回字节集, 字节集
.局部变量 局_偏移缓冲, 字节集
.局部变量 局_替换缓冲, 字节集
.局部变量 局_绝对地址, 整数型
.局部变量 局_尾部, 字节集
.局部变量 局_替换长度, 整数型
.局部变量 局_替换位置, 整数型
.局部变量 局_替换增加, 整数型
.局部变量 局_绝对跳转代码, 字节集
清除数组 (参_存放数组)
局_长度 ＝ 取字节集长度 (参_字节集)
局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 }  ' 256
局_返回字节集 ＝ 参_字节集
局_偏移缓冲 ＝ 取空白字节集 (4)
局_记录值 ＝ 0
.计次循环首 (局_长度, i)
    局_记录值 ＝ 局_记录值 － 1
    .如果真 (局_记录值 ＞ -1)  ' 跳过下面记录的次数 延长i .
        到循环尾 ()
    .如果真结束
    局_字节 ＝ 参_字节集 [i]
    局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]  ' 从1开始 记录代码后面跟随的字节宽度 再跳过。
    ' 逆出绝对地址： 偏移call 或 jmp指令位置-1 +5(一个完整偏移call5字节) +偏移(call后面的数) +函数基址 =绝对地址
    .判断开始 (局_字节 ＝ 232)  ' 偏移call 4
        局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
        局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
        局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
        局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
        局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
        局_尾部 ＝ { 255, 208 }
        局_替换长度 ＝ 5
    .判断 (局_字节 ＝ 233)  ' 偏移jmp 4
        局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
        局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
        局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
        局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
        局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
        局_尾部 ＝ { 255, 224 }
        局_替换长度 ＝ 5
    .判断 (局_字节 ＝ 235)  ' 偏移jmp 1
        局_偏移缓冲 ＝ 到字节集 (到整数 (参_字节集 [i ＋ 1] × 1))
        局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 1 ＋ 取字节集数据 (局_偏移缓冲, 3, )
        ' 调试输出 (绝对地址)
        ' 调试输出 (函数地址)
        ' 调试输出 (取字节集数据 (偏移缓冲, 3, ))
        局_尾部 ＝ { 255, 224 }
        局_替换长度 ＝ 2
    .默认
        到循环尾 ()  ' 非call jmp 不处理。
    .判断结束
    加入成员 (参_存放数组, 局_绝对地址)
    ' 绝对跳转代码 ＝ { 199, 192 } ＋ 到字节集 (绝对地址) ＋ 尾部
    ' 替换位置 ＝ 替换增加 ＋ i
    ' 返回字节集 ＝ 字节集替换 (返回字节集, 替换位置, 替换长度, 绝对跳转代码)
    ' 替换增加 ＝ 替换增加 ＋ 取字节集长度 (绝对跳转代码) － 替换长度  ' ----替换位置偏移
.计次循环尾 ()
返回 (取数组成员数 (参_存放数组))
.子程序 取子程序字节集代码, 字节集, 公开, 返回 子程序头部到第一个返回处的代码集
.参数 参_子程序指针, 子程序指针
.局部变量 局_扫描表, 字节集
.局部变量 局_字节集, 字节集
.局部变量 局_记录值, 整数型
.局部变量 i, 整数型
.局部变量 局_被扫描函数指针, 整数型
.局部变量 局_字节, 字节型
局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 }  ' 256
局_字节集 ＝ { 0 }
局_被扫描函数指针 ＝ 到整数 (参_子程序指针)
局_记录值 ＝ 0
.判断循环首 (i ＞ -1)
    局_记录值 ＝ 局_记录值 － 1
    .如果真 (局_记录值 ＞ -1)  ' 跳过下面记录的次数 延长i .  理想长度
        i ＝ i ＋ 1
        到循环尾 ()
    .如果真结束
    内存_写到内存 (取指针_字节集型 (局_字节集), 局_被扫描函数指针 ＋ i, 1)
    局_字节 ＝ 局_字节集 [1]
    局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]
    i ＝ i ＋ 1
    .判断开始 (局_字节 ＝ 195)
        返回 (指针到字节集 (局_被扫描函数指针, i))
    .默认
        .如果真 (局_字节 ＝ 194)
            返回 (指针到字节集 (局_被扫描函数指针, i ＋ 2))
        .如果真结束
    .判断结束
.判断循环尾 ()
返回 ({  })
.程序集 类_InlineHook, , 公开
.程序集变量 私有_是否被HOOK, 逻辑型
.程序集变量 私有_原字节, 字节集
.程序集变量 私有_新字节, 字节集
.程序集变量 私有_新函数地址, 整数型
.程序集变量 私有_内存地址, 整数型
.程序集变量 私有_内存属性, 精易_内存属性
.程序集变量 私有_目标进程句柄, 整数型
.程序集变量 私有_暂停状态, 逻辑型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
' https://bbs.125.la/forum.php?mod=viewthread&tid=14313676
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.如果真 (私有_是否被HOOK)
    卸载HOOK ()
.如果真结束
.子程序 安装HOOK, 整数型, 公开, 安装HOOK，如果已安装HOOK将直接失败。成功返回 #HOOK状态_成功，失败请自行匹配 #HOOK状态_ 系列常量。请在Hook卸载前不要关闭进程句柄！
.参数 目标进程句柄, 整数型, , -1等于自身进程。如果是其他进程请使用 进程_打开进程() 方法获取句柄。如果是远程进程那么 新函数地址 无论是否为空，都视为拦截HOOK，不会调用到指定函数。
.参数 欲HOOK的地址, 整数型, , 可通过 地址_取API地址() 方法获取地址。
.参数 新函数地址, 子程序指针, 可空, 如果为空则设置为拦截HOOK，当被HOOK函数调用时不执行内容，直接返回0。
.参数 参数数量, 整数型, 可空, 只有新函数地址为空时才有效。这个参数将决定HOOK函数被调用后堆栈平衡问题，请认真填写。
.局部变量 Temp字节集, 字节集
.如果真 (私有_是否被HOOK)
    返回 (#HOOK状态_已HOOK)
.如果真结束
.如果真 (欲HOOK的地址 ＝ 0)
    返回 (#HOOK状态_欲HOOK地址为0)
.如果真结束
私有_内存地址 ＝ 欲HOOK的地址
私有_目标进程句柄 ＝ 目标进程句柄
修改内存保护属性 (-1, 欲HOOK的地址, 私有_内存属性)
' 首先判断目标进程PID。如果是-1则对自身HOOK
.如果真 (目标进程句柄 ＝ -1)
    ' 对自身HOOK步骤：修改内存保护属性
    ' 判断是否有新函数地址, 决定HOOK方式(拦截or调用到指定子程序)
    ' 保存原字节集并修改成新字节集
    ' HOOK成功
    .如果 (是否为空 (新函数地址))
        ' 为空则将函数入口修改成 xor eax,eax ret 到整数(参数数量×4)
        私有_新字节 ＝ { 51, 192, 194 } ＋ 到字节集 (到短整数 (参数数量 × 4))  ' 解释：{51,192}=xor eax,eax(eax清0) {194} =ret ,后面两个字节是ret的具体数字，相当于add esp,数字
        ' 因为易语言会把参数数量×4自动传换成小数型数据，所以到短整数是必须的。否则将得不到预期的结果
    .否则
        ' 不为空则将函数入口修改成 jmp [目标地址]
        私有_新字节 ＝ { 233 } ＋ 到字节集 (到整数 (到整数 (新函数地址) － (欲HOOK的地址 ＋ 5)))  ' 解释：{233}=jmp，更多细节请自行理解
    .如果结束
    ' 保存原字节
    私有_原字节 ＝ 指针到字节集 (欲HOOK的地址, 5)
    ' 修改新内存, 并在原字节的基础上制作往回的跳转(用于被CALL回调原函数)
    .如果真 (WriteProcessMemory_字节集 (-1, 欲HOOK的地址, 私有_新字节, 5, 0) ＝ 假)
        返回 (#HOOK状态_写入内存失败)
    .如果真结束
    私有_原字节 ＝ 私有_原字节 ＋ { 233, 0, 0, 0, 0 }  ' 解释：233依旧是jmp← ←和上面不同的是这个是跳回去的，思路无非就是先执行备份的5字节，然后跳到原函数5字节后的位置继续执行
    ' 至于后面的0,0,0,0是缓冲区, 因为是相对跳转, 需要用到字节的内存地址, 如果直接修改会导致字节集内存地址变化...所以只能提前弄好缓冲区, 然后直接用写内存的方式修改字节集
    私有_新函数地址 ＝ lstrcpyn_字节集 (私有_原字节, 私有_原字节, 取字节集长度 (私有_原字节))
    ' 计算跳转的位置并写入新字节
    .如果真 (WriteProcessMemory_字节集 (-1, 私有_新函数地址 ＋ 6, 到字节集 (到整数 (欲HOOK的地址 ＋ 5 － (私有_新函数地址 ＋ 10))), 4, 0) ＝ 假)
        返回 (#HOOK状态_写入内存失败)
    .如果真结束
    ' 至此, 进程自身的HOOK成功
    私有_是否被HOOK ＝ 真
    返回 (#HOOK状态_成功)
.如果真结束
' 如果进程句柄不等于-1则为远程HOOK
' 远程HOOK因为进程边界问题无法远程调用自身程序的子程序
' 所以如果是远程HOOK，则无视 新函数地址
' 首先计算字节集
私有_新字节 ＝ { 51, 192, 194 } ＋ 到字节集 (到短整数 (参数数量 × 4))
' 保存原字节
私有_原字节 ＝ 取空白字节集 (5)  ' 初始化缓冲区
.如果真 (ReadProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0) ＝ 假)
    ' 访问远程内存失败。
    返回 (#HOOK状态_读取内存失败)
.如果真结束
' 读取完毕则计算新的原字节, 然后将新字节写到远程内存
私有_新函数地址 ＝ 内存_远程创建内存_字节集 (私有_目标进程句柄, 私有_原字节 ＋ { 233, 0, 0, 0, 0 })
.如果真 (私有_新函数地址 ＝ 0)
    返回 (#HOOK状态_申请远程内存失败)
.如果真结束
Temp字节集 ＝ 到字节集 (到整数 (欲HOOK的地址 ＋ 5 － (私有_新函数地址 ＋ 10)))
.如果真 (WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_新函数地址 ＋ 6, Temp字节集, 4, 0) ＝ 假)
    返回 (#HOOK状态_写入内存失败)
.如果真结束
' 写到远程内存
.如果真 (WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_新字节, 5, 0) ＝ 假)
    返回 (#HOOK状态_写入内存失败)
.如果真结束
私有_是否被HOOK ＝ 真
返回 (#HOOK状态_成功)
.子程序 修改内存保护属性, 逻辑型
.参数 进程句柄, 整数型
.参数 函数地址, 整数型
.参数 内存属性, 精易_内存属性, , 请保存好这个参数，还原内存保护需要使用！
.如果真 (VirtualQueryEx (进程句柄, 函数地址, 内存属性, 28) ＝ 0)  ' 取内存保护属性
    输出调试文本 (“取内存保护属性失败”)
    返回 (假)
.如果真结束
.如果真 (VirtualProtectEx (进程句柄, 内存属性.区域地址, 8, 64, 内存属性.当前属性) ＝ 0)  ' 修改内存保护属性(读写)
    输出调试文本 (“修改内存保护属性失败”)
    返回 (假)
.如果真结束
返回 (真)
.子程序 还原内存保护属性, 逻辑型
.参数 进程句柄, 整数型
.参数 内存属性, 精易_内存属性
.如果真 (VirtualProtectEx (进程句柄, 内存属性.区域地址, 8, 32, 内存属性.当前属性) ＝ 0)  ' 还原虚拟内存属性(只读)
    返回 (假)
.如果真结束
返回 (真)
.子程序 卸载HOOK, 逻辑型, 公开, 卸载HOOK，如果卸载失败可尝试 还原_InlineHook()，传递 取原字节集() 函数即可
.如果真 (私有_是否被HOOK ＝ 假)
    返回 (假)
.如果真结束
' 无论本地进程或者远程进程，都可以通过写WeiteProcessMemory函数修改
WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0)
' 如果远程进程已退出也可能导致卸载HOOK失败, 所以这里不做判断
' 如果需要带判断版本请使用 InlineHook还原() 方法
.如果真 (私有_目标进程句柄 ≠ -1)
    内存_释放远程内存 (私有_目标进程句柄, 私有_新函数地址)
.如果真结束
还原内存保护属性 (私有_目标进程句柄, 私有_内存属性)
私有_是否被HOOK ＝ 假
连续赋值 ({  }, 私有_原字节, 私有_新字节)
连续赋值 (0, 私有_内存地址, 私有_新函数地址, 私有_目标进程句柄)
返回 (真)
.子程序 暂停HOOK, 逻辑型, 公开, 暂停(还原)HOOK
.如果真 (私有_暂停状态 ＝ 假)
    WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0)
    私有_暂停状态 ＝ 真
    返回 (真)
.如果真结束
返回 (假)
.子程序 继续HOOK, 逻辑型, 公开, 继续(安装)HOOK
.如果真 (私有_暂停状态 ＝ 真)
    WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_新字节, 5, 0)
    私有_暂停状态 ＝ 假
    返回 (真)
.如果真结束
返回 (假)
.子程序 取地址, 整数型, 公开, 获取一个HOOK地址，这个地址允许被 调用子程序_ 来调用，当调用这个地址时不会触发HOOK函数。请自行区分远程调用和本地调用！
返回 (私有_新函数地址)
.子程序 取原字节集, 字节集, 公开, 取出备份的原字节集，可用于 还原_InlineHook()函数上
返回 (私有_原字节)
.程序集 类_屏蔽菜单, , 公开
.程序集变量 OldhWnd, 整数型
.程序集变量 OldProc, 整数型
.程序集变量 address, 整数型
.程序集变量 Callback, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 ()
Callback ＝ 0
.子程序 初始化, , 公开
.参数 窗口句柄, 整数型
.参数 回调子程序, 整数型, 可空, 到整数 (&xxx)
OldhWnd ＝ 窗口句柄
Callback ＝ 回调子程序
address ＝ 类_取内部方法地址 (5)
OldProc ＝ SetWindowLongA (OldhWnd, #GWL_WNDPROC, address)
.子程序 销毁, , 公开
.如果真 (OldProc ≠ 0)
    SetWindowLongA (OldhWnd, #GWL_WNDPROC, OldProc)
    类_释放内部方法地址 (address)
.如果真结束
.子程序 NewProc, 整数型
.参数 hWnd, 整数型
.参数 message, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.判断开始 (message ＝ #WM_CONTEXTMENU)
    .如果真 (Callback ≠ 0)
        调用子程序_ (Callback, , , , , , , , , , , , , , , )
    .如果真结束
    返回 (0)
.判断 (message ＝ #WM_NCLBUTTONDOWN)
    .如果真 (wParam ＝ 3)  ' #HTSYSMENU
        .如果真 (Callback ≠ 0)
            调用子程序_ (Callback, , , , , , , , , , , , , , , )
        .如果真结束
        返回 (0)
    .如果真结束
.默认
.判断结束
返回 (CallWindowProcA (OldProc, hWnd, message, wParam, lParam))
.程序集 外部超级列表框, , 公开
.程序集变量 集_目标句柄, 整数型
.程序集变量 集_表头句柄, 整数型
.程序集变量 集_外部控件, 逻辑型
.程序集变量 集_外部控件操作, 外部控件操作
.程序集变量 集_进程句柄, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
' 连续赋值 (250, 临时_项目.项目文本长度, 临时_列.缓冲区长度, 集_外部列.缓冲区长度)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
集_外部控件操作.结束操作 (集_进程句柄)
.子程序 初始化, 逻辑型, 公开, 调用此类必须初始化此命令，否则无法调用后面的命令
.参数 超级列表框句柄, 整数型
.参数 是否为外部进程的超级列表框, 逻辑型, 可空, 可以被省略。当为真时，可对这个外部进程一超级列表框进行操作。默认为假。
.参数 超级列表框类名, 文本型, 可空, 默认为空  SYSLISTVIEW32 
.如果真 (是否为空 (超级列表框类名))
    超级列表框类名 ＝ “SysListView32”
.如果真结束
.判断开始 (窗口_取类名 (超级列表框句柄) ＝ 超级列表框类名)  ' SysListView32
    集_外部控件 ＝ 是否为外部进程的超级列表框
    集_目标句柄 ＝ 超级列表框句柄
    集_进程句柄 ＝ 集_外部控件操作.打开进程 (集_目标句柄)  ' 全部子程序共用
    返回 (真)
.默认
    返回 (假)
.判断结束
.子程序 取标题, 文本型, 公开, 取指定表项或子项的标题。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
.参数 缓冲尺寸, 整数型, 可空, 可以被省略
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 局_缓冲区, 文本型
.局部变量 hMem, 整数型
.局部变量 text, 文本型
缓冲尺寸 ＝ 选择 (是否为空 (缓冲尺寸), 260, 缓冲尺寸)
.判断开始 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 缓冲尺寸)
    局部_外部项目.项目文本 ＝ 临时_数据地址2
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.子项目 ＝ 列索引
    局部_外部项目.掩码 ＝ 1
    局部_外部项目.项目文本长度 ＝ 缓冲尺寸
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    .判断开始 (SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1) ≠ 0)
        局_缓冲区 ＝ 到文本 (集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 缓冲尺寸))
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        返回 (局_缓冲区)
    .默认
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        返回 (“”)
    .判断结束
.默认
    hMem ＝ HeapAlloc (GetProcessHeap (), 8, 缓冲尺寸)
    局部_外部项目.子项目 ＝ 列索引
    局部_外部项目.项目文本长度 ＝ 缓冲尺寸
    局部_外部项目.项目文本 ＝ hMem
    SendMessageA (集_目标句柄, 4141, 表项索引, 取数据_通用型 (局部_外部项目))  ' #LVM_GETITEMTEXT=4141
    text ＝ 指针到文本 (hMem)
    HeapFree (GetProcessHeap (), 8, hMem)
    返回 (text)
.判断结束
.子程序 取图片, 整数型, 公开
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局_缓冲区, 字节集
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.子项目 ＝ 列索引
    局部_外部项目.掩码 ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1)
    局_缓冲区 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    写到内存 (局_缓冲区, 临时_项目地址, 40)
    返回 (局部_外部项目.图片索引)
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.子项目 ＝ 列索引
临时_项目.掩码 ＝ 2
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址)
返回 (临时_项目.图片索引)
.子程序 取当前状态图片, 整数型, 公开, 取回指定表项的当前状态图片索引，图片索引指向状态图片组属性中的某一图片，从 0 开始，-1 表示无图片。如果“是否有检查框”属性为真，返回值是当前检查框的选中状态，1表示被选中，0表示未选中。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
返回 (SendMessageA (集_目标句柄, #LVM_GETITEMSTATE, 表项索引, -4096) ÷ 4096 － 1)
.子程序 取缩进数目, 整数型, 公开
.参数 表项索引, 整数型, , 。用于指定列表框中的某一项目，索引值从 0 开始。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局_缓冲区, 字节集
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 16
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1)
    局_缓冲区 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    写到内存 (局_缓冲区, 临时_项目地址, 40)
    返回 (局部_外部项目.缩进)
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 16
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址)
返回 (临时_项目.缩进)
.子程序 取表项数, 整数型, 公开, 返回列表框中所有表项的数目
返回 (SendMessageA (集_目标句柄, #LVM_GETITEMCOUNT, 0, 0))
.子程序 取表项数值, 整数型, 公开
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 局_缓冲区, 字节集
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 4
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1)
    局_缓冲区 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    写到内存 (局_缓冲区, 临时_项目地址, 40)
    返回 (局部_外部项目.项目数值)
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 4
' 集_单一项目.pszText ＝ 取空白文本 (260)
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址)
返回 (临时_项目.项目数值)
.子程序 置标题, , 公开, 设置指定表项或子项的标题。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
.参数 标题, 文本型, 可空, 可以被省略。本参数指定表项或子项的标题文本。如果被省略，默认值为空文本。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 局_项目文本长度, 整数型
.局部变量 局_缓冲区, 整数型
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    局_项目文本长度 ＝ 取字节集长度 (到字节集 (标题)) ＋ 1
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 局_项目文本长度)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.子项目 ＝ 列索引
    局_缓冲区 ＝ lstrcpyn_文本型 (标题, 标题, 0)
    局部_外部项目.项目文本 ＝ 临时_数据地址2
    局部_外部项目.项目文本长度 ＝ 局_项目文本长度
    局部_外部项目.掩码 ＝ 1
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_缓冲区, 局_项目文本长度)
    SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.子项目 ＝ 列索引
临时_项目.掩码 ＝ 1
临时_项目.项目文本 ＝ 标题
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)
.子程序 置图片, , 公开
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
.参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.子项目 ＝ 列索引
    局部_外部项目.掩码 ＝ 2
    局部_外部项目.图片索引 ＝ 图片索引
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.子项目 ＝ 列索引
临时_项目.掩码 ＝ 2
临时_项目.图片索引 ＝ 图片索引
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)
.子程序 置状态图片, , 公开
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 状态图片索引, 整数型, 可空, 可以被省略。状态图片索引用于指定“状态图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (是否为空 (状态图片索引))
    状态图片索引 ＝ -1
.如果真结束
.如果真 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 8
    局部_外部项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
    局部_外部项目.状态掩码 ＝ -4096
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 8
临时_项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
临时_项目.状态掩码 ＝ -4096
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4139, 表项索引, 临时_项目地址)
.子程序 置缩进数目, , 公开, 设置指定表项的缩进数目。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 缩进数目, 整数型, 可空, 可以被省略。“缩进数目”仅在报表型列表框才有效，用作指定显示时在表项首部增加的空白数。如果本参数被省略，默认值为 0 。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 16
    局部_外部项目.缩进 ＝ 缩进数目
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 16
临时_项目.缩进 ＝ 缩进数目
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)
.子程序 置表项数值, , 公开, 设置与指定表项相关联的数值
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.参数 表项数值, 整数型, 可空, 可以被省略。该数值与指定表项相关联。如果本参数被省略，默认值为 0 。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 4
    局部_外部项目.项目数值 ＝ 表项数值
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 4
临时_项目.项目数值 ＝ 表项数值
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)
.子程序 取被选择表项, 变体型, 公开, 返回一个整数数组，內含所有当前被选择表项的位置索引。如果当前没有被选择表项，返回空数组。
.局部变量 局_选中项索引, 变体型
.局部变量 局_成员数, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_选中项索引A, 整数型, , "0"
局_选中项索引.置类型 (#变体类型.数值型数组)
局_成员数 ＝ 取表项数 ()
.变量循环首 (1, 局_成员数, 1, 局_计次)
    .如果真 (是否被选择 (局_计次 － 1))
        加入成员 (局_选中项索引A, 局_计次 － 1)
    .如果真结束
.变量循环尾 ()
局_选中项索引.赋值 (局_选中项索引A, )
返回 (局_选中项索引)
.子程序 取被选中表项, 变体型, 公开, 如果“是否有检查框”属性为真，返回当前所有检查框被选中的表项位置索引
.局部变量 局_选中项索引, 变体型
.局部变量 局_成员数, 整数型
.局部变量 局_计次, 整数型
.局部变量 局_选中项索引A, 整数型, , "0"
局_选中项索引.置类型 (#变体类型.数值型数组)
局_成员数 ＝ 取表项数 ()
.变量循环首 (1, 局_成员数, 1, 局_计次)
    .如果真 (取当前状态图片 (局_计次 － 1) ≠ 0)
        加入成员 (局_选中项索引A, 局_计次 － 1)
    .如果真结束
.变量循环尾 ()
局_选中项索引.赋值 (局_选中项索引A, )
返回 (局_选中项索引)
.子程序 取已选择表项数, 整数型, 公开, 返回当前已被选择表项的数目
返回 (SendMessageA (集_目标句柄, #LVM_GETSELECTEDCOUNT, 0, 0))
.子程序 是否被选择, 逻辑型, 公开, 判断指定表项是否已经被选择，如已被选择，返回真，否则返回假。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
返回 (SendMessageA (集_目标句柄, #LVM_GETITEMSTATE, 表项索引, 2) ＝ 2)
.子程序 选择表项, , 公开
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    ' '集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 8
    局部_外部项目.状态 ＝ 2
    局部_外部项目.状态掩码 ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4139, 表项索引, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 8
临时_项目.状态 ＝ 2
临时_项目.状态掩码 ＝ 2
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, #LVM_SETITEMSTATE, 表项索引, 临时_项目地址)
.子程序 取消表项选择, , 公开, 取消对指定表项的选择。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (集_外部控件)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    局部_外部项目.表项索引 ＝ 表项索引
    局部_外部项目.掩码 ＝ 8
    局部_外部项目.状态 ＝ 位取反 (2)
    局部_外部项目.状态掩码 ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    SendMessageA (集_目标句柄, 4102, 表项索引, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 ()
.如果真结束
临时_项目.项目 ＝ 表项索引
临时_项目.掩码 ＝ 8
临时_项目.状态 ＝ 位取反 (2)
临时_项目.状态掩码 ＝ 2
临时_项目地址 ＝ 取数据_通用型 (临时_项目)
SendMessageA (集_目标句柄, #LVM_SETITEMSTATE, 表项索引, 临时_项目地址)
.子程序 插入表项, 整数型, 公开
.参数 插入位置, 整数型, 可空, 可以被省略。指定新表项插入时的位置索引，索引值从 0 开始。如果提供 -1 ，则插入到列表框的尾部。如果本参数被省略，默认值为 -1 。
.参数 标题, 文本型, 可空, 可以被省略。本参数指定表项的标题文本。如果被省略，默认值为空文本。
.参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.参数 状态图片索引, 整数型, 可空, 可以被省略。状态图片索引用于指定“状态图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.参数 缩进数目, 整数型, 可空, 可以被省略。“缩进数目”仅在报表型列表框才有效，用作指定显示时在表项首部增加的空白数。如果本参数被省略，默认值为 0 。
.参数 表项数值, 整数型, 可空, 可以被省略。该数值与指定表项相关联。如果本参数被省略，默认值为 0 。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局_数值, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
.如果真 (是否为空 (图片索引))
    图片索引 ＝ -1
.如果真结束
.如果真 (是否为空 (状态图片索引))
    状态图片索引 ＝ -1
.如果真结束
.判断开始 (集_外部控件)
    .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
        局部_外部项目.表项索引 ＝ 取表项数 ()
    .默认
        局部_外部项目.表项索引 ＝ 插入位置
    .判断结束
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取字节集长度 (到字节集 (标题)) ＋ 1)
    局部_外部项目.掩码 ＝ 4103 ＋ 8
    局部_外部项目.状态 ＝ 位取反 (2)
    局部_外部项目.项目文本 ＝ 临时_数据地址2
    局部_外部项目.项目文本长度 ＝ 取字节集长度 (到字节集 (标题)) ＋ 1
    局部_外部项目.图片索引 ＝ 图片索引
    局部_外部项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
    局部_外部项目.状态掩码 ＝ -4096
    局部_外部项目.缩进 ＝ 缩进数目
    局部_外部项目.项目数值 ＝ 表项数值
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取字节集长度 (到字节集 (标题)) ＋ 1)
    局_数值 ＝ SendMessageA (集_目标句柄, 4103, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 (局_数值)
.默认
    .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
        临时_项目.项目 ＝ 取表项数 ()
    .默认
        临时_项目.项目 ＝ 插入位置
    .判断结束
    临时_项目.掩码 ＝ 4103 ＋ 8
    临时_项目.项目文本 ＝ 标题
    临时_项目.项目文本长度 ＝ 取字节集长度 (到字节集 (标题)) ＋ 1
    临时_项目.图片索引 ＝ 图片索引
    临时_项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
    临时_项目.状态掩码 ＝ -4096
    临时_项目.缩进 ＝ 缩进数目
    临时_项目.项目数值 ＝ 表项数值
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    返回 (SendMessageA (集_目标句柄, 4103, 0, 临时_项目地址))
.判断结束
.子程序 高速插入表项, , 公开
.参数 插入位置, 整数型, 可空, 可以被省略。指定新表项插入时的位置索引，索引值从 0 开始。如果提供 -1 ，则插入到列表框的尾部。如果本参数被省略，默认值为 -1 。
.参数 列表框信息, 列表框信息, 数组
.参数 排序方式, 整数型, 可空, 可以被省略。指定新新插入数据的排序方式。默认为“#排序方式_不排序”。如要逆向排序，请将常量位取反。如要对指定列排序，请用#排序方式_表项列标题排序+要排序的列索引
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 局_信息1, 列表框信息
.局部变量 局_信息2, 列表框信息, , "0"
.局部变量 局_信息3, 整数型
.局部变量 局_计次1, 整数型
.局部变量 局_成员数, 整数型
.局部变量 局_数据列, 文本型, , "0"
.局部变量 局_当前索引, 整数型
.局部变量 局_计次2, 整数型
.局部变量 局_列图片成员数, 整数型
.局部变量 局_列标题成员数, 整数型
.局部变量 局_列成员数, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_列, 超级列表框7
.局部变量 临时_项目, 超级列表框0
局_信息2 ＝ 列表框信息
快速排序 (局_信息2, , , 排序方式)
局_成员数 ＝ 取数组成员数 (局_信息2)
SendMessageA (集_目标句柄, 11, 0, 0)
.判断开始 (集_外部控件)
    .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
        局部_外部项目.表项索引 ＝ 取表项数 ()
    .默认
        局部_外部项目.表项索引 ＝ 插入位置
    .判断结束
    局部_外部项目.掩码 ＝ 4103 ＋ 8
    局部_外部项目.状态掩码 ＝ -4096
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    .判断循环首 (局_计次1 ＜ 局_成员数)
        局部_外部项目.表项索引 ＝ 插入位置 ＋ 局_计次1
        局_计次1 ＝ 局_计次1 ＋ 1
        局部_外部项目.子项目 ＝ 0
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (局_信息2 [局_计次1].标题) ＋ 1)
        局部_外部项目.项目文本 ＝ 临时_数据地址2
        局部_外部项目.状态 ＝ (局_信息2 [局_计次1].状态图片索引 ＋ 1) × 4096
        局部_外部项目.图片索引 ＝ 局_信息2 [局_计次1].图片索引
        局部_外部项目.缩进 ＝ 局_信息2 [局_计次1].缩进数目
        局部_外部项目.项目数值 ＝ 局_信息2 [局_计次1].表项数值
        局部_外部项目.项目文本长度 ＝ 取字节集长度 (到字节集 (局_信息2 [局_计次1].标题)) ＋ 1
        局_信息3 ＝ lstrcpyn_文本型 (局_信息2 [局_计次1].标题, 局_信息2 [局_计次1].标题, 0)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_信息3, 取文本长度 (局_信息2 [局_计次1].标题) ＋ 1)
        局_当前索引 ＝ SendMessageA (集_目标句柄, 4103, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        .如果真 (局_当前索引 ≠ -1)
            局_列图片成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列图片索引)
            局_列标题成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列标题)
            局_列成员数 ＝ 选择 (局_列标题成员数 ＞ 局_列图片成员数, 局_列标题成员数, 局_列图片成员数)
            .判断循环首 (局_计次2 ＜ 局_列成员数)
                局_计次2 ＝ 局_计次2 ＋ 1
                局部_外部项目.子项目 ＝ 局_计次2 － 1
                .判断开始 (局_计次2 ≤ 局_列标题成员数)
                    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (局_信息2 [局_计次1].列标题 [局_计次2]) ＋ 1)
                    局_信息3 ＝ lstrcpyn_文本型 (局_信息2 [局_计次1].列标题 [局_计次2], 局_信息2 [局_计次1].列标题 [局_计次2], 0)
                    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_信息3, 取文本长度 (局_信息2 [局_计次1].列标题 [局_计次2]) ＋ 1)
                    局部_外部项目.项目文本 ＝ 临时_数据地址2  ' TEMP2 [I].列标题 [I2]
                    局部_外部项目.项目文本长度 ＝ 取文本长度 (局_信息2 [局_计次1].列标题 [局_计次2]) ＋ 1
                    局部_外部项目.掩码 ＝ 1
                .默认
                    局部_外部项目.项目文本 ＝ 0
                    局部_外部项目.掩码 ＝ 0
                .判断结束
                .判断开始 (局_计次2 ≤ 局_列图片成员数)
                    局部_外部项目.图片索引 ＝ 局_信息2 [局_计次1].列图片索引 [局_计次2]
                    局部_外部项目.掩码 ＝ 位或 (局部_外部项目.掩码, 2)
                .默认
                    局部_外部项目.图片索引 ＝ 0
                .判断结束
                集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
                SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
                .如果真 (局部_外部项目.项目文本 ≠ 0)
                    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
                .如果真结束
            .判断循环尾 ()
            局_计次2 ＝ 0
            局部_外部项目.掩码 ＝ 4103 ＋ 8
            局部_外部项目.状态掩码 ＝ -4096
        .如果真结束
    .判断循环尾 ()
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
.默认
    .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
        临时_项目.项目 ＝ 取表项数 ()
    .默认
        临时_项目.项目 ＝ 插入位置
    .判断结束
    临时_项目.掩码 ＝ 4103 ＋ 8
    临时_项目.状态掩码 ＝ -4096
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    .判断循环首 (局_计次1 ＜ 局_成员数)
        临时_项目.项目 ＝ 插入位置 ＋ 局_计次1
        局_计次1 ＝ 局_计次1 ＋ 1
        临时_项目.子项目 ＝ 0
        临时_项目.项目文本 ＝ 局_信息2 [局_计次1].标题
        临时_项目.状态 ＝ (局_信息2 [局_计次1].状态图片索引 ＋ 1) × 4096
        临时_项目.图片索引 ＝ 局_信息2 [局_计次1].图片索引
        临时_项目.缩进 ＝ 局_信息2 [局_计次1].缩进数目
        临时_项目.项目数值 ＝ 局_信息2 [局_计次1].表项数值
        局_当前索引 ＝ SendMessageA (集_目标句柄, 4103, 0, 临时_项目地址)
        .如果真 (局_当前索引 ≠ -1)
            局_列图片成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列图片索引)
            局_列标题成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列标题)
            局_列成员数 ＝ 选择 (局_列标题成员数 ＞ 局_列图片成员数, 局_列标题成员数, 局_列图片成员数)
            .判断循环首 (局_计次2 ＜ 局_列成员数)
                局_计次2 ＝ 局_计次2 ＋ 1
                临时_项目.子项目 ＝ 局_计次2 － 1
                .判断开始 (局_计次2 ≤ 局_列标题成员数)
                    临时_项目.项目文本 ＝ 局_信息2 [局_计次1].列标题 [局_计次2]
                    临时_项目.掩码 ＝ 1
                .默认
                    临时_项目.项目文本 ＝ “”
                    临时_项目.掩码 ＝ 0
                .判断结束
                .判断开始 (局_计次2 ≤ 局_列图片成员数)
                    临时_项目.图片索引 ＝ 局_信息2 [局_计次1].列图片索引 [局_计次2]
                    临时_项目.掩码 ＝ 位或 (临时_项目.掩码, 2)
                .默认
                    临时_项目.图片索引 ＝ 0
                .判断结束
                SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)
            .判断循环尾 ()
            局_计次2 ＝ 0
            临时_项目.掩码 ＝ 4103 ＋ 8
            临时_项目.状态掩码 ＝ -4096
        .如果真结束
    .判断循环尾 ()
.判断结束
SendMessageA (集_目标句柄, 11, 1, 0)
.子程序 快速排序
.参数 列表框信息, 列表框信息, 数组
.参数 左边, 整数型, 可空
.参数 右边, 整数型, 可空
.参数 排序方式, 整数型
.局部变量 局_基准点, 整数型
.局部变量 局_基准值, 列表框信息
.局部变量 局_计次1, 整数型
.局部变量 局_计次2, 整数型
.局部变量 局_列排序, 整数型
.如果真 (排序方式 ＝ 0 或 排序方式 ＝ -1)
    返回 ()
.如果真结束
.如果真 (是否为空 (左边))
    左边 ＝ 1
.如果真结束
.如果真 (是否为空 (右边))
    右边 ＝ 取数组成员数 (列表框信息)
.如果真结束
.如果真 (左边 ≥ 右边)
    返回 ()
.如果真结束
局_计次1 ＝ 左边
局_计次2 ＝ 右边
局_基准值 ＝ 列表框信息 [左边]
.判断开始 (排序方式 ＞ 0)
    .判断开始 (位与 (排序方式, 2048) ≠ 2048 或 位异或 (排序方式, 2048) ＝ 0)
        ' 项目排序
        .判断开始 (排序方式 ＝ 1 或 位异或 (排序方式, 2048) ＝ 0)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].标题 ≥ 局_基准值.标题)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].标题 ≤ 局_基准值.标题)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .判断 (排序方式 ＝ 2)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].图片索引 ≥ 局_基准值.图片索引)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].图片索引 ≤ 局_基准值.图片索引)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .判断 (排序方式 ＝ 3)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].状态图片索引 ≥ 局_基准值.状态图片索引)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].状态图片索引 ≤ 局_基准值.状态图片索引)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .判断 (排序方式 ＝ 4)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].表项数值 ≥ 局_基准值.表项数值)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].表项数值 ≤ 局_基准值.表项数值)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .默认
        .判断结束
    .默认
        ' 列排序
        局_列排序 ＝ 位异或 (排序方式, 2048)
        ' 取得要排序的列索引数
        .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
            .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].列标题 [局_列排序] ≥ 局_基准值.列标题 [局_列排序])  ' 向左侧寻找小于基准值的元素
                局_计次2 ＝ 局_计次2 － 1
            .判断循环尾 ()
            .如果真 (局_计次1 ＜ 局_计次2)
                列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                局_计次1 ＝ 局_计次1 ＋ 1
            .如果真结束
            .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].列标题 [局_列排序] ≤ 局_基准值.列标题 [局_列排序])  ' 向右侧寻找大于基准值的元素
                局_计次1 ＝ 局_计次1 ＋ 1
            .判断循环尾 ()
            .如果真 (局_计次1 ＜ 局_计次2)
                列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                局_计次2 ＝ 局_计次2 － 1
            .如果真结束
        .判断循环尾 ()
    .判断结束
.默认
    ' 排序方式 ＝ 位取反(排序方式)
    ' 逆排方式
    .判断开始 (位与 (位取反 (排序方式), 2048) ≠ 2048 或 位异或 (位取反 (排序方式), 2048) ＝ 0)
        ' 项目排序
        .判断开始 (位取反 (排序方式) ＝ 1 或 位异或 (位取反 (排序方式), 2048) ＝ 0)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].标题 ≤ 局_基准值.标题)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].标题 ≥ 局_基准值.标题)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .判断 (位取反 (排序方式) ＝ 2)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].图片索引 ≤ 局_基准值.图片索引)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].图片索引 ≥ 局_基准值.图片索引)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .判断 (位取反 (排序方式) ＝ 3)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].状态图片索引 ≤ 局_基准值.状态图片索引)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].状态图片索引 ≥ 局_基准值.状态图片索引)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .判断 (位取反 (排序方式) ＝ 4)
            .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].表项数值 ≤ 局_基准值.表项数值)  ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].表项数值 ≥ 局_基准值.表项数值)  ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
            .判断循环尾 ()
        .默认
        .判断结束
    .默认
        ' 列排序
        局_列排序 ＝ 位异或 (位取反 (排序方式), 2048)
        ' 取得要排序的列索引数
        .如果真 (局_列排序 ＞ 取数组成员数 (列表框信息 [局_计次2].列标题))
            返回 ()
        .如果真结束
        .判断循环首 (局_计次1 ＜ 局_计次2)  ' 循环直至左右指针相遇
            .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].列标题 [局_列排序] ≤ 局_基准值.列标题 [局_列排序])  ' 向左侧寻找小于基准值的元素
                局_计次2 ＝ 局_计次2 － 1
            .判断循环尾 ()
            .如果真 (局_计次1 ＜ 局_计次2)
                列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2]  ' 交换i和j的值
                局_计次1 ＝ 局_计次1 ＋ 1
            .如果真结束
            .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].列标题 [局_列排序] ≥ 局_基准值.列标题 [局_列排序])  ' 向右侧寻找大于基准值的元素
                局_计次1 ＝ 局_计次1 ＋ 1
            .判断循环尾 ()
            .如果真 (局_计次1 ＜ 局_计次2)
                列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1]  ' 交换i和j的值
                局_计次2 ＝ 局_计次2 － 1
            .如果真结束
        .判断循环尾 ()
    .判断结束
.判断结束
列表框信息 [局_计次1] ＝ 局_基准值  ' 前面把基准值弄丢了，这里补回来。
快速排序 (列表框信息, 左边, 局_计次1 － 1, 排序方式)
快速排序 (列表框信息, 局_计次1 ＋ 1, 右边, 排序方式)
.子程序 删除表项, , 公开
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
SendMessageA (集_目标句柄, #LVM_DELETEITEM, 表项索引, 0)
.子程序 全部删除, , 公开
SendMessageA (集_目标句柄, #LVM_DELETEALLITEMS, 0, 0)
.子程序 查找表项, 整数型, 公开
.参数 标题, 文本型, , 本参数指定欲查找表项的标题文本。
.参数 起始查找位置, 整数型, 可空, 可以被省略。本参数指定查找表项的起始位置。如果本参数被省略，默认值为 0  ，即从首项开始查找。
.参数 是否精确匹配, 逻辑型, 可空, 可以被省略。本参数指定匹配标题文本时是否为精确匹配，如果本参数为假，则只要表项标题首部包含指定文本即认为匹配成功。如果本参数被省略，默认值为真。
.参数 如果查找不到是否从头开始, 逻辑型, 可空, 可以被省略。本参数指定在查找标题文本时，如果从“起始查找位置”查找不到，是否从头开始查找。默认值为假。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 局_结构1, 超级列表框3
.局部变量 局_结构2, 超级列表框4
.局部变量 局_数值, 整数型
.如果真 (集_外部控件)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 20)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (标题) ＋ 1)
    局_结构2.flags ＝ 位或 (选择 (是否精确匹配, 2, 8), 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0), 1)
    局_结构2.LPCTSTR ＝ 临时_数据地址2
    临时_项目地址 ＝ 取数据_通用型 (局_结构2)
    局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 20)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取文本长度 (标题) ＋ 1)
    局_数值 ＝ SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    返回 (局_数值)
.如果真结束
局_结构1.flags ＝ 位或 (选择 (是否精确匹配, 2, 8), 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
局_结构1.LPCTSTR ＝ 标题
临时_项目地址 ＝ 取数据_通用型 (局_结构1)
返回 (SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_项目地址))
.子程序 查找表项数值, 整数型, 公开
.参数 起始查找位置, 整数型, 可空, 可以被省略。本参数指定查找表项的起始位置。如果本参数被省略，默认值为 0  ，即从首项开始查找。
.参数 表项数值, 整数型, 可空, 可以被省略。该数值与指定表项相关联。如果本参数被省略，默认值为 0 。
.参数 如果查找不到是否从头开始, 逻辑型, 可空, 可以被省略。本参数指定在查找标题文本时，如果从“起始查找位置”查找不到，是否从头开始查找。默认值为假。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 局_结构1, 超级列表框3
.局部变量 局_结构2, 超级列表框4
.局部变量 局_数值, 整数型
.如果真 (集_外部控件)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 20)
    局_结构2.flags ＝ 位或 (1, 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
    局_结构2.lParam ＝ 表项数值
    临时_项目地址 ＝ 取数据_通用型 (局_结构2)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 20)
    局_数值 ＝ SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    返回 (局_数值)
.如果真结束
局_结构1.flags ＝ 位或 (1, 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
局_结构1.lParam ＝ 表项数值
临时_项目地址 ＝ 取数据_通用型 (局_结构1)
返回 (SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_项目地址))
.子程序 保证显示, , 公开
.参数 表项索引, 整数型
SendMessageA (集_目标句柄, #LVM_ENSUREVISIBLE, 表项索引, 1)
.子程序 排列图标, , 公开, 自动排列大图标或小图标列表框中的图标。
SendMessageA (集_目标句柄, #LVM_ARRANGE, 0, 0)
.子程序 取列标题, 文本型, 公开, 返回报表型列表框中指定列的标题。
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 临时_列, 超级列表框7
.局部变量 局_数据, 字节集
.如果真 (集_外部控件)
    临时_外部列.mask ＝ 4  ' LVCF_TEXT    表示获取列的信息。
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 260)
    临时_外部列.列标题 ＝ 临时_数据地址2
    临时_外部列.缓冲区长度 ＝ 260
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    ' LVM_GETCOLUMN=4121    ’表示获取列信息
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
        局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 260)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        返回 (到文本 (局_数据))
    .默认
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        返回 (“”)
    .判断结束
.如果真结束
临时_列.mask ＝ 4
临时_列.列标题 ＝ 取空白文本 (260)
临时_列.缓冲区长度 ＝ 260
临时_项目地址 ＝ 取数据_通用型 (临时_列)
.判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
    返回 (临时_列.列标题)
.默认
    返回 (“”)
.判断结束
.子程序 取列对齐方式, 整数型, 公开, 取回报表型列表框中指定列的对齐方式。返回值为以下常量之一： 0：0； 1：1； 2：2；失败返回-1。
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 局_数据, 字节集
.局部变量 临时_列, 超级列表框7
.如果真 (集_外部控件)
    临时_外部列.mask ＝ 1
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
        局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        写到内存 (局_数据, 临时_项目地址, 32)
        .判断开始 (位与 (临时_外部列.对齐方式, 2) ＝ 2)
            返回 (1)
        .判断 (位与 (临时_外部列.对齐方式, 1) ＝ 1)
            返回 (2)
        .默认
            返回 (0)
        .判断结束
    .默认
        返回 (-1)
    .判断结束
.如果真结束
临时_列.mask ＝ 1
临时_项目地址 ＝ 取数据_通用型 (临时_列)
.判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
    .判断开始 (位与 (临时_列.对齐方式, 2) ＝ 2)
        返回 (1)
    .判断 (位与 (临时_列.对齐方式, 1) ＝ 1)
        返回 (2)
    .默认
        返回 (0)
    .判断结束
.默认
    返回 (-1)
.判断结束
.子程序 取列宽, 整数型, 公开, 返回报表型列表框中指定列的宽度，如指定列不存在，返回 0 。
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 局_数据, 字节集
.局部变量 临时_列, 超级列表框7
.如果真 (集_外部控件)
    临时_外部列.mask ＝ 2
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
        局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        写到内存 (局_数据, 临时_项目地址, 32)
        返回 (临时_外部列.列宽度)
    .默认
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 (0)
    .判断结束
.如果真结束
临时_列.mask ＝ 2
临时_项目地址 ＝ 取数据_通用型 (临时_列)
.判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
    返回 (临时_列.列宽度)
.默认
    返回 (0)
.判断结束
.子程序 取列图片, 整数型, 公开, 返回报表型列表框中指定列的图片索引
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 局_数据, 字节集
.局部变量 临时_列, 超级列表框7
.如果真 (集_外部控件)
    临时_外部列.mask ＝ 16 ＋ 1
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
        局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        写到内存 (局_数据, 临时_项目地址, 32)
        返回 (临时_外部列.列图标)
    .默认
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 (-1)
    .判断结束
.如果真结束
临时_列.mask ＝ 16 ＋ 1
临时_项目地址 ＝ 取数据_通用型 (临时_列)
.判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
    返回 (临时_列.列图标)
.默认
    返回 (-1)
.判断结束
.子程序 图片是否居右, 逻辑型, 公开, 如果报表型列表框中指定列的图片居右显示，返回真，否则返回假
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 局_结构, 字节集
.局部变量 临时_列, 超级列表框7
.如果真 (集_外部控件)
    临时_外部列.mask ＝ 16 ＋ 1
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
        局_结构 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        写到内存 (局_结构, 临时_项目地址, 32)
        返回 (位与 (临时_外部列.对齐方式, 4096) ＝ 4096)
    .默认
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 (假)
    .判断结束
.如果真结束
临时_列.mask ＝ 16 ＋ 1
临时_项目地址 ＝ 取数据_通用型 (临时_列)
.判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
    返回 (位与 (临时_列.对齐方式, 4096) ＝ 4096)
.默认
    返回 (假)
.判断结束
.子程序 置列标题, 逻辑型, 公开, 设置报表型列表框中指定列的标题
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.参数 标题, 文本型, 可空, 可以被省略。本参数指定报表列的标题文本。如果被省略，默认值为空文本。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 局_数值, 整数型
.局部变量 临时_列, 超级列表框7
.局部变量 局部_返回值, 整数型
.判断开始 (集_外部控件)
    临时_外部列.mask ＝ 4
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (标题) ＋ 1)
    临时_外部列.列标题 ＝ 临时_数据地址2
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取文本长度 (标题) ＋ 1)
    局部_返回值 ＝ SendMessageA (集_目标句柄, 4122, 列索引, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    ' 外部控件操作.结束操作 (集_进程句柄)
.默认
    临时_列.mask ＝ 4
    临时_列.列标题 ＝ 标题
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    局部_返回值 ＝ SendMessageA (集_目标句柄, 4122, 列索引, 临时_项目地址)
.判断结束
返回 (局部_返回值 ≠ 0)
.子程序 置列宽, , 公开, 设置报表型列表框中指定列的宽度
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.参数 列宽, 整数型, 可空, 可以被省略。本参数指定报表列的宽度，单位为像素。如果参数值提供为 -1 ，则根据列数据最大宽度自动调整列尺寸，如果参数值提供为 -2 ，则根据列标题宽度自动调整列尺寸。如果本参数被省略，默认值为 -1 。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 临时_列, 超级列表框7
.判断开始 (集_外部控件)
    临时_外部列.mask ＝ 2
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_外部列.列宽度 ＝ 列宽
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    SendMessageA (集_目标句柄, 4122, 列索引, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
.默认
    临时_列.mask ＝ 2
    临时_列.列宽度 ＝ 列宽
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    SendMessageA (集_目标句柄, 4122, 列索引, 临时_项目地址)
.判断结束
.子程序 置列图片, , 公开, 设置报表型列表框中指定列的标志图片。
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
.参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“表头图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 临时_列, 超级列表框7
.判断开始 (集_外部控件)
    临时_外部列.mask ＝ 16
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_外部列.列图标 ＝ 图片索引
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    SendMessageA (集_目标句柄, 4122, 列索引, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
.默认
    临时_列.mask ＝ 16
    临时_列.列图标 ＝ 图片索引
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    SendMessageA (集_目标句柄, 4122, 列索引, 临时_项目地址)
.判断结束
.子程序 取列数, 整数型, 公开, 返回报表型列表框中列的总数
集_表头句柄 ＝ SendMessageA (集_目标句柄, #LVM_GETHEADER, 0, 0)
返回 (SendMessageA (集_表头句柄, 4608, 0, 0))
.子程序 插入列, 整数型, 公开, 在报表型列表框中指定位置插入新的列，成功返回新列的位置索引，失败返回 -1 。
.参数 插入位置, 整数型, 可空, 可以被省略。指定新列插入时的位置索引，索引值从 0 开始。如果提供 -1 ，则插入到尾部。如果本参数被省略，默认值为 -1 。
.参数 标题, 文本型, 可空, 可以被省略。本参数指定报表列的标题文本。如果被省略，默认值为空文本。
.参数 列宽, 整数型, 可空, 可以被省略。本参数指定报表列的宽度，单位为像素。如果被省略，默认值为 50 。
.参数 对齐方式, 整数型, 可空, 可以被省略。参数可以为以下常量之一： 0：0； 1：1； 2：2。如果本参数被省略，默认值为“0”。
.参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“表头图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.参数 图片是否居右, 逻辑型, 可空, 可以被省略。指定图片是否显示在右边，如果本参数被省略，默认值为假。
.局部变量 临时_项目地址, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_外部列, 超级列表框8
.局部变量 局_数值, 整数型
.局部变量 临时_列, 超级列表框7
.如果真 (是否为空 (插入位置) 或 插入位置 ＝ -1)
    插入位置 ＝ 取列数 ()
.如果真结束
.判断开始 (集_外部控件)
    临时_外部列.mask ＝ 16 ＋ 1 ＋ 2 ＋ 4
    ' 集_单一列.pszText ＝ 取空白文本 (256)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (标题) ＋ 1)
    临时_外部列.列标题 ＝ 临时_数据地址2
    .判断开始 (是否为空 (列宽))
        临时_外部列.列宽度 ＝ 50
    .默认
        临时_外部列.列宽度 ＝ 列宽
    .判断结束
    .判断开始 (是否为空 (对齐方式) 或 对齐方式 ＝ 0)
        临时_外部列.对齐方式 ＝ 0
    .判断 (对齐方式 ＝ 2)
        临时_外部列.对齐方式 ＝ 1
    .判断 (对齐方式 ＝ 1)
        临时_外部列.对齐方式 ＝ 2
    .默认
    .判断结束
    .判断开始 (是否为空 (图片索引))
        临时_外部列.列图标 ＝ -1
    .默认
        临时_外部列.列图标 ＝ 图片索引
    .判断结束
    .如果真 (图片是否居右)
        临时_外部列.对齐方式 ＝ 位或 (临时_外部列.对齐方式, 4096)
    .如果真结束
    临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
    局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取文本长度 (标题) ＋ 1)
    局_数值 ＝ SendMessageA (集_目标句柄, 4123, 插入位置, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 (局_数值)
.默认
    临时_列.mask ＝ 16 ＋ 1 ＋ 2 ＋ 4
    临时_列.列标题 ＝ 标题
    .判断开始 (是否为空 (列宽))
        临时_列.列宽度 ＝ 50
    .默认
        临时_列.列宽度 ＝ 列宽
    .判断结束
    .判断开始 (是否为空 (对齐方式) 或 对齐方式 ＝ 0)
        临时_列.对齐方式 ＝ 0
    .判断 (对齐方式 ＝ 2)
        临时_列.对齐方式 ＝ 1
    .判断 (对齐方式 ＝ 1)
        临时_列.对齐方式 ＝ 2
    .默认
    .判断结束
    .判断开始 (是否为空 (图片索引))
        临时_列.列图标 ＝ -1
    .默认
        临时_列.列图标 ＝ 图片索引
    .判断结束
    .如果真 (图片是否居右)
        临时_列.对齐方式 ＝ 位或 (临时_列.对齐方式, 4096)
    .如果真结束
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    返回 (SendMessageA (集_目标句柄, 4123, 插入位置, 临时_项目地址))
.判断结束
.子程序 删除列, , 公开, 删除报表型列表框中指定位置处的列。
.参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
SendMessageA (集_目标句柄, #LVM_DELETECOLUMN, 列索引, 0)
.子程序 进入编辑, , 公开, 让指定表项进入编辑状态，执行本命令成功的前提是“允许编辑”属性为真。
.参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
.判断开始 (集_外部控件)
    SetActiveWindow (GetWindow (集_目标句柄, 4))
    SetFocus (集_目标句柄)
.默认
    SetFocus (集_目标句柄)
.判断结束
SendMessageA (集_目标句柄, 4119, 表项索引, 0)
.子程序 读超级列表框项目数据, , 公开, 取出全部的项目数据
.参数 列表框信息, 列表框信息, 参考 可空 数组
.局部变量 局_项目数, 整数型
.局部变量 局_计次, 整数型
局_项目数 ＝ 取表项数 ()
重定义数组 (列表框信息, 假, 局_项目数)
局_项目数 ＝ 局_项目数 － 1
.变量循环首 (0, 局_项目数, 1, 局_计次)
    列表框信息 [局_计次 ＋ 1] ＝ 取项目数据 (局_计次)
.变量循环尾 ()
.子程序 取项目数据, 列表框信息, , 取指定项目的数据
.参数 项目索引, 整数型
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局_结构, 列表框信息
.局部变量 局_列数, 整数型
.局部变量 局_数据, 字节集
.局部变量 局_计次, 整数型
.局部变量 局部_外部项目, 超级列表框1
.局部变量 临时_项目, 超级列表框0
局_列数 ＝ 取列数 () － 1
重定义数组 (局_结构.列标题, 假, 局_列数)
重定义数组 (局_结构.列图片索引, 假, 局_列数)
.判断开始 (集_外部控件)
    局部_外部项目.表项索引 ＝ 项目索引
    局部_外部项目.掩码 ＝ 1 ＋ 2 ＋ 4 ＋ 16 ＋ 8
    局部_外部项目.状态掩码 ＝ -4096
    临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
    局部_外部项目.子项目 ＝ 0
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 260)
    局部_外部项目.项目文本 ＝ 临时_数据地址2
    局部_外部项目.项目文本长度 ＝ 255
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
    .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1) ≠ 0)
        局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
        写到内存 (局_数据, 临时_项目地址, 40)
        局_结构.标题 ＝ 到文本 (集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 260))
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        局_结构.图片索引 ＝ 局部_外部项目.图片索引
        局_结构.表项数值 ＝ 局部_外部项目.项目数值
        局_结构.缩进数目 ＝ 局部_外部项目.缩进
        局_结构.状态图片索引 ＝ 局部_外部项目.状态 ÷ 4096 － 1
        局部_外部项目.掩码 ＝ 1 ＋ 2
        .变量循环首 (1, 局_列数, 1, 局_计次)
            局部_外部项目.子项目 ＝ 局_计次
            临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 260)
            局部_外部项目.项目文本 ＝ 临时_数据地址2
            局部_外部项目.项目文本长度 ＝ 255
            集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
            .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1) ≠ 0)
                局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
                写到内存 (局_数据, 临时_项目地址, 40)
                局_结构.列标题 [局_计次] ＝ 到文本 (集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 260))
                局_结构.列图片索引 [局_计次] ＝ 局部_外部项目.图片索引
            .如果真结束
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        .变量循环尾 ()
    .如果真结束
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    ' 外部控件操作.结束操作 (集_进程句柄)
.默认
    临时_项目.项目 ＝ 项目索引
    临时_项目.掩码 ＝ 1 ＋ 2 ＋ 4 ＋ 16 ＋ 8
    临时_项目.状态掩码 ＝ -4096
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    临时_项目.子项目 ＝ 0
    临时_项目.项目文本 ＝ 取空白文本 (260)
    .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址) ≠ 0)
        局_结构.标题 ＝ 临时_项目.项目文本
        局_结构.图片索引 ＝ 临时_项目.图片索引
        局_结构.表项数值 ＝ 临时_项目.项目数值
        局_结构.缩进数目 ＝ 临时_项目.缩进
        局_结构.状态图片索引 ＝ 临时_项目.状态 ÷ 4096 － 1
        临时_项目.掩码 ＝ 1 ＋ 2
        .变量循环首 (1, 局_列数, 1, 局_计次)
            临时_项目.子项目 ＝ 局_计次
            临时_项目.项目文本 ＝ 取空白文本 (260)
            .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址) ≠ 0)
                局_结构.列标题 [局_计次] ＝ 临时_项目.项目文本
                局_结构.列图片索引 [局_计次] ＝ 临时_项目.图片索引
            .如果真结束
        .变量循环尾 ()
    .如果真结束
.判断结束
返回 (局_结构)
.子程序 取文本颜色, 整数型, 公开
返回 (SendMessageA (集_目标句柄, #LVM_GETTEXTCOLOR, 0, 0))
.子程序 置文本颜色, , 公开
.参数 文本颜色, 整数型
SendMessageA (集_目标句柄, #LVM_SETTEXTCOLOR, 0, 文本颜色)
刷新显示 ()
.子程序 刷新显示, , 公开
SendMessageA (集_目标句柄, #LVM_REDRAWITEMS, 取第一项索引 (), 取可显示数量 ())
.子程序 取第一项索引, 整数型, 公开, 取在当前超级列表框中显示的第一条项目的索引。失败返回-1
返回 (SendMessageA (集_目标句柄, #LVM_GETTOPINDEX, 0, 0))
.子程序 取可显示数量, 整数型, 公开, 取当前在超级列表框的用户区中大约可以显示的项目数量
返回 (SendMessageA (集_目标句柄, #LVM_GETCOUNTPERPAGE, 0, 0))
.子程序 取文本背景颜色, 整数型, 公开
返回 (SendMessageA (集_目标句柄, #LVM_GETTEXTBKCOLOR, 0, 0))
.子程序 置文本背景颜色, , 公开
.参数 背景颜色, 整数型
SendMessageA (集_目标句柄, #LVM_SETTEXTBKCOLOR, 0, 背景颜色)
刷新显示 ()
.子程序 取背景颜色, 整数型, 公开
返回 (SendMessageA (集_目标句柄, #LVM_GETBKCOLOR, 0, 0))
.子程序 置背景颜色, , 公开
.参数 背景颜色, 整数型
SendMessageA (集_目标句柄, #LVM_SETBKCOLOR, 0, 背景颜色)
刷新显示 ()
.子程序 取类型, 整数型, 公开
.局部变量 局_类型, 整数型
局_类型 ＝ SendMessageA (集_目标句柄, #LVM_GETVIEW, 0, 0)
.判断开始 (局_类型 ＝ 0)  ' 0_大图标列表
    返回 (0)
.判断 (局_类型 ＝ 1)  ' 1_报表列表框
    返回 (3)
.判断 (局_类型 ＝ 2)  ' 2_小图标列表
    返回 (1)
.判断 (局_类型 ＝ 3)  ' 3_普通列表框
    返回 (2)
.判断 (局_类型 ＝ 4)
    返回 (4)
.默认
    返回 (-1)
.判断结束
.子程序 置类型, , 公开
.参数 类型, 整数型
.局部变量 局_类型, 整数型
.判断开始 (类型 ＝ 0)  ' 0_大图标列表
    局_类型 ＝ 0
.判断 (类型 ＝ 3)  ' 1_报表列表框
    局_类型 ＝ 1
.判断 (类型 ＝ 1)  ' 2_小图标列表
    局_类型 ＝ 2
.判断 (类型 ＝ 2)  ' 3_普通列表框
    局_类型 ＝ 3
.判断 (类型 ＝ 4)
    局_类型 ＝ 4
.默认
.判断结束
SendMessageA (集_目标句柄, #LVM_SETVIEW, 局_类型, 0)
.子程序 取背景图片, 文本型, 公开, 返回图片文件名路径
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局_结构1, 超级列表框5
.局部变量 局_结构2, 超级列表框6
.局部变量 局_结构3, 字节集
.判断开始 (集_外部控件)
    局_结构2.ulFlags ＝ 2
    局_结构2.cchImageMax ＝ 256
    临时_项目地址 ＝ 取数据_通用型 (局_结构2)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 24)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 256)
    局_结构2.pszImage ＝ 临时_数据地址2
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 24)
    SendMessageA (集_目标句柄, 4165, 0, 临时_数据地址1)
    局_结构3 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 256)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    ' 外部控件操作.结束操作 (集_进程句柄)
    返回 (到文本 (局_结构3))
.默认
    局_结构1.ulFlags ＝ 2
    局_结构1.图片路径 ＝ 取空白文本 (256)
    局_结构1.最大长度 ＝ 256
    临时_项目地址 ＝ 取数据_通用型 (局_结构1)
    SendMessageA (集_目标句柄, 4165, 0, 临时_项目地址)
    返回 (局_结构1.图片路径)
.判断结束
.子程序 置背景图片, , 公开, 设置背景图片
.参数 图片文件名, 文本型
.参数 是否平铺, 逻辑型, 可空, 可以省略。默认为真。
.局部变量 临时_数据地址1, 整数型
.局部变量 临时_数据地址2, 整数型
.局部变量 临时_项目地址, 整数型
.局部变量 局_结构1, 超级列表框5
.局部变量 局_结构2, 超级列表框6
.局部变量 局_结构3, 整数型
置文本背景颜色 (-1)
.判断开始 (集_外部控件)
    局_结构2.ulFlags ＝ 2
    局_结构2.cchImageMax ＝ 取文本长度 (图片文件名) ＋ 1
    局_结构2.xOffsetPercent ＝ 100
    局_结构2.yOffsetPercent ＝ 100
    .如果真 (是否平铺 或 是否为空 (是否平铺))
        局_结构2.ulFlags ＝ 位或 (局_结构2.ulFlags, 16)
    .如果真结束
    临时_项目地址 ＝ 取数据_通用型 (局_结构2)
    ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
    临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 24)
    临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (图片文件名) ＋ 1)
    局_结构2.pszImage ＝ 临时_数据地址2
    局_结构3 ＝ lstrcpyn_文本型 (图片文件名, 图片文件名, 0)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 24)
    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_结构3, 取文本长度 (图片文件名) ＋ 1)
    SendMessageA (集_目标句柄, 4164, 0, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
    集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
    ' 外部控件操作.结束操作 (集_进程句柄)
.默认
    局_结构1.ulFlags ＝ 2
    局_结构1.图片路径 ＝ 图片文件名
    局_结构1.最大长度 ＝ 取文本长度 (图片文件名) ＋ 1
    局_结构1.xOffsetPercent ＝ 100
    局_结构1.yOffsetPercent ＝ 100
    .如果真 (是否平铺 或 是否为空 (是否平铺))
        局_结构1.ulFlags ＝ 位或 (局_结构1.ulFlags, 16)
    .如果真结束
    临时_项目地址 ＝ 取数据_通用型 (局_结构1)
    SendMessageA (集_目标句柄, 4164, 0, 临时_项目地址)
.判断结束
.子程序 取鼠标指针所在的索引, 整数型, 公开, 如果鼠标指针在超级列表框范围内，取当前其指向的项目索引
返回 (SendMessageA (集_目标句柄, #LVM_GETHOTITEM, 0, 0))
.子程序 取项目行距, 整数型, 公开
返回 (SendMessageA (集_目标句柄, #LVM_GETITEMSPACING, 0, 0))
.子程序 取编辑框句柄, 整数型, 公开, 当列表框在进行编辑时，返回这个编辑框的句柄
返回 (SendMessageA (集_目标句柄, #LVM_GETEDITCONTROL, 0, 0))
.子程序 取表项间距, , 公开
.参数 水平间距, 整数型, 参考, 用于返回表项的水平间距
.参数 垂直间距, 整数型, 参考, 用于返回表项的垂直间距
.参数 列表框类型, 逻辑型, 可空, 可以被省略。当为真时取回小图标列表框的项目间距。当为假时取回大图标列表框的项目间距。默认为假。
.局部变量 局_数据, 字节集
局_数据 ＝ 到字节集 (SendMessageA (集_目标句柄, 4147, 到数值 (列表框类型), 0))
水平间距 ＝ 取字节集数据 (局_数据, #短整数型, 1)
垂直间距 ＝ 取字节集数据 (局_数据, #短整数型, 3)
.子程序 列排序, , 公开, 当超级列表框的类型是报表列表框时才能使用。使用本方法时，请将超级列表框的“排序方式”置为“0.不排序”
.参数 列索引, 整数型, , 要排序的列索引，从0计起。
.参数 排序方式, 逻辑型, 可空, 可以被省略。当为真时为正向排序，当为假时为逆向排序。默认为真，正向排序。
.局部变量 局_列表框信息, 列表框信息, , "0"
读超级列表框项目数据 (局_列表框信息)
全部删除 ()
.判断开始 (是否为空 (排序方式) 或 排序方式 ＝ 真)
    高速插入表项 (0, 局_列表框信息, 2048 ＋ 列索引)
.默认
    高速插入表项 (0, 局_列表框信息, 位取反 (2048 ＋ 列索引))
.判断结束
.子程序 单一选择, 逻辑型, 公开
.参数 是否单一选择, 逻辑型, 可空, 可以被省略。当被省略时，只返回当前的单一选择设置状态，而不改变其状态。
.局部变量 局_数值, 整数型
局_数值 ＝ GetWindowLongA (集_目标句柄, -16)
.如果真 (是否为空 (是否单一选择))
    返回 (位与 (局_数值, 4) ＝ 4)
.如果真结束
.判断开始 (位与 (局_数值, 4) ＝ 4 且 是否单一选择 ＝ 假)
    局_数值 ＝ 位异或 (局_数值, 4)
    SetWindowLongA (集_目标句柄, -16, 局_数值)
.默认
    局_数值 ＝ 位或 (局_数值, 4)
    SetWindowLongA (集_目标句柄, -16, 局_数值)
.判断结束
局_数值 ＝ GetWindowLongA (集_目标句柄, -16)
返回 (位与 (局_数值, 4) ＝ 4)
.子程序 取现行选中项, 整数型, 公开
返回 (SendMessageA (集_目标句柄, #LVM_GETNEXTITEM, -1, 2))
.判断开始 (单一选择 ())
    返回 (SendMessageA (集_目标句柄, #LVM_GETNEXTITEM, -1, 2))
.默认
    返回 (-1)
.判断结束
.子程序 置现行选中项, , 公开
.参数 现行选中项, 整数型
.如果真 (单一选择 (真))
    选择表项 (现行选中项)
.如果真结束
.子程序 导出Excel, 逻辑型, 公开, 把超级列表框内容导出为Excel表格文件，成功返回真，失败返回假。注：只能导出报表列表框。
.参数 保存文件, 文本型, , 保存到目标文件，后缀名一般为“xls”。注：如果文件已存在则会重写改文件，如果不能打开文件则返回假。
.参数 保留表头, 逻辑型, 可空, 是否把超级列表框表头一起导出到表格文件，如果不需要导出表头，请留空此值或者赋值“假”。
.局部变量 hFile, 整数型
.局部变量 列数, 整数型
.局部变量 行数, 整数型
.局部变量 列索引, 整数型
.局部变量 表项索引, 整数型
.局部变量 局_列标题, 文本型
.局部变量 局_行标题, 文本型
列数 ＝ 取列数 ()
行数 ＝ 取表项数 ()
.如果真 (行数 ＝ 0 或 列数 ＝ 0)
    返回 (假)
.如果真结束
hFile ＝ 打开文件 (保存文件, #重写, #无限制)
.如果真 (hFile ＝ 0)
    返回 (假)
.如果真结束
移到文件首 (hFile)
写文本行 (hFile, “<table border=” ＋ #引号 ＋ “1” ＋ #引号 ＋ “>”)
.如果真 (保留表头 ＝ 真 且 列数 ＞ 0)
    写文本行 (hFile, “  <tr>”)
    列索引 ＝ 0
    .计次循环首 (列数, )
        局_列标题 ＝ 取列标题 (列索引)
        写文本行 (hFile, “    <th>” ＋ 局_列标题 ＋ “</th>”)
        列索引 ＝ 列索引 ＋ 1
    .计次循环尾 ()
    写文本行 (hFile, “  </tr>”)
.如果真结束
.如果真 (行数 ＞ 0)
    表项索引 ＝ 0
    .计次循环首 (行数, )
        写文本行 (hFile, “  <tr>”)
        列索引 ＝ 0
        .计次循环首 (列数, )
            局_行标题 ＝ 取标题 (表项索引, 列索引, 1024)
            写文本行 (hFile, “    <td>” ＋ 局_行标题 ＋ “</td>”)
            列索引 ＝ 列索引 ＋ 1
        .计次循环尾 ()
        写文本行 (hFile, “  </tr>”)
        表项索引 ＝ 表项索引 ＋ 1
    .计次循环尾 ()
.如果真结束
写文本行 (hFile, “</table>”)
关闭文件 (hFile)
返回 (真)
.子程序 _置外部操作, , 公开, 如果是外部控件，就要用这个方法初始化
集_外部控件 ＝ 真
.子程序 _销毁外部操作, , 公开, 如果不再需要对外部控件进行初始化，可用这个销毁
集_外部控件 ＝ 假
.子程序 取表项位置, 整数型, 公开, 取出表项在列表框中的坐标位置
.参数 索引, 整数型
.参数 点, POINT, 参考, 用于装载坐标的变量
.局部变量 _POINT, 整数型
.局部变量 返回值, 整数型
.如果 (集_外部控件)
    _POINT ＝ VirtualAllocEx (集_进程句柄, 0, 8, #MEM_COMMIT, #PAGE_READWRITE)
    返回值 ＝ SendMessageA (集_目标句柄, #LVM_GETITEMPOSITION, 索引, _POINT)
    ReadProcessMemory_整数型1 (集_进程句柄, _POINT, 取数据_通用型 (点), 8, 0)
    VirtualFreeEx (集_进程句柄, _POINT, 0, #MEM_RELEASE)
.否则
    返回值 ＝ SendMessageA (集_目标句柄, #LVM_GETITEMPOSITION, 索引, 取数据_通用型 (点))
.如果结束
返回 (返回值)
.程序集 外部控件操作, , 公开
.程序集变量 系统类别, 整数型
.程序集变量 映射文件, 内存映射数据9X, , "0"
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 结束操作, , 公开
.参数 进程句柄, 整数型
.如果真 (进程句柄 ≠ 0)
    CloseHandle (进程句柄)  ' 关闭一个内核对象。
    清除数组 (映射文件)
    进程句柄 ＝ 0
.如果真结束
.子程序 打开进程, 整数型, 公开, 成功就返回进程句柄
.参数 对象句柄, 整数型
.局部变量 进程ID, 整数型
GetWindowThreadProcessId (对象句柄, 进程ID)
返回 (OpenProcess (2035711, 0, 进程ID))  ' 2035711
.子程序 写进程内存, 逻辑型, 公开
.参数 进程句柄, 整数型
.参数 数据指针, 整数型
.参数 数据地址, 整数型
.参数 数据长度, 整数型
返回 (WriteProcessMemory_整数型 (进程句柄, 数据指针, 数据地址, 数据长度, 0) ≠ 0)  ' 写进程内存
.子程序 分配外部指针, 整数型, 公开
.参数 进程句柄, 整数型
.参数 数据长度, 整数型, , 分配的数据长度
.局部变量 TEMP, 内存映射数据9X
系统类别 ＝ 取操作系统类别 ()
.判断开始 (系统类别 ＝ 3)
    返回 (VirtualAllocEx (进程句柄, 0, 数据长度, 4096, 4))
.默认
    TEMP.映射文件号 ＝ CreateFileMappingA (-1, 0, 4, 0, 数据长度, “”)  ' 创建一个新的文件映射对象
    TEMP.指针 ＝ MapViewOfFile (TEMP.映射文件号, 983071, 0, 0, 0)  ' 将一个文件映射对象映射到当前应用程序的地址空间
    重定义数组 (映射文件, 真, 取数组成员数 (映射文件) ＋ 1)
    映射文件 [取数组成员数 (映射文件)] ＝ TEMP
    返回 (TEMP.指针)
.判断结束
.子程序 销毁外部指针, , 公开
.参数 进程句柄, 整数型
.参数 外部指针, 整数型
.局部变量 成员数, 整数型
.局部变量 I, 整数型
.判断开始 (系统类别 ＝ 3)
    VirtualFreeEx (进程句柄, 外部指针, 0, 32768)  ' 在目标进程中释放内存空间。
.默认
    成员数 ＝ 取数组成员数 (映射文件)
    .变量循环首 (1, 成员数, 1, I)
        .如果真 (映射文件 [I].指针 ＝ 外部指针)
            UnmapViewOfFile (外部指针)  ' 在当前应用程序的内存地址空间解除对一个文件映射对象的映射
            CloseHandle (映射文件 [I].映射文件号)
            删除成员 (映射文件, I, )
            跳出循环 ()
        .如果真结束
    .变量循环尾 ()
.判断结束
.子程序 读外部指针数据, 字节集, 公开
.参数 进程句柄, 整数型
.参数 外部程序指针, 整数型
.参数 读取数据大小, 整数型
.局部变量 内存数据, 字节集
内存数据 ＝ 取空白字节集 (读取数据大小)
ReadProcessMemory_字节集 (进程句柄, 外部程序指针, 内存数据, 读取数据大小, 0)
返回 (内存数据)
.程序集 外部树型框, , 公开
.程序集变量 m_hItemParent, 长整数型, , "0", 有父项目的句柄组
.程序集变量 集_单一项目, TVITEMEX
.程序集变量 集_树型框项目, TVITEMEX2
.程序集变量 集_外部数据地址1, 整数型
.程序集变量 集_外部数据地址2, 整数型
.程序集变量 集_项目地址, 整数型
.程序集变量 m_hWnd, 整数型
.程序集变量 _数据地址, 整数型, , , 加入项目1 使用，可避免重复使用一些API函数
.程序集变量 _项目, TVINSERTSTRUCT, , , 加入项目1 使用
.程序集变量 _搜索回调Call, 整数型
.程序集变量 m_hProc, 整数型, , , 树型框所在进程的进程句柄, 此值作为判断是否操作外部进程, 操作内部进程此值为0
.程序集变量 m_hItems, 长整数型, , "0", 树型框所有项目句柄
.程序集变量 m_isWow64, 逻辑型, , , 是否运行在Wow64环境下, 为真则进程是32位程序
.程序集变量 m_item, 整数型, , , 项目缓冲区, 所有发送TVITEMEXW结构的都使用这个地址, 包含文本缓冲区
.程序集变量 m_itemSize, 整数型, , , m_item 当前的尺寸, 缓冲区变大时需要重新分配
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
集_单一项目.cchTextMax ＝ 260
集_树型框项目.cchTextMax ＝ 260
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.如果 (m_hProc ≠ 0)  ' 原本是外部操作
    .如果真 (m_item ≠ 0)  ' 释放旧数据
        VirtualFreeEx (m_hProc, m_item, 0, #MEM_RELEASE)
    .如果真结束
    CloseProc (m_hProc)
.否则
    .如果真 (m_item ≠ 0)
        LocalFree (m_item)
    .如果真结束
.如果结束
m_item ＝ 0
m_itemSize ＝ 0
清除数组 (m_hItems)
.子程序 初始化, 逻辑型, 公开
.参数 树型框句柄, 整数型
.参数 树型框类名, 文本型, 可空
.参数 是否操作外部控件, 逻辑型, 可空
.局部变量 项目数, 整数型, 静态
.局部变量 ret, 逻辑型
.局部变量 isWow64, 逻辑型
.局部变量 isTem32, 逻辑型
.局部变量 currentPid, 整数型
.局部变量 treePid
x64Init ()
isTem32 ＝ 系统_是否64位操作系统 () ＝ 假
m_isWow64 ＝ isTem32
.如果真 (窗口_句柄是否有效 (树型框句柄) ＝ 假)
    返回 (假)
.如果真结束
_数据地址 ＝ 0
' 相同的不再初始化
.如果真 (m_hWnd ＝ 树型框句柄 且 项目数 ＝ 取项目数 ())
    返回 (真)
.如果真结束
currentPid ＝ 进程_取自进程ID ()
treePid ＝ 窗口_句柄取进程ID (树型框句柄)
是否操作外部控件 ＝ currentPid ≠ treePid
.如果 (是否操作外部控件)
    m_hProc ＝ OpenProc (树型框句柄)
    .如果真 (m_hProc ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (isTem32 ＝ 假 且 IsWow64Process (m_hProc, m_isWow64) ＝ 假)
        m_isWow64 ＝ 真
    .如果真结束
.否则
    m_isWow64 ＝ 真
.如果结束
m_hWnd ＝ 树型框句柄
.如果真 (m_isWow64 ＝ 假)
    输出调试文本 (“不支持x64”)
    返回 (假)
.如果真结束
内部_遍历句柄 ()
返回 (真)
.子程序 OpenProc, 整数型, , 打开进程
.参数 hwnd_or_pid, 整数型
.局部变量 pid, 整数型
.判断开始 (IsWindow (hwnd_or_pid) ≠ 0)
    GetWindowThreadProcessId (hwnd_or_pid, pid)
.默认
    pid ＝ hwnd_or_pid
.判断结束
返回 (OpenProcess (#PROCESS_ALL_ACCESS, 0, pid))
.子程序 CloseProc
.参数 hProc, 整数型, 参考
.如果真 (hProc ＞ 0)
    CloseHandle (hProc)
.如果真结束
hProc ＝ 0
.子程序 make_TVITEMW, 整数型, , TVITEMEXW x64 是80个字节, x86是60个字节, 这里只设置TVITEM结构, 返回文本缓冲区地址
.参数 mask, 整数型, , +0  +0
.参数 hItem, 长整数型, , +4  +8
.参数 state, 整数型, 可空, +8  +16
.参数 stateMask, 整数型, 可空, +12 +20
.参数 cchTextMax, 整数型, 可空, +20 +32  缓冲区设置大小就有, 为0表示不使用缓冲区
.参数 iImage, 整数型, 可空, +24 +36
.参数 iSelectedImage, 整数型, 可空, +28 +40
.参数 cChildren, 整数型, 可空, +32 +44
.参数 lParam, 长整数型, 可空, +36 +48
.参数 iIntegral, 整数型, 可空, +40 +56
.参数 uStateEx, 整数型, 可空, +44 +60
.参数 hwnd, 长整数型, 可空, +48 +64  必须为NULL
.参数 iExpandedImage, 整数型, 可空, +52 +72  当项目处于展开状态时要显示的控件图像列表中图像的索引
.参数 hParent, 长整数型, 可空, -8 -16
.参数 hInsertAfter, 长整数型, 可空, -4 -8
.局部变量 pszText, 整数型, , , +16 +24
.局部变量 len, 整数型
.局部变量 iReserved, 整数型, , , +56 +76
len ＝ 4096
.判断开始 (m_hProc ≠ 0)  ' 外部进程
    .如果真 (cchTextMax ＋ 80 ＞ len)
        len ＝ cchTextMax ＋ 80
        len ＝ len ＼ 4096 × 4096 ＋ 选择 (len ％ 4096 ≠ 0, 4096, 0)  ' 4k对齐
    .如果真结束
    .如果真 (len ＞ m_itemSize)  ' 新的缓冲区比旧的大, 重新分配内存
        .如果真 (m_itemSize ≠ 0 且 m_item ≠ 0)
            VirtualFreeEx (m_hProc, m_item, 0, #MEM_RELEASE)
        .如果真结束
        m_itemSize ＝ len
        m_item ＝ VirtualAllocEx (m_hProc, 0, m_itemSize, #MEM_COMMIT, #PAGE_READWRITE)
        .如果真 (m_item ＝ 0)
            m_itemSize ＝ 0
            返回 (0)
        .如果真结束
        m_item ＝ m_item ＋ 16
    .如果真结束
    pszText ＝ m_item ＋ 80
    .判断开始 (m_isWow64)
        WriteProcessMemory_整数3 (m_hProc, m_item ＋ 0, mask, 4, 0)
        WriteProcessMemory_整数3 (m_hProc, m_item ＋ 4, hItem, 4, 0)
        .如果真 (取反 (是否为空 (hParent)))
            WriteProcessMemory_整数3 (m_hProc, m_item － 8, mask, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (hInsertAfter)))
            WriteProcessMemory_整数3 (m_hProc, m_item － 4, mask, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (state)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 8, state, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (stateMask)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 12, stateMask, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (cchTextMax)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 16, pszText, 4, 0)
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 20, cchTextMax, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iImage)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 24, iImage, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iSelectedImage)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 28, iSelectedImage, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (cChildren)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 32, cChildren, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (lParam)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 36, lParam, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iIntegral)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 40, iIntegral, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (uStateEx)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 44, uStateEx, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (hwnd)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 48, hwnd, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iExpandedImage)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 52, iExpandedImage, 4, 0)
        .如果真结束
    .默认
        WriteProcessMemory_整数3 (m_hProc, m_item ＋ 0, mask, 4, 0)
        WriteProcessMemory_整数型 (m_hProc, m_item ＋ 8, 取指针_通用型 (hItem), 8, 0)
        .如果真 (取反 (是否为空 (hParent)))
            WriteProcessMemory_整数型 (m_hProc, m_item － 16, 取指针_通用型 (hParent), 8, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (hInsertAfter)))
            WriteProcessMemory_整数型 (m_hProc, m_item － 8, 取指针_通用型 (hInsertAfter), 8, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (state)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 16, state, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (stateMask)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 20, stateMask, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (cchTextMax)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 24, pszText, 4, 0)  ' 这里申请的是32位的内存, 所以不需要拷贝8个字节
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 32, cchTextMax, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iImage)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 36, iImage, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iSelectedImage)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 40, iSelectedImage, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (cChildren)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 44, cChildren, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (lParam)))
            WriteProcessMemory_整数型 (m_hProc, m_item ＋ 48, 取指针_通用型 (lParam), 8, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iIntegral)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 56, iIntegral, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (uStateEx)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 60, uStateEx, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (hwnd)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 64, hwnd, 4, 0)
        .如果真结束
        .如果真 (取反 (是否为空 (iExpandedImage)))
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 72, iExpandedImage, 4, 0)
        .如果真结束
    .判断结束
.默认
    ' 内部进程直接申请内存, 内部进程只有32位, 所以没必要处理64位的
    .如果真 (len ＞ m_itemSize)  ' 新的缓冲区比旧的大, 重新分配内存
        .如果真 (m_itemSize ≠ 0 且 m_item ≠ 0)
            LocalFree (m_item)
        .如果真结束
        m_itemSize ＝ len
        m_item ＝ LocalAlloc (#LMEM_ZEROINIT, m_itemSize)
        .如果真 (m_item ＝ 0)
            m_itemSize ＝ 0
            返回 (0)
        .如果真结束
        m_item ＝ m_item ＋ 16
    .如果真结束
    pszText ＝ m_item ＋ 80
    __set (m_item, 0, mask)
    __set (m_item, 4, hItem)
    .如果真 (取反 (是否为空 (hParent)))
        __set (m_item － 8, 0, hParent)
    .如果真结束
    .如果真 (取反 (是否为空 (hInsertAfter)))
        __set (m_item － 4, 8, hInsertAfter)
    .如果真结束
    .如果真 (取反 (是否为空 (state)))
        __set (m_item, 8, state)
    .如果真结束
    .如果真 (取反 (是否为空 (stateMask)))
        __set (m_item, 12, stateMask)
    .如果真结束
    .如果真 (取反 (是否为空 (cchTextMax)))
        __set (m_item, 16, pszText)
        __set (m_item, 20, cchTextMax)
    .如果真结束
    .如果真 (取反 (是否为空 (iImage)))
        __set (m_item, 24, iImage)
    .如果真结束
    .如果真 (取反 (是否为空 (iSelectedImage)))
        __set (m_item, 28, iSelectedImage)
    .如果真结束
    .如果真 (取反 (是否为空 (cChildren)))
        __set (m_item, 32, cChildren)
    .如果真结束
    .如果真 (取反 (是否为空 (lParam)))
        __set (m_item, 36, lParam)
    .如果真结束
    .如果真 (取反 (是否为空 (iIntegral)))
        __set (m_item, 40, iIntegral)
    .如果真结束
    .如果真 (取反 (是否为空 (uStateEx)))
        __set (m_item, 44, uStateEx)
    .如果真结束
    .如果真 (取反 (是否为空 (hwnd)))
        __set (m_item, 48, hwnd)
    .如果真结束
    .如果真 (取反 (是否为空 (iExpandedImage)))
        __set (m_item, 52, iExpandedImage)
    .如果真结束
.判断结束
返回 (m_item)
.子程序 __SendMsgW, 长整数型
.参数 message, 整数型
.参数 wParam, 长整数型
.参数 lParam, 长整数型
返回 (SendMessageW (m_hWnd, message, wParam, lParam))
.' 如果真 (m_isWow64)
    ' 返回 (SendMessageW (m_hWnd, message, wParam, lParam))
.如果真结束
' 返回 (SendMsgW (m_hWnd, message, wParam, lParam))
.子程序 __SendMsgA, 长整数型
.参数 message, 整数型
.参数 wParam, 长整数型
.参数 lParam, 长整数型
.如果真 (m_isWow64)
    返回 (SendMessageA (m_hWnd, message, wParam, lParam))
.如果真结束
返回 (SendMsgA (m_hWnd, message, wParam, lParam))
.子程序 write_Text, 逻辑型, , Unicode格式
.参数 text, 字节集
.局部变量 len, 整数型
.局部变量 offset, 整数型
.如果真 (m_item ＝ 0)
    返回 (假)
.如果真结束
offset ＝ 80  ' 不管x86或x64文本缓冲区都是指针加80
len ＝ lstrlenW (取指针_字节集型 (text)) × 2 ＋ 2
.判断开始 (m_hProc ≠ 0)  ' 外部
    返回 (WriteProcessMemory_字节集 (m_hProc, m_item ＋ offset, text, len, 0))
.默认
    RtlMoveMemory (m_item ＋ offset, 取指针_字节集型 (text), len)
.判断结束
返回 (真)
.子程序 read_Text, 字节集, , 从缓冲区里读取文本, Unicode格式
.参数 size, 整数型, 可空, 读出长度, 为空则读取2000个字节
.局部变量 ret, 字节集
.局部变量 len, 整数型
.局部变量 offset, 整数型
.如果真 (m_item ＝ 0)
    返回 ({  })
.如果真结束
offset ＝ 80  ' 不管x86或x64文本缓冲区都是指针加80
.如果真 (size ＝ 0)
    size ＝ 2000
.如果真结束
.判断开始 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (size)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, size, 0)
.默认
    ret ＝ 指针到字节集 (m_item ＋ offset, size)
.判断结束
len ＝ lstrlenW (取指针_字节集型 (ret)) × 2 ＋ 2
.如果真 (len ＝ size)
    返回 (ret)
.如果真结束
.如果真 (len ＞ size)
    len ＝ size
.如果真结束
返回 (取字节集左边 (ret, len))
.子程序 read_State, 整数型, , 从缓冲区里取出当前状态
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 8, 16)  ' 32位和64位偏移不一样
.判断开始 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
.默认
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
.判断结束
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_StateMask, 整数型, , 从缓冲区里取出当前状态
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 12, 20)  ' 32位和64位偏移不一样
.判断开始 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
.默认
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
.判断结束
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_Image, 整数型, , 从缓冲区里取出当前状态
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 24, 36)  ' 32位和64位偏移不一样
.判断开始 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
.默认
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
.判断结束
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_SelectedImage, 整数型, , 从缓冲区里取出当前状态
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 28, 40)  ' 32位和64位偏移不一样
.判断开始 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
.默认
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
.判断结束
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_Children, 整数型, , 从缓冲区里取出当前状态
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 32, 44)  ' 32位和64位偏移不一样
.判断开始 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
.默认
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
.判断结束
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_Param, 长整数型, , 从缓冲区里取出当前状态
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 36, 48)  ' 32位和64位偏移不一样
.如果真 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (8)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 8, 0)
    返回 (取字节集数据 (ret, #长整数型, ))
.如果真结束
ret ＝ 指针到字节集 (m_item ＋ offset, 4)
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_Integral, 整数型, , 项目的高度
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 40, 56)  ' 32位和64位偏移不一样
.如果真 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    返回 (取字节集数据 (ret, #整数型, ))
.如果真结束
ret ＝ 指针到字节集 (m_item ＋ offset, 4)
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_StateEx, 整数型, , 扩展状态中的一个或多个（按位组合）
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 44, 60)  ' 32位和64位偏移不一样
.如果真 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    返回 (取字节集数据 (ret, #整数型, ))
.如果真结束
ret ＝ 指针到字节集 (m_item ＋ offset, 4)
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_hwnd, 长整数型, , 必须为NULL
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 48, 64)  ' 32位和64位偏移不一样
.如果真 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (8)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 8, 0)
    返回 (取字节集数据 (ret, #长整数型, ))
.如果真结束
ret ＝ 指针到字节集 (m_item ＋ offset, 4)
返回 (取字节集数据 (ret, #整数型, ))
.子程序 read_ExpandedImage, 整数型, , 当项目处于展开状态时要显示的控件图像列表中图像的索引
.局部变量 offset, 整数型
.局部变量 ret, 字节集
.如果真 (m_item ＝ 0)
    返回 (0)
.如果真结束
offset ＝ 选择 (m_isWow64, 52, 72)  ' 32位和64位偏移不一样
.如果真 (m_hProc ≠ 0)  ' 外部
    ret ＝ 取空白字节集 (4)
    ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    返回 (取字节集数据 (ret, #整数型, ))
.如果真结束
ret ＝ 指针到字节集 (m_item ＋ offset, 4)
返回 (取字节集数据 (ret, #整数型, ))
.子程序 取项目数, 整数型, 公开, 返回树型框中所有项目的数目。
返回 (__SendMsgW (#TVM_GETCOUNT, 0, 0))
.子程序 取项目句柄数组, 整数型, 公开
.参数 句柄组, 长整数型, 参考 数组
句柄组 ＝ m_hItems
返回 (取数组成员数 (句柄组))
.子程序 取缩进层次, 整数型, 公开, 返回指定项目所处缩进层次，层次值从1开始。如果未找到指定项目，返回 0 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (0)
.如果真结束
返回 (取缩进层次_句柄 (m_hItems [项目索引 ＋ 1]))
.子程序 取缩进层次_句柄, 整数型, 公开
.参数 项目句柄, 长整数型
.局部变量 父项目, 长整数型
.局部变量 层次, 整数型
层次 ＝ 1
父项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, 3, 项目句柄)
.判断循环首 (父项目 ≠ 0)
    父项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, 3, 父项目)
    层次 ＝ 层次 ＋ 1
.判断循环尾 ()
返回 (层次)
.子程序 取项目文本, 文本型, 公开, 返回指定项目的文本。如果该项目不存在，将返回空文本。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (“”)
.如果真结束
返回 (取项目文本_句柄 (m_hItems [项目索引 ＋ 1]))
.子程序 取项目文本W, 字节集, 公开, 返回指定项目的文本。如果该项目不存在，将返回空文本。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 ({  })
.如果真结束
返回 (取项目文本_句柄W (m_hItems [项目索引 ＋ 1]))
.子程序 取项目文本_句柄W, 字节集, 公开
.参数 项目句柄, 长整数型
.如果真 (项目句柄 ＝ 0)
    返回 ({  })
.如果真结束
make_TVITEMW (#TVIF_TEXT, 项目句柄, , , 2000, , , , , , , , , , )
__SendMsgW (#TVM_GETITEMW, 0, m_item)
返回 (read_Text (2000))
.子程序 取项目文本_句柄, 文本型, 公开
.参数 项目句柄, 长整数型
返回 (W2A (取项目文本_句柄W (项目句柄)))
.子程序 取图片, 整数型, 公开, 返回指定项目的图片索引。如果该项目不存在，将返回 -1 
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (-1)
.如果真结束
返回 (取图片_句柄 (m_hItems [项目索引 ＋ 1]))
.子程序 取图片_句柄, 整数型, 公开
.参数 项目句柄, 长整数型
.如果真 (项目句柄 ＝ 0)
    返回 (0)
.如果真结束
make_TVITEMW (#TVIF_IMAGE, 项目句柄, , , , , , , , , , , , , )
__SendMsgW (#TVM_GETITEMW, 0, m_item)
返回 (read_Image ())
.子程序 取选中图片, 整数型, 公开, 返回指定项目被选中后的图片索引。如果该项目不存在，将返回 -1 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (-1)
.如果真结束
make_TVITEMW (#TVIF_SELECTEDIMAGE, m_hItems [项目索引 ＋ 1], , , , , , , , , , , , , )
__SendMsgW (#TVM_GETITEMW, 0, m_item)
返回 (read_SelectedImage ())
.子程序 取项目数值, 整数型, 公开, 返回与指定项目相关联的数值。如果该项目不存在，将返回 0 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (-1)
.如果真结束
返回 (取项目数值_句柄 (m_hItems [项目索引 ＋ 1]))
.子程序 取项目数值_句柄, 整数型, 公开, 返回与指定项目相关联的数值。如果该项目不存在，将返回 0 。
.参数 项目句柄, 长整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目句柄 ＝ 0)
    返回 (0)
.如果真结束
make_TVITEMW (#TVIF_PARAM, 项目句柄, , , , , , , , , , , , , )
__SendMsgW (#TVM_GETITEMW, 0, m_item)
返回 (read_Param ())
.子程序 置图片, 逻辑型, 公开, 设置在指定项目首部所显示图片的索引。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
make_TVITEMW (#TVIF_IMAGE, m_hItems [项目索引 ＋ 1], , , , 图片索引, , , , , , , , , )
返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)
.子程序 置选中图片, 逻辑型, 公开, 设置指定项目被选中后所显示图片的索引。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
make_TVITEMW (#TVIF_SELECTEDIMAGE, m_hItems [项目索引 ＋ 1], , , , , 图片索引, , , , , , , , )
返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)
.子程序 置项目数值, 逻辑型, 公开, 设置与指定项目相关联的数值。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 欲置入的项目数值, 整数型, 可空, 可以被省略。该数值与指定项目相关联。如果本参数被省略，默认值为 0 。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
make_TVITEMW (#TVIF_PARAM, m_hItems [项目索引 ＋ 1], , , , , , , 欲置入的项目数值, , , , , , )
返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)
.子程序 置项目文本W, 逻辑型, 公开, 设置指定项目的文本。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 欲置入的项目文本, 字节集
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
write_Text (欲置入的项目文本)
make_TVITEMW (#TVIF_TEXT, m_hItems [项目索引 ＋ 1], , , 4000, , , , , , , , , , )
返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)
.子程序 置项目文本, 逻辑型, 公开, 设置指定项目的文本。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 欲置入的项目文本, 文本型
返回 (置项目文本W (项目索引, 编码_Ansi到Unicode (欲置入的项目文本, )))
.子程序 保证显示, , 公开
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 ()
.如果真结束
保证显示_句柄 (m_hItems [项目索引 ＋ 1])
.子程序 保证显示_句柄, , 公开
.参数 项目句柄, 长整数型, , 0 为项目一，1 为项目二，如此类推。
__SendMsgW (#TVM_ENSUREVISIBLE, 0, 项目句柄)
.子程序 扩展, , 公开, 将指打开指定项目的下属分枝。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.判断开始 (项目索引 ＞ 99999)  ' 如果大于9w，表示传进来的是句柄
    __SendMsgW (#TVM_EXPAND, #TVE_EXPAND, 项目索引)
.判断 (项目索引 ＋ 1 ≤ 取数组成员数 (m_hItems) 且 项目索引 ≥ 0)
    __SendMsgW (#TVM_EXPAND, #TVE_EXPAND, m_hItems [项目索引 ＋ 1])
.默认
.判断结束
.子程序 扩展全部, , 公开
.参数 不扩展第一项, 逻辑型, 可空
.局部变量 i, 整数型
.如果真 (取数组成员数 (m_hItemParent) ＝ 0)
    内部_遍历句柄_父项目 ()
.如果真结束
.计次循环首 (取数组成员数 (m_hItemParent), i)
    .如果真 (不扩展第一项 且 i ＝ 1)
        到循环尾 ()
    .如果真结束
    __SendMsgW (#TVM_EXPAND, #TVE_EXPAND, m_hItemParent [i])
.计次循环尾 ()
.子程序 收缩, , 公开, 缩回指定项目的下属分枝。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ≤ 取数组成员数 (m_hItems) 且 项目索引 ≥ 0)
    .判断开始 (项目索引 ＞ 99999)  ' 如果大于9w，表示传进来的是句柄
        __SendMsgW (#TVM_EXPAND, #TVE_COLLAPSE, 项目索引)
    .默认
        __SendMsgW (#TVM_EXPAND, #TVE_COLLAPSE, m_hItems [项目索引 ＋ 1])
    .判断结束
.如果真结束
.子程序 收缩全部, , 公开
.局部变量 i, 整数型
.如果真 (取数组成员数 (m_hItemParent) ＝ 0)
    内部_遍历句柄_父项目 ()
.如果真结束
.计次循环首 (取数组成员数 (m_hItemParent), i)
    .如果真 (i ＝ 1)
        到循环尾 ()
    .如果真结束
    __SendMsgW (#TVM_EXPAND, #TVE_COLLAPSE, m_hItemParent [i])
.计次循环尾 ()
.子程序 强制刷新, , 公开
内部_遍历句柄 ()
.子程序 排序, , 公开
.参数 排序1级缩进, 逻辑型, 可空, 是否排序缩进层次为1的，可空为不排序。
.参数 排序指定层次, 整数型, 可空, 可空，0=全部排序(默认)，排序大于为等于此值的缩进层次，如：2，将排序缩进层次≥2的项目，-1=不排序
.局部变量 i, 整数型
.如果真 (取数组成员数 (m_hItemParent) ＝ 0)
    内部_遍历句柄_父项目 ()
.如果真结束
.如果真 (排序1级缩进)
    __SendMsgW (#TVM_SORTCHILDREN, 0, 0)
.如果真结束
.如果真 (排序指定层次 ＝ -1)
    返回 ()
.如果真结束
.计次循环首 (取数组成员数 (m_hItemParent), i)
    .如果 (排序指定层次 ＞ 0)
        .如果真 (取缩进层次 (i) ≥ 排序指定层次)
            __SendMsgW (#TVM_SORTCHILDREN, 0, m_hItemParent [i])
        .如果真结束
    .否则
        ' 全部排序
        __SendMsgW (#TVM_SORTCHILDREN, 0, m_hItemParent [i])
    .如果结束
.计次循环尾 ()
.子程序 排序_句柄, , 公开
.参数 项目句柄, 长整数型
__SendMsgW (#TVM_SORTCHILDREN, 0, 项目句柄)
.子程序 加入项目, 整数型, 公开, 将单个或一批项目加入到树型框中，如果仅加入一个项目，成功返回加入后该项目所处的位置，失败返回 -1 。如果成批加入项目，成功返回 0 ，失败返回 -1 。成批加入项目可以用作一次性快速加入大量项目到树型框中。
.参数 父项目索引, 整数型, 可空, 可以被省略。指定欲加入项目所处的父项目，0 为项目一，1 为项目二，如此类推。如果没有父项目（即欲加入项目为顶层项目），请提供值 -1 。如果本参数被省略，默认值为 -1 。
.参数 项目数据1, 项目数据, 可空, 用于只加入一个项目，如欲批量加入，请留空
.参数 项目数据2, 项目数据, 可空 数组, 用于批量加入项目
.参数 加入方式, 整数型, 可空, 可以被省略。默认为 3
.参数 加入完成后是否排序, 逻辑型, 可空
.局部变量 成员数, 整数型
.局部变量 计次, 整数型
.局部变量 数据地址, 整数型
.局部变量 插入项目, TVINSERTSTRUCT
.局部变量 插入项目2, TVINSERTSTRUCT2
.局部变量 当前项目, 整数型
.局部变量 空白数据, 字节集
.局部变量 项目句柄, 长整数型
.判断开始 (父项目索引 ＞ 99999)  ' 如果大于9w，表示传进来的是句柄
    连续赋值 (父项目索引, 插入项目.hParent, 插入项目2.hParent)
.判断 (是否为空 (父项目索引) ＝ 假 且 父项目索引 ＋ 1 ≤ 取数组成员数 (m_hItems) 且 父项目索引 ≥ 0)
    连续赋值 (m_hItems [父项目索引 ＋ 1], 插入项目.hParent, 插入项目2.hParent)
.默认
.判断结束
.如果真 (是否为空 (加入方式) 或 加入方式 ＞ 4 或 加入方式 ＜ 1)
    加入方式 ＝ 3
.如果真结束
.判断开始 (是否为空 (项目数据1) ＝ 假)
    插入项目.hInsertAfter ＝ 多项选择 (加入方式, #TVI_ROOT, #TVI_FIRST, #TVI_LAST, #TVI_SORT)
    插入项目.pszText ＝ 项目数据1.项目文本
    插入项目.iImage ＝ 项目数据1.图片索引
    插入项目.iSelectedImage ＝ 项目数据1.选中图片索引
    插入项目.lParam ＝ 项目数据1.项目数值
    插入项目.mask ＝ #TVIF_ALL
    数据地址 ＝ 取内存变量地址_TVINSERTSTRUCT (插入项目, 插入项目, 0)
    返回 (__SendMsgW (#TVM_INSERTITEMA, 0, 数据地址))
.判断 (是否为空 (项目数据2) ＝ 假)
    __SendMsgW (#WM_SETREDRAW, 0, 0)  ' 是否使用高速插入
    .判断开始 (加入方式 ＝ 2)
        计次 ＝ 成员数
        .判断循环首 (计次 ＞ 0)
            插入项目.hInsertAfter ＝ 多项选择 (加入方式, #TVI_ROOT, #TVI_FIRST, #TVI_LAST, #TVI_SORT)
            插入项目.mask ＝ #TVIF_ALL
            插入项目.pszText ＝ 项目数据2 [计次].项目文本
            插入项目.iImage ＝ 项目数据2 [计次].图片索引
            插入项目.iSelectedImage ＝ 项目数据2 [计次].选中图片索引
            插入项目.lParam ＝ 项目数据2 [计次].项目数值
            数据地址 ＝ 取内存变量地址_TVINSERTSTRUCT (插入项目, 插入项目, 0)
            __SendMsgW (#TVM_INSERTITEMA, 0, 数据地址)
            计次 ＝ 计次 － 1
        .判断循环尾 ()
    .默认
        成员数 ＝ 取数组成员数 (项目数据2)
        .判断循环首 (计次 ＜ 成员数)
            计次 ＝ 计次 ＋ 1
            插入项目.hInsertAfter ＝ 多项选择 (加入方式, #TVI_ROOT, #TVI_FIRST, #TVI_LAST, #TVI_SORT)
            插入项目.mask ＝ #TVIF_ALL
            插入项目.pszText ＝ 项目数据2 [计次].项目文本
            插入项目.iImage ＝ 项目数据2 [计次].图片索引
            插入项目.iSelectedImage ＝ 项目数据2 [计次].选中图片索引
            插入项目.lParam ＝ 项目数据2 [计次].项目数值
            数据地址 ＝ 取内存变量地址_TVINSERTSTRUCT (插入项目, 插入项目, 0)
            项目数据2 [计次].项目句柄 ＝ __SendMsgW (#TVM_INSERTITEMA, 0, 数据地址)
            .如果真 (项目数据2 [计次].是否加粗)
                加粗_句柄 (项目数据2 [计次].项目句柄)
            .如果真结束
        .判断循环尾 ()
    .判断结束
    .如果真 (加入完成后是否排序)
        排序 (真, -1)
    .如果真结束
    __SendMsgW (#WM_SETREDRAW, 1, 0)  ' 是否使用高速插入
    返回 (0)
.默认
    返回 (-1)
.判断结束
.子程序 加入项目W, 长整数型, 公开
.参数 父项目句柄, 长整数型, 可空
.参数 项目文本, 字节集
.参数 图片索引, 整数型, 可空
.参数 选中图片索引, 整数型, 可空
.参数 项目数值, 整数型, 可空
.参数 是否加粗, 逻辑型, 可空
make_TVITEMW (#TVIF_ALL, 0, 选择 (是否加粗, #TVIS_BOLD, 0), 16, 4000, 图片索引, 选中图片索引, , 项目数值, , , , , 父项目句柄, 3)
write_Text (项目文本)
.如果真 (m_isWow64)
    返回 (__SendMsgW (#TVM_INSERTITEMW, 0, m_item － 8))
.如果真结束
返回 (__SendMsgW (#TVM_INSERTITEMW, 0, m_item － 16))
.子程序 删除项目, 逻辑型, 公开, 删除树型框中的指定项目。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
返回 (__SendMsgW (#TVM_DELETEITEM, 0, m_hItems [项目索引 ＋ 1]) ≠ 0)
.子程序 清空, , 公开, 删除树型框中的所有项目。
' __SendMsgW (#WM_SETREDRAW, 0, 0)  ' 会导致重绘失败
__SendMsgW (#TVM_DELETEITEM, 0, 0)  ' 删除项目
' __SendMsgW (#WM_SETREDRAW, 1, 0)
.子程序 取父项目, 整数型, 公开, 返回指定项目的父项目索引。如果该项目为顶层项目，将返回 -1 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 i, 整数型
.局部变量 count, 整数型
.局部变量 hParent, 长整数型
count ＝ 取数组成员数 (m_hItems)
.如果真 (项目索引 ＋ 1 ＞ count 或 项目索引 ＜ 0)
    返回 (-1)
.如果真结束
hParent ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_PARENT, m_hItems [项目索引 ＋ 1])
.如果真 (hParent ＝ 0)
    返回 (-1)
.如果真结束
.判断循环首 (i ＜ count)
    i ＝ i ＋ 1
    .如果真 (m_hItems [i] ＝ hParent)
        返回 (i － 1)
    .如果真结束
.判断循环尾 ()
返回 (-1)
.子程序 取父项目文本, 文本型, 公开
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
返回 (取项目文本 (取父项目 (项目索引)))
.子程序 是否有子项目, 逻辑型, 公开, 如果指定项目存在子项目，返回真，否则返回假。如果本命令返回真，意味着指定项目的下一项即为此项目的第一个子项目。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
make_TVITEMW (#TVIF_CHILDREN, m_hItems [项目索引 ＋ 1], , , , , , , , , , , , , )
返回 (__SendMsgW (#TVM_GETITEMW, 0, m_item) ≠ 0)
.子程序 是否已扩展, 逻辑型, 公开, 如果树型框中的指定项目具有子项目并已扩展显示，返回真，否则返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 是否自动更新数据, 逻辑型, 可空, 可以被省略。选择是否自动进行数据更新。当为真时，每次读取数据时都会对数据进行刷新，可能会因此而减慢速度。默认值为“置自动更新状态”方法所设置的状态。
.局部变量 成员数, 整数型
成员数 ＝ 取数组成员数 (m_hItems)
.如果真 (项目索引 ＋ 1 ≥ 成员数 或 项目索引 ＜ 0)
    ' 如果索引超出范围，或索引是最后一个项目
    返回 (假)
.如果真结束
成员数 ＝ __SendMsgW (#TVM_GETITEMSTATE, m_hItems [项目索引 ＋ 1], 0)
返回 (位与 (成员数, 32) ＝ 32)
.子程序 置背景色, , 公开
.参数 背景颜色, 整数型
__SendMsgW (#TVM_SETBKCOLOR, 0, 背景颜色)
.子程序 取背景色, 整数型, 公开
返回 (__SendMsgW (#TVM_GETBKCOLOR, 0, 0))
.子程序 置项目间隔, , 公开
.参数 间隔距离, 整数型, 可空, 默认为16
.如果真 (是否为空 (间隔距离))
    间隔距离 ＝ 16
.如果真结束
__SendMsgW (#TVM_SETITEMHEIGHT, 间隔距离, 0)
.子程序 取项目间隔, 整数型, 公开
返回 (__SendMsgW (#TVM_GETITEMHEIGHT, 0, 0))
.子程序 置文本颜色, , 公开
.参数 文本颜色, 整数型
__SendMsgW (#TVM_SETTEXTCOLOR, 0, 文本颜色)
.子程序 取文本颜色, 整数型, 公开
返回 (__SendMsgW (#TVM_GETTEXTCOLOR, 0, 0))
.子程序 置连线颜色, , 公开
.参数 连线颜色, 整数型
__SendMsgW (#TVM_SETLINECOLOR, 0, 连线颜色)
.子程序 取连线颜色, 整数型, 公开
返回 (__SendMsgW (#TVM_GETLINECOLOR, 0, 0))
.子程序 使用复选框, , 公开
.如果真 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_CHECKBOXES) ≠ #TVS_CHECKBOXES)
    SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_CHECKBOXES))
.如果真结束
.子程序 使用热点跟踪, , 公开
.如果真 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_TRACKSELECT) ≠ #TVS_TRACKSELECT)
    SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_TRACKSELECT))
.如果真结束
.子程序 禁止滚动条, 逻辑型, 公开, 返回禁止的状态
.参数 禁止, 逻辑型, 可空, 真为禁止，假为解除禁止。默认为真
.判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL) ≠ #TVS_NOSCROLL 且 (禁止 或 是否为空 (禁止)))
    SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL))
    返回 (真)
.判断 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL) ＝ #TVS_NOSCROLL 且 取反 (禁止) 且 取反 (是否为空 (禁止)))
    SetWindowLongA (m_hWnd, #GWL_STYLE, 位异或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL))
    返回 (假)
.默认
    返回 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL) ≠ #TVS_NOSCROLL)
.判断结束
.子程序 禁止水平滚动条, 逻辑型, 公开, 返回禁止的状态
.参数 禁止, 逻辑型, 可空, 真为禁止，假为解除禁止。默认为真
.判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL) ≠ #TVS_NOHSCROLL 且 (禁止 或 是否为空 (禁止)))
    SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL))
    返回 (真)
.判断 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL) ＝ #TVS_NOHSCROLL 且 取反 (禁止) 且 取反 (是否为空 (禁止)))
    SetWindowLongA (m_hWnd, #GWL_STYLE, 位异或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL))
    返回 (假)
.默认
    返回 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL) ≠ #TVS_NOHSCROLL)
.判断结束
.子程序 使用整行选择, 逻辑型, 公开, 要使用本功能，就不能使用显示连线。
.参数 是否使用, 逻辑型, 可空, 真为使用，假为不使用。默认为真。
.判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), 2) ≠ 2)
    .判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT) ≠ #TVS_FULLROWSELECT 且 (是否使用 或 是否为空 (是否使用)))
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT))
        返回 (真)
    .判断 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT) ＝ #TVS_FULLROWSELECT 且 取反 (是否使用) 且 取反 (是否为空 (是否使用)))
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位异或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT))
        返回 (假)
    .默认
        返回 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT) ≠ #TVS_FULLROWSELECT)
    .判断结束
.默认
    暂停 ()
    返回 (假)
.判断结束
.子程序 是否选中, 逻辑型, 公开
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 是否自动更新数据, 逻辑型, 可空, 可以被省略。选择是否自动进行数据更新。当为真时，每次读取数据时都会对数据进行刷新，可能会因此而减慢速度。默认值为“置自动更新状态”方法所设置的状态。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], , , , , , , , , , , , , )
__SendMsgW (#TVM_GETITEMW, 0, m_item)
返回 (位与 (read_State (), 8192) ＝ 8192)
.子程序 选中项目, 逻辑型, 公开, 操作成功返回真
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 是否选中, 逻辑型, 可空, 可以被省略。设置项目的选中状态，默认为真。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 (假)
.如果真结束
make_TVITEMW (位或 (#TVIF_STATE, #TVIS_BOLD), m_hItems [项目索引 ＋ 1], 选择 (是否选中 或 是否为空 (是否选中), 8192, 4096), 61440, , , , , , , , , , , )
__SendMsgW (#TVM_SETITEMW, 0, m_item)
返回 (位与 (read_State (), 8192) ＝ 8192)
.子程序 加粗, , 公开
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 ()
.如果真结束
make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], #TVIS_BOLD, 16, , , , , , , , , , , )
__SendMsgW (#TVM_SETITEMW, 0, m_item)
.子程序 加粗_句柄, , 公开
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 ()
.如果真结束
make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], #TVIS_BOLD, 16, , , , , , , , , , , )
__SendMsgW (#TVM_SETITEMW, 0, m_item)
.子程序 取消加粗, , 公开, 将指定项目的标题取消加粗显示。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 ()
.如果真结束
make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], 位取反 (#TVIS_BOLD), 16, , , , , , , , , , , )
__SendMsgW (#TVM_SETITEMW, 0, m_item)
.子程序 取可显示数量, 整数型, 公开, 取当前在树形框的用户区中大约可以显示的项目数量
返回 (__SendMsgW (#TVM_GETVISIBLECOUNT, 0, 0))
.子程序 取第一项索引, 整数型, 公开, 取在当前树形框中显示的第一条项目的索引。失败返回-1
.局部变量 hItem, 长整数型
.局部变量 count, 整数型
.局部变量 i, 整数型
hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_FIRSTVISIBLE, 0)
count ＝ 取数组成员数 (m_hItems)
.判断循环首 (i ＜ count)
    i ＝ i ＋ 1
    .如果真 (hItem ＝ m_hItems [i])
        返回 (i － 1)
    .如果真结束
.判断循环尾 ()
返回 (-1)
.子程序 取现行选中项, 整数型, 公开
.局部变量 hItem, 长整数型
.局部变量 count, 整数型
.局部变量 i, 整数型
hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CARET, 0)  ' 先取第一个根
.如果真 (hItem ≠ 0)
    count ＝ 取数组成员数 (m_hItems)
    .判断循环首 (i ＜ count)
        i ＝ i ＋ 1
        .如果真 (m_hItems [i] ＝ hItem)
            返回 (i － 1)
        .如果真结束
    .判断循环尾 ()
.如果真结束
返回 (-1)
.子程序 置现行选中项, , 公开
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
    返回 ()
.如果真结束
置现行选中项_句柄 (m_hItems [项目索引 ＋ 1])
.子程序 置现行选中项_句柄, , 公开
.参数 项目句柄, 整数型, , 0 为项目一，1 为项目二，如此类推。
__SendMsgW (#TVM_SELECTITEM, #TVGN_CARET, 项目句柄)
.子程序 取全部选中项, 变体型, 公开, 返回选中项索引数组
.局部变量 选中项索引, 变体型
.局部变量 选中项索引A, 整数型, , "0"
.局部变量 成员数, 整数型
.局部变量 成员数2, 整数型
.局部变量 i, 整数型
选中项索引.置类型 (#变体类型.数值型数组)
成员数 ＝ 取数组成员数 (m_hItems)
重定义数组 (选中项索引A, 假, 成员数)
.判断循环首 (i ＜ 成员数)
    i ＝ i ＋ 1
    make_TVITEMW (#TVIF_STATE, m_hItems [i], , , , , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, 集_外部数据地址1)
    .如果真 (位与 (read_State (), 8192) ＝ 8192)
        成员数2 ＝ 成员数2 ＋ 1
        选中项索引A [成员数2] ＝ i － 1
    .如果真结束
.判断循环尾 ()
重定义数组 (选中项索引A, 真, 成员数2)
选中项索引.赋值 (选中项索引A, )
返回 (选中项索引)
.子程序 更新缓存, , 公开, 如果项目增加或减少，需要调用此命令进行更新
内部_遍历句柄 ()
.子程序 置外部操作, , 公开
.参数 是否操作外部控件, 逻辑型
.如果真 (m_hProc ＝ 0 且 是否操作外部控件)
    m_hProc ＝ OpenProc (m_hWnd)
.如果真结束
.子程序 内部_遍历句柄
.局部变量 hParent, 长整数型
.局部变量 hItem, 长整数型
.局部变量 hItemTmp, 长整数型
.局部变量 done, 逻辑型
.局部变量 i, 整数型
清除数组 (m_hItemParent)
重定义数组 (m_hItems, 假, 取项目数 ())
hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_ROOT, 0)  ' 先取第一个根
.判断循环首 (hItem ≠ 0)
    i ＝ i ＋ 1
    m_hItems [i] ＝ hItem
    hItemTmp ＝ hItem
    hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, hItem)  ' 取第一个子
    .如果真 (hItem ＝ 0)  ' 取子取不到，就取兄弟
        hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hItemTmp)  ' 取子的兄弟
        ' 找到了兄弟就直接到循环尾，否则进入下面的循环找父项目
        .判断循环首 (hItem ＝ 0)
            hParent ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_PARENT, hItemTmp)  ' 退回上一级
            .如果真 (hParent ＝ 0)
                done ＝ 真
                跳出循环 ()
            .如果真结束
            hItemTmp ＝ hParent
            hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hParent)  ' 取父的兄弟
        .判断循环尾 ()
    .如果真结束
    .如果真 (done)
        跳出循环 ()
    .如果真结束
.判断循环尾 ()
.子程序 内部_遍历句柄_父项目, , , 遍历有子项目的句柄
.局部变量 i, 整数型
.局部变量 计次, 整数型
重定义数组 (m_hItemParent, 假, 取数组成员数 (m_hItems))
.计次循环首 (取数组成员数 (m_hItems), i)
    .如果真 (是否有子项目 (i － 1))
        计次 ＝ 计次 ＋ 1
        m_hItemParent [计次] ＝ m_hItems [i]
    .如果真结束
.计次循环尾 ()
重定义数组 (m_hItemParent, 真, 计次)
.子程序 遍历句柄_子项目, 整数型, 公开, 遍历指定父项目下的所有子项目句柄
.参数 父项目句柄, 整数型
.参数 项目数据, 项目数据, 参考 可空 数组
.参数 是否提取项目数值, 逻辑型, 可空
.局部变量 hItem, 长整数型
.局部变量 item, 项目数据
hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 父项目句柄)  ' 取第一个子
.如果真 (hItem ＝ 0)
    返回 (0)
.如果真结束
.判断开始 (是否提取项目数值)
    .判断循环首 (hItem ≠ 0)
        ' 局_项目数据.项目数值 ＝ 取项目数值_句柄 (局_子项目)
        item.项目文本 ＝ 取项目文本_句柄 (hItem)
        item.项目句柄 ＝ hItem
        加入成员 (项目数据, item)
        hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hItem)  ' 取子的兄弟
    .判断循环尾 ()
.默认
    .判断循环首 (hItem ≠ 0)
        ' 局_项目数据.项目数值 ＝ 取项目数值_句柄 (局_子项目)
        item.项目文本 ＝ 取项目文本_句柄 (hItem)
        item.项目句柄 ＝ hItem
        加入成员 (项目数据, item)
        hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hItem)  ' 取子的兄弟
    .判断循环尾 ()
.判断结束
返回 (取数组成员数 (项目数据))
.子程序 句柄取索引, 整数型, 公开, 用树型框的项目句柄获取他的项目索引
.参数 欲查找句柄, 整数型
.局部变量 i, 整数型
.局部变量 count, 整数型
i ＝ 1
count ＝ 取数组成员数 (m_hItems)
.判断循环首 (i ＜ count)  ' 循环直至左右指针相遇
    .如果真 (m_hItems [i] ＝ 欲查找句柄)
        返回 (i － 1)
    .如果真结束
    .如果真 (m_hItems [count] ＝ 欲查找句柄)
        返回 (count － 1)
    .如果真结束
    .判断开始 (i ＜ count)
        i ＝ i ＋ 1
        count ＝ count － 1
    .默认
        返回 (0)
    .判断结束
.判断循环尾 ()
返回 (0)
.子程序 索引取句柄, 整数型, 公开, 失败返回-1
.参数 项目索引, 整数型, , 从0开始
.局部变量 i, 整数型
i ＝ 项目索引 ＋ 1
.如果真 (取数组成员数 (m_hItems) ＝ 0)
    内部_遍历句柄 ()
.如果真结束
.如果真 (i ＞ 0 且 i ≤ 取数组成员数 (m_hItems))
    返回 (m_hItems [i])
.如果真结束
返回 (-1)
.子程序 查找项目, 整数型, 公开, 成功返回项目索引
.参数 项目文本, 文本型
.参数 精确查找, 逻辑型, 可空, 可空，默认为假，真=精确查找
.参数 项目句柄, 整数型, 参考 可空
.局部变量 i, 整数型
.局部变量 count, 整数型
内部_遍历句柄 ()
i ＝ 0
count ＝ 取数组成员数 (m_hItems)
.判断开始 (精确查找)
    .判断循环首 (i ＜ count)  ' 循环直至左右指针相遇
        .如果真 (取项目文本 (i) ＝ 项目文本)
            .如果真 (是否为空 (项目句柄) ＝ 假)
                项目句柄 ＝ m_hItems [i ＋ 1]
            .如果真结束
            返回 (i)
        .如果真结束
        .如果真 (取项目文本 (count) ＝ 项目文本)
            .如果真 (是否为空 (项目句柄) ＝ 假)
                项目句柄 ＝ m_hItems [count ＋ 1]
            .如果真结束
            返回 (count)
        .如果真结束
        .判断开始 (i ＜ count)
            i ＝ i ＋ 1
            count ＝ count － 1
        .默认
            返回 (-1)
        .判断结束
    .判断循环尾 ()
.默认
    .判断循环首 (i ＜ count)  ' 循环直至左右指针相遇
        .如果真 (寻找文本 (取项目文本 (i), 项目文本, , 假) ≠ -1)
            .如果真 (是否为空 (项目句柄) ＝ 假)
                项目句柄 ＝ m_hItems [i ＋ 1]
            .如果真结束
            返回 (i)
        .如果真结束
        .如果真 (寻找文本 (取项目文本 (count), 项目文本, , 假) ≠ -1)
            .如果真 (是否为空 (项目句柄) ＝ 假)
                项目句柄 ＝ m_hItems [count ＋ 1]
            .如果真结束
            返回 (count)
        .如果真结束
        .判断开始 (i ＜ count)
            i ＝ i ＋ 1
            count ＝ count － 1
        .默认
            返回 (-1)
        .判断结束
    .判断循环尾 ()
.判断结束
返回 (-1)
.子程序 查找项目数值, 整数型, 公开, 成功返回索引
.参数 项目数值, 整数型
.局部变量 i, 整数型
.局部变量 count, 整数型
i ＝ 0
count ＝ 取数组成员数 (m_hItems)
.判断循环首 (i ＜ count)  ' 循环直至左右指针相遇
    .如果真 (取项目数值 (i) ＝ 项目数值)
        返回 (i)
    .如果真结束
    .如果真 (取项目数值 (count) ＝ 项目数值)
        返回 (count)
    .如果真结束
    .判断开始 (i ＜ count)
        i ＝ i ＋ 1
        count ＝ count － 1
    .默认
        返回 (-1)
    .判断结束
.判断循环尾 ()
返回 (-1)
.子程序 查找项目_外部, 整数型, 公开, 返回结果数量，被查找出来的项目数值，对应目标树型框的项目索引
.参数 欲查找的文本, 文本型
.参数 结果树型框句柄, 整数型, , 用于存放结果的树型框句柄
.参数 查找结果是否扩展, 逻辑型, 可空, 查找后，结果项目是否扩展开
.参数 是否同步图标, 逻辑型, 可空, 是否同步项目的图标，会影响速度
.参数 搜索时禁止重绘, 逻辑型, 可空, 禁止重绘，可能会导致未找到时(只有1个项目时，无法重绘)
.参数 搜索状态回调Call, 整数型, 可空, 共2个参数，参数1:状态文本(文本型)，参数2:备用(整数)
.局部变量 父项目索引, 长整数型
.局部变量 树型框, 外部树型框
.局部变量 项目数据, 项目数据
.局部变量 一级项目, 长整数型
.局部变量 图片索引, 整数型
.局部变量 索引, 整数型
.局部变量 被查找索引, 整数型
.局部变量 搜索结果数量, 整数型
.如果真 (IsWindow (结果树型框句柄) ＝ 0)
    输出调试文本 (“结果树型框句柄 - 无效”)
    返回 (0)
.如果真结束
树型框.初始化 (结果树型框句柄, , m_hProc ≠ 0)
树型框.清空 ()
树型框.更新缓存 ()
.如果 (搜索状态回调Call ＞ 0)
    _搜索回调Call ＝ 搜索状态回调Call
.否则
    _搜索回调Call ＝ 0
.如果结束
搜索结果数量 ＝ 0
图片索引 ＝ 取图片 (0)
树型框.加入项目W (, 取项目文本W (0), 图片索引, 图片索引, 取项目数值 (0), 真)
树型框.更新缓存 ()
.如果真 (搜索时禁止重绘)
    __SendMsgW (#WM_SETREDRAW, 0, 0)
.如果真结束
一级项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_ROOT, 0)
内部_递归子项目 (m_hWnd, 一级项目, 欲查找的文本, 索引, 被查找索引, 父项目索引, 树型框, , 是否同步图标, 搜索结果数量)
.如果真 (树型框.取子项目数 (0) ＝ 0)
    索引 ＝ 索引 － 1
    被查找索引 ＝ 被查找索引 － 1
    树型框.删除项目 (0)
.如果真结束
.判断循环首 (一级项目 ＞ 0)
    索引 ＝ 索引 ＋ 1
    被查找索引 ＝ 被查找索引 ＋ 1
    一级项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, 一级项目)  ' 取兄弟
    .如果真 (一级项目 ＝ 0)
        跳出循环 ()
    .如果真结束
    图片索引 ＝ 取图片_句柄 (一级项目)
    树型框.加入项目W (, 取项目文本_句柄W (一级项目), 图片索引, 图片索引, 取项目数值_句柄 (一级项目), 真)
    树型框.更新缓存 ()
    .如果真 (取项目文本_句柄 (一级项目) ＝ “”)
        暂停 ()
    .如果真结束
    父项目索引 ＝ 索引
    内部_递归子项目 (m_hWnd, 一级项目, 欲查找的文本, 索引, 被查找索引, 父项目索引, 树型框, , 是否同步图标, 搜索结果数量)
    .如果真 (树型框.取子项目数 (父项目索引) ＝ 0)
        树型框.删除项目 (父项目索引)
        索引 ＝ 索引 － 1
    .如果真结束
.判断循环尾 ()
.如果真 (搜索时禁止重绘)
    __SendMsgW (#WM_SETREDRAW, 1, 0)
.如果真结束
.如果真 (查找结果是否扩展)
    树型框.扩展全部 ()
.如果真结束
内部_加入父项目 (, -1, , , , , )
树型框.置现行选中项 (0)
返回 (搜索结果数量)
.子程序 内部_递归子项目, 逻辑型, , 【查找项目_外部】
.参数 树型框句柄, 整数型
.参数 父项目句柄, 长整数型, 可空
.参数 欲查找的文本, 文本型
.参数 索引, 整数型, 参考
.参数 被查找索引, 整数型, 参考
.参数 主父项目索引, 整数型, 可空
.参数 树型框, 外部树型框, 可空
.参数 有查找到结果, 逻辑型, 参考 可空
.参数 是否同步图标, 逻辑型, 可空, 是否同步项目的图标，会影响速度
.参数 搜索结果数量, 整数型, 参考
.局部变量 局_子项目, 长整数型
.局部变量 局_文本, 文本型
.局部变量 内部_父项目索引, 整数型
.局部变量 图片索引, 整数型
.局部变量 Temp, 文本型
局_子项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 父项目句柄)  ' 取子项目的句柄
.如果真 (局_子项目 ＝ 0)
    返回 (假)
.如果真结束
.判断循环首 (局_子项目 ＞ 0)
    被查找索引 ＝ 被查找索引 ＋ 1
    局_文本 ＝ 取项目文本_句柄 (局_子项目)
    .判断开始 (__SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 局_子项目) ＞ 0)  ' 取子程序下是否有子
        索引 ＝ 索引 ＋ 1
        有查找到结果 ＝ 假
        .如果真 (是否同步图标)
            图片索引 ＝ 取图片_句柄 (局_子项目)
        .如果真结束
        ' 搜索回调
        .如果真 (_搜索回调Call ＞ 0)
            Temp ＝ “正在搜索[” ＋ 局_文本 ＋ “]...”
            程序_Call (_搜索回调Call, 取指针文本_ (Temp), 0, , , )
        .如果真结束
        内部_父项目索引 ＝ 内部_加入父项目 (树型框, 主父项目索引, 局_文本, 局_子项目, 索引, 图片索引, 被查找索引)
        内部_递归子项目 (树型框句柄, 局_子项目, 欲查找的文本, 索引, 被查找索引, 内部_父项目索引, 树型框, 有查找到结果, 是否同步图标, 搜索结果数量)
        .判断开始 (树型框.取子项目数 (内部_父项目索引) ＝ 0 且 寻找文本 (局_文本, 欲查找的文本, , 真) ＝ -1)
            索引 ＝ 索引 － 1
            树型框.删除项目 (内部_父项目索引)
        .默认
            搜索结果数量 ＝ 搜索结果数量 ＋ 1
        .判断结束
    .判断 (寻找文本 (局_文本, 欲查找的文本, , 真) ≠ -1)
        搜索结果数量 ＝ 搜索结果数量 ＋ 1
        索引 ＝ 索引 ＋ 1
        有查找到结果 ＝ 真
        .如果真 (是否同步图标)
            图片索引 ＝ 取图片_句柄 (局_子项目)
        .如果真结束
        树型框.加入项目W (主父项目索引, 编码_Ansi到Unicode (局_文本, ), 图片索引, 图片索引, 被查找索引, )
    .默认
    .判断结束
    局_子项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, 局_子项目)  ' 取兄弟
.判断循环尾 ()
返回 (真)
.子程序 内部_加入父项目, 整数型, , 【查找项目_外部】
.参数 树型框, 外部树型框, 可空
.参数 主父项目索引, 整数型, 可空, -1=初始化
.参数 项目文本, 文本型, 可空
.参数 父项目句柄, 整数型, 可空
.参数 索引, 整数型, 可空
.参数 图片索引, 整数型, 可空
.参数 被查找索引, 整数型, 可空
.局部变量 句项数组, 整数型, 静态, "0"
.局部变量 索引数组, 整数型, 静态, "0"
.局部变量 i, 整数型
.如果真 (主父项目索引 ＝ -1)
    清除数组 (句项数组)
    清除数组 (索引数组)
    返回 (0)
.如果真结束
.计次循环首 (取数组成员数 (索引数组), i)
    .如果真 (句项数组 [i] ＝ 父项目句柄)
        返回 (索引数组 [i])
    .如果真结束
.计次循环尾 ()
树型框.加入项目W (主父项目索引, 编码_Ansi到Unicode (项目文本, ), 图片索引, 图片索引, 被查找索引, 真)
树型框.更新缓存 ()
加入成员 (句项数组, 父项目句柄)
加入成员 (索引数组, 索引)
返回 (索引)
.子程序 取子项目数, 整数型, 公开, 获取当前选中项目的子项目数量
.参数 项目索引, 整数型, 可空, 可空，默认取选中项的子项目数
.局部变量 局_当前项目句柄, 长整数型
.局部变量 局_数量, 整数型
.局部变量 局_子项目句柄, 长整数型
.如果 (是否为空 (项目索引))
    局_当前项目句柄 ＝ __SendMsgW (#TVM_GETNEXTITEM, 9, 0)
.否则
    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (0)
    .如果真结束
    局_当前项目句柄 ＝ m_hItems [项目索引 ＋ 1]
.如果结束
局_子项目句柄 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 局_当前项目句柄)  ' 取第一个子项目的句柄
局_数量 ＝ 0
.判断循环首 (局_子项目句柄 ＞ 0)
    局_数量 ＝ 局_数量 ＋ 1
    局_子项目句柄 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, 局_子项目句柄)  ' 取同级的下一个项目句柄
.判断循环尾 ()
返回 (局_数量)
.子程序 双击项目, , 公开
.参数 项目句柄, 长整数型
.局部变量 精易_矩形, 精易_矩形
.局部变量 p, 整数型
p ＝ 取指针_通用型 (项目句柄)
精易_矩形.左边 ＝ __get (p, 0)
精易_矩形.顶边 ＝ __get (p, 4)
.计次循环首 (2, )
    __SendMsgW (#TVM_GETITEMRECT, 0, 取数据_通用型 (精易_矩形))  ' 取矩形
    __SendMsgW (#TVM_ENSUREVISIBLE, 0, 项目句柄)  ' 保证显示
.计次循环尾 ()
鼠标_消息 (m_hWnd, 精易_矩形.左边 ＋ 50, 精易_矩形.顶边 ＋ 10, , 2)
鼠标_移动 (m_hWnd, 精易_矩形.左边 ＋ 50, 精易_矩形.顶边 ＋ 10)
.子程序 取所有父项目, 整数型, 公开, 获取所有有子项目的项目索引，成功返回获取到的数量
.参数 项目索引数组, 整数型, 参考 数组, 用于存放父项目索引的数组
.参数 排除父项目, 文本型, 可空, 如：类，将不获取类下的所有有子项目的父项目索引
.参数 缩进层次, 整数型, 可空, 可空，默认为所有。获取小于或等于这个层次的父项目，缩进层次从1开始
.参数 指定缩进层次, 整数型, 可空, 可空，默认为所有。如果有指定，第23参数将无效，只获取指定缩进层次的父项目
.局部变量 i, 整数型
.局部变量 局_缩进层次, 整数型
.局部变量 局_父项目名称, 文本型
清除数组 (项目索引数组)
.计次循环首 (取项目数 (), i)
    .如果真 (是否有子项目 (i － 1) ＝ 假)
        到循环尾 ()
    .如果真结束
    .判断开始 (是否为空 (指定缩进层次) ＝ 假)
        局_缩进层次 ＝ 取缩进层次 (i － 1)
        .如果真 (局_缩进层次 ≠ 指定缩进层次)
            到循环尾 ()
        .如果真结束
    .默认
        .如果真 (缩进层次 ≠ 0)
            局_缩进层次 ＝ 取缩进层次 (i － 1)
            .如果真 (局_缩进层次 ＞ 缩进层次)
                到循环尾 ()
            .如果真结束
        .如果真结束
        .如果真 (是否为空 (排除父项目) ＝ 假)
            局_父项目名称 ＝ 取项目文本 (取父项目 (i － 1))
            .如果真 (局_父项目名称 ＝ 排除父项目)
                到循环尾 ()
            .如果真结束
        .如果真结束
    .判断结束
    加入成员 (项目索引数组, i － 1)
.计次循环尾 ()
返回 (取数组成员数 (项目索引数组))
.子程序 取上一个同级项目, 整数型, 公开
.参数 项目索引, 整数型
.局部变量 局_成员数, 整数型
.局部变量 局_项目索引, 整数型
.局部变量 i, 整数型
局_成员数 ＝ 取数组成员数 (m_hItems)
.如果真 (项目索引 ＜ 0 或 项目索引 ≥ 局_成员数)
    返回 (-1)
.如果真结束
' .常量 TVM_GETNEXTITEM, "4362", , 获取与树视图控件中的指定项目具有指定关系的项目
' .常量 TVGN_PREVIOUS, "2", , 获取指定项目的同一组中的上一个项目
局_项目索引 ＝ __SendMsgW (#TVM_GETNEXTITEM, 2, m_hItems [项目索引 ＋ 1])
.如果真 (局_项目索引 ＝ 0)
    返回 (-1)
.如果真结束
.计次循环首 (局_成员数, i)
    .如果真 (m_hItems [i] ＝ 局_项目索引)
        返回 (i － 1)
    .如果真结束
.计次循环尾 ()
返回 (-1)
.子程序 取下一个同级项目, 整数型, 公开
.参数 项目索引, 整数型
.局部变量 局_成员数, 整数型
.局部变量 局_项目索引, 整数型
.局部变量 i, 整数型
局_成员数 ＝ 取数组成员数 (m_hItems)
.如果真 (项目索引 ＜ 0 或 项目索引 ≥ 局_成员数)
    返回 (-1)
.如果真结束
' .常量 TVM_GETNEXTITEM, "4362", , 获取与树视图控件中的指定项目具有指定关系的项目
' .常量 TVGN_NEXT, "1", , 获取与指定项目相同的组中的下一个项目
局_项目索引 ＝ __SendMsgW (#TVM_GETNEXTITEM, 1, m_hItems [项目索引 ＋ 1])
.如果真 (局_项目索引 ＝ 0)
    返回 (-1)
.如果真结束
.计次循环首 (局_成员数, i)
    .如果真 (m_hItems [i] ＝ 局_项目索引)
        返回 (i － 1)
    .如果真结束
.计次循环尾 ()
返回 (-1)
.程序集 类_通用对话框, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 打开文件, 文本型, 公开, 与支持库通用对话框功能一样，成功返回一个通用对话框文件名，失败返回空。
.参数 易样式, 逻辑型, 可空, 是否使用易语言样式。可为空，默认不使用。
.参数 标题, 文本型, 可空, 仅适用于打开文件和保存文件对话框。
.参数 文件名, 文本型, 可空, 从本属性中读取的文件名包括驱动器符和全路径目录，同时本属性也用作初始对话框中的文件名编辑框。
.参数 过滤器, 文本型, 可空, 文本型。过滤器文本由单个或多个成对的文本串组成，每对文本串的第一个描述显示形式，如：“文本文件（*.txt）”；第二个指定实际的过滤匹配符，如：“*.txt”，所有各文本串之间用“|”号隔开。
.参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录。
.参数 默认文件后缀, 文本型, 可空, 指定当用户没有输入文件的后缀名称时所自动使用的文件后缀名称。
.参数 创建时提示, 逻辑型, 可空, 当类型为打开文件对话框时，如果用户指定了一个不存在的文件名称，是否提示用户即将创建它。
.参数 文件必须存在, 逻辑型, 可空, 当类型为打开文件对话框时，是否允许用户指定一个不存在的文件。
.参数 目录必须存在, 逻辑型, 可空, 是否允许用户指定一个不存在的目录。
.参数 不改变目录, 逻辑型, 可空, 在对话框关闭后是否自动返回到进入对话框时的文件目录。
.局部变量 ofn, OPENFILENAME
.局部变量 bool, 逻辑型
.局部变量 mark
ofn.结构大小 ＝ 76
ofn.窗口句柄 ＝ GetActiveWindow ()
ofn.文件标题 ＝ “Open a file”
ofn.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0, 0 }
ofn.文件名 ＝ 取空白字节集 (255)
lstrcpy_bin (ofn.文件名, 到字节集 (文件名) ＋ { 0, 0 })
ofn.初始目录 ＝ 初始目录
ofn.默认扩展名 ＝ 默认文件后缀
ofn.标题 ＝ 标题
ofn.文件名最大长度 ＝ 255
mark ＝ 524288  ' OFN_EXPLORER
.如果真 (创建时提示)
    mark ＝ 位或 (mark, 8192)  ' OFN_CREATEPROMPT
.如果真结束
.如果真 (文件必须存在)
    mark ＝ 位或 (mark, 4096)  ' OFN_FILEMUSTEXIST
.如果真结束
.如果真 (目录必须存在)
    mark ＝ 位或 (mark, 2048)  ' OFN_PATHMUSTEXIST
.如果真结束
.如果真 (不改变目录)
    mark ＝ 位或 (mark, 8)  ' OFN_NOCHANGEDIR
.如果真结束
ofn.标志 ＝ mark
.如果 (是否为空 (易样式) 或 易样式 ＝ 假)
    bool ＝ GetOpenFileNameA (ofn)
.否则
    bool ＝ GetOpenFileNamePreview (ofn)
.如果结束
返回 (选择 (bool, 到文本 (ofn.文件名), “”))
.子程序 保存文件, 文本型, 公开, 与支持库通用对话框功能一样，成功返回一个通用对话框文件名，失败返回空。
.参数 易样式, 逻辑型, 可空, 是否使用易语言样式。可为空，默认不使用。
.参数 标题, 文本型, 可空, 仅适用于打开文件和保存文件对话框。
.参数 文件名, 文本型, 可空, 从本属性中读取的文件名包括驱动器符和全路径目录，同时本属性也用作初始对话框中的文件名编辑框。
.参数 过滤器, 文本型, 可空, 格式：“MP3文件(*.mp3)|*.mp3|媒体文件(*.mpg)|*.mpg”
.参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录。
.参数 默认文件后缀, 文本型, 可空, 指定当用户没有输入文件的后缀名称时所自动使用的文件后缀名称。
.参数 文件覆盖提示, 逻辑型, 可空, 当类型为保存文件对话框时，如果用户指定了一个已经存在的文件，是否询问用户确定覆盖此文件。
.参数 目录必须存在, 逻辑型, 可空, 是否允许用户指定一个不存在的目录。
.参数 不改变目录, 逻辑型, 可空, 在对话框关闭后是否自动返回到进入对话框时的文件目录。
.局部变量 ofn, OPENFILENAME
.局部变量 bool, 逻辑型
.局部变量 mark
ofn.结构大小 ＝ 76
ofn.窗口句柄 ＝ GetActiveWindow ()
ofn.文件标题 ＝ “Save a file”
ofn.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0 } ＋ { 0 }
ofn.文件名 ＝ 取空白字节集 (255)
lstrcpy_bin (ofn.文件名, 到字节集 (文件名) ＋ { 0, 0 })
ofn.初始目录 ＝ 初始目录
ofn.默认扩展名 ＝ 默认文件后缀
ofn.标题 ＝ 标题
ofn.文件名最大长度 ＝ 255
mark ＝ 524288  ' OFN_EXPLORER
.如果真 (文件覆盖提示)
    mark ＝ 位或 (mark, 2)  ' OFN_OVERWRITEPROMPT
.如果真结束
.如果真 (目录必须存在)
    mark ＝ 位或 (mark, 2048)  ' OFN_PATHMUSTEXIST
.如果真结束
.如果真 (不改变目录)
    mark ＝ 位或 (mark, 8)  ' OFN_NOCHANGEDIR
.如果真结束
ofn.标志 ＝ mark
.如果 (是否为空 (易样式) 或 易样式 ＝ 假)
    bool ＝ GetSaveFileNameA (ofn)
.否则
    bool ＝ GetSaveFileNamePreview (ofn)
.如果结束
返回 (选择 (bool, 到文本 (ofn.文件名), “”))
.子程序 多选文件, 文本型, 公开, 显示一个文件打开对话框，允许用户选择或输入多个所需要打开的已存在文件，返回用户所选择或输入后的结果文本型。
.参数 易样式, 逻辑型, 可空, 是否使用易语言样式。可为空，默认不使用。
.参数 标题, 文本型, 可空, 可以被省略。指定文件打开对话框的标题，如果被省略，则默认为“请输入欲打开的文件：”。
.参数 过滤器, 文本型, 可空, 可以被省略。过滤器文本由单个或多个成对的文本串组成，每对文本串的第一个描述显示形式，如：“文本文件（*.txt）”；
.参数 初始目录, 文本型, 可空, 可以被省略。指定当打开对话框时所自动跳转到的目录，如果被省略，则默认为当前目录。
.局部变量 文件列表, OPENFILENAME
.局部变量 文件名, 字节集
.局部变量 文件名数组, 文本型, , "0"
.局部变量 Xh, 整数型
.局部变量 Retrun, 文本型
.局部变量 bool, 逻辑型
处理事件 ()
文件列表.结构大小 ＝ 76
文件列表.窗口句柄 ＝ GetActiveWindow ()
文件列表.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0 } ＋ { 0 }
文件列表.文件名 ＝ 取空白字节集 (4096)
文件列表.文件名最大长度 ＝ 4096
' 文件列表.文件标题 ＝ 文本_取空白文本 (文件缓冲数)
文件列表.文件标题最大长度 ＝ 4096
文件列表.初始目录 ＝ 初始目录
文件列表.标题 ＝ 标题
文件列表.标志 ＝ 524800 ＋ 8
.如果 (是否为空 (易样式) 或 易样式 ＝ 假)
    bool ＝ GetOpenFileNameA (文件列表)
.否则
    bool ＝ GetOpenFileNamePreview (文件列表)
.如果结束
.如果 (bool)
    文件名 ＝ 文件列表.文件名
    文件名 ＝ 取字节集左边 (文件名, 寻找字节集 (文件名, { 0, 0 }, ) － 1)
    .如果 (寻找字节集 (文件名, { 0 }, ) ≠ -1)
        文件名数组 ＝ 分割文本 (到文本 (子字节集替换 (文件名, { 0 }, { 124 }, , )), “|”, )
        .如果真 (取文本右边 (文件名数组 [1], 1) ≠ “\”)
            文件名数组 [1] ＝ 文件名数组 [1] ＋ “\”
        .如果真结束
        .计次循环首 (取数组成员数 (文件名数组) － 1, Xh)
            .如果 (取数组成员数 (文件名数组) － 1 ≠ Xh)
                Retrun ＝ Retrun ＋ 文件名数组 [1] ＋ 文件名数组 [Xh ＋ 1] ＋ #换行符
            .否则
                Retrun ＝ Retrun ＋ 文件名数组 [1] ＋ 文件名数组 [Xh ＋ 1]
            .如果结束
            处理事件 ()
        .计次循环尾 ()
        返回 (Retrun)
    .否则
        返回 (到文本 (文件名))
    .如果结束
.否则
    返回 (“”)
.如果结束
.子程序 选择字体, 字体, 公开, 打开选择字体对话框，成功返回字体相关信息，调用格式如； 编辑框.字体=选择字体()
.参数 字体名称, 文本型, 可空
.参数 字体大小, , 可空
.参数 字体颜色, , 可空
.参数 加粗, 逻辑型, 可空
.参数 倾斜, 逻辑型, 可空
.参数 删除线, 逻辑型, 可空
.参数 下划线, 逻辑型, 可空
.局部变量 cf, CHOOSEFONT
.局部变量 lfont, LOGFONT
.局部变量 hMem, 整数型
.局部变量 局部_字体信息, 字体
.局部变量 hDC, 整数型
lstrcpy_bytes (lfont.lfFaceName, 字体名称)
hDC ＝ GetDC (0)
lfont.lfHeight ＝ －MulDiv (字体大小, GetDeviceCaps (hDC, 90), 72)  ' 把字体转换为lfHeight，用到公式
lfont.lfWeight ＝ 选择 (是否为空 (加粗) 或 加粗 ＝ 假, 400, 700)
lfont.lfUnderline ＝ 选择 (是否为空 (下划线) 或 下划线 ＝ 假, 0, 1)
lfont.lfItalic ＝ 选择 (是否为空 (倾斜) 或 倾斜 ＝ 假, 0, 1)
lfont.lfStrikeOut ＝ 选择 (是否为空 (删除线) 或 删除线 ＝ 假, 0, 1)
lfont.lfCharSet ＝ 1
hMem ＝ GlobalAlloc (64, 60)
CopyMemory_logfont2int (hMem, lfont, 60)
cf.结构大小 ＝ 60
cf.窗口句柄 ＝ GetActiveWindow ()
cf.字体结构指针 ＝ hMem
cf.标志 ＝ 位或 (3, 256, 65536, 64, 8192)
cf.颜色值 ＝ 字体颜色
cf.字体类型 ＝ 1024
cf.最小尺寸 ＝ 8
cf.最大尺寸 ＝ 72
.如果真 (ChooseFont (cf))
    CopyMemory_int2logfont (lfont, hMem, 60)
    局部_字体信息.字体名称 ＝ 到文本 (lfont.lfFaceName)
    局部_字体信息.字体大小 ＝ cf.点大小 ÷ 10
    局部_字体信息.倾斜 ＝ lfont.lfItalic ≠ 0
    局部_字体信息.下划线 ＝ lfont.lfUnderline ＝ 1
    局部_字体信息.加粗 ＝ lfont.lfWeight ＝ 700
    局部_字体信息.删除线 ＝ lfont.lfStrikeOut ＝ 1
    局部_字体信息.角度 ＝ lfont.lfEscapement
.如果真结束
GlobalFree (hMem)
返回 (局部_字体信息)
.程序集 类_任务栏自身, , 公开, 对自身程序任务栏有效
.程序集变量 m_obj, 对象
.程序集变量 m_taskbarBtnCreatedMsg, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
m_taskbarBtnCreatedMsg ＝ RegisterWindowMessage (“TaskbarButtonCreated”)
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 _Create, 整数型
.参数 ClassId, 字节集
.参数 iid, 字节集
m_obj.清除 ()
返回 (CoCreateInstance_字节集 (ClassId, 0, #CLSCTX_INPROC_SERVER, iid, m_obj))
.子程序 取指针, 整数型, 公开
返回 (_取指针对象 (m_obj))
.子程序 显示, 逻辑型, 公开, AddTab 将窗口添加到任务栏列表
.参数 参数_窗口句柄, 整数型, , 建议至少包含 WS_CAPTION 风格
.局部变量 hr, 整数型
hr ＝ ITaskbarList_AddTab (_取指针对象 (m_obj), 参数_窗口句柄)
返回 (hr ＝ 0)
.子程序 隐藏, 逻辑型, 公开, DeleteTab 将窗口从任务栏列表删除
.参数 参数_窗口句柄, 整数型
.局部变量 hr, 整数型
hr ＝ ITaskbarList_DeleteTab (_取指针对象 (m_obj), 参数_窗口句柄)
返回 (hr ＝ 0)
.子程序 销毁, , 公开
m_obj.清除 ()
.子程序 激活, 逻辑型, 公开, ActivateTab 激活任务栏列表项
.参数 参数_窗口句柄, 整数型
.局部变量 hr, 整数型
hr ＝ ITaskbarList_ActivateTab (_取指针对象 (m_obj), 参数_窗口句柄)
返回 (hr ＝ 0)
.子程序 标记激活, 逻辑型, 公开, SetActiveAlt 将任务栏列表项标记为激活，但没有视觉效果
.参数 参数_窗口句柄, 整数型
.局部变量 hr, 整数型
hr ＝ ITaskbarList_SetActiveAlt (_取指针对象 (m_obj), 参数_窗口句柄)
返回 (hr ＝ 0)
.子程序 创建, 逻辑型, 公开
.局部变量 hr, 整数型
hr ＝ _Create (文本到CLSID (#CLSID_TaskbarList), 文本到CLSID (#IID_ITaskbarList3))
返回 (hr ＝ 0)
.子程序 置进度条值, 逻辑型, 公开, SetProgressValue
.参数 参数_窗口句柄, 整数型
.参数 参数_当前位置, 整数型
.参数 参数_总大小, 整数型
.局部变量 hr, 整数型
hr ＝ ITaskbarList_SetProgressValue (取指针 (), 参数_窗口句柄, 参数_当前位置, 参数_总大小)
返回 (hr ＝ 0)
.子程序 置进度条状态, 逻辑型, 公开, SetProgressState
.参数 参数_窗口句柄, 整数型
.参数 参数_进度条状态, 整数型, , “任务栏进度_”开头常量
.局部变量 hr, 整数型
hr ＝ ITaskbarList_SetProgressState (取指针 (), 参数_窗口句柄, 参数_进度条状态)
返回 (hr ＝ 0)
.子程序 注册选项卡, 逻辑型, 公开, RegisterTab
.参数 参数_选项卡窗口, 整数型, , 必须已注册
.参数 参数_主窗口, 整数型, , 应用程序主窗口
.局部变量 hr, 整数型
hr ＝ ITaskbarList_RegisterTab (取指针 (), 参数_选项卡窗口, 参数_主窗口)
返回 (hr ＝ 0)
.子程序 卸载选项卡, 逻辑型, 公开, UnregisterTab
.参数 参数_选项卡窗口, 整数型, , 必须已注册
.局部变量 hr, 整数型
hr ＝ ITaskbarList_UnregisterTab (取指针 (), 参数_选项卡窗口)
返回 (hr ＝ 0)
.子程序 置选项卡顺序, 逻辑型, 公开, SetTabOrder
.参数 参数_选项卡窗口, 整数型, , 必须已注册
.参数 参数_此窗口句柄之前, 整数型, , 可以为0
.局部变量 hr, 整数型
hr ＝ ITaskbarList_SetTabOrder (取指针 (), 参数_选项卡窗口, 参数_此窗口句柄之前)
返回 (hr ＝ 0)
.子程序 激活选项卡, 逻辑型, 公开, SetTabActive
.参数 参数_选项卡窗口, 整数型, , 必须已注册
.参数 参数_主窗口, 整数型
.局部变量 hr, 整数型
hr ＝ ITaskbarList_SetTabActive (取指针 (), 参数_选项卡窗口, 参数_主窗口, 0)
返回 (hr ＝ 0)
.子程序 添加按钮, 逻辑型, 公开, ThumbBarAddButtons
.参数 参数_窗口句柄, 整数型
.参数 参数_缩略图按钮组, 精易_任务栏缩略图按钮, 数组
.局部变量 thumbBtn, THUMBBUTTON
.局部变量 wstr, 字节集
.局部变量 pButton, 整数型
.局部变量 hr, 整数型
.局部变量 count, 整数型
.局部变量 i, 整数型
count ＝ 取数组成员数 (参数_缩略图按钮组)
pButton ＝ _Alloc (540 × count)
.计次循环首 (count, i)
    thumbBtn.dwMask ＝ 参数_缩略图按钮组 [i].掩码
    thumbBtn.iId ＝ 参数_缩略图按钮组 [i].ID
    thumbBtn.hIcon ＝ 参数_缩略图按钮组 [i].图标
    thumbBtn.iBitmap ＝ 参数_缩略图按钮组 [i].图片索引
    wstr ＝ A2W (参数_缩略图按钮组 [i].提示文本)
    RtlMoveMemory_bytes (thumbBtn.szTip, wstr, 取字节集长度 (wstr))
    thumbBtn.dwFlags ＝ 参数_缩略图按钮组 [i].按钮风格
    RtlMoveMemory_THUMBBUTTON2ptr (pButton ＋ (i － 1) × 540, thumbBtn, 540)
.计次循环尾 ()
hr ＝ ITaskbarList_ThumbBarAddButtons (取指针 (), 参数_窗口句柄, count, pButton)
_Free (pButton)
返回 (hr ＝ 0)
.子程序 修改按钮, 逻辑型, 公开, ThumbBarUpdateButtons
.参数 参数_窗口句柄, 整数型
.参数 参数_缩略图按钮, 精易_任务栏缩略图按钮
.局部变量 thumbBtn, THUMBBUTTON
.局部变量 wstr, 字节集
.局部变量 pButton, 整数型
.局部变量 hr, 整数型
pButton ＝ _Alloc (540)
thumbBtn.dwMask ＝ 参数_缩略图按钮.掩码
thumbBtn.iId ＝ 参数_缩略图按钮.ID
thumbBtn.hIcon ＝ 参数_缩略图按钮.图标
thumbBtn.iBitmap ＝ 参数_缩略图按钮.图片索引
wstr ＝ A2W (参数_缩略图按钮.提示文本)
RtlMoveMemory_bytes (thumbBtn.szTip, wstr, 取字节集长度 (wstr))
thumbBtn.dwFlags ＝ 参数_缩略图按钮.按钮风格
RtlMoveMemory_THUMBBUTTON2ptr (pButton, thumbBtn, 540)
hr ＝ ITaskbarList_ThumbBarUpdateButtons (取指针 (), 参数_窗口句柄, 1, pButton)
_Free (pButton)
返回 (hr ＝ 0)
.子程序 置按钮图片组, 逻辑型, 公开, ThumbBarSetImageList 设置 添加按钮 时的图片组
.参数 参数_窗口句柄, 整数型
.参数 参数_图片组, 字节集, , 图片组必须是32位，宽度高度分别为 GetSystemMetrics(SM_CXICON)  GetSystemMetrics(SM_CYICON)
.局部变量 hr, 整数型
.局部变量 istream, 整数型
.局部变量 bin, 字节集
.局部变量 len, 整数型
.局部变量 himg, 整数型
.局部变量 oldhimg, 整数型
len ＝ 取字节集长度 (参数_图片组)
bin ＝ 取字节集中间 (参数_图片组, 9, len － 8)
istream ＝ _CreateIStream (bin)
.如果真 (istream ＝ 0)
    返回 (假)
.如果真结束
himg ＝ ImageList_Read (istream)
.如果真 (himg ＝ 0)
    ITaskbarList_Release (istream)
    返回 (假)
.如果真结束
oldhimg ＝ GetPropA (参数_窗口句柄, “hImageList”)
.如果真 (oldhimg ≠ 0)
    ImageList_Destroy (oldhimg)
.如果真结束
SetPropA (参数_窗口句柄, “hImageList”, himg)
hr ＝ ITaskbarList_ThumbBarSetImageList (取指针 (), 参数_窗口句柄, himg)
ITaskbarList_Release (istream)
返回 (hr ＝ 0)
.子程序 置覆盖图标, 逻辑型, 公开, SetOverlayIcon 任务栏必须是大图标模式
.参数 参数_窗口句柄, 整数型
.参数 参数_图标句柄, 整数型, , 应该是一个小图标,16 x16 像素 96 dpi
.参数 参数_描述文本, 文本型
.局部变量 hIcon, 整数型
.局部变量 wStr, 字节集
.局部变量 hr, 整数型
hIcon ＝ GetPropA (参数_窗口句柄, “OverlayIcon”)
.如果真 (hIcon ≠ 0)
    DestroyIcon (hIcon)
.如果真结束
hIcon ＝ 参数_图标句柄
SetPropA (参数_窗口句柄, “OverlayIcon”, hIcon)
wStr ＝ A2W (参数_描述文本)
hr ＝ ITaskbarList_SetOverlayIcon (取指针 (), 参数_窗口句柄, hIcon, _取指针字节集 (wStr))
返回 (hr ＝ 0)
.子程序 置缩略图提示文本, 逻辑型, 公开, SetThumbnailTooltip
.参数 参数_窗口句柄, 整数型
.参数 参数_提示文本, 文本型
.局部变量 wStr, 字节集
.局部变量 hr, 整数型
wStr ＝ A2W (参数_提示文本)
hr ＝ ITaskbarList_SetThumbnailTooltip (取指针 (), 参数_窗口句柄, _取指针字节集 (wStr))
返回 (hr ＝ 0)
.子程序 置缩略图区域, 逻辑型, 公开, SetThumbnailClip 将窗口的一部分作为缩略图显示
.参数 参数_窗口句柄, 整数型
.参数 参数_左边, 整数型
.参数 参数_顶边, 整数型
.参数 参数_宽度, 整数型
.参数 参数_高度, 整数型
.局部变量 pRect, 整数型
.局部变量 hr, 整数型
pRect ＝ _Alloc (16)
SetRect (pRect, 参数_左边, 参数_顶边, 参数_左边 ＋ 参数_宽度, 参数_顶边 ＋ 参数_高度)
hr ＝ ITaskbarList_SetThumbnailClip (取指针 (), 参数_窗口句柄, pRect)
_Free (pRect)
返回 (hr ＝ 0)
.子程序 事件_任务栏按钮被创建, , 公开, TaskbarButtonCreated
.参数 参数_窗口句柄, 整数型
.参数 参数_事件指针, 子程序指针, , 返回值：无 （整数型 窗口句柄）
.局部变量 oldProc, 整数型
.局部变量 hLib, 整数型
.局部变量 ChangeWindowMessageFilter, 整数型
oldProc ＝ GetWindowLongA (参数_窗口句柄, #GWL_WNDPROC)
.如果真 (oldProc ≠ 到整数 (&WndProc))
    SetWindowLongA (参数_窗口句柄, #GWL_WNDPROC, 到整数 (&WndProc))
    SetPropA (参数_窗口句柄, “oldProc”, oldProc)
.如果真结束
hLib ＝ GetModuleHandleA (“User32.dll”)
.如果真 (hLib ≠ 0)
    ChangeWindowMessageFilter ＝ GetProcAddress (hLib, “ChangeWindowMessageFilter”)
    .如果真 (ChangeWindowMessageFilter ≠ 0)
        call2 (ChangeWindowMessageFilter, m_taskbarBtnCreatedMsg, #MSGFLT_ADD)
        call2 (ChangeWindowMessageFilter, #WM_COMMAND, #MSGFLT_ADD)
    .如果真结束
.如果真结束
SetPropA (参数_窗口句柄, “taskbarBtnCreatedMsg”, m_taskbarBtnCreatedMsg)
SetPropA (参数_窗口句柄, “onTaskbarBtnCreated”, 到整数 (参数_事件指针))
.子程序 事件_任务栏按钮被单击, , 公开, OnTaskbarButtonClick
.参数 参数_窗口句柄, 整数型
.参数 参数_事件指针, 子程序指针, , 返回值：无 （整数型 窗口句柄，整数型 按钮ID）
SetPropA (参数_窗口句柄, “onTaskbarBtnClick”, 到整数 (参数_事件指针))
.程序集 任务栏扩展命令
.子程序 WndProc, 整数型
.参数 hWnd, 整数型
.参数 msg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 oldProc, 整数型
.局部变量 taskbarBtnCreatedMsg, 整数型
.局部变量 onTaskbarBtnCreated, 整数型
.局部变量 onTaskbarBtnClick, 整数型
.局部变量 code, 整数型
.局部变量 hImageList, 整数型
.局部变量 hIcon, 整数型
oldProc ＝ GetPropA (hWnd, “oldProc”)
taskbarBtnCreatedMsg ＝ GetPropA (hWnd, “taskbarBtnCreatedMsg”)
.判断开始 (msg ＝ taskbarBtnCreatedMsg)
    onTaskbarBtnCreated ＝ GetPropA (hWnd, “onTaskbarBtnCreated”)
    .如果真 (onTaskbarBtnCreated ≠ 0)
        call1 (onTaskbarBtnCreated, hWnd)
    .如果真结束
.判断 (msg ＝ #WM_COMMAND)
    code ＝ 右移 (wParam, 16)
    .判断开始 (code ＝ #THBN_CLICKED)
        onTaskbarBtnClick ＝ GetPropA (hWnd, “onTaskbarBtnClick”)
        .如果真 (onTaskbarBtnClick ≠ 0)
            call2 (onTaskbarBtnClick, hWnd, 位与 (wParam, 65535))
        .如果真结束
    .默认
    .判断结束
.判断 (msg ＝ #WM_DESTROY)
    .如果真 (oldProc ≠ 0)
        SetWindowLongA (hWnd, #GWL_WNDPROC, oldProc)
        SetPropA (hWnd, “oldProc”, 0)
    .如果真结束
    hImageList ＝ GetPropA (hWnd, “hImageList”)
    .如果真 (hImageList ≠ 0)
        ImageList_Destroy (hImageList)
        SetPropA (hWnd, “hImageList”, 0)
    .如果真结束
    hIcon ＝ GetPropA (hWnd, “OverlayIcon”)
    .如果真 (hIcon ≠ 0)
        DestroyIcon (hIcon)
        SetPropA (hWnd, “OverlayIcon”, 0)
    .如果真结束
.默认
.判断结束
.如果真 (oldProc ≠ 0)
    返回 (CallWindowProcA (oldProc, hWnd, msg, wParam, lParam))
.如果真结束
返回 (DefWindowProc (hWnd, msg, wParam, lParam))
.子程序 call1, 整数型
.参数 函数地址, 整数型
.参数 参数1, 整数型
置入代码 ({ 139, 69, 8, 139, 93, 4, 137, 93, 8, 93, 91, 255, 224 })
返回 (0)
.子程序 call2, 整数型
.参数 函数地址, 整数型
.参数 参数1, 整数型
.参数 参数2, 整数型
置入代码 ({ 139, 69, 8, 139, 93, 4, 137, 93, 8, 93, 91, 255, 224 })
返回 (0)
.子程序 _Alloc, 整数型
.参数 Size, 整数型
返回 (HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Size))
.子程序 _Free
.参数 addr, 整数型
HeapFree (GetProcessHeap (), 0, addr)
.子程序 _CreateIStream, 整数型
.参数 参数_字节集, 字节集, 可空, 字节集数据。
.参数 参数_大小, 整数型, 可空, 默认为 参数_字节集 的长度
.局部变量 hMem, 整数型
.局部变量 IStream, 整数型
.局部变量 ptr, 整数型
.如果真 (是否为空 (参数_大小))
    参数_大小 ＝ 取字节集长度 (参数_字节集)
.如果真结束
hMem ＝ GlobalAlloc (位或 (#GMEM_ZEROINIT, #GMEM_MOVEABLE), 参数_大小)
CreateStreamOnHGlobal_整数型 (hMem, 1, IStream)
.如果真 (是否为空 (参数_字节集) ＝ 假)
    ptr ＝ GlobalLock (hMem)
    写到内存 (参数_字节集, ptr, 参数_大小)
    GlobalUnlock (hMem)
.如果真结束
返回 (IStream)
.子程序 创建图标自字节集, 整数型, 公开, 创建自图标文件字节集，格式必须是ICON。成功返回图标句柄
.参数 参数_字节集, 字节集
.参数 参数_索引, 整数型, 可空, 索引从0开始
.参数 参数_宽度, 整数型, 可空, 指定图标的宽度，空表示不改变
.参数 参数_高度, 整数型, 可空, 指定图标的高度，空表示不改变
.局部变量 hIcon, 整数型
.局部变量 局部_指针, 整数型
.局部变量 局部_idType, 整数型
.局部变量 局部_IconDirEntry, IconDirEntry
局部_指针 ＝ _取指针字节集 (参数_字节集)
局部_idType ＝ _指针到短整数 (局部_指针 ＋ 2)
RtlMoveMemory_IconDirEntry (局部_IconDirEntry, 局部_指针 ＋ 6 ＋ 参数_索引 × 16, 16)
hIcon ＝ CreateIconFromResourceEx (局部_指针 ＋ 局部_IconDirEntry.dwImageOffset, 局部_IconDirEntry.dwBytesInRes, 局部_idType, 196608, 参数_宽度, 参数_高度, 0)
返回 (hIcon)
.子程序 _取指针字节集, 整数型
.参数 参数_字节集, 字节集, 参考
置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 5, 5, 8, 0, 0, 0, 201, 194, 4, 0 })
返回 (0)
.子程序 _指针到短整数, 短整数型
.参数 参数_指针, 整数型
置入代码 ({ 139, 93, 8, 49, 192, 139, 3, 201, 194, 4, 0 })
' mov ebx,[ebp+08]
' xor eax,eax
' mov word eax,[ebx]
' leave
' retn 04
返回 (0)
.子程序 文本到CLSID, 字节集
.参数 参数_文本, 文本型
.局部变量 局部_clsid, 字节集
.局部变量 wzText, 字节集
局部_clsid ＝ 取空白字节集 (16)
wzText ＝ A2W (参数_文本, )
CLSIDFromString (取指针_字节集型 (wzText), 局部_clsid)
返回 (局部_clsid)
.子程序 GUID到文本, 文本型
.参数 参数_GUID, 字节集
.局部变量 局部_String, 字节集
局部_String ＝ 取空白字节集 (78)
StringFromGUID2 (参数_GUID, 局部_String, 78)
返回 (任务栏_W2A (局部_String))
.子程序 任务栏_W2A, 文本型
.参数 参数_Unicode, 字节集
.局部变量 局部_Ansi长度, 整数型
.局部变量 局部_返回值, 文本型
局部_Ansi长度 ＝ WideCharToMultiByte (0, 0, 取指针_字节集型 (参数_Unicode), -1, 取指针_文本型 (局部_返回值), 0, 0, 0)
局部_返回值 ＝ 取空白文本 (局部_Ansi长度)
WideCharToMultiByte (0, 0, 取指针_字节集型 (参数_Unicode), -1, 取指针_文本型 (局部_返回值), 局部_Ansi长度, 0, 0)
返回 (局部_返回值)
.子程序 _取指针对象, 整数型
.参数 参数_对象, 对象, 参考
置入代码 ({ 139, 69, 8, 139, 0, 139, 0, 201, 194, 4, 0 })
' mov eax,[ebp+08]
' mov eax,[eax]
' mov eax,[eax]
' leave
' retn 04
返回 (0)
.子程序 分割线, , , ——————————————————————————————————————————————————————————
.子程序 ITaskbarList_QueryInterface, 整数型
.参数 This, 整数型
.参数 riid, 整数型
.参数 ppvObject, 整数型, , __RPC__deref_out  void **
.局部变量 index, 整数型
index ＝ 0
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_AddRef, 整数型
.参数 This, 整数型
.局部变量 index, 整数型
index ＝ 1
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (0)
.子程序 ITaskbarList_Release, 整数型
.参数 This, 整数型
.局部变量 index, 整数型
index ＝ 2
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (0)
.子程序 ITaskbarList_HrInit, 整数型, , HRESULT
.参数 This, 整数型
.局部变量 index, 整数型
index ＝ 3
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_AddTab, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 4
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_DeleteTab, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 5
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_ActivateTab, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 6
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetActiveAlt, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 7
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_MarkFullscreenWindow, 整数型, , ITaskbarList2 =====================================
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 fFullscreen, 整数型, , /* [in] */ BOOL
.局部变量 index, 整数型
index ＝ 8
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetProgressValue, 整数型, , ITaskbarList3 =====================================
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 ullCompleted, 长整数型, , /* [in] */ ULONGLONG
.参数 ullTotal, 长整数型, , /* [in] */ ULONGLONG
.局部变量 index, 整数型
index ＝ 9
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetProgressState, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 tbpFlags, 整数型, , /* [in] */ TBPFLAG
.局部变量 index, 整数型
index ＝ 10
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_RegisterTab, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
.参数 hwndMDI, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 11
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_UnregisterTab, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 12
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetTabOrder, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
.参数 hwndInsertBefore, 整数型, , /* [in] */ __RPC__in HWND
.局部变量 index, 整数型
index ＝ 13
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetTabActive, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
.参数 hwndMDI, 整数型, , /* [in] */ __RPC__in HWND
.参数 dwReserved, 整数型, , /* [in] */ DWORD
.局部变量 index, 整数型
index ＝ 14
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_ThumbBarAddButtons, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 cButtons, 整数型, , /* [in] */ UINT
.参数 pButton, 整数型, , /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON
.局部变量 index, 整数型
index ＝ 15
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_ThumbBarUpdateButtons, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 cButtons, 整数型, , /* [in] */ UINT
.参数 pButton, 整数型, , /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON
.局部变量 index, 整数型
index ＝ 16
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_ThumbBarSetImageList, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 himl, 整数型, , /* [in] */ __RPC__in_opt HIMAGELIST
.局部变量 index, 整数型
index ＝ 17
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetOverlayIcon, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 hIcon, 整数型, , /* [in] */ __RPC__in HICON
.参数 pszDescription, 整数型, , /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR
.局部变量 index, 整数型
index ＝ 18
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetThumbnailTooltip, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 pszTip, 整数型, , /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR
.局部变量 index, 整数型
index ＝ 19
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.子程序 ITaskbarList_SetThumbnailClip, 整数型, , HRESULT
.参数 This, 整数型
.参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
.参数 prcClip, 整数型, , /* [in] */ __RPC__in RECT*
.局部变量 index, 整数型
index ＝ 20
置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
返回 (1)
.程序集 类_编辑框菜单, , 公开, 对自身程序编辑框有效
.程序集变量 New_call, 整数型
.程序集变量 程_菜单结构, 菜单结构, , "0"
.子程序 _初始化, , , 1
.子程序 _销毁, , , 2
移除全部 ()
.子程序 NewWndProc, 整数型, , 3
.参数 hWnd, 整数型
.参数 uMsg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 局_是否弹出, 逻辑型, 静态
.局部变量 局_菜单句柄, 整数型, 静态
.局部变量 局_总数, 整数型
.局部变量 i, 整数型
.局部变量 局_标识, 整数型
.局部变量 局_二级菜单, 整数型
.局部变量 索引, 整数型
索引 ＝ 内_取索引 (hWnd)
.如果真 (索引 ≠ 0)
    局_总数 ＝ 取数组成员数 (程_菜单结构 [索引].菜单数据)
.如果真结束
.判断开始 (uMsg ＝ #WM_ENTERIDLE 且 wParam ＝ #MSGF_MENU 且 局_菜单句柄 ＝ 0)
    .如果真 (局_是否弹出)
        局_菜单句柄 ＝ SendMessageA (lParam, #MN_GETHMENU, 0, 0)  ' 16=下拉,0无下拉,2048=分割线，256=无位图菜单，64=横宽菜单
        局_二级菜单 ＝ CreatePopupMenu ()
        InsertMenuA (局_菜单句柄, 程_菜单结构 [索引].插入位置, #MF_BYPOSITION ＋ #MF_POPUP ＋ #MF_STRING, 局_二级菜单, 程_菜单结构 [索引].菜单标题)
        .计次循环首 (局_总数, i)
            局_标识 ＝ i ＋ 2018
            .如果 (程_菜单结构 [索引].菜单数据 [i].是否插入)
                InsertMenuA (局_二级菜单, i － 1, #MF_STRING, 局_标识, 程_菜单结构 [索引].菜单数据 [i].名称)
            .否则
                AppendMenuA (局_菜单句柄, #MF_STRING, 局_标识, 程_菜单结构 [索引].菜单数据 [i].名称)
            .如果结束
        .计次循环尾 ()
    .如果真结束
.默认
    .计次循环首 (局_总数, i)
        .如果真 (uMsg ＝ i ＋ 2018)  ' 2018
            .如果真 (到整数 (程_菜单结构 [索引].菜单数据 [i].事件) ＞ 0)
                程序_执行整数子程序 (程_菜单结构 [索引].菜单数据 [i].事件, hWnd)
            .如果真结束
        .如果真结束
    .计次循环尾 ()
.判断结束
.如果真 (uMsg ＝ #WM_CONTEXTMENU)
    局_菜单句柄 ＝ 0
    局_是否弹出 ＝ SendMessageA (hWnd, #WM_NCHITTEST, 0, lParam) ≠ #HTVSCROLL
.如果真结束
返回 (CallWindowProcA (程_菜单结构 [索引].原回调地址, hWnd, uMsg, wParam, lParam))
.子程序 添加编辑框, , 公开, 插入一个主菜单
.参数 参_编辑框句柄, 整数型
.参数 参_插入位置, 整数型
.参数 参_菜单标题, 文本型
.局部变量 局_结构, 菜单结构
.如果真 (内_取索引 (参_编辑框句柄) ≠ 0)
    返回 ()
.如果真结束
.如果真 (New_call ＝ 0)
    New_call ＝ 类_取内部方法地址 (3)
.如果真结束
局_结构.窗口句柄 ＝ 参_编辑框句柄
局_结构.菜单标题 ＝ 参_菜单标题
局_结构.插入位置 ＝ 参_插入位置
清除数组 (局_结构.菜单数据)
局_结构.原回调地址 ＝ SetWindowLongA (参_编辑框句柄, #GWL_WNDPROC, New_call)
加入成员 (程_菜单结构, 局_结构)
.子程序 内_取索引, 整数型
.参数 句柄, 整数型
.局部变量 i, 整数型
.计次循环首 (取数组成员数 (程_菜单结构), i)
    .如果真 (程_菜单结构 [i].窗口句柄 ＝ 句柄)
        返回 (i)
    .如果真结束
.计次循环尾 ()
返回 (0)
.子程序 添加子菜单, , 公开, 添加二级菜单
.参数 参_编辑框句柄, 整数型
.参数 参_菜单消息, 菜单消息
.局部变量 索引, 整数型
索引 ＝ 内_取索引 (参_编辑框句柄)
.如果真 (索引 ≠ 0)
    加入成员 (程_菜单结构 [索引].菜单数据, 参_菜单消息)
.如果真结束
.子程序 重置菜单, , 公开
.参数 参_编辑框句柄, 整数型
.局部变量 索引, 整数型
索引 ＝ 内_取索引 (参_编辑框句柄)
.如果真 (索引 ≠ 0)
    清除数组 (程_菜单结构 [索引].菜单数据)
.如果真结束
.子程序 移除编辑框, , 公开
.参数 参_编辑框句柄, 整数型
.局部变量 索引, 整数型
索引 ＝ 内_取索引 (参_编辑框句柄)
.如果真 (索引 ≠ 0)
    SetWindowLongA (程_菜单结构 [索引].窗口句柄, #GWL_WNDPROC, 程_菜单结构 [索引].原回调地址)
    删除成员 (程_菜单结构, 索引, 1)
.如果真结束
.子程序 移除全部
.局部变量 i, 整数型
.局部变量 数量, 整数型
数量 ＝ 取数组成员数 (程_菜单结构)
.计次循环首 (数量, i)
    移除编辑框 (数量 － i ＋ 1)
.计次循环尾 ()
.程序集 类_外部选择夹, , 公开
.程序集变量 集_选择夹句柄, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
.子程序 初始化选择夹, 逻辑型, 公开
.参数 参_窗口句柄, 整数型
.判断开始 (集_选择夹句柄 ＝ 0)
    集_选择夹句柄 ＝ 参_窗口句柄
    返回 (真)
.默认
    返回 (假)
.判断结束
.子程序 取类名, 文本型
.参数 窗口句柄, 整数型
返回 (窗口_取类名 (窗口句柄))
.子程序 删除子夹, 逻辑型, 公开, 成功返回真
.参数 欲删除的子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.局部变量 结果, 整数型
.如果真 (欲删除的子夹索引 ＝ -1)
    欲删除的子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
结果 ＝ SendMessageA (集_选择夹句柄, #TCM_DELETEITEM, 欲删除的子夹索引, 0)
返回 (选择 (结果 ≠ 0, 真, 假))
.子程序 插入子夹, 整数型, 公开, 成功返回位置索引，失败返回-1
.参数 插入位置, 整数型, 可空, 默认为-1，加到子夹末尾。0 代表子夹一，1 代表子夹二，如此类推(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.参数 子夹标题, 文本型
.参数 子夹项目数值, 整数型, 可空, 默认为0
.参数 图片索引, 整数型, 可空, 默认为-1(无图片)
.局部变量 子夹结构, TCITEM
.局部变量 结果, 整数型
.局部变量 子夹数, 整数型
.如果真 (是否为空 (图片索引) 或 取图片组句柄 () ＝ 0)
    图片索引 ＝ -1
.如果真结束
子夹数 ＝ 取子夹数目 ()
.如果真 (是否为空 (插入位置) 或 插入位置 ＞ 子夹数 － 1 或 插入位置 ＝ -1)
    插入位置 ＝ 子夹数
.如果真结束
子夹结构.mask ＝ #TCIF_TEXT ＋ #TCIF_IMAGE ＋ #TCIF_PARAM  ' 1 +  2 + 8
子夹结构.dwState ＝ 0
子夹结构.dwStateMask ＝ 0
子夹结构.pszText ＝ 子夹标题
子夹结构.cchTextMax ＝ 0
子夹结构.iImage ＝ 图片索引
子夹结构.lParam ＝ 子夹项目数值
结果 ＝ SendMessageA (集_选择夹句柄, #TCM_INSERTITEMA, 插入位置, 取数据地址 (子夹结构, 子夹结构, 0))
.如果真 (子夹数 ＝ 0)
    UpdateWindow (GetParent (集_选择夹句柄))
.如果真结束
返回 (结果)
.子程序 取子夹数目, 整数型, 公开
返回 (SendMessageA (集_选择夹句柄, #TCM_GETITEMCOUNT, 0, 0))
.子程序 取子夹标题, 文本型, 公开
.参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.局部变量 子夹结构, TCITEM
.局部变量 结果, 整数型
.如果真 (子夹索引 ＝ -1)
    子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
子夹结构.mask ＝ #TCIF_TEXT
子夹结构.dwState ＝ 0
子夹结构.dwStateMask ＝ 0
子夹结构.pszText ＝ 取空白文本 (256)
子夹结构.cchTextMax ＝ 256
子夹结构.iImage ＝ -1
子夹结构.lParam ＝ 1
SendMessageA (集_选择夹句柄, #TCM_GETITEMA, 子夹索引, 取数据地址 (子夹结构, 子夹结构, 0))
返回 (子夹结构.pszText)
.子程序 取子夹数值, 整数型, 公开
.参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.局部变量 子夹结构, TCITEM
.局部变量 结果, 整数型
.如果真 (子夹索引 ＝ -1)
    子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
子夹结构.mask ＝ #TCIF_PARAM
SendMessageA (集_选择夹句柄, #TCM_GETITEMA, 子夹索引, 取数据地址 (子夹结构, 子夹结构, 0))
返回 (子夹结构.lParam)
.子程序 置子夹标题, 逻辑型, 公开
.参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.参数 欲置入的子夹标题, 文本型
.局部变量 子夹结构, TCITEM
.局部变量 结果, 整数型
.如果真 (子夹索引 ＝ -1)
    子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
子夹结构.mask ＝ #TCIF_TEXT
子夹结构.dwState ＝ 0
子夹结构.dwStateMask ＝ 0
子夹结构.pszText ＝ 欲置入的子夹标题
子夹结构.cchTextMax ＝ 0
子夹结构.iImage ＝ -1
子夹结构.lParam ＝ 1
结果 ＝ SendMessageA (集_选择夹句柄, #TCM_SETITEMA, 子夹索引, 取数据地址 (子夹结构, 子夹结构, 0))
返回 (选择 (结果 ≠ 0, 真, 假))
.子程序 置子夹数值, 逻辑型, 公开
.参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.参数 欲置入的子夹数值, 整数型
.局部变量 子夹结构, TCITEM
.局部变量 结果, 整数型
.如果真 (子夹索引 ＝ -1)
    子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
子夹结构.mask ＝ #TCIF_PARAM
子夹结构.lParam ＝ 欲置入的子夹数值
结果 ＝ SendMessageA (集_选择夹句柄, #TCM_SETITEMA, 子夹索引, 取数据地址 (子夹结构, 子夹结构, 0))
返回 (选择 (结果 ≠ 0, 真, 假))
.子程序 置现行子夹, , 公开
.参数 欲选择的子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.如果真 (欲选择的子夹索引 ＝ -1)
    欲选择的子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
SendMessageA (集_选择夹句柄, #TCM_SETCURFOCUS, 欲选择的子夹索引, 0)
.子程序 取现行子夹, 整数型, 公开, 0 代表子夹一，1 代表子夹二，如此类推(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
返回 (SendMessageA (集_选择夹句柄, #TCM_GETCURFOCUS, 0, 0))
.子程序 删除全部子夹, , 公开
SendMessageA (集_选择夹句柄, #TCM_DELETEALLITEMS, 0, 0)
.子程序 取图片组句柄, 整数型, 公开
返回 (SendMessageA (集_选择夹句柄, #TCM_GETIMAGELIST, 0, 0))
.子程序 取行数, 整数型, 公开
返回 (SendMessageA (集_选择夹句柄, #TCM_GETROWCOUNT, 0, 0))
.子程序 置入图片组, , 公开
.参数 图片组句柄, 整数型
SendMessageA (集_选择夹句柄, #TCM_SETIMAGELIST, 0, 图片组句柄)
.子程序 置子夹图片, 逻辑型, 公开
.参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
.参数 图片索引, 整数型
.局部变量 子夹结构, TCITEM
.局部变量 结果, 整数型
.如果真 (子夹索引 ＝ -1)
    子夹索引 ＝ 取子夹数目 () － 1
.如果真结束
子夹结构.mask ＝ #TCIF_IMAGE
子夹结构.iImage ＝ 图片索引
结果 ＝ SendMessageA (集_选择夹句柄, #TCM_SETITEMA, 子夹索引, 取数据地址 (子夹结构, 子夹结构, 0))
返回 (选择 (结果 ≠ 0, 真, 假))
.子程序 置子夹栏尺寸, , 公开
.参数 子夹栏宽度
.参数 子夹栏高度
SendMessageA (集_选择夹句柄, #TCM_SETITEMSIZE, 0, 合并整数 (子夹栏宽度, 子夹栏高度))
.子程序 置子夹栏宽度, , 公开
.参数 子夹栏宽度
SendMessageA (集_选择夹句柄, #TCM_SETMINTABWIDTH, 0, 子夹栏宽度)
.程序集 类_超级列表框, , 公开, 仅支持自身窗口的超列表框
.程序集变量 集_结构, LVINFO, , "0"
.程序集变量 集_标识, 整数型
.程序集变量 集_行高, 整数型
.程序集变量 集_超级列表框句柄, 整数型
.程序集变量 集_父窗口句柄, 整数型
.程序集变量 集_call, 整数型
.程序集变量 集_表头高度, 整数型
.程序集变量 集_新样式数组, 精易_表头样式, , "0"
.程序集变量 集_表头句柄, 整数型
.程序集变量 集_指针_超级列表框, 整数型
.程序集变量 集_子类化_超级列表框, 整数型
.程序集变量 集_子类化_表头, 整数型
.程序集变量 集_表头项, HDITEM
.程序集变量 集_指针_表头, 整数型
.程序集变量 集_列数, 整数型
.程序集变量 集_是否去除滚动条, 逻辑型
.子程序 _初始化, , , 1
.子程序 _销毁, , , 2
表项_销毁 ()
表头_销毁 ()
.子程序 子类化_超级列表框_表项, 整数型, , 3
.参数 hWnd, 整数型
.参数 uMsg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 lvcd, NMLVCUSTOMDRAW
.局部变量 i, 整数型
.局部变量 局_xmlRoot, 对象
.局部变量 局_childNode, 对象
.局部变量 row, 整数型
.局部变量 Column, 整数型
.局部变量 clrText, 整数型
.局部变量 clrTextBk, 整数型
.判断开始 (uMsg ＝ #WM_NOTIFY)
    RtlMoveMemory_NMLVCUSTOMDRAW (lvcd, lParam, 104)
    .计次循环首 (取数组成员数 (集_结构), i)
        .如果真 (lvcd.nmcd.hdr.code ＝ #NM_CUSTOMDRAW 且 lvcd.nmcd.hdr.hWndFrom ＝ 集_结构 [i].窗口句柄)
            .判断开始 (lvcd.nmcd.dwDrawStage ＝ #CDDS_PREPAINT)
                返回 (#CDRF_NOTIFYSUBITEMDRAW)
            .判断 (lvcd.nmcd.dwDrawStage ＝ #CDDS_ITEMPREPAINT)
                返回 (#CDRF_NOTIFYSUBITEMDRAW)
            .判断 (lvcd.nmcd.dwDrawStage ＝ 位或 (#CDDS_ITEMPREPAINT, #CDDS_SUBITEM))
                局_xmlRoot ＝ 集_结构 [i].对象.对象型方法 (“getElementsByTagName”, “LVINFO”).读对象型属性 (“item”, 0)
                局_childNode ＝ 局_xmlRoot.对象型方法 (“getElementsByTagName”, “Item” ＋ 到文本 (lvcd.nmcd.dwItemSpec) ＋ “.” ＋ 到文本 (lvcd.iSubItem)).读对象型属性 (“item”, 0)
                .如果 (局_childNode.是否为空 () ＝ 假)
                    row ＝ 局_childNode.数值方法 (“getAttribute”, “Row”)
                    Column ＝ 局_childNode.数值方法 (“getAttribute”, “Column”)
                    clrText ＝ 局_childNode.数值方法 (“getAttribute”, “clrText”)
                    clrTextBk ＝ 局_childNode.数值方法 (“getAttribute”, “clrTextBk”)
                    lvcd.clrText ＝ clrText
                    lvcd.clrTextBk ＝ clrTextBk
                    RtlMoveMemory_NMLVCUSTOMDRAW2 (lParam, lvcd, 104)
                    返回 (CallWindowProcA (GetPropA (hWnd, #旧窗口过程), hWnd, uMsg, wParam, lParam))
                .否则
                    lvcd.clrText ＝ SendMessageA (集_结构 [i].窗口句柄, #LVM_GETTEXTCOLOR, 0, 0)
                    lvcd.clrTextBk ＝ SendMessageA (集_结构 [i].窗口句柄, #LVM_GETBKCOLOR, 0, 0)
                    RtlMoveMemory_NMLVCUSTOMDRAW2 (lParam, lvcd, 104)
                .如果结束
            .默认
            .判断结束
        .如果真结束
    .计次循环尾 ()
.判断 (uMsg ＝ #WM_MEASUREITEM)  ' 超列计算行高时发送这个消息给父窗口，需要指定超列的 LVS_OWNERDRAWFIXED样式
    ' 因为消息是发送到父窗口中的，一个窗口中可能有多个控件，所以在实际应用中还应该判断是否是要指定的控件，可以通过MEASUREITEMSTRUCT结构中的CtlType成员或CtlID成员来进行判断。
    ' lparam=MEASUREITEMSTRUCT 结构
    ' MEASUREITEMSTRUCT中的itemHeight成员偏移长度为16
    ' 直接写内存修改itemHeight成员的高度
    写到内存 (集_行高, lParam ＋ 16, 4)
.判断 (uMsg ＝ #WM_NCCALCSIZE)
    .判断开始 (集_是否去除滚动条)
        返回 (1)
    .默认
    .判断结束
.默认
.判断结束
返回 (CallWindowProcA (集_标识, hWnd, uMsg, wParam, lParam))
.子程序 子类化_超级列表框_表头, 整数型, , 4   子类化超列
.参数 hwnd, 整数型, , 超列的句柄
.参数 msg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 hDC, 整数型
.局部变量 局_列索引, 整数型
.局部变量 局_矩形, RECT
.局部变量 局_刷子, 整数型
.局部变量 局_背景色, 整数型
.局部变量 局_文本色, 整数型
.局部变量 局_颜色, 整数型
.局部变量 drawItemStruct, DRAWITEMSTRUCT
.局部变量 buf, 字节集
.局部变量 局_返回, 整数型
.局部变量 局_新样式, 精易_表头样式
.判断开始 (msg ＝ #WM_DRAWITEM)
    CopyMemory_DRAWITEMSTRUCT (drawItemStruct, lParam, 48)
    hDC ＝ drawItemStruct.hDC
    局_列索引 ＝ drawItemStruct.itemID
    局_矩形 ＝ drawItemStruct.rcItem
    局_新样式 ＝ 内_索引转样式 (局_列索引)
    .判断开始 (局_新样式.参_列索引 ≠ -1)
        局_背景色 ＝ 局_新样式.参_背景色
        局_文本色 ＝ 局_新样式.参_文本色
    .默认
        局_背景色 ＝ #浅灰
        局_文本色 ＝ #黑色
    .判断结束
    局_刷子 ＝ CreateSolidBrush (局_背景色)
    FillRect_RECT (hDC, 局_矩形, 局_刷子)
    DeleteObject (局_刷子)
    局_颜色 ＝ SetTextColor (hDC, 局_文本色)
    SetBkMode (hDC, #TRANSPARENT)
    集_表头项.mask ＝ #HDI_TEXT
    集_表头项.cchTextMax ＝ 100
    buf ＝ 取空白字节集 (100)
    集_表头项.pszText ＝ 取空白字节集 (256)  ' 取变量地址 (buf)
    SendMessage_HDITEM (集_表头句柄, #HDM_GETITEM, 局_列索引, 集_表头项)
    DrawText_RECT (hDC, 到文本 (集_表头项.pszText), -1, 局_矩形, 位或 (#DT_CENTER, #DT_VCENTER, #DT_SINGLELINE))
    SetTextColor (hDC, 局_颜色)
.默认
.判断结束
局_返回 ＝ CallWindowProcA (集_子类化_超级列表框, hwnd, msg, wParam, lParam)
返回 (局_返回)
.子程序 子类化_表头, 整数型, , 5  子类化超列表头
.参数 hwnd, 整数型, , 超列表头的句柄
.参数 msg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 局_返回, 整数型
局_返回 ＝ CallWindowProcA (集_子类化_表头, hwnd, msg, wParam, lParam)
.如果真 (msg ＝ #HDM_LAYOUT)
    写到内存 (集_表头高度, 指针_到整数 (lParam) ＋ 4, 4)  ' 27为新表头高度
    写到内存 (集_表头高度, 指针_到整数 (lParam ＋ 4) ＋ 20, 4)
    ' SetHDItem ()
.如果真结束
返回 (局_返回)
.子程序 初始化, , 公开
.参数 父窗口句柄, 整数型
.参数 超级列表框句柄, 整数型
集_父窗口句柄 ＝ 父窗口句柄
集_超级列表框句柄 ＝ 超级列表框句柄
.子程序 表项_销毁, , , 清除子类化
.如果真 (集_标识 ≠ 0)
    SetWindowLongA (集_父窗口句柄, -4, 到整数 (集_标识))
    类_释放内部方法地址 (集_call)
.如果真结束
CoUninitialize ()
.子程序 表项_初始化, , 公开
重定义数组 (集_结构, 假, 0)
集_call ＝ 类_取内部方法地址 (3)
集_标识 ＝ SetWindowLongA (集_父窗口句柄, #GWL_WNDPROC, 集_call)
.子程序 表项_置行列颜色, , 公开, 设置超级列表框表项颜色
.参数 表项行号, 整数型
.参数 表项列号, 整数型
.参数 文本颜色, 整数型
.参数 背景颜色, 整数型
.局部变量 局_标识, 整数型
.局部变量 局_结构, LVINFO
.局部变量 局_是否存在, 逻辑型
.局部变量 i, 整数型
.局部变量 局_xmlRoot, 对象
.局部变量 局_childNode, 对象
.局部变量 局_NodeName, 文本型
.计次循环首 (取数组成员数 (集_结构), i)
    .如果真 (集_结构 [i].窗口句柄 ＝ 集_超级列表框句柄)
        局_结构 ＝ 集_结构 [i]
        局_是否存在 ＝ 真
        跳出循环 ()
    .如果真结束
.计次循环尾 ()
.如果 (局_是否存在 ＝ 假)  ' 
    局_结构.窗口句柄 ＝ 集_超级列表框句柄
    CoInitialize (0)
    .如果真 (局_结构.对象.创建 (“Microsoft.XMLDOM”, ) ＝ 假)
        局_结构.对象.创建 (“MSXML.DOMDocument”, )
    .如果真结束
    局_xmlRoot ＝ 局_结构.对象.对象型方法 (“createElement”, “LVINFO”)
    局_xmlRoot.方法 (“setAttribute”, “hParent”, 集_父窗口句柄)
    局_xmlRoot.方法 (“setAttribute”, “hWnd”, 集_超级列表框句柄)
.否则
    局_xmlRoot ＝ 局_结构.对象.对象型方法 (“getElementsByTagName”, “LVINFO”).读对象型属性 (“item”, 0)
.如果结束
局_NodeName ＝ “Item” ＋ 到文本 (表项行号) ＋ “.” ＋ 到文本 (表项列号)
局_childNode ＝ 局_结构.对象.对象型方法 (“getElementsByTagName”, 局_NodeName).读对象型属性 (“item”, 0)
.如果真 (局_childNode.是否为空 ())
    局_childNode ＝ 局_结构.对象.对象型方法 (“createElement”, 局_NodeName)
.如果真结束
局_childNode.数值方法 (“setAttribute”, “Row”, 表项行号)
局_childNode.数值方法 (“setAttribute”, “Column”, 表项列号)
局_childNode.数值方法 (“setAttribute”, “clrText”, 文本颜色)
局_childNode.数值方法 (“setAttribute”, “clrTextBk”, 背景颜色)
局_xmlRoot.方法 (“appendChild”, 局_childNode)
局_结构.对象.方法 (“appendChild”, 局_xmlRoot)
.如果 (局_是否存在 ＝ 假)
    加入成员 (集_结构, 局_结构)
.否则
    集_结构 [i] ＝ 局_结构
.如果结束
InvalidateRect (集_超级列表框句柄, 0, 1)
.子程序 表项_删除行列颜色, , 公开
.参数 表项行号, 整数型
.参数 表项列号, 整数型
.局部变量 i, 整数型
.局部变量 局_xmlRoot, 对象
.局部变量 局_childNode, 对象
.计次循环首 (取数组成员数 (集_结构), i)
    .如果真 (集_结构 [i].窗口句柄 ＝ 集_超级列表框句柄)
        局_xmlRoot ＝ 集_结构 [i].对象.对象型方法 (“getElementsByTagName”, “LVINFO”).读对象型属性 (“item”, 0)
        局_childNode ＝ 局_xmlRoot.对象型方法 (“getElementsByTagName”, “Item” ＋ 到文本 (表项行号) ＋ “.” ＋ 到文本 (表项列号)).读对象型属性 (“item”, 0)
        .如果真 (局_childNode.是否为空 () ＝ 假)
            局_xmlRoot.方法 (“removeChild”, 局_childNode)
            InvalidateRect (集_超级列表框句柄, 0, 1)
        .如果真结束
    .如果真结束
.计次循环尾 ()
.子程序 表项_清空行列颜色, , 公开
.局部变量 i, 整数型
.变量循环首 (取数组成员数 (集_结构), 1, -1, i)
    .如果真 (集_结构 [i].窗口句柄 ＝ 集_超级列表框句柄)
        删除成员 (集_结构, i, )
        InvalidateRect (集_超级列表框句柄, 0, 1)
    .如果真结束
.变量循环尾 ()
.子程序 表项_置行高, , 公开, 设置超级列表框行高
.参数 行高, 整数型
.局部变量 winpos, WINDOWPOS
.局部变量 OldStyle, 整数型
集_行高 ＝ 行高
winpos.hwnd ＝ 集_超级列表框句柄
OldStyle ＝ GetWindowLongA (winpos.hwnd, #GWL_STYLE)
SetWindowLongA (winpos.hwnd, #GWL_STYLE, 位或 (OldStyle, #LVS_OWNERDRAWFIXED))
SendMessageWINDOWPOS (winpos.hwnd, #WM_WINDOWPOSCHANGED, 0, winpos)
SetWindowLongA (winpos.hwnd, #GWL_STYLE, OldStyle)
SendMessageA (winpos.hwnd, #LVM_UPDATE, 0, 0)
.子程序 表项_去除滚动条, , 公开, 去除超列滚动条
.参数 参_是否去除, 逻辑型, , 真=去除，假=不去除
集_是否去除滚动条 ＝ 参_是否去除
.子程序 方法1, , , 以上为  表项相关
.子程序 表头_设置新样式, , 公开
.参数 参_表头高度, 整数型
.参数 参_新样式数组, 精易_表头样式, 数组
' 该例程收录自;https://bbs.125.la/thread-14355436-1-1.html
' 原作者：http://bbs.eyuyan.com/read.php?tid=410674
集_表头高度 ＝ 参_表头高度
集_新样式数组 ＝ 参_新样式数组
集_表头句柄 ＝ SendMessageA (集_超级列表框句柄, #LVM_GETHEADER, 0, 0)  ' 取表头句柄
集_列数 ＝ SendMessageA (集_表头句柄, #HDM_GETITEMCOUNT, 0, 0)
集_指针_超级列表框 ＝ 类_取内部方法地址 (4)
集_指针_表头 ＝ 类_取内部方法地址 (5)
集_子类化_超级列表框 ＝ SetWindowLongA (集_超级列表框句柄, -4, 集_指针_超级列表框)  ' 子类化超列
集_子类化_表头 ＝ SetWindowLongA (集_表头句柄, -4, 集_指针_表头)  ' 子类化超列表头
内_设置表头项 ()
SendMessageA (集_超级列表框句柄, #LVM_UPDATE, 0, 0)
.子程序 表头_销毁, , , 清除子类化，清除样式数组
清除数组 (集_新样式数组)
.如果真 (集_子类化_表头 ≠ 0)
    SetWindowLongA (集_表头句柄, -4, 集_指针_表头)
    类_释放内部方法地址 (集_指针_表头)
.如果真结束
.如果真 (集_子类化_超级列表框 ≠ 0)
    SetWindowLongA (集_超级列表框句柄, -4, 集_指针_超级列表框)
    类_释放内部方法地址 (集_指针_超级列表框)
.如果真结束
.子程序 内_索引转样式, 精易_表头样式
.参数 参_索引, 整数型
.局部变量 i, 整数型
.局部变量 局_单数据, 精易_表头样式
.计次循环首 (取数组成员数 (集_新样式数组), i)
    局_单数据 ＝ 集_新样式数组 [i]
    .如果真 (局_单数据.参_列索引 ＝ 参_索引)
        返回 (局_单数据)
    .如果真结束
.计次循环尾 ()
局_单数据.参_列索引 ＝ -1
返回 (局_单数据)
.子程序 内_设置表头项
.局部变量 i, 整数型
.如果真 (集_表头句柄 ＝ 0)
    返回 ()
.如果真结束
集_表头项.mask ＝ #HDI_FORMAT  ' 这句必须有
' SendMessage_HDITEM (m_HDHwnd, #HDM_GETITEM, 1, hditem)
集_表头项.fmt ＝ #HDF_OWNERDRAW  ' 默认是 #HDF_STRING
.计次循环首 (集_列数, i)
    SendMessage_HDITEM (集_表头句柄, #HDM_SETITEM, i － 1, 集_表头项)
.计次循环尾 ()
.子程序 方法2, , , 以上为表头相关
.子程序 滚动条_是否在顶端或底端, 逻辑型, 公开
.参数 参_是否在底端, 逻辑型, 可空, 可空，默认：假=是否在底端，真=是否在顶端
.局部变量 info, SCROLLINFO
info.cbSize ＝ 28
info.fMask ＝ #SIF_ALL
GetScrollInfo (集_超级列表框句柄, #SB_VERT, info)
.如果 (参_是否在底端)
    返回 (info.nPos ＝ 0)
.否则
    返回 (info.nPage ＋ info.nPos ＝ info.nMax ＋ 1)
.如果结束
.程序集 类_编辑框透明, , 公开
.程序集变量 集_窗口句柄, 整数型
.程序集变量 集_编辑框, 编辑框
.程序集变量 集_字体颜色, 整数型
.程序集变量 集_子类化_窗口, 整数型
.程序集变量 ImageObject, 对象
.程序集变量 hBkBitmap, 整数型
.程序集变量 集_子类化_编辑框, 整数型
.子程序 _初始化, , , 1
.子程序 _销毁, , , 2
.子程序 NewProc_Main, 整数型, , 3
.参数 hWnd, 整数型
.参数 Msg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.判断开始 (Msg ＝ #WM_CTLCOLOREDIT)
    .判断开始 (lParam ＝ 集_编辑框.取窗口句柄 ())
        SetTextColor (wParam, 集_字体颜色)  ' 50174)
        SetBkMode (wParam, #TRANSPARENT)
        返回 (GetStockObject (#NULL_BRUSH))
    .默认
    .判断结束
.判断 (Msg ＝ #WM_COMMAND)
    .判断开始 (lParam ＝ 集_编辑框.取窗口句柄 ())
        .判断开始 (右移 (wParam, 16) ＝ #EN_VSCROLL)
            InvalidateRect_逻辑型 (lParam, 0, 真)
        .判断 (右移 (wParam, 16) ＝ #EN_HSCROLL)
            InvalidateRect_逻辑型 (lParam, 0, 真)
        .判断 (右移 (wParam, 16) ＝ #EN_CHANGE)
            InvalidateRect_逻辑型 (lParam, 0, 真)
        .默认
        .判断结束
    .默认
    .判断结束
.默认
.判断结束
返回 (CallWindowProcA (集_子类化_窗口, hWnd, Msg, wParam, lParam))
.子程序 NewProc_Edit, 整数型, , 4
.参数 hWnd, 整数型
.参数 Msg, 整数型
.参数 wParam, 整数型
.参数 lParam, 整数型
.局部变量 hMemDC_BkPicture, 整数型
.局部变量 hOldBitmap, 整数型
.局部变量 矩形, 精易_矩形
.局部变量 hBrush, 整数型
.局部变量 hOldBrush, 整数型
.局部变量 hTempMemBitmap, 整数型
.局部变量 hScrDC, 整数型
.局部变量 hOldTempMemBitmap, 整数型
.局部变量 hMemDC_BkColor, 整数型
.判断开始 (Msg ＝ #WM_ERASEBKGND)
    .如果真 (hBkBitmap ＝ 0)
        集_编辑框.可视 ＝ 假
        处理事件 ()
        CoInitialize (0)
        .如果真 (ImageObject.创建图片对象 (快照 (集_编辑框.取窗口句柄 (), , )))
            hBkBitmap ＝ ImageObject.读数值属性 (“handle”, )
        .如果真结束
        CoUninitialize ()
        集_编辑框.可视 ＝ 真
    .如果真结束
    GetClientRect (hWnd, 矩形)
    hScrDC ＝ GetDC (0)
    hMemDC_BkColor ＝ CreateCompatibleDC (hScrDC)
    hTempMemBitmap ＝ CreateCompatibleBitmap (hScrDC, 矩形.右边, 矩形.底边)
    hOldTempMemBitmap ＝ SelectObject (hMemDC_BkColor, hTempMemBitmap)
    hBrush ＝ CreateSolidBrush (#白色)
    hOldBrush ＝ SelectObject (hMemDC_BkColor, hBrush)
    FillRect (hMemDC_BkColor, 矩形, hBrush)
    SelectObject (hMemDC_BkColor, hOldBrush)
    DeleteObject (hBrush)
    hMemDC_BkPicture ＝ CreateCompatibleDC (hScrDC)
    hOldBitmap ＝ SelectObject (hMemDC_BkPicture, hBkBitmap)
    BitBlt (hMemDC_BkColor, 矩形.左边, 矩形.顶边, 矩形.右边, 矩形.底边, hMemDC_BkPicture, 0, 0, #SRCCOPY)
    BitBlt (wParam, 矩形.左边, 矩形.顶边, 矩形.右边, 矩形.底边, hMemDC_BkColor, 0, 0, #SRCCOPY)
    SelectObject (hMemDC_BkPicture, hOldBitmap)
    DeleteDC (hMemDC_BkPicture)
    SelectObject (hMemDC_BkColor, hOldTempMemBitmap)
    DeleteObject (hTempMemBitmap)
    DeleteDC (hMemDC_BkColor)
    ReleaseDC (0, hScrDC)
    InvalidateRect_逻辑型 (hWnd, 0, 假)
.判断 (Msg ＝ #WM_VSCROLL)
    InvalidateRect_逻辑型 (hWnd, 0, 真)
.判断 (Msg ＝ #WM_HSCROLL)
    InvalidateRect_逻辑型 (hWnd, 0, 真)
.判断 (Msg ＝ #WM_DESTROY)
    .如果真 (取反 (ImageObject.是否为空 ()))
        ImageObject.清除 ()
    .如果真结束
.默认
.判断结束
返回 (CallWindowProcA (集_子类化_编辑框, hWnd, Msg, wParam, lParam))
.子程序 初始化, , 公开
.参数 参_窗口句柄, 整数型
.参数 参_编辑框, 编辑框
.参数 参_字体颜色, 整数型
集_窗口句柄 ＝ 参_窗口句柄
集_编辑框 ＝ 参_编辑框
集_字体颜色 ＝ 参_字体颜色
集_子类化_窗口 ＝ SetWindowLongA (参_窗口句柄, #GWL_WNDPROC, 类_取内部方法地址 (3))
集_子类化_编辑框 ＝ SetWindowLongA (参_编辑框.取窗口句柄 (), #GWL_WNDPROC, 类_取内部方法地址 (4))
.子程序 销毁, , 公开
SetWindowLongA (集_窗口句柄, #GWL_WNDPROC, 集_子类化_窗口)
SetWindowLongA (集_编辑框.取窗口句柄 (), #GWL_WNDPROC, 集_子类化_编辑框)
.程序集 类_树型框_字节集操作, , 公开, 仅作为树型框项目数据的操作，并非对外部或自身组件操作
.程序集变量 类_ID, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
类_ID ＝ 打开内存文件 ()
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
清空 ()
关闭文件 (类_ID)
.子程序 生成项目, 字节集, 公开, 创建一条项目。
.参数 项目文本, 文本型
.参数 图片索引, 整数型
.参数 选中后图片索引, 整数型
.参数 项目数值, 整数型
.参数 是否加粗, 逻辑型, 可空, 空 不加粗
.参数 是否扩展, 逻辑型, 可空, 空 展开
.参数 缩进层次, 整数型
.参数 检查框状态索引, 整数型, 可空, 空 = -1 表示无检查框，索引从零开始
.局部变量 局_长度, 整数型
.局部变量 局_项目数据, 字节集
局_长度 ＝ 取文本长度 (项目文本)
局_项目数据 ＝ 取空白字节集 (局_长度 ＋ 21)
局_项目数据 ＝ 字节集替换 (局_项目数据, 1, 局_长度, 到字节集 (项目文本))  ' 项目文本
局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 2, 4, 到字节集 (图片索引))
局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 6, 4, 到字节集 (选中后图片索引))
局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 10, 4, 到字节集 (项目数值))
.如果真 (是否为空 (是否加粗))
    是否加粗 ＝ 假
.如果真结束
.如果真 (是否为空 (是否扩展))
    是否扩展 ＝ 真
.如果真结束
.判断开始 (是否加粗 ＝ 假 且 是否扩展 ＝ 假)
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 0, 0, 0, 0 })
.判断 (是否加粗 且 是否扩展 ＝ 假)
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 1, 0, 0, 0 })
.判断 (是否加粗 ＝ 假 且 是否扩展)
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 2, 0, 0, 0 })
.默认
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 3, 0, 0, 0 })
.判断结束
.如果 (是否为空 (检查框状态索引) 或 检查框状态索引 ＝ -1)
.否则
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 17, 1, 到字节集 (到字节 ((检查框状态索引 ＋ 1) × 16)))
.如果结束
局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 18, 4, 到字节集 (缩进层次))
返回 (局_项目数据)
.子程序 初始化自字节集, 逻辑型, 公开, 从字节集创建树项目数据。
.参数 树项目, 字节集
.如果真 (类_ID ＝ 0)
    返回 (假)
.如果真结束
清空 ()
写出字节集 (类_ID, 树项目)
移到文件首 (类_ID)
返回 (真)
.子程序 初始化自文件, 逻辑型, 公开, 从文件创建树项目数据。
.参数 文件, 文本型
.如果真 (类_ID ＝ 0)
    返回 (假)
.如果真结束
清空 ()
.如果真 (文件是否存在 (文件))
    写出字节集 (类_ID, 读入文件 (文件))
    移到文件首 (类_ID)
    返回 (真)
.如果真结束
返回 (假)
.子程序 初始化, 逻辑型, 公开, 创建一个空的树项目数据。
.如果真 (类_ID ＝ 0)
    返回 (假)
.如果真结束
清空 ()
返回 (真)
.子程序 取项目, 字节集, 公开, 失败返回一个空字节集
.局部变量 Z, 字节集
移到文件首 (类_ID)
Z ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
返回 (Z)
.子程序 取项目数, 整数型, 公开, 返回树型框中所有项目的数目。
.局部变量 项目, 字节集
.局部变量 临位, 整数型
.局部变量 索引, 整数型
移到文件首 (类_ID)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
    临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
    索引 ＝ 索引 ＋ 1
    临位 ＝ 临位 ＋ 21
.判断循环尾 ()
返回 (索引)
.子程序 取缩进层次, 整数型, 公开, 返回指定项目所处缩进层次，层次值从1开始。如果未找到指定项目，返回 0 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        返回 (到数值 (取字节集数据 (项目, #字节型, 起位置 ＋ 17)))
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (0)
.子程序 取项目文本, 文本型, 公开, 返回指定项目的文本。如果该项目不存在，将返回空文本。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 临位, 整数型
.局部变量 索引, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
临位 ＝ 1
.判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
    .如果真 (索引 ＝ 项目索引)  ' 与上一项目索引一样时，刚好对应的是目标项目的位置
        返回 (到文本 (取字节集中间 (项目, 临位, 寻找字节集 (项目, { 0 }, 临位) － 临位)))
    .如果真结束
    临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
    索引 ＝ 索引 ＋ 1
    临位 ＝ 临位 ＋ 21
.判断循环尾 ()
返回 (“”)
.子程序 取图片, 整数型, 公开, 返回指定项目的图片索引。如果该项目不存在，将返回 -1 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        返回 (取字节集数据 (项目, #整数型, 起位置 ＋ 1))
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (0)
.子程序 取选中图片, 整数型, 公开, 返回指定项目被选中后的图片索引。如果该项目不存在，将返回 -1 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        返回 (取字节集数据 (项目, #整数型, 起位置 ＋ 5))
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (0)
.子程序 取项目数值, 整数型, 公开, 返回与指定项目相关联的数值。如果该项目不存在，将返回 0 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        返回 (取字节集数据 (项目, #整数型, 起位置 ＋ 9))
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (0)
.子程序 置项目文本, 逻辑型, 公开, 设置指定项目的文本。成功返回真，失败返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.参数 欲置入的项目文本, 文本型
.局部变量 项目, 字节集
.局部变量 临位, 整数型
.局部变量 索引, 整数型
.局部变量 起始位置, 整数型
.局部变量 结束位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
    临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
    索引 ＝ 索引 ＋ 1
    临位 ＝ 临位 ＋ 21
    .如果真 (索引 ＝ 项目索引)  ' 与上一项目索引一样时，刚好对应的是目标项目的位置
        起始位置 ＝ 临位
        结束位置 ＝ 寻找字节集 (项目, { 0 }, 临位)
        跳出循环 ()
    .如果真结束
.判断循环尾 ()
清空 ()
写出字节集 (类_ID, 字节集替换 (项目, 起始位置, 结束位置 － 起始位置, 到字节集 (欲置入的项目文本)))
返回 (移到文件首 (类_ID))
.子程序 置图片, 逻辑型, 公开, 设置在指定项目首部所显示图片的索引。成功返回真，失败返回假。
.参数 项目索引, , , 0 为项目一，1 为项目二，如此类推。
.参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。
.局部变量 索引, 整数型
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        清空 ()
        写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 1, #整数型, 到字节集 (图片索引)))
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (移到文件首 (类_ID))
.子程序 置选中图片, 逻辑型, 公开, 设置指定项目被选中后所显示图片的索引。成功返回真，失败返回假。
.参数 项目索引, , , 0 为项目一，1 为项目二，如此类推。
.参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。
.局部变量 索引, 整数型
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        清空 ()
        写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 5, #整数型, 到字节集 (图片索引)))
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (移到文件首 (类_ID))
.子程序 置项目数值, 逻辑型, 公开, 设置与指定项目相关联的数值。成功返回真，失败返回假。
.参数 项目索引, , , 0 为项目一，1 为项目二，如此类推。
.参数 欲置入的项目数值, 整数型, 可空, 可以被省略。该数值与指定项目相关联。如果本参数被省略，默认值为 0 。
.局部变量 索引, 整数型
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        清空 ()
        写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 9, #整数型, 到字节集 (欲置入的项目数值)))
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (移到文件首 (类_ID))
.子程序 加粗, , 公开
.局部变量 项目索引, 整数型, , , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        清空 ()
        .判断开始 (粗展状态 ＝ 0)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 1 }))
        .判断 (粗展状态 ＝ 2)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 3 }))
        .默认
        .判断结束
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
移到文件首 (类_ID)
.子程序 取消加粗, , 公开, 将指定项目的标题取消加粗显示。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        清空 ()
        .判断开始 (粗展状态 ＝ 1)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 0 }))
        .判断 (粗展状态 ＝ 3)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 2 }))
        .默认
        .判断结束
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
移到文件首 (类_ID)
.子程序 是否已加粗, 逻辑型, 公开, 如果树型框中的指定项目的标题被加粗显示，返回真，否则返回假。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        .判断开始 (粗展状态 ＝ 1 或 粗展状态 ＝ 3)
            返回 (真)
        .判断 (粗展状态 ＝ 0 或 粗展状态 ＝ 2)
            返回 (假)
        .默认
        .判断结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (假)
.子程序 扩展, , 公开, 打开指定项目的下属分枝。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        清空 ()
        .判断开始 (粗展状态 ＝ 0)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 2 }))
        .判断 (粗展状态 ＝ 1)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 3 }))
        .默认
        .判断结束
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
移到文件首 (类_ID)
.子程序 是否已扩展, 逻辑型, 公开, 指定项目的下属分枝是否已经展开。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        .判断开始 (粗展状态 ＝ 0 或 粗展状态 ＝ 1)
            返回 (假)
        .判断 (粗展状态 ＝ 2 或 粗展状态 ＝ 3)
            返回 (真)
        .默认
        .判断结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (假)
.子程序 收缩, , 公开, 缩回指定项目的下属分枝。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
.局部变量 起位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        清空 ()
        .判断开始 (粗展状态 ＝ 2)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 0 }))
        .判断 (粗展状态 ＝ 3)
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 1 }))
        .默认
        .判断结束
        跳出循环 ()
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
移到文件首 (类_ID)
.子程序 是否已收缩, 逻辑型, 公开, 指定项目的下属分枝是否已经缩回。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 粗展状态, 字节型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        .判断开始 (粗展状态 ＝ 0 或 粗展状态 ＝ 1)
            返回 (真)
        .判断 (粗展状态 ＝ 2 或 粗展状态 ＝ 3)
            返回 (假)
        .默认
        .判断结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (假)
.子程序 加入项目, 整数型, 公开, 将单个项目加入到树型框中，成功返回加入后该项目所处的位置，失败返回 -1 。
.参数 父项目索引, 整数型, 可空, 可以被省略。指定欲加入项目所处的父项目，0 为项目一，1 为项目二，如此类推。如果没有父项目（即欲加入项目为顶层项目），请提供值 -1 。如果本参数被省略，默认值为 -1 。
.参数 项目文本, 文本型
.参数 图片索引, 整数型, 可空, 可以被省略，如果本参数被省略，所加入项目的图片索引默认为 0 。
.参数 选中图片索引, 整数型, 可空, 选中图片索引用于指定项目被选中后所显示的图片，-1 表示与图片索引一致。如果本参数被省略，所加入项目的选中图片索引默认为 -1 。
.参数 项目数值, 整数型, 可空, 指定与本项目相关联的数值。如果本参数被省略，所加入项目的项目数值默认为 0 。
.参数 是否加粗, 逻辑型, 可空, 可以被省略，如果本参数被省略，所加入项目的项目数值默认为假。
.参数 检查框状态, 整数型, 可空, 可以被省略，如果本参数被省略，所加入项目的项目数值默认为 0 。默认情况下，0：未选中，1：选中，2：半选中。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 父层次, 整数型
.局部变量 层次, 整数型
.局部变量 插入位置, 整数型
.局部变量 粗展状态, 字节型
.局部变量 检查状态, 字节型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.如果真 (是否为空 (图片索引) 或 图片索引 ＜ 0)
    图片索引 ＝ 0
.如果真结束
.如果真 (是否为空 (选中图片索引) 或 选中图片索引 ＜ 0)
    选中图片索引 ＝ 图片索引
.如果真结束
.如果真 (是否为空 (项目数值) 或 项目数值 ＜ 0)
    项目数值 ＝ 0
.如果真结束
.如果真 (是否为空 (是否加粗))
    是否加粗 ＝ 假
.如果真结束
.如果真 (是否为空 (检查框状态) 或 检查框状态 ＜ 0)
    检查框状态 ＝ 0
.如果真结束
.如果真 (是否为空 (父项目索引) 或 父项目索引 ＜ 0)
    移到文件尾 (类_ID)
    写出字节集 (类_ID, 生成项目 (项目文本, 图片索引, 选中图片索引, 项目数值, 是否加粗, , 1, 检查框状态))
    移到文件首 (类_ID)
    返回 (取项目数 () － 1)
.如果真结束
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 父项目索引)
        父层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
        检查状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 16) ÷ 16 － 1
        .判断开始 (粗展状态 ＝ 0 或 粗展状态 ＝ 2)
            项目 ＝ 字节集替换 (项目, 起位置 ＋ 13, 1, { 2 })
        .判断 (粗展状态 ＝ 1 或 粗展状态 ＝ 3)
            项目 ＝ 字节集替换 (项目, 起位置 ＋ 13, 1, { 3 })
        .默认
        .判断结束
        .如果真 (检查状态 ＝ 1)
            .如果真 (选中图片索引 ＝ 0)
                检查状态 ＝ 2
            .如果真结束
        .如果真结束
        项目 ＝ 字节集替换 (项目, 起位置 ＋ 16, 1, 到字节集 (检查状态))
        插入位置 ＝ 起位置 ＋ 21
    .如果真结束
    .如果真 (索引 ＞ 父项目索引)
        层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        .如果 (层次 ≤ 父层次)
            跳出循环 ()
        .否则
            插入位置 ＝ 起位置 ＋ 21
        .如果结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
清空 ()
写出字节集 (类_ID, 字节集替换 (项目, 插入位置, 0, 生成项目 (项目文本, 图片索引, 选中图片索引, 项目数值, 是否加粗, , 父层次 ＋ 1, 检查框状态)))
移到文件首 (类_ID)
返回 (索引)
.子程序 删除项目, , 公开, 删除树型框中的指定项目。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 层次, 整数型
.局部变量 目标层次, 整数型
.局部变量 目标索引, 整数型
.局部变量 开始位置, 整数型
.局部变量 结束位置, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        目标索引 ＝ 索引
        目标层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
    .如果真结束
    .如果真 (索引 ＞ 项目索引)
        层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        .判断开始 (层次 ＞ 目标层次)
            结束位置 ＝ 起位置 ＋ 21
        .判断 (层次 ≤ 目标层次)
            跳出循环 ()
        .默认
        .判断结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
索引 ＝ 0
起位置 ＝ 0
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
    .如果真 (索引 ＝ 项目索引)
        开始位置 ＝ 起位置
        跳出循环 ()
    .如果真结束
.判断循环尾 ()
清空 ()
写出字节集 (类_ID, 字节集替换 (项目, 开始位置, 结束位置 － 开始位置, ))
移到文件首 (类_ID)
.子程序 清空, , 公开, 删除树型框中的所有项目。
移到文件首 (类_ID)
删除数据 (类_ID, 取文件长度 (类_ID))
.子程序 取父项目, 整数型, 公开, 返回指定项目的父项目索引。如果该项目为顶层项目，将返回 -1 。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 层次, 整数型
.局部变量 上层次, 整数型, , "0"
.局部变量 i, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .判断开始 (索引 ＜ 项目索引)
        加入成员 (上层次, 取字节集数据 (项目, #整数型, 起位置 ＋ 17))
    .判断 (索引 ＝ 项目索引)
        层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        .变量循环首 (取数组成员数 (上层次), 1, -1, i)
            .如果真 (上层次 [i] ＜ 层次)
                返回 (i － 1)
            .如果真结束
        .变量循环尾 ()
        跳出循环 ()
    .默认
        跳出循环 ()
    .判断结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (-1)
.子程序 是否有子项目, 逻辑型, 公开, 如果指定项目存在子项目，返回真，否则返回假。如果本命令返回真，意味着指定项目的下一项即为此项目的第一个子项目。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 层次, 整数型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
    .如果真结束
    .如果真 (索引 ＞ 项目索引)
        .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 17) ＞ 层次)
            返回 (真)
        .如果真结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (假)
.子程序 取检查框状态, 整数型, 公开, 返回值表示检查框中选中状态。默认情况下，0：未选中，1：选中，2：半选中。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 索引, 整数型
.局部变量 状态, 字节型
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (索引 ＝ 项目索引)
        状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 16)
        返回 (状态 ÷ 16 － 1)
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
返回 (0)
.子程序 置检查框状态, , 公开, 设置项目的检查框状态。
.参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。在参数“连同子项目”为真的情况下，此参数可为-1，表示设置所有项目的检查框状态。
.参数 检查框状态, 整数型, , 默认情况下，0表示未选中，1表示已选中，2表示半选中。
.参数 连同子项目, 逻辑型, 可空, 可以被省略。如果此参数为真，则参数“项目索引”所指定项目的所有子项目也被一并设置其检查框状态。默认为假。
.局部变量 项目, 字节集
.局部变量 临位, 整数型
.局部变量 索引, 整数型
.局部变量 层次, 整数型
.如果真 (项目索引 ＜ 0)
    返回 ()
.如果真结束
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
    临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
    .如果真 (索引 ＝ 项目索引)
        项目 ＝ 字节集替换 (项目, 临位 ＋ 16, 1, 到字节集 (到字节 ((检查框状态 ＋ 1) × 16)))
        层次 ＝ 取字节集数据 (项目, #整数型, 临位 ＋ 17)
    .如果真结束
    .如果真 (连同子项目 且 索引 ＞ 项目索引)
        .如果真 (取字节集数据 (项目, #整数型, 临位 ＋ 17) ＞ 层次)
            项目 ＝ 字节集替换 (项目, 临位 ＋ 16, 1, 到字节集 (到字节 ((检查框状态 ＋ 1) × 16)))
        .如果真结束
    .如果真结束
    索引 ＝ 索引 ＋ 1
    临位 ＝ 临位 ＋ 21
.判断循环尾 ()
清空 ()
写出字节集 (类_ID, 项目)
移到文件首 (类_ID)
.子程序 查找项目_缩进层次, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
.参数 项目缩进层次, 整数型, , 默认情况下，0表示未选中，1表示已选中，2表示半选中。
.参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
.局部变量 起位置, 整数型
.局部变量 项目, 字节集
.局部变量 索引, 整数型
重定义数组 (查找结果, 假, 0)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 17) ＝ 项目缩进层次)
        加入成员 (查找结果, 索引)
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
.如果 (取数组成员数 (查找结果) ≠ 0)
    返回 (查找结果 [1])
.否则
    返回 (-1)
.如果结束
.子程序 查找项目_检查框状态, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
.参数 项目检查框状态, 整数型, , 默认情况下，0表示未选中，1表示已选中，2表示半选中。
.参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
.局部变量 起位置, 整数型
.局部变量 项目, 字节集
.局部变量 索引, 整数型
.局部变量 状态, 字节型
重定义数组 (查找结果, 假, 0)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 16)
    .如果真 (状态 ÷ 16 － 1 ＝ 项目检查框状态)
        加入成员 (查找结果, 索引)
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
.如果 (取数组成员数 (查找结果) ≠ 0)
    返回 (查找结果 [1])
.否则
    返回 (-1)
.如果结束
.子程序 查找项目_选中图片, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
.参数 项目选中图片索引, 整数型
.参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
.局部变量 起位置, 整数型
.局部变量 项目, 字节集
.局部变量 索引, 整数型
重定义数组 (查找结果, 假, 0)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 5) ＝ 项目选中图片索引)
        加入成员 (查找结果, 索引)
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
.如果 (取数组成员数 (查找结果) ≠ 0)
    返回 (查找结果 [1])
.否则
    返回 (-1)
.如果结束
.子程序 查找项目_图片, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
.参数 项目图片索引, 整数型
.参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
.局部变量 起位置, 整数型
.局部变量 项目, 字节集
.局部变量 索引, 整数型
重定义数组 (查找结果, 假, 0)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 1) ＝ 项目图片索引)
        加入成员 (查找结果, 索引)
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
.如果 (取数组成员数 (查找结果) ≠ 0)
    返回 (查找结果 [1])
.否则
    返回 (-1)
.如果结束
.子程序 查找项目_数值, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
.参数 项目数值, 整数型
.参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
.局部变量 起位置, 整数型
.局部变量 项目, 字节集
.局部变量 索引, 整数型
重定义数组 (查找结果, 假, 0)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
    起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
    .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 9) ＝ 项目数值)
        加入成员 (查找结果, 索引)
    .如果真结束
    索引 ＝ 索引 ＋ 1
    起位置 ＝ 起位置 ＋ 21
.判断循环尾 ()
.如果 (取数组成员数 (查找结果) ≠ 0)
    返回 (查找结果 [1])
.否则
    返回 (-1)
.如果结束
.子程序 查找项目_文本, 整数型, , 找到返回首个被找到项目的索引，失败返回-1。
.参数 项目文本, 文本型
.参数 是否精确匹配, 逻辑型, 可空, 默认为真，为假时所有包含“参数一”的项目。
.参数 区分大小写, 逻辑型, 可空, 默认不区分，“参数二”为真时将忽略本参数。
.参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
.局部变量 目标长度, 整数型
.局部变量 项目, 字节集
.局部变量 起位置, 整数型
.局部变量 下位置, 整数型
.局部变量 索引, 整数型
重定义数组 (查找结果, 假, 0)
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
目标长度 ＝ 取文本长度 (项目文本)
.判断开始 (是否精确匹配 或 是否为空 (是否精确匹配))
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (文本比较 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, 真) ＝ 0)
            加入成员 (查找结果, 索引)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
.默认
    .如果 (取反 (区分大小写) 或 是否为空 (区分大小写))
        .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
            起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
            .如果真 (寻找文本 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, , 真) ≠ -1)
                加入成员 (查找结果, 索引)
            .如果真结束
            索引 ＝ 索引 ＋ 1
            起位置 ＝ 起位置 ＋ 21
        .判断循环尾 ()
    .否则
        .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
            起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
            .如果真 (寻找文本 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, , 假) ≠ -1)
                加入成员 (查找结果, 索引)
            .如果真结束
            索引 ＝ 索引 ＋ 1
            起位置 ＝ 起位置 ＋ 21
        .判断循环尾 ()
    .如果结束
.判断结束
.如果 (取数组成员数 (查找结果) ≠ 0)
    返回 (查找结果 [1])
.否则
    返回 (-1)
.如果结束
.子程序 取项目开始位置, 整数型, 公开, 查找指定索引的项目在字节集中的位置，失败返回-1。
.参数 项目索引, 整数型
.局部变量 项目, 字节集
.局部变量 临位, 整数型
.局部变量 索引, 整数型
.如果真 (项目索引 ＜ 0)
    返回 (-1)
.如果真结束
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
    临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
    索引 ＝ 索引 ＋ 1
    临位 ＝ 临位 ＋ 21
    .如果真 (索引 ＝ 项目索引)  ' 与上一项目索引一样时，刚好对应的是目标项目的位置
        返回 (临位 － 1)
    .如果真结束
.判断循环尾 ()
返回 (-1)
.子程序 取项目长度, 整数型, 公开, 取指定项目的数据长度，失败返回-1。
.参数 项目索引, 整数型
.局部变量 项目, 字节集
.局部变量 临位, 整数型
.局部变量 索引, 整数型
.如果真 (项目索引 ＜ 0)
    返回 (-1)
.如果真结束
项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
移到文件首 (类_ID)
.判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
    临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
    索引 ＝ 索引 ＋ 1
    临位 ＝ 临位 ＋ 21
    .如果真 (索引 ＝ 项目索引)
        返回 (寻找字节集 (项目, { 0 }, 临位) － 临位 ＋ 21)
    .如果真结束
.判断循环尾 ()
返回 (-1)
.程序集 类_外部状态条, , 公开
.程序集变量 集_状态条句柄, 整数型
.程序集变量 hProcess, 整数型
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 ()
.子程序 初始化, 逻辑型, 公开
.参数 参_状态条句柄, 整数型
.参数 参_是否为外部进程, 逻辑型, 可空
.局部变量 dwProcessId, 整数型
.如果真 (IsWindow (参_状态条句柄) ＝ 0)
    返回 (假)
.如果真结束
集_状态条句柄 ＝ 参_状态条句柄
.如果真 (参_是否为外部进程)
    GetWindowThreadProcessId (集_状态条句柄, dwProcessId)
    hProcess ＝ OpenProcess (位或 (#PROCESS_VM_OPERATION, #PROCESS_VM_READ, #PROCESS_VM_WRITE), 0, dwProcessId)
.如果真结束
返回 (真)
.子程序 销毁, , 公开
.如果真 (hProcess ＞ 0)
    CloseHandle (hProcess)
    hProcess ＝ 0
.如果真结束
集_状态条句柄 ＝ 0
.子程序 取文本, 文本型, 公开
.参数 参_栏目索引, 整数型
.局部变量 局_文本长度, 整数型
.局部变量 局_栏目文本, 文本型
.局部变量 局_内存地址, 整数型
.如果真 (集_状态条句柄 ＝ 0)
    返回 (“”)
.如果真结束
局_文本长度 ＝ SendMessageA (集_状态条句柄, #SB_GETTEXTLENGTHA, 参_栏目索引, 0)
.如果真 (局_文本长度 ＞ 0)
    局_栏目文本 ＝ 取空白文本 (局_文本长度)
    .如果 (hProcess ＞ 0)
        局_内存地址 ＝ 内存_远程创建内存_文本 (hProcess, 局_栏目文本)
        SendMessageA (集_状态条句柄, #SB_GETTEXTA, 参_栏目索引, 局_内存地址)
        ReadProcessMemory_文本型 (hProcess, 局_内存地址, 局_栏目文本, 局_文本长度, 0)
        内存_释放远程内存 (hProcess, 局_内存地址)
    .否则
        SendMessageA (集_状态条句柄, #SB_GETTEXTA, 参_栏目索引, 取指针_文本型 (局_栏目文本))
    .如果结束
.如果真结束
返回 (局_栏目文本)
.子程序 置文本, , 公开
.参数 参_栏目索引, 整数型
.参数 参_栏目文本, 文本型
.局部变量 局_内存地址, 整数型
.如果真 (集_状态条句柄 ＝ 0)
    返回 ()
.如果真结束
.如果 (hProcess ＞ 0)
    局_内存地址 ＝ 内存_远程创建内存_文本 (hProcess, 参_栏目文本)
    SendMessageA (集_状态条句柄, #SB_SETTEXTA, 参_栏目索引, 局_内存地址)
    内存_释放远程内存 (hProcess, 局_内存地址)
.否则
    SendMessageA (集_状态条句柄, #SB_SETTEXTA, 参_栏目索引, 取指针文本_ (参_栏目文本))
.如果结束
.子程序 背景颜色, , 公开
.参数 参_RGB, 整数型
.如果真 (集_状态条句柄 ＝ 0)
    返回 ()
.如果真结束
SendMessageA (集_状态条句柄, #SB_SETBKCOLOR, 0, 参_RGB)
.程序集 程序集_x64
.程序集变量 m_Mods, 整数型
.子程序 x64Init
.局部变量 ret, 逻辑型
.局部变量 isWow64, 逻辑型
.如果真 (m_Mods ＝ 0)
    ret ＝ IsWow64Process (GetCurrentProcess (), isWow64)
    .如果真 (ret ＝ 假 或 isWow64 ＝ 假)
        返回 ()
    .如果真结束
    m_Mods ＝ eWOW64ExtInit ()
.如果真结束
.子程序 SendMsgA, 长整数型
.参数 hWnd, 长整数型
.参数 message, 整数型
.参数 wParam, 长整数型
.参数 lParam, 长整数型
.局部变量 pFun, 长整数型, 静态
.局部变量 hModule, 长整数型
.如果真 (pFun ＝ 0)
    hModule ＝ LoadDll (“user32.dll”)
    .如果真 (hModule ＝ 0)
        返回 (0)
    .如果真结束
    pFun ＝ GetProcAddress64 (hModule, “SendMessageA”)
    .如果真 (pFun ＝ 0)
        返回 (0)
    .如果真结束
.如果真结束
返回 (X64Call (pFun, hWnd, message, wParam, lParam, , , , , , ))
.子程序 SendMsgW, 长整数型
.参数 hWnd, 整数型
.参数 message, 整数型
.参数 wParam, 长整数型
.参数 lParam, 长整数型
.局部变量 pFun, 长整数型, 静态
.局部变量 hModule, 长整数型
.如果真 (pFun ＝ 0)
    hModule ＝ LoadDll (“user32.dll”)
    .如果真 (hModule ＝ 0)
        返回 (0)
    .如果真结束
    pFun ＝ GetProcAddress64 (hModule, “SendMessageW”)
    .如果真 (pFun ＝ 0)
        返回 (0)
    .如果真结束
.如果真结束
返回 (X64Call (pFun, hWnd, message, wParam, lParam, , , , , , ))
.子程序 LoadDll, 长整数型
.参数 dll, 文本型, , 完整路径
.局部变量 arg, 整数型
.局部变量 file, 文本型
.局部变量 path, 字节集
.局部变量 pos, 整数型
.局部变量 pPath, 整数型
.局部变量 ret, 长整数型
.局部变量 ulong, 整数型
.局部变量 hUser, 长整数型
.局部变量 pFun, 长整数型, 静态
.局部变量 h, 长整数型
.如果真 (pFun ＝ 0)
    h ＝ GetNtdll64 ()
    pFun ＝ GetProcAddress64 (h, “LdrLoadDll”)
.如果真结束
pos ＝ 倒找文本 (dll, “\”, , 假)
.判断开始 (pos ≠ -1)
    file ＝ 取文本右边 (dll, 取文本长度 (dll) － pos)
    path ＝ A2W (取文本左边 (dll, pos － 1), )
    pPath ＝ 取指针_字节集型 (path)
.默认
    file ＝ dll
.判断结束
arg ＝ UNICODE_STRING_X64 (file)
ret ＝ X64Call (pFun, pPath, 取指针_通用型 (ulong), arg, 取指针_通用型 (hUser), , , , , , )
LocalFree (arg)
返回 (hUser)
.子程序 X64Call, 长整数型, , 调用 64 位函数通用版本（注：返回长整数对于很多函数是必要的，但某些 NTDLL 函数返回值为 NTSTATUS 错误码 时应将返回值转为整数！）
.参数 func, 长整数型
.参数 arg1, 长整数型, 可空, 必须按顺序填写 API 所需参数，数值型直接传入，其他类型及传址参数传入 32/64 内存地址均可。不使用参数必须“留空”，不能是写 0
.参数 arg2, 长整数型, 可空
.参数 arg3, 长整数型, 可空
.参数 arg4, 长整数型, 可空
.参数 arg5, 长整数型, 可空
.参数 arg6, 长整数型, 可空
.参数 arg7, 长整数型, 可空
.参数 arg8, 长整数型, 可空
.参数 arg9, 长整数型, 可空
.参数 arg10, 长整数型, 可空, 应该够用了，不弄太多影响效率了
.局部变量 fs
fs ＝ 0
置入代码 (#X64_SaveFs)
置入代码 (#X64_Start)
置入代码 ({ 131, 196, 176, 103, 72, 141, 85, 64, 76, 141, 68, 36, 32, 72, 51, 201, 177, 6, 139, 66, 8, 133, 192, 116, 21, 72, 139, 2, 73, 137, 0, 72, 255, 201, 116, 10, 72, 141, 82, 12, 77, 141, 64, 8, 235, 228, 103, 72, 139, 77, 16, 103, 72, 139, 85, 28, 103, 76, 139, 69, 40, 103, 76, 139, 77, 52, 103, 72, 139, 69, 8, 255, 208, 72, 141, 100, 36, 80, 72, 139, 208, 72, 193, 234, 32 })
置入代码 (#X64_End)
置入代码 (#X64_RestoreFs)
置入代码 ({ 139, 229, 93, 194, 128, 0 })
返回 (0)
.子程序 UNICODE_STRING_X64, 整数型
.参数 str, 文本型
.局部变量 wzName, 字节集
.局部变量 ptr, 整数型
.局部变量 len, 整数型
.局部变量 strSize, 整数型
wzName ＝ A2W (str, )
len ＝ lstrlenW (取指针_字节集型 (wzName)) × 2
strSize ＝ len ＋ 2
ptr ＝ LocalAlloc (#LMEM_ZEROINIT, 16 ＋ strSize)
__set_short (ptr, 0, len)
__set_short (ptr, 2, strSize)
RtlMoveMemory (ptr ＋ 16, 取指针_字节集型 (wzName), strSize)
__set (ptr, 8, ptr ＋ 16)
返回 (ptr)
.子程序 __set_short, 整数型, 公开, 请确保指针的合法性,写到内存
.参数 lpAddr, 整数型, , 内存地址
.参数 offset, 整数型, , 偏移
.参数 value, 短整数型, , 写入值
置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 11, 102, 139, 85, 16, 102, 137, 20, 11, 201, 194, 12, 0 })
' mov ebx,[ebp+8]
' mov ecx,[ebp+12]
' mov eax,[ecx+ebx]
' mov dx,[ebp+16]
' mov [ecx+ebx],dx
' leave
' ret 12
返回 (0)
.子程序 eWOW64ExtInit, 整数型
置入代码 (#X86_Init)
置入代码 (#X64_Init)
置入代码 ({ 102, 140, 217, 102, 142, 209, 139, 77, 252, 102, 142, 225, 139, 229, 93, 195 })
返回 (0)
.子程序 GetNtdll64, 长整数型, , ntdll.dll 在 64 位环境下的内存基址，有了它，几乎就无所不能了
.局部变量 pMods
pMods ＝ m_Mods
置入代码 ({ 139, 69, 252, 139, 64, 4, 141, 0, 139, 80, 4, 139, 0, 139, 229, 93, 195 })
返回 (0)
.子程序 GetProcAddress64, 长整数型, , 取 64 位函数调用地址
.参数 hModule, 长整数型, , 本模块 GetModuleHandle64* 函数返回值，一般的只能传递 ntdll.dll 的基址
.参数 lpProcName, 文本型, , 直接调用 64 API 实现而不是取哈希查询，所以区分大小写
.局部变量 fs
.局部变量 pMods
fs ＝ 0
pMods ＝ m_Mods
置入代码 (#X64_SaveFs)
置入代码 (#X64_Start)
置入代码 ({ 72, 51, 210, 103, 72, 139, 69, 8, 72, 133, 192, 116, 97, 72, 131, 196, 192, 103, 139, 85, 16, 103, 139, 18, 72, 141, 76, 36, 48, 103, 139, 69, 248, 103, 139, 64, 4, 103, 72, 139, 128, 136, 0, 0, 0, 255, 208, 76, 141, 76, 36, 32, 77, 51, 192, 72, 141, 84, 36, 48, 103, 72, 139, 77, 8, 103, 139, 69, 248, 103, 139, 64, 4, 103, 72, 139, 128, 184, 0, 0, 0, 255, 208, 72, 51, 210, 72, 255, 202, 133, 192, 120, 12, 72, 139, 68, 36, 32, 72, 139, 208, 72, 193, 234, 32, 72, 141, 100, 36, 64 })
置入代码 (#X64_End)
置入代码 (#X64_RestoreFs)
置入代码 ({ 133, 210, 121, 19, 139, 200, 139, 85, 248, 139, 2, 139, 128, 164, 1, 0, 0, 255, 208, 51, 192, 51, 210, 139, 229, 93, 194, 12, 0 })
返回 (0)
.子程序 GetProcAddressEx64, 长整数型, , 取 64 位函数调用地址
.参数 hModule, 长整数型, , 本模块 GetModuleHandle64* 函数返回值，一般的只能传递 ntdll.dll 的基址
.参数 dwProcHash, , , 本模块 fn_CalcModOrFuncHash 函数计算值 或者是 函数序号
.局部变量 pMods
pMods ＝ m_Mods
置入代码 (#X64_Start)
置入代码 ({ 103, 72, 139, 77, 8, 103, 139, 85, 16, 103, 139, 69, 252, 103, 139, 64, 4, 103, 139, 128, 176, 1, 0, 0, 72, 131, 196, 216, 255, 208, 72, 131, 196, 40 })
置入代码 (#X64_End)
置入代码 ({ 139, 229, 93, 194, 12, 0 })
返回 (0)
.数据类型 精易_表头样式, 公开
    .成员 参_列索引, 整数型
    .成员 参_文本色, 整数型
    .成员 参_背景色, 整数型
.数据类型 DRAWITEMSTRUCT, , 12*4=48
    .成员 CtlType, 整数型, , , 控件类型
    .成员 CtlID, 整数型, , , 组合框、列表框等控件的ID标识号
    .成员 itemID, 整数型, , , 菜单项的ID标识 号或列表框、组合框中某一项的索引值
    .成员 itemAction, 整数型, , , 控件行为
    .成员 itemState, 整数型, , , 控件状态
    .成员 hwndItem, 整数型, , , 父窗口句柄或菜单句柄
    .成员 hDC, 整数型, , , 控件对应的绘图设备句柄
    .成员 rcItem, RECT, , , 控件所占据的矩形区域,注意：这里不是传址，4*4=16
    .成员 itemData, 整数型, , , 列表框或组合框中某一项的值
.数据类型 HDITEM
    .成员 mask, 整数型
    .成员 cxy, 整数型
    .成员 pszText, 字节集, , , LPSTR　字符串指针
    .成员 hbm, 整数型, , , HBITMAP　句柄
    .成员 cchTextMax, 整数型
    .成员 fmt, 整数型
    .成员 lParam, 整数型, , , LPARAM　自定义类型
    .成员 iImage, 整数型
    .成员 iOrder, 整数型
    .成员 type, 整数型
    .成员 pvFilter, 整数型, , , void　无类型指针
    .成员 state, 整数型
.数据类型 RECT, 公开
    .成员 left, 整数型
    .成员 top, 整数型
    .成员 right, 整数型
    .成员 bottom, 整数型
.数据类型 剪辑版数据, 公开
    .成员 剪辑版数据格式, 整数型
    .成员 文本型数据, 文本型
    .成员 字节集长度, 整数型
    .成员 字节集数据, 字节集
.数据类型 WINDOWPOS
    .成员 hwnd, 整数型
    .成员 hwndInsertAfter, 整数型
    .成员 x, 整数型
    .成员 y, 整数型
    .成员 cx, 整数型
    .成员 cy, 整数型
    .成员 flags, 整数型
.数据类型 NMHDR, , 12
    .成员 hWndFrom, 整数型
    .成员 idFrom, 整数型
    .成员 code, 整数型
.数据类型 NMCUSTOMDRAW, , 48
    .成员 hdr, NMHDR, , , 12
    .成员 dwDrawStage, 整数型, , , 4
    .成员 hdc, 整数型, , , 4
    .成员 rc, 矩形信息, , , 16
    .成员 dwItemSpec, 整数型, , , 4
    .成员 uItemState, 整数型, , , 4
    .成员 lItemlParam, 整数型, , , 4
.数据类型 NMLVCUSTOMDRAW, , 48+40+16=104
    .成员 nmcd, NMCUSTOMDRAW, , , 48
    .成员 clrText, 整数型, , , 4
    .成员 clrTextBk, 整数型, , , 4
    .成员 iSubItem, 整数型, , , 4
    .成员 dwItemType, 整数型, , , 4
    .成员 clrFace, 整数型, , , 4
    .成员 iIconEffect, 整数型, , , 4
    .成员 iIconPhase, 整数型, , , 4
    .成员 iPartId, 整数型, , , 4
    .成员 iStateId, 整数型, , , 4
    .成员 rcText, 矩形信息, , , 16
    .成员 uAlign, 整数型, , , 4
.数据类型 LVINFO
    .成员 窗口句柄, 整数型
    .成员 对象, 对象
.数据类型 TCITEM
    .成员 mask, 整数型
    .成员 dwState, 整数型
    .成员 dwStateMask, 整数型
    .成员 pszText, 文本型
    .成员 cchTextMax, 整数型
    .成员 iImage, 整数型
    .成员 lParam, 整数型
.数据类型 SYSTEM_PROCESSES
    .成员 NextEntryDelta, 整数型
    .成员 ThreadCount, 整数型
    .成员 Reserved1, 整数型, , "6"
    .成员 CreateTime, 长整数型
    .成员 UserTime, 长整数型
    .成员 KernelTime, 长整数型
    .成员 ProcessName, UNICODE_STRING
    .成员 BasePriority, 整数型
    .成员 ProcessID, 整数型
    .成员 InheritedFromProcessId, 整数型
    .成员 HandleCount, 整数型
    .成员 SessionId, 整数型
    .成员 Reserved2, 整数型, , "2"
    .成员 VmCounters, VM_COUNTERS
    .成员 PrivatePageCount, 整数型
    .成员 IoCounters, IO_COUNTERSEX
    .成员 Threads, SYSTEM_THREADS, , "1"
.数据类型 VM_COUNTERS, 公开, 进程_取父ID
    .成员 PeakVirtualSize, 整数型
    .成员 VirtualSize, 整数型
    .成员 PageFaultCount, 整数型
    .成员 PeakWorkingSetSize, 整数型
    .成员 WorkingSetSize, 整数型
    .成员 QuotaPeakPagedPoolUsage, 整数型
    .成员 QuotaPagedPoolUsage, 整数型
    .成员 QuotaPeakNonPagedPoolUsage, 整数型
    .成员 QuotaNonPagedPoolUsage, 整数型
    .成员 PagefileUsage, 整数型
    .成员 PeakPagefileUsage, 整数型
.数据类型 IO_COUNTERSEX
    .成员 ReadOperationCount, 长整数型
    .成员 WriteOperationCount, 长整数型
    .成员 OtherOperationCount, 长整数型
    .成员 ReadTransferCount, 长整数型
    .成员 WriteTransferCount, 长整数型
    .成员 OtherTransferCount, 长整数型
.数据类型 SYSTEM_THREADS
    .成员 KernelTime, 长整数型
    .成员 UserTime, 长整数型
    .成员 CreateTime, 长整数型
    .成员 WaitTime, 整数型
    .成员 StartAddress, 整数型
    .成员 ClientId, CLIENT_ID
    .成员 Priority, 整数型
    .成员 BasePriority, 整数型
    .成员 ContextSwitchCount, 整数型
    .成员 State, 整数型
    .成员 WaitReason, 整数型
.数据类型 菜单消息, 公开
    .成员 名称, 文本型
    .成员 是否插入, 逻辑型, , , 默认为假 假=在菜单末尾添加新的菜单
    .成员 事件, 子程序指针
.数据类型 菜单结构
    .成员 窗口句柄, 整数型
    .成员 菜单标题, 文本型
    .成员 插入位置, 整数型
    .成员 原回调地址, 整数型
    .成员 菜单数据, 菜单消息, , "1"
.数据类型 精易_任务栏缩略图按钮, 公开
    .成员 掩码, 整数型, , , “缩略图按钮掩码_”开头常量组合
    .成员 ID, 整数型
    .成员 图片索引, 整数型
    .成员 图标, 整数型
    .成员 提示文本, 文本型
    .成员 按钮风格, 整数型, , , “缩略图按钮_”开头常量组合
.数据类型 THUMBBUTTON
    .成员 dwMask, 整数型
    .成员 iId, 整数型
    .成员 iBitmap, 整数型
    .成员 hIcon, 整数型
    .成员 szTip, 字节型, , "520"
    .成员 dwFlags, 整数型
.数据类型 DISPLAY_DEVICEA, 公开
    .成员 cb, 整数型
    .成员 DeviceName, 字节型, , "32"
    .成员 DeviceString, 字节型, , "128"
    .成员 StateFlags, 整数型
    .成员 DeviceID, 字节型, , "128"
    .成员 DeviceKey, 字节型, , "128"
.数据类型 MOUSEHOOKSTRUCT, 公开
    .成员 pt, POINT
    .成员 hwnd, 整数型, , , 如果消息是WM_MOUSEWHEEL，则该成员的高位字是轮增量。低位字是保留的。正值表示车轮向前旋转，远离用户; 负值表示车轮向后旋转，朝向用户。单轮定位单击定义为WHEEL_DELTA，即120。如果消息是WM_XBUTTONDOWN，WM_XBUTTONUP，WM_XBUTTONDBLCLK，WM_NCXBUTTONDOWN，WM_NCXBUTTONUP或WM_NCXBUTTONDBLCLK，则高位字指定按下或释放哪个X按钮，并保留低位字。
    .成员 wHitTestCode, 整数型
    .成员 dwExtraInfo, 整数型
.数据类型 POINT, 公开
    .成员 X, 整数型
    .成员 Y, 整数型
.数据类型 HashMap_Str_Str_键值型
    .成员 散列值, 整数型
    .成员 键, 文本型
    .成员 值, 整数型
.数据类型 HashMap_Str_Str_节点型
    .成员 键值链数组, HashMap_Str_Str_键值型, , "1"
.数据类型 LIST_ENTRY64
    .成员 Flink, 长整数型
    .成员 Blink, 长整数型
.数据类型 LDR_DATA_TABLE_ENTRY64
    .成员 InLoadOrderLinks, LIST_ENTRY64, , , 按加载顺序
    .成员 InMemoryOrderLinks, LIST_ENTRY64, , , 按内存顺序
    .成员 InInitializationOrderLinks, LIST_ENTRY64, , , 按初始化顺序
    .成员 DllBase, 长整数型
    .成员 EntryPoint, 长整数型
    .成员 SizeOfImage, 长整数型
    .成员 FullDllName, UNICODE_STRING64
    .成员 BaseDllName, UNICODE_STRING64
.数据类型 模块信息, 公开
    .成员 模块句柄, 文本型
    .成员 模块路径, 文本型
.数据类型 位图结构_
    .成员 bmType, 整数型, , , 一定是0
    .成员 位图宽度, 整数型, , , bmWidth
    .成员 位图高度, 整数型, , , bmHeight
    .成员 bmWidthBytes, 整数型
    .成员 bmPlanes, 整数型
    .成员 bmBitsPixel, 整数型
    .成员 bmBits, 整数型
.数据类型 TRAYDATAEX
    .成员 hWnd, 整数型
    .成员 idCommand, 整数型
    .成员 strFilePath, 文本型
    .成员 strTile, 文本型
.数据类型 TRAYDATA
    .成员 hWnd, 长整数型
    .成员 uID, 整数型
    .成员 uCallbackMessage, 整数型
    .成员 Reserved, 整数型, , "2"
    .成员 hIcon, 整数型
.数据类型 TBBUTTON
    .成员 idBitMap, 整数型
    .成员 idCommand, 整数型
    .成员 fsState, 字节型
    .成员 fsStyle, 字节型
    .成员 bReserved, 字节型, , "6"
    .成员 dwData, 整数型
    .成员 iString, 整数型
.数据类型 CLIENT_ID
    .成员 UniqueProcess, 整数型
    .成员 UniqueThread, 整数型
.数据类型 OBJECT_ATTRIBUTES
    .成员 Length, 整数型
    .成员 RootDirectory, 整数型
    .成员 ObjectName, 整数型
    .成员 Attributes, 整数型
    .成员 SecurityDescriptor, 整数型
    .成员 SecurityQualityOfService, 整数型
.数据类型 SYSTEM_HANDLE_TABLE_ENTRY_INFO
    .成员 UniqueProcessId, 短整数型, , , ""
    .成员 CreatorBackTraceIndex, 短整数型, , , ""
    .成员 ObjectTypeIndex, 字节型, , , ""
    .成员 HandleAttributes, 字节型, , , ""
    .成员 HandleValue, 短整数型, , , ""
    .成员 pObject, 整数型, , , ""
    .成员 GrantedAccess, 整数型, , , ""
.数据类型 IP_ADDR_STRING
    .成员 Next, 整数型
    .成员 IpAddress, 字节型, , "16", IP_ADDRESS_STRING
    .成员 IpMask, 字节型, , "16", IP_MASK_STRING=IP_ADDRESS_STRING
    .成员 Context, 整数型
.数据类型 精易_网卡信息, 公开
    .成员 名称, 文本型
    .成员 连接名称, 文本型
    .成员 Mac, 文本型
    .成员 Ip, 文本型
    .成员 掩码, 文本型
    .成员 网关, 文本型
    .成员 DNS1, 文本型
    .成员 DNS2, 文本型
.数据类型 IMAGE_DATA_DIRECTORY
    .成员 VirtualAddress, 整数型
    .成员 Size, 整数型
.数据类型 IMAGE_OPTIONAL_HEADER
    .成员 Magic, 短整数型
    .成员 MajorLinkerVersion, 字节型
    .成员 MinorLinkerVersion, 字节型
    .成员 SizeOfCode, 整数型
    .成员 SizeOfInitializedData, 整数型
    .成员 SizeOfUnitializedData, 整数型
    .成员 AddressOfEntryPoint, 整数型
    .成员 BaseOfCode, 整数型
    .成员 BaseOfData, 整数型
    .成员 ImageBase, 整数型
    .成员 SectionAlignment, 整数型
    .成员 FileAlignment, 整数型
    .成员 MajorOperatingSystemVersion, 短整数型
    .成员 MinorOperatingSystemVersion, 短整数型
    .成员 MajorImageVersion, 短整数型
    .成员 MinorImageVersion, 短整数型
    .成员 MajorSubsystemVersion, 短整数型
    .成员 MinorSubsystemVersion, 短整数型
    .成员 W32VersionValue, 整数型
    .成员 SizeOfImage, 整数型
    .成员 SizeOfHeaders, 整数型
    .成员 CheckSum, 整数型
    .成员 SubSystem, 短整数型
    .成员 DllCharacteristics, 短整数型
    .成员 SizeOfStackReserve, 整数型
    .成员 SizeOfStackCommit, 整数型
    .成员 SizeOfHeapReserve, 整数型
    .成员 SizeOfHeapCommit, 整数型
    .成员 LoaderFlags, 整数型
    .成员 NumberOfRvaAndSizes, 整数型
    .成员 DataDirectory, IMAGE_DATA_DIRECTORY, , "16"
.数据类型 IMAGE_FILE_HEADER
    .成员 Machine, 短整数型
    .成员 NumberOfSections, 短整数型
    .成员 TimeDateStamp, 整数型
    .成员 PointerToSymbolTable, 整数型
    .成员 NumberOfSymbols, 整数型
    .成员 SizeOfOptionalHeader, 短整数型
    .成员 characteristics, 短整数型
.数据类型 FLOATING_SAVE_AREA
    .成员 ControlWord, 整数型
    .成员 StatusWord, 整数型
    .成员 TagWord, 整数型
    .成员 ErrorOffset, 整数型
    .成员 ErrorSelector, 整数型
    .成员 DataOffset, 整数型
    .成员 DataSelector, 整数型
    .成员 RegisterArea, 字节型, , "80"
    .成员 Cr0NpxState, 整数型
.数据类型 IMAGE_SECTION_HEADER
    .成员 SecName, 字节型, , "8"
    .成员 VirtualSize, 整数型
    .成员 VirtualAddress, 整数型
    .成员 SizeOfRawData, 整数型
    .成员 PointerToRawData, 整数型
    .成员 PointerToRelocations, 整数型
    .成员 PointerToLinenumbers, 整数型
    .成员 NumberOfRelocations, 短整数型
    .成员 NumberOfLinenumbers, 短整数型
    .成员 characteristics, 整数型
.数据类型 CONTEXT86
    .成员 ContextFlags, 整数型
    .成员 Dr0, 整数型
    .成员 Dr1, 整数型
    .成员 Dr2, 整数型
    .成员 Dr3, 整数型
    .成员 Dr6, 整数型
    .成员 Dr7, 整数型
    .成员 FloatSave, FLOATING_SAVE_AREA
    .成员 SegGs, 整数型
    .成员 SegFs, 整数型
    .成员 SegEs, 整数型
    .成员 SegDs, 整数型
    .成员 Edi, 整数型
    .成员 Esi, 整数型
    .成员 Ebx, 整数型
    .成员 Edx, 整数型
    .成员 Ecx, 整数型
    .成员 Eax, 整数型
    .成员 Ebp, 整数型
    .成员 Eip, 整数型
    .成员 SegCs, 整数型
    .成员 EFlags, 整数型
    .成员 Esp, 整数型
    .成员 SegSs, 整数型
.数据类型 STARTUPINFO_x
    .成员 cb, 整数型
    .成员 lpReserved, 整数型
    .成员 lpDesktop, 整数型
    .成员 lpTitle, 整数型
    .成员 dwX, 整数型
    .成员 dwY, 整数型
    .成员 dwXSize, 整数型
    .成员 dwYSize, 整数型
    .成员 dwXCountChars, 整数型
    .成员 dwYCountChars, 整数型
    .成员 dwFillAttribute, 整数型
    .成员 dwFlags, 整数型
    .成员 wShowWindow, 短整数型
    .成员 cbReserved2, 短整数型
    .成员 lpReserved2, 整数型
    .成员 hStdInput, 整数型
    .成员 hStdOutput, 整数型
    .成员 hStdError, 整数型
.数据类型 IMAGE_NT_HEADERS
    .成员 Signature, 整数型
    .成员 FileHeader, IMAGE_FILE_HEADER
    .成员 OptionalHeader, IMAGE_OPTIONAL_HEADER
.数据类型 IMAGE_DOS_HEADER
    .成员 e_magic, 短整数型
    .成员 e_cblp, 短整数型
    .成员 e_cp, 短整数型
    .成员 e_crlc, 短整数型
    .成员 e_cparhdr, 短整数型
    .成员 e_minalloc, 短整数型
    .成员 e_maxalloc, 短整数型
    .成员 e_ss, 短整数型
    .成员 e_sp, 短整数型
    .成员 e_csum, 短整数型
    .成员 e_ip, 短整数型
    .成员 e_cs, 短整数型
    .成员 e_lfarlc, 短整数型
    .成员 e_ovno, 短整数型
    .成员 e_res, 短整数型, , "4"
    .成员 e_oemid, 短整数型
    .成员 e_oeminfo, 短整数型
    .成员 e_res2, 短整数型, , "10"
    .成员 e_lfanew, 整数型
.数据类型 精易_运行信息, 公开
    .成员 进程句柄, 整数型
    .成员 主线程句柄, 整数型
    .成员 进程ID, 整数型
    .成员 主线程ID, 整数型
.数据类型 临界许可, 公开, 临界许可类
    .成员 标识, 整数型, , , DebugInfo 这个只要大于0就表示许可证存在
    .成员 LockCount, 整数型
    .成员 RecursionCount, 整数型
    .成员 OwningThread, 整数型
    .成员 LockSemaphore, 整数型
    .成员 SpinCount, 整数型
.数据类型 矩形信息, 公开
    .成员 左边, 整数型
    .成员 顶边, 整数型
    .成员 宽度, 整数型
    .成员 高度, 整数型
.数据类型 精易_详细信息, 公开, 用于存放解析的自绘窗口元素信息
    .成员 子窗口数, 文本型
    .成员 控件ID, 文本型
    .成员 控件描述, 文本型
    .成员 控件名称, 文本型
    .成员 控件状态, 文本型
    .成员 控件类型, 文本型
    .成员 控件值, 文本型
    .成员 窗口位置, 文本型
    .成员 矩形信息, 矩形信息
    .成员 默认动作, 文本型
    .成员 状态标识, 文本型
    .成员 类型标识, 文本型
    .成员 屏幕位置, 文本型
    .成员 窗口大小, 文本型
.数据类型 精易_鼠标移入移出事件, 公开
    .成员 句柄, 整数型
    .成员 消息钩子句柄, 整数型
    .成员 移入事件, 子程序指针
    .成员 移出事件, 子程序指针
.数据类型 物理字体属性信息_, , TEXTMETRIC
    .成员 tmHeight, 整数型
    .成员 tmAscent, 整数型
    .成员 tmDescent, 整数型
    .成员 tmInternalLeading, 整数型
    .成员 tmExternalLeading, 整数型
    .成员 tmAveCharWidth, 整数型
    .成员 tmMaxCharWidth, 整数型
    .成员 tmWeight, 整数型
    .成员 tmOverhang, 整数型
    .成员 tmDigitizedAspectX, 整数型
    .成员 tmDigitizedAspectY, 整数型
    .成员 tmFirstChar, 字节型
    .成员 tmLastChar, 字节型
    .成员 tmDefaultChar, 字节型
    .成员 tmBreakChar, 字节型
    .成员 tmItalic, 字节型
    .成员 tmUnderlined, 字节型
    .成员 tmStruckOut, 字节型
    .成员 tmPitchAndFamily, 字节型
    .成员 tmCharSet, 字节型
.数据类型 PROCESS_BASIC_INFORMATION, 公开
    .成员 ExitStatus, 整数型
    .成员 PebBaseAddress, 整数型
    .成员 AffinityMask, 整数型
    .成员 BasePriority, 整数型
    .成员 UniqueProcessId, 整数型
    .成员 InheritedFromUniqueProcessId, 整数型
.数据类型 Process_Memory_Counters, , 进程内存统计_
    .成员 结构大小, 整数型, , , cb
    .成员 页错误数量, 整数型, , , PageFaultCount
    .成员 最高工作设置大小, 整数型, , , PeakWorkingSetSize
    .成员 当前工作设置大小, 整数型, , , WorkingSetSize
    .成员 最高页使用, 整数型, , , QuotaPeakPagedPoolUsage
    .成员 当前页使用, 整数型, , , QuotaPagedPoolUsage
    .成员 最高非页使用, 整数型, , , QuotaPeakNonPagedPoolUsage
    .成员 当前非页使用, 整数型, , , QuotaPeakNonPagedPoolUsage
    .成员 页文件使用, 整数型, , , PagefileUsage
    .成员 最高页文件使用, 整数型, , , PeakPagefileUsage
.数据类型 MEMORY_BASIC_INFORMATION
    .成员 BaseAddress, 整数型
    .成员 byscsd, 整数型, , , 应用程序可用的最小地址
    .成员 AllocattionProtect, 整数型, , , 应用程序可用的最大地址
    .成员 RegionSize, 整数型
    .成员 State, 整数型
    .成员 Protect, 整数型
    .成员 Type, 整数型
.数据类型 SYSTEM_PROCESS_INFORMATION_ex
    .成员 dwNextEntryOffset, 整数型
    .成员 dwNumberOfThreads, 整数型
    .成员 qSpareLi1, 长整数型
    .成员 qSpareLi2, 长整数型
    .成员 qSpareLi3, 长整数型
    .成员 qCreateTime, 长整数型
    .成员 qUserTime, 长整数型
    .成员 qKernelTime, 长整数型
    .成员 ImageName, UNICODE_STRING
    .成员 nBasePriority, 整数型
    .成员 dwProcessId, 整数型
    .成员 dwInheritedFromUniqueProcessId, 整数型
    .成员 dwHandleCount, 整数型
    .成员 dwSessionId, 整数型
    .成员 dwSpareUl3, 长整数型
    .成员 tPeakVirtualSize, 整数型
    .成员 tVirtualSize, 整数型
    .成员 dwPageFaultCount, 整数型
    .成员 dwPeakWorkingSetSize, 整数型
    .成员 dwWorkingSetSize, 整数型
    .成员 tQuotaPeakPagedPoolUsage, 整数型
    .成员 tQuotaPagedPoolUsage, 整数型
    .成员 tQuotaPeakNonPagedPoolUsage, 整数型
    .成员 tQuotaNonPagedPoolUsage, 整数型
    .成员 tPagefileUsage, 整数型
    .成员 tPeakPagefileUsage, 整数型
    .成员 tPrivatePageCount, 整数型
    .成员 qReadOperationCount, 长整数型
    .成员 qWriteOperationCount, 长整数型
    .成员 qOtherOperationCount, 长整数型
    .成员 qReadTransferCount, 长整数型
    .成员 qWriteTransferCount, 长整数型
    .成员 qOtherTransferCount, 长整数型
.数据类型 PROCESS_BASIC_INFORMATION64
    .成员 ExitStatus, 整数型
    .成员 Reserved0, 整数型
    .成员 PebBaseAddress, 长整数型
    .成员 AffinityMask, 长整数型
    .成员 BasePriority, 整数型
    .成员 Reserved1, 整数型
    .成员 UniqueProcessId, 长整数型
    .成员 InheritedFromUniqueProcessId, 长整数型
.数据类型 PEB_LDR_DATA
    .成员 Reserved1, 整数型, , "6"
    .成员 Ldr, 长整数型
    .成员 ProcessParameters, 长整数型
.数据类型 RTL_USER_PROCESS_PARAMETERS, , 14 
    .成员 ImagePathName, UNICODE_STRING64, , , 16
    .成员 CommandLine, UNICODE_STRING64, , , 16
.数据类型 UNICODE_STRING64
    .成员 Length, 短整数型
    .成员 MaximumLength, 短整数型
    .成员 Reserved, 整数型, , , 占位符
    .成员 Buffer, 长整数型
.数据类型 LPMODULEENTRY32, , 模块信息
    .成员 size, 整数型
    .成员 mid, 整数型, , , 模块ID
    .成员 pid, 整数型, , , 进程ID
    .成员 gusage, 整数型, , , 全局引用数
    .成员 pusage, 整数型, , , 引用数
    .成员 base, 整数型, , , 模块基址
    .成员 bsize, 整数型, , , 模块大小
    .成员 hmodule, 整数型, , , 模块句柄
    .成员 szname, 字节型, , "256", 模块名
    .成员 szpath, 字节型, , "256", 模块路径
.数据类型 SHFILEINFO
    .成员 hIcon
    .成员 iIcon
    .成员 dwAttributes
    .成员 szDisplayName, 字节型, , "260"
    .成员 szTypeName, 字节型, , "80"
.数据类型 struct
    .成员 hwnd, 整数型
    .成员 message, 整数型
    .成员 wParam, 整数型
    .成员 lParam, 整数型
    .成员 time, 整数型
    .成员 pt, 整数型
.数据类型 钩子相关
    .成员 键盘钩子回调函数, 子程序指针
    .成员 键盘钩子句柄, 整数型
    .成员 鼠标钩子回调函数, 子程序指针
    .成员 鼠标钩子句柄, 整数型
.数据类型 INTERNET_CACHE_ENTRY_INFO
    .成员 dwStructSize, 整数型, , "1", 结构尺寸
    .成员 lpszSourceUrlName, 文本型, , , url
    .成员 lpszLocalFileName, 文本型, , , 路径文件名
    .成员 CacheEntryType, 整数型, , ,  ？65是什么
    .成员 dwUseCount, 整数型, , , 缓存条目
    .成员 dwHitRate, 整数型, , , 已访问次数
    .成员 dwSizeLow, 整数型, , , 缓存文件大小
    .成员 dwSizeHigh, 整数型
    .成员 LastModifiedTime, 长整数型, , , 最后修改时间
    .成员 ExpireTime, 长整数型, , , 到期时间
    .成员 LastAccessTime, 长整数型, , , 上次访问的时间
    .成员 LastSyncTime, 长整数型, , , 最后一次缓存时间
    .成员 lpHeaderInfo, 文本型, , , 地址缓冲包含标题信息
    .成员 dwHeaderInfoSize, 整数型, , , lpHeaderInfo缓冲区大小
    .成员 lpszFileExtension, 文本型, , , 地址的一个字符串
    .成员 dwReserved, 整数型, , , 0 保留
    .成员 dwExemptDelta, 整数型, , , 访问间隔？
.数据类型 LARGE_INTEGER, , 长整数型_;
    .成员 lowpart, 整数型
    .成员 highpart, 整数型
.数据类型 INTERNET_PROXY_INFO, , 代理服务器信息
    .成员 dwAccessType, 整数型
    .成员 lpszProxy, 文本型
    .成员 lpszProxyBypass, 文本型
.数据类型 SERVICE_DESCRIPTION, , 服务描述结构
    .成员 lpDescription, 文本型
.数据类型 SERVICE_Table, , 服务表结构
    .成员 lpServiceName, 整数型
    .成员 lpServiceProc, 整数型
.数据类型 QUERY_SERVICE_CONFIG, , 服务的配置信息。
    .成员 dwServiceType, 整数型, , , 4
    .成员 dwStartType, 整数型, , , 4
    .成员 dwErrorControl, 整数型, , , 4
    .成员 lpBinaryPathName
    .成员 lpLoadOrderGroup
    .成员 dwTagId, 整数型, , , 4
    .成员 lpDependencies
    .成员 lpServiceStartName
    .成员 lpDisplayName
.数据类型 SERVICE_STATUS, , 服务状态结构
    .成员 dwServiceType, 整数型
    .成员 dwCurrentState, 整数型
    .成员 dwControlsAccepted, 整数型
    .成员 dwWin32ExitCode, 整数型
    .成员 dwServiceSpecificExitCode, 整数型
    .成员 dwCheckPoint, 整数型
    .成员 dwWaitHint, 整数型
.数据类型 SHFILEOPSTRUCT
    .成员 句柄, 整数型
    .成员 wFunc, 整数型
    .成员 pFrom, 字节集
    .成员 pTo, 字节集
    .成员 fFlags, 短整数型
    .成员 fAnyOperationsAborted, 整数型
    .成员 hNameMappings, 整数型
    .成员 lpszProgressTitle, 文本型
.数据类型 地址信息
    .成员 地址, 文本型
    .成员 端口, 整数型
.数据类型 客户信息, 公开
    .成员 IP, 文本型
    .成员 端口, 短整数型
    .成员 句柄, 整数型
.数据类型 fd_set
    .成员 fd_count, 整数型
    .成员 fd_array, 整数型
.数据类型 套接字地址, 公开, sockaddr
    .成员 常量, 短整数型, , , sin_family
    .成员 端口, 短整数型, , , sin_port
    .成员 地址, 整数型, , , sin_addr
    .成员 地址范围, 字节型, , "8", sin_zero
.数据类型 套接字信息, 公开, WSADataType
    .成员 版本, 短整数型, , , wVersion
    .成员 高版本, 短整数型, , , wHighVersion
    .成员 种类, 字节型, , "257", * WSA_DescriptionSize
    .成员 系统状态, 字节型, , "129", * WSA_SysStatusSize
    .成员 最大套接字, 短整数型, , , iMaxSockets
    .成员 最大Udp, 短整数型, , , iMaxUdpDg
    .成员 信息, 整数型, , , lpVendorInfo
.数据类型 按钮信息, , 显示或隐藏任务栏指定按钮
    .成员 cbSize, 整数型, , , 32
    .成员 dwMask, 整数型
    .成员 idCommand, 整数型
    .成员 iImage, 整数型
    .成员 fsState, 字节型
    .成员 fsStyle, 字节型
    .成员 cx, 短整数型
    .成员 lParam, 整数型
    .成员 pszText, 整数型
    .成员 cchText, 整数型
.数据类型 IDE, , 取磁盘信息
    .成员 bFeaturesReg, 字节型
    .成员 bSectorCountReg, 字节型
    .成员 bSectorNumberReg, 字节型
    .成员 bCylLowReg, 字节型
    .成员 bCylHighReg, 字节型
    .成员 bDriveHeadReg, 字节型
    .成员 bCommandReg, 字节型
.数据类型 SCIP, , 取磁盘信息
    .成员 cBufferSize, 整数型
    .成员 irDriveRegs, IDE
    .成员 bDriveNumber, 字节型
    .成员 bReserved, 字节型, , "3"
    .成员 dwReserved, 整数型, , "4"
    .成员 bBuffer, 字节型, , "1"
.数据类型 精易_磁盘信息, 公开
    .成员 型号, 文本型
    .成员 序列号, 文本型
    .成员 固件版本, 文本型
.数据类型 项目数据, 公开, 树型框操作类
    .成员 项目文本, 文本型, , , 项目文本
    .成员 图片索引, 整数型, , , 图象
    .成员 选中图片索引, 整数型, , , 选择图象
    .成员 项目数值, 整数型, , , 项目数值
    .成员 是否加粗, 逻辑型
    .成员 项目句柄, 长整数型, 传址
.数据类型 树型框结构, , 树型框操作类
    .成员 项目文本, 文本型
    .成员 图片索引, 整数型
    .成员 选中图片索引, 整数型
    .成员 项目数值, 整数型
    .成员 加粗扩展, 整数型, , , 0、普通，1、加粗，2、扩展，3、加粗+扩展
    .成员 缩进层次, 整数型
.数据类型 TVITEMEX, , 树型框操作类
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 文本型, 传址, , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。
.数据类型 TVITEMEX2, , 树型框操作类
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 整数型, , , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。
.数据类型 TVINSERTSTRUCT, , 树型框操作类
    .成员 hParent, 整数型, , , 父
    .成员 hInsertAfter, 整数型, , , 插入标志
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 文本型, 传址, , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。
.数据类型 TVINSERTSTRUCT2, , 树型框操作类
    .成员 hParent, 整数型, , , 父
    .成员 hInsertAfter, 整数型, , , 插入标志
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 整数型, , , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。
.数据类型 内存映射数据9X
    .成员 映射文件号, 整数型
    .成员 指针, 整数型
.数据类型 线程许可证, 公开
    .成员 调试信息, 整数型
    .成员 锁计数, 整数型
    .成员 递归计数, 整数型
    .成员 拥有线程, 整数型
    .成员 锁信号量, 整数型
    .成员 自旋数, 整数型
.数据类型 剪贴板_置文件
    .成员 pFiles, 整数型
    .成员 pt, 精易_坐标
    .成员 fNC, 整数型
    .成员 fWide, 整数型
.数据类型 取硬盘特征号0, , 33-1
    .成员 cBufferSize, 整数型
    .成员 bFeaturesReg, 字节型, , , IDEREGS_Begin
    .成员 bSectorCountReg, 字节型
    .成员 bSectorNumberReg, 字节型
    .成员 bCylLowReg, 字节型
    .成员 bCylHighReg, 字节型
    .成员 bDriveHeadReg, 字节型
    .成员 bCommandReg, 字节型
    .成员 bReserved1, 字节型, , , IDEREGS_End
    .成员 bDriveNumber, 字节型
    .成员 bReserved, 字节型, , "3"
    .成员 dwReserved, 整数型, , "4"
    .成员 bBuffer, 字节型
.数据类型 取硬盘特征号1, , 24
    .成员 bVersion, 字节型
    .成员 bRevision, 字节型
    .成员 bReserved, 字节型
    .成员 bIDEDeviceMap, 字节型
    .成员 fCapabilities, 整数型
    .成员 dwReserved, 整数型, , "4"
.数据类型 取硬盘特征号2, , 28+33-1
    .成员 HeaderLength, 整数型
    .成员 Signature, 字节型, , "8"
    .成员 Timeout, 整数型
    .成员 ControlCode, 整数型
    .成员 ReturnCode, 整数型
    .成员 Length, 整数型
    .成员 cBufferSize, 整数型, , , SENDCMDINPARAMS_Begin
    .成员 bFeaturesReg, 字节型, , , IDEREGS_Begin
    .成员 bSectorCountReg, 字节型
    .成员 bSectorNumberReg, 字节型
    .成员 bCylLowReg, 字节型
    .成员 bCylHighReg, 字节型
    .成员 bDriveHeadReg, 字节型
    .成员 bCommandReg, 字节型
    .成员 bReserved1, 字节型, , , IDEREGS_End
    .成员 bDriveNumber, 字节型
    .成员 bReserved, 字节型, , "3"
    .成员 dwReserved, 整数型, , "4"
    .成员 bBuffer, 字节型, , , SENDCMDINPARAMS_End
.数据类型 取硬盘特征号3, , 256
    .成员 wGenConfig, 短整数型
    .成员 wNumCyls, 短整数型
    .成员 wReserved, 短整数型
    .成员 wNumHeads, 短整数型
    .成员 wBytesPerTrack, 短整数型
    .成员 wBytesPerSector, 短整数型
    .成员 wSectorsPerTrack, 短整数型
    .成员 wVendorUnique, 短整数型, , "3"
    .成员 sSerialNumber, 字节型, , "20"
    .成员 wBufferType, 短整数型
    .成员 wBufferSize, 短整数型
    .成员 wECCSize, 短整数型
    .成员 sFirmwareRev, 字节型, , "8"
    .成员 sModelNumber, 字节型, , "40"
    .成员 wMoreVendorUnique, 短整数型
    .成员 wDoubleWordIO, 短整数型
    .成员 wCapabilities, 短整数型
    .成员 wReserved1, 短整数型
    .成员 wPIOTiming, 短整数型
    .成员 wDMATiming, 短整数型
    .成员 wBS, 短整数型
    .成员 wNumCurrentCyls, 短整数型
    .成员 wNumCurrentHeads, 短整数型
    .成员 wNumCurrentSectorsPerTrack, 短整数型
    .成员 ulCurrentSectorCapacity, 整数型
    .成员 wMultSectorStuff, 短整数型
    .成员 ulTotalAddressableSectors, 整数型
    .成员 wSingleWordDMA, 短整数型
    .成员 wMultiWordDMA, 短整数型
    .成员 bReserved, 字节型, , "128"
.数据类型 GdiplusStartupInput
    .成员 GdiplusVersion, 整数型
    .成员 DebugEventCallback, 整数型
    .成员 SuppressBackgroundThread, 整数型
    .成员 SuppressExternalCodecs, 整数型
.数据类型 BLENDFUNCTION
    .成员 BlendOp, 字节型
    .成员 BlendFlags, 字节型
    .成员 SourceConstantAlpha, 字节型
    .成员 AlphaFormat, 字节型
.数据类型 Size, , 尺寸;
    .成员 cx, 整数型
    .成员 cy, 整数型
.数据类型 BITMAPINFO
    .成员 BITMAPINFOHEADER, BITMAPINFOHEADER
    .成员 bmiColors, 整数型, , , RGBQUAD          bmiColors[1]; 
.数据类型 BITMAPINFOHEADER
    .成员 biSize, 整数型
    .成员 biWidth, 整数型
    .成员 biHeight, 整数型
    .成员 biPlanes, 短整数型
    .成员 biBitCount, 短整数型
    .成员 biCompression, 整数型
    .成员 biSizeImage, 整数型
    .成员 biXPelsPerMeter, 整数型
    .成员 biYPelsPerMeter, 整数型
    .成员 biClrUsed, 整数型
    .成员 biClrImportant, 整数型
.数据类型 BITMAPFILEHEADER
    .成员 bfType, 短整数型
    .成员 bfSize, 整数型
    .成员 bfReserved1, 短整数型
    .成员 bfReserved2, 短整数型
    .成员 bfOffBits, 整数型
.数据类型 BITMAP
    .成员 bmType, 整数型
    .成员 bmWidth, 整数型
    .成员 bmHeight, 整数型
    .成员 bmWidthBytes, 整数型
    .成员 bmPlanes, 短整数型
    .成员 bmBitsPixel, 短整数型
    .成员 bmBits, 整数型, 传址
.数据类型 位图信息_, , 位图信息_
    .成员 结果大小, 整数型, , , biSize
    .成员 位图宽度, 整数型, , , biWidth
    .成员 位图高度, 整数型, , , biHeight
    .成员 位图位面数, 短整数型, , , biPlanes
    .成员 位深度, 短整数型, , , biBitCount
    .成员 压缩率, 整数型, , , biCompression
    .成员 位图大小, 整数型, , , biSizeImage
    .成员 水平折像度, 整数型, , , biXPelsPerMeter
    .成员 垂直折像度, 整数型, , , biYPelsPerMeter
    .成员 位图颜色表索引, 整数型, , , biClrUsed
    .成员 位图显示索引, 整数型, , , biClrImportant
    .成员 蓝色值, 字节型, , , rgbBlue
    .成员 绿色值, 字节型, , , rgbGreen
    .成员 红色值, 字节型, , , rgbRed
    .成员 保留参数, 字节型, , , rgbReserved
.数据类型 _验证码取图, , 设备无关位图;
    .成员 biSize, 整数型, , , 40
    .成员 biWidth, 整数型, , , btm.bmWidth
    .成员 biHeight, 整数型, , , btm.bmHeight
    .成员 biPlanes, 短整数型, , , 1
    .成员 biBitCount, 短整数型, , , btm.bmBitsPixel
    .成员 biCompression, 整数型, , , 0
    .成员 biSizeImage, 整数型, , , (btm.bmWidth*24+31)/8*btm.bmHeight
    .成员 biXPelsPerMeter, 整数型, , , 0
    .成员 biYPelsPerMeter, 整数型, , , 0
    .成员 biClrUsed, 整数型, , , 0 24色取0
    .成员 biClrImportant, 整数型, , , 0
.数据类型 超级列表框0
    .成员 掩码, 整数型
    .成员 项目, 整数型
    .成员 子项目, 整数型
    .成员 状态, 整数型
    .成员 状态掩码, 整数型
    .成员 项目文本, 文本型, 传址
    .成员 项目文本长度, 整数型
    .成员 图片索引, 整数型
    .成员 项目数值, 整数型
    .成员 缩进, 整数型
.数据类型 超级列表框1
    .成员 掩码, 整数型
    .成员 表项索引, 整数型
    .成员 子项目, 整数型
    .成员 状态, 整数型
    .成员 状态掩码, 整数型
    .成员 项目文本, 整数型
    .成员 项目文本长度, 整数型
    .成员 图片索引, 整数型
    .成员 项目数值, 整数型
    .成员 缩进, 整数型
.数据类型 列表框信息, 公开
    .成员 标题, 文本型, 传址, , 本参数指定表项的标题文本(也即是第0列的标题)。
    .成员 图片索引, 整数型, , , 图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。
    .成员 状态图片索引, 整数型, , , 状态图片索引用于指定“状态图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。
    .成员 表项数值, 整数型, , , 该数值与指定表项相关联。
    .成员 缩进数目, 整数型, , , “缩进数目”仅在报表型列表框才有效，用作指定显示时在表项首部增加的空白数。
    .成员 列标题, 文本型, , "1", 从第1列开始计起的列标题，多列请按列索引次序依次写到相应的数组成员中
    .成员 列图片索引, 整数型, , "1", 从第1列开始计起，可以被省略。图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
.数据类型 超级列表框3
    .成员 flags, 整数型, , , 查找类型常量
    .成员 LPCTSTR, 文本型, 传址, , LVFI_STRING or LVFI_PARTIAL 才能有效
    .成员 lParam, 整数型, , , LVFI_PARAM 才能有效
    .成员 pt, 精易_坐标, 传址, , LVFI_NEARESTXY 才能有效
    .成员 vkDirection, 整数型, , , 查找热键常量，LVFI_NEARESTXY 才能有效
.数据类型 超级列表框4
    .成员 flags, 整数型, , , 查找类型常量
    .成员 LPCTSTR, 整数型, , , LVFI_STRING or LVFI_PARTIAL 才能有效
    .成员 lParam, 整数型, , , LVFI_PARAM 才能有效
    .成员 pt, 整数型, , , LVFI_NEARESTXY 才能有效
    .成员 vkDirection, 整数型, , , 查找热键常量，LVFI_NEARESTXY 才能有效
.数据类型 超级列表框5
    .成员 ulFlags, 整数型
    .成员 hbm, 整数型, , , 没有使用,置0
    .成员 图片路径, 文本型, 传址
    .成员 最大长度, 整数型
    .成员 xOffsetPercent, 整数型, , , X补偿百分比
    .成员 yOffsetPercent, 整数型, , , Y补偿百分比
.数据类型 超级列表框6
    .成员 ulFlags, 整数型
    .成员 hbm, 整数型, , , 没有使用,置0
    .成员 pszImage, 整数型, , , 图片路径
    .成员 cchImageMax, 整数型, , , 最大长度
    .成员 xOffsetPercent, 整数型, , , X补偿百分比
    .成员 yOffsetPercent, 整数型, , , Y补偿百分比
.数据类型 超级列表框7
    .成员 mask, 整数型
    .成员 对齐方式, 整数型
    .成员 列宽度, 整数型
    .成员 列标题, 文本型, 传址
    .成员 缓冲区长度, 整数型
    .成员 列索引, 整数型
    .成员 列图标, 整数型
    .成员 iOrder, 整数型
.数据类型 超级列表框8
    .成员 mask, 整数型
    .成员 对齐方式, 整数型
    .成员 列宽度, 整数型
    .成员 列标题, 整数型
    .成员 缓冲区长度, 整数型
    .成员 列索引, 整数型
    .成员 列图标, 整数型
    .成员 iOrder, 整数型
.数据类型 精易_颜色对话框, 公开
    .成员 长度, 整数型
    .成员 窗口句柄, 整数型
    .成员 hInstance, 整数型
    .成员 rgbResult, 整数型
    .成员 颜色数长度, 文本型
    .成员 lCustData, 整数型
    .成员 lpfnHook, 整数型
    .成员 lpTemplateName, 文本型
.数据类型 查找的文件信息
    .成员 dwFileAttributes, 整数型
    .成员 ftCreationTime, 文件时间
    .成员 ftLastAccessTime, 文件时间
    .成员 ftLastWriteTime, 文件时间
    .成员 nFileSizeHigh, 整数型
    .成员 nFileSizeLow, 整数型
    .成员 dwReserved0, 整数型
    .成员 dwReserved1, 整数型
    .成员 cFileName, 字节型, , "260"
    .成员 cAlternate, 字节型, , "14"
.数据类型 文件时间, , 文件时间;
    .成员 底部时间数据, 整数型
    .成员 顶部时间数据, 整数型
.数据类型 精易_任务相关
    .成员 cbSize, 整数型
    .成员 hwnd, 整数型
    .成员 uCallbackMessage, 整数型
    .成员 uEdge, 整数型
    .成员 rc, 精易_矩形
    .成员 lParam, 整数型
.数据类型 权限特征, , TOKEN_PRIVILEGES
    .成员 权限, 整数型, , , PrivilegeCount
    .成员 低三十二位, 整数型, , , LowPart
    .成员 高三十二位, 整数型, , , HighPart
    .成员 属性, 整数型, , , Attributes
    .成员 低三十二位1, 整数型, , , LowPart
    .成员 高三十二位1, 整数型, , , HighPart
    .成员 属性1, 整数型, , , Attributes
.数据类型 精易_进程权限, , From:AdjustTokenPrivileges
    .成员 PrivilegeCount, 整数型
    .成员 LowPart, 整数型
    .成员 HighPart, 整数型
    .成员 Attributes, 整数型
.数据类型 精易_进程令牌, , 进程令牌
    .成员 低三十二位, 整数型
    .成员 高三十二位, 整数型
.数据类型 精易_模块信息, 公开, 进程模块信息
    .成员 size, 整数型, , , 1
    .成员 mid, 整数型, , , 模块ID
    .成员 pid, 整数型, , , 进程ID
    .成员 gusage, 整数型, , , 全局引用数
    .成员 pusage, 整数型, , , 引用数
    .成员 base, 整数型, , , 模块基址
    .成员 大小, 整数型, , , 模块大小
    .成员 模块句柄, 整数型, , , 模块句柄
    .成员 模块文件名, 字节型, , "256", 模块名
    .成员 模块完整路径, 字节型, , "256", 模块路径
.数据类型 精易_目录浏览
    .成员 hOwner, 整数型
    .成员 pidlRoot, 整数型
    .成员 pszDisplayName, 文本型
    .成员 lpszTitle, 文本型
    .成员 ulFlags, 整数型
    .成员 lpfn, 子程序指针
    .成员 lParam, 整数型
    .成员 iImage, 整数型
.数据类型 精易_热键信息
    .成员 窗口句柄, 整数型
    .成员 热键ID
    .成员 回调函数, 整数型
.数据类型 光驱相关1
    .成员 dwCallback, 整数型
    .成员 wDeviceID, 整数型
    .成员 lpstrDeviceType, 文本型
    .成员 lpstrElementName, 文本型
    .成员 lpstrAlias, 整数型
.数据类型 光驱相关2
    .成员 dwCallback, 整数型
    .成员 dwTimeFormat, 整数型
    .成员 dwAudio, 整数型
.数据类型 精易_进程信息, 公开
    .成员 进程ID, 整数型
    .成员 进程名, 文本型
    .成员 进程全路径名, 文本型
.数据类型 精易_进程结构, 公开
    .成员 进程句柄, 整数型, , , hProcess
    .成员 线程句柄, 整数型, , , hThread
    .成员 进程标识符, 整数型, , , dwProcessId
    .成员 线程标识符, 整数型, , , dwThreadId
.数据类型 StartupInfo, 公开
    .成员 cbSize, 整数型
    .成员 lpReserved, 整数型
    .成员 lpDesktop, 整数型
    .成员 lpTitle, 整数型
    .成员 dwX, 整数型
    .成员 dwY, 整数型
    .成员 dwXSize, 整数型
    .成员 dwYSize, 整数型
    .成员 dwXCountChars, 整数型
    .成员 dwYCountChars, 整数型
    .成员 dwFillAttribute, 整数型
    .成员 dwFlags, 整数型
    .成员 wShowWindow, 长整数型
    .成员 cbReserved2, 长整数型
    .成员 lpReserved2, 整数型
    .成员 hStdInput, 整数型
    .成员 hStdOutput, 整数型
    .成员 hStdError, 整数型
.数据类型 精易_窗口信息, 公开
    .成员 窗口句柄, 整数型
    .成员 进程ID, 整数型
    .成员 线程ID, 整数型
    .成员 窗口标题, 文本型
    .成员 窗口类名, 文本型
.数据类型 精易_进程信息数组, 公开
    .成员 进程标识符, 整数型, , , 初始值为 0 。
    .成员 进程名称, 文本型, , , 初始值为“”。
    .成员 进程模块标识符, 整数型, , , 初始值为 0 。
    .成员 父进程标识符, 整数型, , , 初始值为 0 。
    .成员 线程优先权, 整数型, , , 初始值为 0 。
    .成员 线程数, 整数型, , , 初始值为 0 。
.数据类型 精易_进程信息列表, 公开, PROCESSENTRY32
    .成员 dwSize, 整数型, , , 1
    .成员 cntUsage, 整数型, , , 2
    .成员 进程ID, 整数型, , , 3
    .成员 th32DefaultHeapID, 整数型, , , 4
    .成员 th32ModuleID, 整数型, , , 5
    .成员 cntThreads, 整数型, , , 6
    .成员 th32ParentProcessID, 整数型, , , 7
    .成员 pcPriClassBase, 整数型, , , 8
    .成员 dwFlags, 整数型, , , 9
    .成员 进程名称, 字节型, , "260", 10
.数据类型 PGUITHREADINFO
    .成员 cbSize, 整数型
    .成员 flags, 整数型
    .成员 hwndActive, 整数型
    .成员 hwndFocus, 整数型
    .成员 hwndCapture, 整数型
    .成员 hwndMenuOwner, 整数型
    .成员 hwndMoveSize, 整数型
    .成员 hwndCaret, 整数型
    .成员 rcCaret, 精易_矩形
.数据类型 线程入口结构
    .成员 结构大小, 整数型, , , 注意！请先初始化！
    .成员 引用线程数, 整数型, , , 请传0
    .成员 线程ID, 整数型
    .成员 父进程ID, 整数型
    .成员 优先级, 整数型
    .成员 更改的优先级, 整数型
    .成员 保留, 整数型
.数据类型 MSG
    .成员 hwnd, 整数型
    .成员 message, 整数型
    .成员 wParam, 整数型
    .成员 lParam, 整数型
    .成员 time, 整数型
    .成员 pt, 精易_坐标
.数据类型 点阵型
    .成员 x, 整数型
    .成员 y, 整数型
    .成员 z, 整数型
.数据类型 精易_坐标, 公开
    .成员 横, 整数型, , , 横X
    .成员 纵, 整数型, , , 纵Y
.数据类型 点阵, 公开
    .成员 点, 整数型, , "1", 低16位X,高16位Y
.数据类型 精易_位置和大小, 公开
    .成员 左边, 整数型, , , 左边，相当于左上角的x
    .成员 顶边, 整数型, , , 顶边，相当于左上角的y
    .成员 宽度, 整数型, , , 窗口的宽度
    .成员 高度, 整数型, , , 窗口的高度
.数据类型 精易_矩形, 公开
    .成员 左边, 整数型, , , 左边，相当于左上角的x
    .成员 顶边, 整数型, , , 顶边，相当于左上角的y
    .成员 右边, 整数型, , , 右边，相当于右下角的x
    .成员 底边, 整数型, , , 底边，相当于右下角的y
.数据类型 表项结构信息, 公开
    .成员 横向, 整数型
    .成员 纵向, 整数型
    .成员 flags, 整数型
    .成员 行, 整数型
    .成员 列, 整数型
.数据类型 精易_内存属性, 公开, MEMORY_BASIC_INFORMATION
    .成员 区域地址, 整数型, , , BaseAddress
    .成员 分配地址, 整数型, , , AllocationBase
    .成员 初始属性, 整数型, , , AllocationProtect
    .成员 区域长度, 整数型, , , RegionSize
    .成员 保留值, 整数型, , , 已提交值,保留值,自由值State
    .成员 当前属性, 整数型, , , Protect
    .成员 页类型, 整数型, , , lType
.数据类型 程序延时
    .成员 成员_时间, 长整数型, , , 占用8个字节
.数据类型 ADSL拨号0
    .成员 结构的大小, 整数型, , , 该结构的大小（以字节为单位）
    .成员 访问的入口名, 字节型, , "257", 表示一个远程访问的入口名,拨号网络中的连接图标小的文字,空表示仅与第一个有效的MODEM建立远程连接
    .成员 呼叫的号码, 字节型, , "129", 表示呼叫的号码,szEntryName为空时,该元素不能为空
    .成员 回叫号码, 字节型, , "129", 表示回叫号码,一般都设为空
    .成员 指定用户名称, 字节型, , "257", 指定用户名称
    .成员 指定用户密码, 字节型, , "257", 指定用户密码
    .成员 指定域, 字节型, , "16", 指定域
.数据类型 取连接信息用结构, , ADSL拨号1
    .成员 内存大小, 整数型, , , 该结构占内存大小
    .成员 拨号连接名称, 字节型, , "255", 拨号连接名称
    .成员 缓冲区的大小, 字节型, , , 缓冲区的大小
    .成员 连接的个数, 文本型, , , 实际的连接的个数
.数据类型 ADSL拨号2
    .成员 data1, 整数型
    .成员 data2, 短整数型
    .成员 data3, 短整数型
    .成员 data4, 字节型, , "8"
.数据类型 ADSL拨号3
    .成员 a, 字节型
    .成员 b, 字节型
    .成员 c, 字节型
    .成员 d, 字节型
.数据类型 LSA_UNICODE_STRING
    .成员 长度, 短整数型
    .成员 最大长度, 短整数型
    .成员 缓冲区, 字节集
.数据类型 创建连接所用结构, , ADSL拨号4
    .成员 dwSize, 整数型
    .成员 dwfOptions, 整数型
    .成员 dwCountryID, 整数型
    .成员 dwCountryCode, 整数型
    .成员 szAreaCode, 字节型, , "8"
    .成员 szLocalPhoneNumber, 字节型, , "132"
    .成员 dwAlternateOffset, 整数型
    .成员 ipaddr, ADSL拨号3
    .成员 ipaddrDns, ADSL拨号3
    .成员 dbury, ADSL拨号3
    .成员 ipaddrWins, ADSL拨号3
    .成员 ipaddrWinsAlt, ADSL拨号3
    .成员 dwFrameSize, 整数型
    .成员 hr57hfb, 整数型
    .成员 dwFramingProtocol, 整数型
    .成员 szScript, 字节型, , "260"
    .成员 szAutodialDll, 字节型, , "260"
    .成员 d75hdrb, 字节型, , "260"
    .成员 szDeviceType, 字节型, , "16"
    .成员 szDeviceName, 字节型, , "132"
    .成员 szX25PadType, 字节型, , "32"
    .成员 sd5h7rd, 字节型, , "200"
    .成员 szX25Facilities, 字节型, , "200"
    .成员 szX25UserData, 字节型, , "204"
    .成员 dwChannels, 整数型
    .成员 sd5rybh, 整数型
    .成员 dwReserved2, 整数型
    .成员 dwSubEntries, 整数型
    .成员 dwDialMode, 整数型
    .成员 dwDialExtraPercent, 整数型
    .成员 dbh5uy, 整数型
    .成员 dwHangUpExtraPercent, 整数型
    .成员 dwHangUpExtraSampleSeconds, 整数型
    .成员 dburgy, 整数型
    .成员 dwType, 整数型
    .成员 sdr5uyhbd, 整数型
    .成员 dwCustomAuthKey, 整数型
    .成员 guidId, ADSL拨号2
    .成员 szCustomDialDll, 字节型, , "260"
    .成员 sbyhrs, 整数型
    .成员 dwfOptions2, 整数型
    .成员 dwfOptions3, 整数型
    .成员 szDnsSuffix, 字节型, , "256"
    .成员 dwTcpWindowSize, 整数型
    .成员 szPrerequisitePbk, 字节型, , "260"
    .成员 szPrerequisiteEntry, 字节型, , "260"
    .成员 dwRedialCount, 整数型
    .成员 dwRedialPause, 整数型
.数据类型 设置拨号所以结构, , ADSL拨号5
    .成员 dsubr, 整数型, , , 该结构的大小（以字节为单位）
    .成员 dwMask, 整数型
    .成员 szUserName, 字节型, , "257"
    .成员 szPassword, 字节型, , "257"
    .成员 szDomain, 字节型, , "16"
.数据类型 IP_ADAPTER_INFO
    .成员 Next, 整数型
    .成员 ComboIndex, 整数型
    .成员 AdapterName, 字节型, , "260", 名称
    .成员 Description, 字节型, , "132", 描述
    .成员 AddressLength, 整数型
    .成员 Address, 字节型, , "8"
    .成员 Index, 整数型
    .成员 Type, 整数型, , , 类型
    .成员 DhcpEnabled, 整数型
    .成员 CurrentIpAddress, 整数型
    .成员 IpAddressList, IP_ADDR_STRING
    .成员 GatewayList, IP_ADDR_STRING
    .成员 DhcpServer, IP_ADDR_STRING
    .成员 HaveWins, 逻辑型
    .成员 PrimaryWinsServer, IP_ADDR_STRING
    .成员 SecondaryWinsServer, IP_ADDR_STRING
    .成员 LeaseObtained, 整数型
    .成员 LeaseExpires, 整数型
.数据类型 IP_PER_ADAPTER_INFO_彗星
    .成员 AutoconfigEnabled, 整数型, , , UINT。AutoconfigEnabled
    .成员 AutoconfigActive, 整数型, , , UINT。AutoconfigActive
    .成员 CurrentDnsServer, 整数型, , , PIP_ADDR_STRING。CurrentDnsServer
    .成员 DnsServerList, IP_ADDR_STRING, , , IP_ADDR_STRING。DnsServerList
.数据类型 IP_PER_ADAPTER_INFO
    .成员 tmp, 整数型, , "3"
    .成员 CurrentDnsServer, IP_ADDR_STRING
    .成员 DnsServerList, IP_ADDR_STRING
.数据类型 OPENFILENAME, 公开, 打开文件名结构
    .成员 结构大小, 整数型, , , win2k以上为88，以下为76  1
    .成员 窗口句柄, 整数型, , , 2
    .成员 实例句柄, 整数型, , , 3
    .成员 过滤器, 字节集, , , 4
    .成员 自定义过滤器, 文本型, , , 5
    .成员 自定义过滤器最大长度, 整数型, , , 6
    .成员 过滤器索引, 整数型, , , 7
    .成员 文件名, 字节集, , , 8
    .成员 文件名最大长度, 整数型, , , 9
    .成员 文件标题, 文本型, , , 10
    .成员 文件标题最大长度, 整数型, , , 11
    .成员 初始目录, 文本型, , , 12
    .成员 标题, 文本型, , , 13
    .成员 标志, 整数型, , , 14
    .成员 文件偏移量, 短整数型, , , 15
    .成员 文件扩展名, 短整数型, , , 16
    .成员 默认扩展名, 文本型, , , 17
    .成员 自定义数据, 整数型, , , 18
    .成员 回调函数地址, 整数型, , , 19
    .成员 模板名, 整数型, , , 20
.数据类型 PLASTINPUTINFO, , 取系统空闲时间
    .成员 cbSize, 整数型
    .成员 dwTime, 整数型
.数据类型 数据_APIHOOK类
    .成员 区域地址, 整数型
    .成员 API命令名, 文本型
    .成员 继续暂停, 文本型
    .成员 原函数地址, 整数型
    .成员 新函数地址, 字节集
    .成员 原保护值, 整数型
    .成员 原字节, 字节集
    .成员 命令标识, 文本型, , , 动态链接库名+API命令名
.数据类型 精易_时间, 公开, , SYSTEMTIME
    .成员 年, 短整数型, , , wYear
    .成员 月, 短整数型, , , wMonth
    .成员 星期, 短整数型
    .成员 日, 短整数型, , , wDay
    .成员 时, 短整数型, , , wHour
    .成员 分, 短整数型, , , wMinute
    .成员 秒, 短整数型, , , wSecond
    .成员 毫, 短整数型, , , wMilliseconds
.数据类型 LSA_OBJECT_ATTRIBUTES
    .成员 Length, 整数型
    .成员 RootDirectory, 整数型
    .成员 ObjectName, LSA_UNICODE_STRING, , , 未知类型：PLSA_UNICODE_STRING。
    .成员 Attributes, 整数型
    .成员 SecurityDescriptor, 整数型, 传址, , 此参数需传址。
    .成员 SecurityQualityOfService, 整数型, 传址, , 此参数需传址。
.数据类型 OSVERSIONINFOEX, 公开, 系统_取操作系统类别
    .成员 dwOSVersionInfoSize, , , , 结构的大小
    .成员 dwMajorVersion, , , , 主版本号
    .成员 dwMinorVersion, , , , 次版本号
    .成员 dwBuildNumber, , , , 构建号
    .成员 dwPlatformId, , , , 支持的平台
    .成员 szCSDVersion, 字节型, , "128", 补丁包的名称
    .成员 wServicePackMajor, 短整数型, , , 补丁包的主版本
    .成员 wServicePackMinor, 短整数型, , , 补丁包的次版本
    .成员 wSuiteMask, 短整数型, , , 系统上的程序组
    .成员 wProductType, 字节型, , , 系统类型
    .成员 wReserved, 字节型, , , 保留
.数据类型 OSVersionInfo
    .成员 版本信息大小, 整数型
    .成员 主版本, 整数型
    .成员 次版本, 整数型
    .成员 构造版本, 整数型
    .成员 平台标识符, 整数型
    .成员 CSD版本, 文本型
.数据类型 RasEntry
    .成员 dwSize, 整数型
    .成员 dwfOptions, 整数型
    .成员 dwCountryID, 整数型
    .成员 dwCountryCode, 整数型
    .成员 szAreaCode, 字节型, , "8"
    .成员 szLocalPhoneNumber, 字节型, , "132"
    .成员 dwAlternatesOffset, 整数型
    .成员 ipaddr, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrDns, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrDnsAlt, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrWins, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrWinsAlt, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 dwFrameSize, 整数型
    .成员 dwfNetProtocols, 整数型
    .成员 dwFramingProtocol, 整数型
    .成员 szScript, 字节型, , "260", 数组：MAX_PATH - 1+1。
    .成员 szAutodialDll, 字节型, , "260", 数组：MAX_PATH - 1+1。
    .成员 szAutodialFunc, 字节型, , "260", 数组：MAX_PATH - 1+1。
    .成员 szDeviceType, 字节型, , "16"
    .成员 szDeviceName, 字节型, , "132"
    .成员 szX25PadType, 字节型, , "32"
    .成员 szX25Address, 字节型, , "200"
    .成员 szX25Facilities, 字节型, , "200"
    .成员 szX25UserData, 字节型, , "204"
    .成员 dwChannels, 整数型
    .成员 dwReserved1, 整数型
    .成员 dwReserved2, 整数型
    .成员 dwSubEntries, 整数型
    .成员 dwDialMode, 整数型
    .成员 dwDialExtraPercent, 整数型
    .成员 dwDialExtraSampleSeconds, 整数型
    .成员 dwHangUpExtraPercent, 整数型
    .成员 dwHangUpExtraSampleSeconds, 整数型
    .成员 dwIdleDisconnectSeconds, 整数型
.数据类型 Stroks
    .成员 名字, 文本型
    .成员 条目名字, 文本型
    .成员 用户, 文本型
    .成员 值, 文本型
.数据类型 RARHeaderData, , RAR 档案文件头数据结构
    .成员 ArcName, 字节型, , "260", 输出，返回当前档案文件名，可用于检测是否为正确的分卷名。
    .成员 FileName, 字节型, , "260", 输出，返回 OEM (DOS) 编码的文件名
    .成员 Flags, 整数型, , , 输出，文件标志（&H1-文件继承自前卷; &H2-文件延续至后卷; &H4-文件使用密码加密; &H8-文件包含注释文本; &H10-先前文件使用了压缩[固实标志]）
    .成员 PackSize, 整数型, , , 输出，返回打包文件或分卷大小（如果使用了分卷压缩）
    .成员 UnpSize, 整数型, , , 输出，返回解包后的文件大小
    .成员 HostOS, 整数型, , , 输出，返回执行的操作系统（(0-MS DOS; 1-0S/2; 2-Win32; 3-Unix)）
    .成员 FileCRC, 整数型, , , 输出，返回解包文件的 CRC 校验信息. 如果文件被分卷,只有最后分卷部分包含了正确的 CRC 信息并且只有使用了 RAR_OM_LIST_INCSPLIT 模式才可正常读取.
    .成员 FileTime, 整数型, , , 输出，返回标准 MS DOS 格式的日期和时间
    .成员 UnpVer, 整数型, , , 输出，返回提取文件所需的 RAR 版本，返回格式为： 10*主版本号+副版本号
    .成员 Method, 整数型, , , 输出，返回打包方法。
    .成员 FileAttr, 整数型, , , 输出，返回文件属性。
    .成员 CmtBuf, 整数型, , , 输入/输出，本应为档案注释文本，文本型数据，但新版本的 DLL 将不再执行该功能，CmtState 一直为 0。
    .成员 CmtBufSize, 整数型, , , 输入，返回缓冲大小,新版本中不必再设置(见上)
    .成员 CmtSize, 整数型, , , 输出，返回实际缓冲大小,新版本中无效(见上)
    .成员 CmtState, 整数型, , , 输出，返回注释获取状态,新版本中无效(将始终返回无注释状态, 见上)
.数据类型 SHELLEXECUTEINFOA
    .成员 cbSize, 整数型
    .成员 fMask, 整数型
    .成员 hwnd, 整数型
    .成员 lpVerb, 文本型
    .成员 lpFile, 文本型
    .成员 lpParameters, 文本型
    .成员 lpDirectory, 文本型
    .成员 nShow, 整数型
    .成员 hInstApp, 整数型
    .成员 lpIDList, 整数型
    .成员 lpClass, 文本型
    .成员 hkeyClass, 整数型
    .成员 dwHotKey, 整数型
    .成员 hIcon, 整数型
    .成员 hProcess, 整数型
.数据类型 SHELLEXECUTEINFOW
    .成员 cbSize, 整数型
    .成员 fMask, 整数型
    .成员 hwnd, 整数型
    .成员 lpVerb, 字节集
    .成员 lpFile, 字节集
    .成员 lpParameters, 字节集
    .成员 lpDirectory, 字节集
    .成员 nShow, 整数型
    .成员 hInstApp, 整数型
    .成员 lpIDList, 整数型
    .成员 lpClass, 字节集
    .成员 hkeyClass, 整数型
    .成员 dwHotKey, 整数型
    .成员 hIcon, 整数型
    .成员 hProcess, 整数型
.数据类型 RAROpenArchiveDataEx, , RAR 档案打开数据结构
    .成员 ArcName, 文本型, , , 输入，指定档案文件名。
    .成员 ArcNameW, 字节集, , , 输入，指定档案文件名的 Unicode 字符串，未指定 Unicode 名称时设为空。
    .成员 OpenMode, 整数型, , , 输入，指定打开方式，为 RAR_OM_* 常数之一。
    .成员 OpenResult, 整数型, , , 输出，返回 0 表示执行成功，其他值参见 ERAR_* 常数[仅 11-15 部分]。
    .成员 CmtBuf, 文本型, , , 输入/输出，可选。档案注释文本缓冲区，最大缓冲长度为 64 Kb；缓冲过小时超出部分被截断，本成员为空时表示不获取注释文本。
    .成员 CmtBufSize, 整数型, , , 输入，指定 CmtBuf 成员的缓冲区大小。
    .成员 CmtSize, 整数型, , , 输出，返回实际读取到档案注释文本的缓冲大小， 该值不会超过 CmtBufSize 成员。
    .成员 CmtState, 整数型, , , 输出，返回档案注释文本读取结果(0 表示未设置注释;1 表示注释读取完成, 其他返回值见 ERAR_* 常数[仅 11,12,14,20])
    .成员 Flags, 整数型, , , 输出，位标记组合。(&H1-分卷属性; &H2-包含档案注释; &H4-档案锁定属性; &H8-固实档案属性; &H10-新式分卷命名方案[volname.partN.rar]; &H20-包含校验信息; &H40-包含恢复记录; &H80-区块头被加密; &H100-首个分卷[需 RAR 3.0 以上版本])
.数据类型 SECURITY_ATTRIBUTES, , 系统_取DOS执行结果
    .成员 nLength, 整数型
    .成员 lpSecurityDescriptor, 整数型
    .成员 bInheritHandle, 逻辑型
.数据类型 注册表_键, 公开
    .成员 键名称, 文本型
    .成员 键值, 字节集
    .成员 类型, 整数型
.数据类型 PROCESS_INFORMATION
    .成员 hProcess, 整数型
    .成员 hThread, 整数型
.数据类型 STARTUPINFO_短整数
    .成员 cb, 整数型
    .成员 lpReserved, 文本型
    .成员 lpDesktop, 文本型
    .成员 lpTitle, 文本型
    .成员 dwX, 整数型
    .成员 dwY, 整数型
    .成员 dwXSize, 整数型
    .成员 dwYSize, 整数型
    .成员 dwXCountChars, 整数型
    .成员 dwYCountChars, 整数型
    .成员 dwFillAttribute, 整数型
    .成员 dwFlags, 整数型
    .成员 wShowWindow, 短整数型
    .成员 cbReserved2, 短整数型
    .成员 lpReserved2, 整数型
    .成员 hStdInput, 整数型
    .成员 hStdOutput, 整数型
    .成员 hStdError, 整数型
.数据类型 RESTOREPTINFO, , 系统还原_创建还原点
    .成员 dwEventType
    .成员 dwRestorePtType
    .成员 llSequenceNumber, 长整数型
    .成员 szDescription, 字节型, , "64"
.数据类型 SMGRSTATUS, , 系统还原_创建还原点
    .成员 nStatus
    .成员 llSequenceNumber, 长整数型
.数据类型 FONT_RESOURCE, , 系统_取字体名
    .成员 dwDup, 整数型, , "7"
    .成员 wszFontName, 短整数型, , "1024"
.数据类型 SYSTEM_INFO, , 系统_取CPU占用率
    .成员 wProcessorArchitecture, 整数型
    .成员 dwPageSize, 整数型
    .成员 lpMinimumApplicationAddress, 整数型
    .成员 lpMaximumApplicationAddress, 整数型
    .成员 dwActiveProcessorMask, 整数型
    .成员 dwNumberOrfProcessors, 整数型
    .成员 dwProcessorType, 整数型
    .成员 dwAllocationGranularity, 整数型
    .成员 dwReserved, 整数型
.数据类型 PFLASHWINFO, , 窗口_闪动Ex
    .成员 cbSize, 整数型
    .成员 hwnd, 整数型
    .成员 dwFlags, 整数型
    .成员 uCount, 整数型
    .成员 dwTimeout, 整数型
.数据类型 GUID, 公开
    .成员 Data1, 整数型
    .成员 Data2, 短整数型
    .成员 Data3, 短整数型
    .成员 Data4, 字节型, , "8"
.数据类型 时区信息_, , 系统_取系统时区
    .成员 Bias, 整数型
    .成员 StandardName, 字节型, , "63"
    .成员 系统时间年, 短整数型
    .成员 系统时间月, 短整数型
    .成员 系统时间星期, 短整数型
    .成员 系统时间天, 短整数型
    .成员 系统时间时, 短整数型
    .成员 系统时间分, 短整数型
    .成员 系统时间秒, 短整数型
    .成员 系统时间毫秒, 短整数型
    .成员 StandardBias, 整数型
    .成员 DaylightName, 短整数型, , "32"
    .成员 时区时间年, 短整数型
    .成员 时区时间月, 短整数型
    .成员 时区时间星期, 短整数型
    .成员 时区时间天, 短整数型
    .成员 时区时间时, 短整数型
    .成员 时区时间分, 短整数型
    .成员 时区时间秒, 短整数型
    .成员 时区时间毫秒, 短整数型
    .成员 DaylightBias, 整数型
.数据类型 WINDOWINFO, , 窗口_是否激活
    .成员 cbSize, 整数型
    .成员 rcWindow, 精易_矩形
    .成员 rcClient, 精易_矩形
    .成员 dwStyle, 整数型
    .成员 dwExStyle, 整数型
    .成员 dwWindowStatus, 整数型
    .成员 cxWindowBorders, 整数型
    .成员 cyWindowBorders, 整数型
    .成员 atomWindowType, 短整数型
    .成员 wCreatorVersion, 短整数型
.数据类型 IO_STATUS_BLOCK, , 文件_句柄取路径
    .成员 Status
    .成员 Information
.数据类型 FILE_NAME_INFORMATION, , 文件_句柄取路径
    .成员 FileNameLength
    .成员 FileName
.数据类型 BY_HANDLE_FILE_INFORMATION, , 文件_句柄取路径
    .成员 dwFileAttributes, 整数型
    .成员 ftCreationTime, 文件时间
    .成员 ftLastAccessTime, 文件时间
    .成员 ftLastWriteTime, 文件时间
    .成员 dwVolumeSerialNumber, 整数型
    .成员 nFileSizeHigh, 整数型
    .成员 nFileSizeLow, 整数型
    .成员 nNumberOfLinks, 整数型
    .成员 nFileIndexHigh, 整数型
    .成员 nFileIndexLow, 整数型
.数据类型 IO_COUNTERS, , 进程_取IO读取字节 进程_取IO其它计数
    .成员 读取操作数量, 长整数型, , , ReadOperationCount
    .成员 写入操作数量, 长整数型, , , WriteOperationCount
    .成员 其它读写操作数量, 长整数型, , , OtherOperationCount
    .成员 读取字节数, 长整数型, , , ReadTransferCount
    .成员 写入字节数, 长整数型, , , WriteTransferCount
    .成员 其它读写操作字节, 长整数型, , , OtherTransferCount
.数据类型 MINMAXINFO, , 窗口_限定尺寸
    .成员 ptReserved, 精易_坐标
    .成员 ptMaxSize, 精易_坐标
    .成员 ptMaxPosition, 精易_坐标
    .成员 ptMinTrackSize, 精易_坐标
    .成员 ptMaxTrackSize, 精易_坐标
.数据类型 MD5_CTX
    .成员 i, 整数型, , "2"
    .成员 buf, 整数型, , "4"
    .成员 in, 字节型, , "64"
    .成员 digest, 字节型, , "16"
.数据类型 URL_COMPONENTS, 公开
    .成员 dwStructSize, , , , 本结构长度，注：60
    .成员 lpszScheme, , , , 协议类型
    .成员 dwSchemeLength, , , , 协议类型缓冲区长度
    .成员 nScheme, , , , 链接类型，1=http，2=https。（INTERNET_SCHEME_HTTP=1，INTERNET_SCHEME_HTTPS=2）
    .成员 lpszHostName, , , , 主机域名(Host)
    .成员 dwHostNameLength, , , , 主机域名缓冲区长度
    .成员 nPort, , , , 端口
    .成员 lpszUserName, , , , 帐号
    .成员 dwUserNameLength, , , , 帐号缓冲区长度
    .成员 lpszPassword, , , , 密码
    .成员 dwPasswordLength, , , , 密码缓冲区长度
    .成员 lpszUrlPath, , , , 路径(页面地址)
    .成员 dwUrlPathLength, , , , 路径缓冲区长度
    .成员 lpszExtraInfo, , , , 额外信息，比如“?”或“#”之后的参数字符串。
    .成员 dwExtraInfoLength, , , , 额外信息长度
.数据类型 LOGFONT, 公开, 定义字体的属性
    .成员 lfHeight, 整数型, , , 字体单元格或字符的高度（以逻辑单位表示）。字符高度值（也称为em高度）是字符单元格高度值减去内部前导值。
    .成员 lfWidth, 整数型, , , 字体中字符的平均宽度（以逻辑单位表示）。如果lfWidth为零，则设备的宽高比与可用字体的数字化宽高比相匹配，以找到最接近的匹配，由差值的绝对值确定。
    .成员 lfEscapement, 整数型, , , 设备x轴之间的角度，以十分之一度为单位
    .成员 lfOrientation, 整数型, , , 每个字符的基线和设备的x轴之间的角度，以十分之一度为单位。
    .成员 lfWeight, 整数型, , , 字体的权重范围为0到1000.例如，400表示正常，700表示粗体。如果此值为零，则使用默认权重。
    .成员 lfItalic, 字节型, , , 斜体
    .成员 lfUnderline, 字节型, , , 下划线
    .成员 lfStrikeOut, 字节型, , , 删除线
    .成员 lfCharSet, 字节型, , , 字符集
    .成员 lfOutPrecision, 字节型, , , 输出精度。输出精度定义输出必须与请求的字体的高度，宽度，字符方向，擒纵，音高和字体类型匹配的程度。
    .成员 lfClipPrecision, 字节型, , , 剪裁精度。裁剪精度定义了如何剪辑部分位于裁剪区域之外的字符。
    .成员 lfQuality, 字节型, , , 输出质量。输出质量定义了图形设备接口（GDI）必须如何仔细地将逻辑字体属性与实际物理字体的属性相匹配。
    .成员 lfPitchAndFamily, 字节型, , , 字体族
    .成员 lfFaceName, 字节型, , "32", W版为64个成员的字节数组或者32个成员的短整数数组,以null结尾的字符串，用于指定字体的字体名称。此字符串的长度不得超过32个TCHAR值，包括终止NULL。该EnumFontFamiliesEx函数可用于枚举所有当前可用字体的字体名称。如果lfFaceName是空字符串，则GDI使用与其他指定属性匹配的第一个字体。
.数据类型 CHOOSEFONT, , 对话框_选择字体
    .成员 结构大小, 整数型
    .成员 窗口句柄, 整数型
    .成员 设备场景句柄, 整数型
    .成员 字体结构指针, 整数型
    .成员 点大小, 整数型
    .成员 标志, 整数型
    .成员 颜色值, 整数型
    .成员 自定义数据, 整数型
    .成员 回调函数地址, 整数型
    .成员 模板名称, 文本型
    .成员 实例句柄, 整数型
    .成员 字体风格, 文本型
    .成员 字体类型, 短整数型
    .成员 空白队列, 短整数型
    .成员 最小尺寸, 整数型
    .成员 最大尺寸, 整数型
.数据类型 NOTIFYICONDATA
    .成员 cbSize, 整数型, , , 结构大小
    .成员 hWnd, 整数型, , , 窗口句柄
    .成员 uID, 整数型, , , 标识符
    .成员 uFlags, 整数型, , , 标志
    .成员 uCallbackMessage, 整数型, , , 返回信息
    .成员 hIcon, 整数型, , , 图标句柄
    .成员 szTip, 字节型, , "128", 提示文本
    .成员 dwState, 整数型
    .成员 dwStateMask, 整数型
    .成员 szInfo, 字节型, , "256", 提示信息
    .成员 uTimeoutAndVersion, 整数型
    .成员 szInfoTitle, 字节型, , "64", 标题
    .成员 dwInfoFlags, 整数型, , , 提示图标
.数据类型 IconDirEntry, , 16
    .成员 bWidth, 字节型, , , 图标图片的显示宽度
    .成员 bHeight, 字节型, , , 图标图片的显示高度
    .成员 bColorCount, 字节型, , , 图标图片的颜色数
    .成员 bReserved, 字节型, , , 保留域总是 0
    .成员 wPlanes, 短整数型, , , 图标图片的位面数
    .成员 wBitCount, 短整数型, , , 图标图片的颜色深度
    .成员 dwBytesInRes, 整数型, , , 图标图片占用的数据量
    .成员 dwImageOffset, 整数型, , , 图标图片的开始位置
.数据类型 hostent
    .成员 h_name
    .成员 h_aliases
    .成员 h_addrtype, 短整数型
    .成员 h_length, 短整数型
    .成员 h_addr_list
.数据类型 ICMP_ECHO_REPLY
    .成员 address, 整数型, , ,  ‘包含正回复的IP地址
    .成员 Status, 整数型, , ,   ‘包含回复的状态（参看后面的常量部分）
    .成员 RoundTripTime, 整数型, , , ‘往返时间RTT(毫秒)
    .成员 DataSize, 整数型, , , ‘回复数据大小(字节)
    .成员 Reserved, 短整数型, , ,  ‘保留
    .成员 ptrData, 短整数型, , , ‘指向回复数据的指针
    .成员 Options, IP_OPTION_INFORMATION, , , 回复选项
    .成员 Data, 字节型, , "250"
.数据类型 IP_OPTION_INFORMATION
    .成员 Ttl, 字节型, , ,  ‘生存时间
    .成员 Tos, 字节型, , , ‘服务类型
    .成员 Flags, 字节型, , ,  ‘IP头标志
    .成员 OptionsSize, 字节型, , ,  ‘选项数据的大小，字节
    .成员 OptionsData, 整数型, , , ‘指向选项数据的指针
.数据类型 WAVEOUTCAPS
    .成员 wMid, 短整数型
    .成员 wPid, 短整数型
    .成员 vDriverVersion, 整数型
    .成员 szPname, 字节型, , "32"
    .成员 dwFormats, 整数型
    .成员 wChannels, 短整数型
    .成员 dwSupport, 整数型
.数据类型 配置节数据, 公开
    .成员 节名称, 文本型
    .成员 项, 配置项数据, , "1"
.数据类型 配置项数据, 公开
    .成员 配置项名称, 文本型
    .成员 值, 文本型
.数据类型 ULARGE_INTEGER, , 进程_取父ID
    .成员 LowPart
    .成员 HighPart
.数据类型 UNICODE_STRING, , 进程_取父ID
    .成员 长度, 短整数型, , , Length
    .成员 最大长度, 短整数型, , , MaximumLength
    .成员 缓冲区, 整数型, , , Buffer
.数据类型 SYSTEM_PROCESS_INFORMATION, 公开, 进程_取父ID
    .成员 NextEntryDelta, 整数型
    .成员 ThreadCount, 整数型
    .成员 Reserved1, LARGE_INTEGER, , "3"
    .成员 CreateTime, LARGE_INTEGER
    .成员 UserTime, LARGE_INTEGER
    .成员 KernelTime, LARGE_INTEGER
    .成员 ImageName, UNICODE_STRING
    .成员 BasePriority, 整数型, , , KPRIORITY               
    .成员 ProcessId, 整数型
    .成员 InheritedFromProcessId, 整数型
    .成员 HandleCount, 整数型
    .成员 Reserved2, 整数型, , "2"
    .成员 VirtualMemoryCounters, VM_COUNTERS, , , VM_COUNTERS             
    .成员 IoCounters, IO_COUNTERS, , , IO_COUNTERS             
.数据类型 OVERLAPPED
    .成员 Internal, 整数型
    .成员 InternalHigh, 整数型
    .成员 offset, 整数型
    .成员 OffsetHigh, 整数型
    .成员 hEvent, 整数型
.数据类型 精易_系统服务列表, 公开, 系统服务_枚举系统服务
    .成员 服务名称, 文本型
    .成员 显示名称, 文本型
    .成员 描述, 文本型
    .成员 文件路径, 文本型
    .成员 启动类型, 文本型
    .成员 服务状态, 文本型
    .成员 登陆为, 文本型
.数据类型 精易_系统服务列表Ex, 公开, 系统服务_枚举系统服务
    .成员 服务名称, 文本型
    .成员 显示名称, 文本型
    .成员 描述, 文本型
    .成员 进程ID
    .成员 文件路径, 文本型
    .成员 启动类型, 文本型
    .成员 服务状态, 文本型
    .成员 登陆为, 文本型
.数据类型 ENUM_SERVICE_STATUS_PROCESS
    .成员 lpServiceName
    .成员 lpDisplayName
    .成员 ServiceStatusProcess, SERVICE_STATUS_PROCESS
.数据类型 SERVICE_STATUS_PROCESS
    .成员 dwServiceType
    .成员 dwCurrentState
    .成员 dwControlsAccepted
    .成员 dwWin32ExitCode
    .成员 dwServiceSpecificExitCode
    .成员 dwCheckPoint
    .成员 dwWaitHint
    .成员 dwProcessId
    .成员 dwServiceFlags
.数据类型 ENUM_SERVICE_STATUS, , 枚举服务
    .成员 lpServiceName
    .成员 lpDisplayName
    .成员 ServiceStatus, SERVICE_STATUS
.数据类型 SYSTEMTIME
    .成员 wYear, 短整数型
    .成员 wMonth, 短整数型
    .成员 wDayOfWeek, 短整数型
    .成员 wDay, 短整数型
    .成员 wHour, 短整数型
    .成员 wMinute, 短整数型
    .成员 wSecond, 短整数型
    .成员 wMilliseconds, 短整数型
.数据类型 Cookie, 公开, cookie类型
    .成员 健, 文本型
    .成员 值, 文本型
.数据类型 NetworkCardMapName
    .成员 Index, 整数型
    .成员 strMapName, 文本型
    .成员 strFriendName, 文本型
    .成员 strGUID, 文本型
.数据类型 IP_ADAPTER_INFO_彗星
    .成员 Next, 整数型, , , _IP_ADAPTER_INFO* Next
    .成员 ComboIndex, 整数型, , , DWORD。ComboIndex
    .成员 AdapterName, 字节型, , "260", Char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];MAX_ADAPTER_NAME_LENGTH = 256
    .成员 Description, 字节型, , "132", char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];MAX_ADAPTER_DESCRIPTION_LENGTH = 128
    .成员 AddressLength, 整数型, , , UINT。AddressLength
    .成员 Address, 字节型, , "8", BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];MAX_ADAPTER_ADDRESS_LENGTH=8
    .成员 Index, 整数型, , , DWORD。Index
    .成员 Type, 整数型, , , UINT。Type
    .成员 DhcpEnabled, 整数型, , , UINT。DhcpEnabled
    .成员 CurrentIpAddress, 整数型, , , PIP_ADDR_STRING。CurrentIpAddress
    .成员 IpAddressList, IP_ADDR_STRING, , , IP_ADDR_STRING。IpAddressList
    .成员 GatewayList, IP_ADDR_STRING, , , IP_ADDR_STRING。GatewayList
    .成员 DhcpServer, IP_ADDR_STRING, , , IP_ADDR_STRING。DhcpServer
    .成员 HaveWins, 整数型, , , BOOL。HaveWins
    .成员 PrimaryWinsServer, IP_ADDR_STRING, , , IP_ADDR_STRING。PrimaryWinsServer
    .成员 SecondaryWinsServer, IP_ADDR_STRING, , , IP_ADDR_STRING。SecondaryWinsServer
    .成员 LeaseObtained, 长整数型, , , time_t。LeaseObtained
    .成员 LeaseExpires, 长整数型, , , time_t。LeaseExpires
.数据类型 IP_INTERFACE_INFO
    .成员 NumAdapters, 整数型, , , LONG。NumAdapters
    .成员 Adapter, IP_ADAPTER_INDEX_MAP, , , IP_ADAPTER_INDEX_MAP。Adapter[1]
.数据类型 精易_网卡信息_彗星, 公开, 网卡信息
    .成员 网卡名称, 文本型, , , 网卡名称
    .成员 网卡描述, 文本型, , , 网卡描述
    .成员 连接名称, 文本型, , , 友好名称，本地连接
    .成员 网卡类型n, 整数型
    .成员 网卡类型, 文本型, , , 网卡类型
    .成员 MAC地址, 文本型, , , MAC地址
    .成员 IP地址, 文本型, , , IP地址
    .成员 子网掩码, 文本型, , , 子网掩码
    .成员 网关地址, 文本型, , , 网关地址
    .成员 首选DNS服务器, 文本型, , , 首选DNS服务器
    .成员 备用DNS服务器, 文本型, , , 备用DNS服务器
    .成员 是否启用DHCP, 逻辑型
.数据类型 IP_ADAPTER_INDEX_MAP
    .成员 Index, 整数型, , , ULONG。Index
    .成员 Name, 字节型, , "256", WCHAR。Name。[MAX_ADAPTER_NAME];MAX_ADAPTER_NAME=128
.数据类型 精易_IP归属地, 公开
    .成员 IP, 文本型
    .成员 国家, 文本型
    .成员 省份, 文本型
    .成员 城市, 文本型
    .成员 运营商, 文本型
.数据类型 模糊属性, 公开, _DWM_BLURBEHIND
    .成员 dwFlags, 整数型, , , DWM Blur Behind常量值的按位组合，指示已设置此结构的哪些成员。
    .成员 fEnable, 逻辑型, , , TRUE将窗口句柄注册到DWM模糊后面; FALSE从DWM注销的窗口句柄模糊后面。
    .成员 hRgnBlur, 整数型, , , 客户区内将应用模糊的区域。一个NULL值将应用于整个客户区域的模糊。
    .成员 fTransitionOnMaximized, 整数型, , , 如果窗口的着色应转换为与最大化窗口匹配，则为TRUE ; 否则，FALSE。
.数据类型 EncoderParameter
    .成员 Guid, 字节型, , "16", 为了方便使用了字节型数组，本来应该是GUID类型。
    .成员 NumberOfValues, 整数型
    .成员 Type, 整数型
    .成员 Value, 整数型, , , Value *
.数据类型 缩略图属性, 公开, _DWM_THUMBNAIL_PROPERTIES
    .成员 dwFlags, 整数型, , , 按位组合DWM略缩图常数值，该值指示设置了此结构的哪些成员。1=源矩形，2=显示矩形，4=透明度，8=可视，16=仅工作区
    .成员 目标矩形, 精易_矩形, , , rcDestination         1.略缩图将显示到目标窗口中的矩形区域。
    .成员 源矩形, 精易_矩形, , , rcSource              2.要用作略缩图的源窗口的区域。默认情况下，整个窗口用作略缩图。
    .成员 透明度, 字节型, , , opacity               4.渲染略缩图的不透明度。取值0-255。0是完全透明的，而255是完全不透明的。默认值为255。
    .成员 可视, 逻辑型, , , fVisible              8.可视
    .成员 仅工作区, 逻辑型, , , fSourceClientAreaOnly 16.仅使用略缩图源的工作区
.数据类型 EncoderParameters
    .成员 Count, 整数型
    .成员 Parameter, EncoderParameter, , "1"
.数据类型 SCROLLINFO
    .成员 cbSize, 整数型
    .成员 fMask, 整数型
    .成员 nMin, 整数型
    .成员 nMax, 整数型
    .成员 nPage, 整数型
    .成员 nPos, 整数型
    .成员 nTrackPos, 整数型
.数据类型 SCROLLBARINFO
    .成员 cbSize, 整数型
    .成员 rcScrollBar, RECT
    .成员 dxyLineButton, 整数型
    .成员 xyThumbTop, 整数型
    .成员 xyThumbBottom, 整数型
    .成员 reserved, 整数型
    .成员 rgstate, 整数型, , "6"
.数据类型 COMBOBOXINFO, 公开
    .成员 cbSize, 整数型, , , 结构大小
    .成员 rcItem, RECT, , , 条目矩形
    .成员 rcButton, RECT, , , 按钮矩形
    .成员 stateButton, 整数型, , , 按钮状态
    .成员 hwndCombo, 整数型, , , 超级组合框句柄
    .成员 hwndItem, 整数型, , , 编辑框句柄
    .成员 hwndList, 整数型, , , 列表框句柄
.数据类型 MIB_TCPTABLE_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366921.aspx
    .成员 dwNumEntries, 整数型, , , 表中MIB_TCPROW_OWNER_PID元素的数量。
    .成员 TCP_TABLE_CLASS, MIB_TCPROW_OWNER_PID, , "255", MIB_TCPROW_OWNER_PID数组。
.数据类型 MIB_TCPROW_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366913.aspx
    .成员 dwState, 整数型, , , //连接状态
    .成员 dwLocalAddr, 整数型, , , //本地 IP地址,值为零表示TCP侦听器愿意接受与本地计算机相关联的任何IP接口的数据报。
    .成员 dwLocalPort, 整数型, , , //本地端口,本地计算机上TCP端点的端口号。该成员以网络字节顺序存储。
    .成员 dwRemoteAddr, 整数型, , , //远程 IP 地址
    .成员 dwRemotePort, 整数型, , , //远程端口
    .成员 dwOwningPid, 整数型, , , //关联的进程ID,发出UDP端点绑定功能的进程的PID 。当PID不可用时，该成员设置为0。
.数据类型 MIB_UDPTABLE_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366932.aspx
    .成员 dwNumEntries, 整数型, , , 表中MIB_UDPROW_OWNER_PID元素的数量。
    .成员 UDP_TABLE_CLASS, MIB_UDPROW_OWNER_PID, , "255", MIB_UDPTABLE_OWNER_PID数组。
.数据类型 MIB_UDPROW_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366928.aspx
    .成员 dwLocalAddr, 整数型, , , //本地 IP地址,值为零表示UDP侦听器愿意接受与本地计算机相关联的任何IP接口的数据报。
    .成员 dwLocalPort, 整数型, , , //本地端口,本地计算机上UDP端点的端口号。该成员以网络字节顺序存储。
    .成员 dwOwningPid, 整数型, , , //关联的进程ID,发出UDP端点绑定功能的进程的PID 。当PID不可用时，该成员设置为0。
.数据类型 HotKeyData
    .成员 hWnd, 整数型
    .成员 nModifiers, 整数型, , , #MOD_CONTROL #MOD_SHIFT #MOD_ALT
    .成员 nVirtKey, 整数型
    .成员 hProc, 整数型
    .成员 nType, 整数型
    .成员 bChar, 逻辑型
.数据类型 WINDOWCOMPOSITIONATTRIBDATA
    .成员 Attrib, 整数型
    .成员 pvData, ACCENT_POLICY, 传址
    .成员 cbData, 整数型
.数据类型 ACCENT_POLICY
    .成员 AccentState, 整数型
    .成员 AccentFlags, 整数型
    .成员 GradientColor, 整数型
    .成员 AnimationId, 整数型
.数据类型 STORAGE_DEVICE_DESCRIPTOR, , 输出参数
    .成员 Version, 整数型
    .成员 Size, 整数型
    .成员 DeviceType, 字节型
    .成员 DeviceTypeModifier, 字节型
    .成员 RemovableMedia, 字节型
    .成员 CommandQueueing, 字节型
    .成员 VendorIdOffset, 整数型
    .成员 ProductIdOffset, 整数型
    .成员 ProductRevisionOffset, 整数型
    .成员 SerialNumberOffset, 整数型
    .成员 BusType, 整数型, , , STORAGE_BUS_TYPE
    .成员 RawPropertiesLength, 整数型
    .成员 RawDeviceProperties, 字节型, , "1"
.数据类型 STORAGE_PROPERTY_QUERY, , 输入参数
    .成员 PropertyId, 长整数型
    .成员 QueryType, 长整数型
    .成员 AdditionalParameters, 字节型, , "1"
.数据类型 WINDOWPLACEMENT, 公开
    .成员 Length, 整数型, , , 结构的长度
    .成员 flags, 整数型, , , 控制最小化窗口的位置和恢复窗口的方法(#WPF_xxx)
    .成员 showCmd, 整数型, , , 窗口的当前显示状态(#SW_xxx)
    .成员 ptMinPosition, POINT, , , 窗口最小化时窗口左上角的坐标
    .成员 ptMaxPosition, POINT, , , 窗口最大化时窗口左上角的坐标
    .成员 rcNormalPosition, RECT, , , 当窗口处于恢复位置时窗口的坐标
.数据类型 PROCESSENTRY32W
    .成员 dwSize, 整数型
    .成员 cntUsage, 整数型
    .成员 th32ProcessID, 整数型
    .成员 th32DefaultHeapID, 整数型
    .成员 th32ModuleID, 整数型
    .成员 cntThreads, 整数型
    .成员 th32ParentProcessID, 整数型
    .成员 pcPriClassBase, 整数型
    .成员 dwFlags, 整数型
    .成员 szExeFile, 字节型, , "520"
.数据类型 WIN32_FIND_DATAW
    .成员 dwFileAttributes, 整数型
    .成员 ftCreationTime, FILETIME
    .成员 ftLastAccessTime, FILETIME
    .成员 ftLastWriteTime, FILETIME
    .成员 nFileSizeHigh, 整数型
    .成员 nFileSizeLow, 整数型
    .成员 dwReserved0, 整数型
    .成员 dwReserved1, 整数型
    .成员 cFileName, 字节型, , "520"
    .成员 cAlternateFileName, 字节型, , "28"
.数据类型 FILETIME
    .成员 dwLowDateTime, 整数型
    .成员 dwHighDateTime, 整数型
.数据类型 KBDLLHOOKSTRUCT
    .成员 vkCode, 整数型
    .成员 scanCode, 整数型
    .成员 flags, 整数型
    .成员 time, 整数型
    .成员 dwExtraInfo, 整数型
.数据类型 精易_时区信息
    .成员 时区, 文本型
    .成员 时区名, 文本型
    .成员 时区代码, 文本型
